{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/umami-view.js","path":"js/umami-view.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"df45d6c3550a445890e57c834a6620fcaf4da69e","modified":1757607333084},{"_id":"source/_posts/.DS_Store","hash":"ad79cff23acef1558e3c43bbc9d8ac9fc1a72c3b","modified":1757607338376},{"_id":"source/_posts/test.md","hash":"e3a5f76406104dc2c9fa345bef788243da54bd1d","modified":1757610220385},{"_id":"source/_posts/JavaScript笔记.md","hash":"0b2e2ab4445bbcb07f3b7de8cff00c0130bdfefb","modified":1757590580594},{"_id":"source/_posts/个人博客搭建.md","hash":"a86fee8e50e73cdd5827c841d78397d24a112be0","modified":1757590580594},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1757606895251},{"_id":"source/_posts/中缀计算式转换为后缀计算式.md","hash":"ac38066cfcbd052fa466678be2aa6852346fef26","modified":1757590580594},{"_id":"source/_posts/CSS笔记.md","hash":"ac47149538aac6c557d7db31068e2cc530a7d976","modified":1757590580593},{"_id":"source/_posts/HTML笔记.md","hash":"81a496e079edaa2de39a3b1e8b8c22fc394a3315","modified":1757590580594},{"_id":"source/_posts/大学物理1笔记.md","hash":"a751b8b7dd47b4512bacd0cecdced13c8029d4c6","modified":1757607394916},{"_id":"source/_posts/Git笔记.md","hash":"0602a04e74ec48870cccccbbcf7489afb4310e2e","modified":1757590580593},{"_id":"source/_posts/大学物理3笔记.md","hash":"0ac2ac1afb7ae5f9116d58ff5ced95f119f1baab","modified":1757607357624},{"_id":"source/_posts/大学物理2笔记.md","hash":"a2125676003b2c26d4575c0ff88edc8b413552a4","modified":1757607354255},{"_id":"source/_posts/毛概.md","hash":"0f7d7cc7341be1f819ad75534f42a63d3f023181","modified":1757590580597},{"_id":"source/_posts/数理方法笔记.md","hash":"ef781f1a41b4efd883bb7531f02df53f3afe3415","modified":1757607370821},{"_id":"source/_posts/高数2笔记.md","hash":"a07d29ade0bbdec23ca91a6c91c9f89ff25bbcc5","modified":1757607360928},{"_id":"source/_posts/黑波.md","hash":"5d125945a04683334543f09cff690cfb511f544a","modified":1757590580597},{"_id":"source/_posts/毛概整理.md","hash":"dae3f878a636ac0fe0518454670e2f18b367754c","modified":1757590580597},{"_id":"source/_posts/数据结构笔记.md","hash":"d50f0292aca7ddd3f6b38f9943dec08a8ff733b1","modified":1757607366115},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1757606997731},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"7746460fc2eba7439b494c46aa9b5ded81370819","modified":1757606997723},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"58dccef1d98b472dc4e6f4693c2297b0c9c5afba","modified":1757606997731},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"9c580471257f5a32bee701a059a45ea96755dcdc","modified":1757606997731},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"026ddf1a49bf8ddfef6ed86ab4d6af143c1dd95f","modified":1757606997732},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1757606997714},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"7c1a0c9f6186b6643b19d3980f055329bdb4efa4","modified":1757606997732},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"550b95d3614a64592f02666938d235e9f11e449e","modified":1757606997732},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"ff9b0e1fb9dba665af2f1e4a577f8cb9e840464b","modified":1757606997723},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"e1043de394f6dcf5c0647adcfdefe60637f78426","modified":1757606997732},{"_id":"node_modules/hexo-theme-fluid/languages/ru.yml","hash":"93818f8bf07195fb1ebffbb5210e531b0e3a6ec4","modified":1757606997732},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"a60847136709bb95586a98d9d67b50390a8d2c96","modified":1757606997732},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"e62d2e25cae57e8469e3f48c9d17be1fd284a969","modified":1757606997731},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"052e9fc19c753f53fdc083c7fb098e3668880140","modified":1757606997715},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1757606997715},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1757606997716},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1757606997715},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"51c2b4d64c6992a39bfd2586a1bdf5fbbbdf0175","modified":1757606997732},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1757606997716},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"33c3317cdcee062789de2336dd8d0cc7f86d3650","modified":1757606997717},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1757606997720},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1757606997717},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1757606997717},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":1757606997720},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"82bb06686158ebe160a631c79f156cd4fde35656","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1757606997720},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1757606997720},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":1757606997720},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1757606997720},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1757606997722},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"966689d7c5e4320008285395fbaa2751f6209be5","modified":1757606997723},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"4d48c424e47ff9a17a563167ea5f480890267adf","modified":1757606997723},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1757606997719},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"6eaf53cf4bfc756a65bda18184cf8998a12c861d","modified":1757606997719},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1757606997720},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/fold.js","hash":"73e4fd12ce3e47981479391ed354b7d9d3279f70","modified":1757606997720},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1757606997719},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1757606997722},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/crypto.js","hash":"ae4ad8a188ef5b3fa6818b01629fc962b3de8551","modified":1757606997720},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"9bf0d357a607a282f3b9cb04525a4df0cc2a8b76","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1757606997715},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"6869811f67e4c3de3edfa4b08464bb242b97a402","modified":1757606997720},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"1ef88c881b9f942deadde3d890387b94c617342a","modified":1757606997719},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1757606997720},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1757606997723},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1757606997731},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1757606997719},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/source/js/umami-view.js","hash":"33c4b3883fa747604074ad3921606eeeaeb50716","modified":1757606997722},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1757606997723},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1757606997728},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1757606997730},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1757606997719},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1757606997723},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1757606997716},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1757606997725},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1757606997724},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1757606997715},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1757606997716},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1757606997717},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1757606997716},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"1dadb118d580280524ed0a5f69bd34d234a92276","modified":1757606997717},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"67be642f99482c07904474f410cfbc2f99003288","modified":1757606997717},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1757606997717},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1757606997720},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"bd8376e1cf7892dc2daa58f2f443574be559fdbf","modified":1757606997720},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"a5fe1deccb73b5f578797dbb11038efc15f63ce8","modified":1757606997720},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"c19ac8050b82c3676b0332a56099ccfcc36d9d52","modified":1757606997720},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1757606997721},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"40c8b0852873032e7aaef3f68e8ea08706cdef13","modified":1757606997717},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1757606997716},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"954a29b58d72647d20450da270b5d8fb2e0824f5","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1757606997717},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1757606997724},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1757606997731},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1757606997725},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1757606997716},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":1757606997717},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1757606997717},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1757606997717},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1757606997717},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1757606997719},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1757606997717},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1757606997719},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"3d08c73b77e412d2f06a24d9344565fc7dbc76f8","modified":1757606997719},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1757606997716},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"37d750428772d7c71ba36ce0c2540780d90fadea","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":1757606997717},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1757606997716},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1757606997717},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1757606997717},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1757606997724},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"e6dcbf1c2f56314d56bb46b50aca86ff68cacebd","modified":1757606997715},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1757606997715},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1757606997717},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1757606997716},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"cbfa32c5f5973133afd043853b24f8200455cb2d","modified":1757606997716},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"54dd479dbb440126e4ddd9d902229db5afaaae98","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/moment.ejs","hash":"4ff3fb1b60ccc95a0af3bbdbd0757fedefc088b5","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":1757606997719},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1757606997718},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1757606997724},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1757606997724},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1757606997724},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"85492ef64d7e5f70f0f7e46d570bbc911e686d7e","modified":1757606997725},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1757606997730},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1757606997730},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1757606997730},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"25fb6fa4c783b847c632584c49a7e1593cdb2f5d","modified":1757606997730},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1757606997725},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":1757606997731},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1757606997731},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1757606997725},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1757606997725},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1757606997725},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1757606997728},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1757606997730},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1757606997724},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"c96d36aa8fe20f0c3c1a29ee2473cd8064b10f73","modified":1757606997731},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1757606997725},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1757606997725},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1757606997724},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1757606997725},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1757606997725},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d42b748f2f49ef32aafb1a21d75991d2459da927","modified":1757606997725},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1757606997725},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"7eee3f78296a3c81849a5415d1d43dcc6e03e6aa","modified":1757606997731},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1757606997730},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1757606997730},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1757606997730},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1757606997731},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1757606997731},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1757606997731},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1757606997731},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1757606997731},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1757606997723}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"JavaScript笔记","_content":"","source":"_posts/JavaScript笔记.md","raw":"---\ntitle: JavaScript笔记\n---\n","slug":"JavaScript笔记","published":1,"date":"2025-09-11T11:36:20.594Z","updated":"2025-09-11T11:36:20.594Z","comments":1,"layout":"post","photos":[],"_id":"cmffo52nq00006xzd0pd65xr4","content":"\n","excerpt":"","more":"\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2025-09-11T16:08:15.251Z","updated":"2025-09-11T16:08:15.251Z","comments":1,"layout":"post","photos":[],"_id":"cmffo52nr00016xzd7jwn1xk6","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very\nfirst post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for\nmore info. If you get any problems when using Hexo, you can find the\nanswer in <a\nhref=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or\nyou can ask me on <a\nhref=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"quick-start\">Quick Start</h2>\n<h3 id=\"create-a-new-post\">Create a new post</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n<p>More info: <a\nhref=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"run-server\">Run server</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"generate-static-files\">Generate static files</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n<p>More info: <a\nhref=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"deploy-to-remote-sites\">Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n<p>More info: <a\nhref=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very\nfirst post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for\nmore info. If you get any problems when using Hexo, you can find the\nanswer in <a\nhref=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or\nyou can ask me on <a\nhref=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"quick-start\">Quick Start</h2>\n<h3 id=\"create-a-new-post\">Create a new post</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n<p>More info: <a\nhref=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"run-server\">Run server</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"generate-static-files\">Generate static files</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n<p>More info: <a\nhref=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"deploy-to-remote-sites\">Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n<p>More info: <a\nhref=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"个人博客搭建","_content":"\n参考\n\n1. [2024 年，如何使用 github pages + Hexo + Next 搭建个人博客](https://mini-pi.github.io/2024/02/28/how-to-make-blog-wedsite/)\n2. [Hexo 文档](https://hexo.io/zh-cn/docs/)\n3. [teru 姐姐的笔记](https://teruteru.space/)\n4. [fluid 主题](https://github.com/dcldyhb/dcldyhb.github.io)\n\n使用 Github pages+Hexo 进行搭建\n\n## 第一步：github 仓库准备\n\n新建立一个 Repo，名字为你的名字+github.io\n\n## 第二步，本地化部署 Hexo 环境\n\n1.  安装 Hexo：\n\n    ```bash\n    npm install -g hexo-cli\n    ```\n\n    在 MacOS 上，可能会出现权限问题，使用修改 npm 全局安装目录的方式解决\n\n    1. 创建新的全局安装目录\n\n       ```bash\n       mkdir ~/.npm-global\n       ```\n\n    2. 配置 npm 使用新的目录路径\n\n       ```bash\n       npm config set prefix '~/.npm-global'\n       ```\n\n    3. 更新环境变量\n       打开 shell 配置文件，对于 zsh 是 `~/.zshrc`，对于 bash 是 `~/.bash_profile` 或 `~/.bashrc`，以用 vim 打开 `~/.zshrc` 为例\n\n       ```bash\n       vim ~/.zshrc\n       ```\n\n       在文件末尾添加以下行，以将新的 npm 全局目录添加到环境变量 `PATH` 中：\n\n       ```bash\n       export PATH=\"$PATH:$HOME/.npm-global/bin\"\n       ```\n\n    4. 保存并应用配置\n       保存文件，然后运行以下命令以使更改生效：\n\n       ```bash\n       source ~/.zshrc # 或 source ~/.bash_profile\n       ```\n\n    5. 验证安装\n       通过下面的命令来检查 PATH 变量是否包含了你新添加的路径\n\n       ```bash\n       echo $PATH\n       ```\n\n       如果输出的内容里包含了 `/Users/yourname/.npm-global/bin` (或者 `$HOME/.npm-global/bin`)，就说明配置成功了。\n\n2.  初始化 Hexo 框架\n\n    ```bash\n    hexo init <你的blog文件夹名字>\n    ```\n\n3.  进入 blog 文件夹\n\n    ```bash\n    cd <你的blog文件夹名字>\n    ```\n\n4.  安装依赖\n\n    ```bash\n    npm install\n    ```\n\n5.  运行 Hexo 本地服务器\n\n    ```bash\n    hexo server\n    ```\n\n## 配置主题\n\n这里以 [fluid](https://github.com/fluid-dev/hexo-theme-fluid) 主题为例（看了[teru 姐姐的笔记](https://teruteru.space/)，这个主题真的很好看）\n\n1. 进入 blog 文件夹\n2. 安装主题\n\n   ```bash\n   npm install --save hexo-theme-fluid\n   ```\n","source":"_posts/个人博客搭建.md","raw":"---\ntitle: 个人博客搭建\n---\n\n参考\n\n1. [2024 年，如何使用 github pages + Hexo + Next 搭建个人博客](https://mini-pi.github.io/2024/02/28/how-to-make-blog-wedsite/)\n2. [Hexo 文档](https://hexo.io/zh-cn/docs/)\n3. [teru 姐姐的笔记](https://teruteru.space/)\n4. [fluid 主题](https://github.com/dcldyhb/dcldyhb.github.io)\n\n使用 Github pages+Hexo 进行搭建\n\n## 第一步：github 仓库准备\n\n新建立一个 Repo，名字为你的名字+github.io\n\n## 第二步，本地化部署 Hexo 环境\n\n1.  安装 Hexo：\n\n    ```bash\n    npm install -g hexo-cli\n    ```\n\n    在 MacOS 上，可能会出现权限问题，使用修改 npm 全局安装目录的方式解决\n\n    1. 创建新的全局安装目录\n\n       ```bash\n       mkdir ~/.npm-global\n       ```\n\n    2. 配置 npm 使用新的目录路径\n\n       ```bash\n       npm config set prefix '~/.npm-global'\n       ```\n\n    3. 更新环境变量\n       打开 shell 配置文件，对于 zsh 是 `~/.zshrc`，对于 bash 是 `~/.bash_profile` 或 `~/.bashrc`，以用 vim 打开 `~/.zshrc` 为例\n\n       ```bash\n       vim ~/.zshrc\n       ```\n\n       在文件末尾添加以下行，以将新的 npm 全局目录添加到环境变量 `PATH` 中：\n\n       ```bash\n       export PATH=\"$PATH:$HOME/.npm-global/bin\"\n       ```\n\n    4. 保存并应用配置\n       保存文件，然后运行以下命令以使更改生效：\n\n       ```bash\n       source ~/.zshrc # 或 source ~/.bash_profile\n       ```\n\n    5. 验证安装\n       通过下面的命令来检查 PATH 变量是否包含了你新添加的路径\n\n       ```bash\n       echo $PATH\n       ```\n\n       如果输出的内容里包含了 `/Users/yourname/.npm-global/bin` (或者 `$HOME/.npm-global/bin`)，就说明配置成功了。\n\n2.  初始化 Hexo 框架\n\n    ```bash\n    hexo init <你的blog文件夹名字>\n    ```\n\n3.  进入 blog 文件夹\n\n    ```bash\n    cd <你的blog文件夹名字>\n    ```\n\n4.  安装依赖\n\n    ```bash\n    npm install\n    ```\n\n5.  运行 Hexo 本地服务器\n\n    ```bash\n    hexo server\n    ```\n\n## 配置主题\n\n这里以 [fluid](https://github.com/fluid-dev/hexo-theme-fluid) 主题为例（看了[teru 姐姐的笔记](https://teruteru.space/)，这个主题真的很好看）\n\n1. 进入 blog 文件夹\n2. 安装主题\n\n   ```bash\n   npm install --save hexo-theme-fluid\n   ```\n","slug":"个人博客搭建","published":1,"date":"2025-09-11T11:36:20.594Z","updated":"2025-09-11T11:36:20.594Z","comments":1,"layout":"post","photos":[],"_id":"cmffo52ns00026xzdhaog9jr7","content":"<p>参考</p>\n<ol type=\"1\">\n<li><a\nhref=\"https://mini-pi.github.io/2024/02/28/how-to-make-blog-wedsite/\">2024\n年，如何使用 github pages + Hexo + Next 搭建个人博客</a></li>\n<li><a href=\"https://hexo.io/zh-cn/docs/\">Hexo 文档</a></li>\n<li><a href=\"https://teruteru.space/\">teru 姐姐的笔记</a></li>\n<li><a href=\"https://github.com/dcldyhb/dcldyhb.github.io\">fluid\n主题</a></li>\n</ol>\n<p>使用 Github pages+Hexo 进行搭建</p>\n<h2 id=\"第一步github-仓库准备\">第一步：github 仓库准备</h2>\n<p>新建立一个 Repo，名字为你的名字+github.io</p>\n<h2 id=\"第二步本地化部署-hexo-环境\">第二步，本地化部署 Hexo 环境</h2>\n<ol type=\"1\">\n<li><p>安装 Hexo：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm install -g hexo-cli<br></code></pre></td></tr></table></figure>\n<p>在 MacOS 上，可能会出现权限问题，使用修改 npm\n全局安装目录的方式解决</p>\n<ol type=\"1\">\n<li><p>创建新的全局安装目录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">mkdir</span> ~/.npm-global<br></code></pre></td></tr></table></figure></li>\n<li><p>配置 npm 使用新的目录路径</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm config <span class=\"hljs-built_in\">set</span> prefix <span class=\"hljs-string\">&#x27;~/.npm-global&#x27;</span><br></code></pre></td></tr></table></figure></li>\n<li><p>更新环境变量 打开 shell 配置文件，对于 zsh 是\n<code>~/.zshrc</code>，对于 bash 是 <code>~/.bash_profile</code> 或\n<code>~/.bashrc</code>，以用 vim 打开 <code>~/.zshrc</code> 为例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim ~/.zshrc<br></code></pre></td></tr></table></figure>\n<p>在文件末尾添加以下行，以将新的 npm 全局目录添加到环境变量\n<code>PATH</code> 中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">export</span> PATH=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$PATH</span>:<span class=\"hljs-variable\">$HOME</span>/.npm-global/bin&quot;</span><br></code></pre></td></tr></table></figure></li>\n<li><p>保存并应用配置 保存文件，然后运行以下命令以使更改生效：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">source</span> ~/.zshrc <span class=\"hljs-comment\"># 或 source ~/.bash_profile</span><br></code></pre></td></tr></table></figure></li>\n<li><p>验证安装 通过下面的命令来检查 PATH\n变量是否包含了你新添加的路径</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$PATH</span><br></code></pre></td></tr></table></figure>\n<p>如果输出的内容里包含了 <code>/Users/yourname/.npm-global/bin</code>\n(或者 <code>$HOME/.npm-global/bin</code>)，就说明配置成功了。</p></li>\n</ol></li>\n<li><p>初始化 Hexo 框架</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo init &lt;你的blog文件夹名字&gt;<br></code></pre></td></tr></table></figure></li>\n<li><p>进入 blog 文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">cd</span> &lt;你的blog文件夹名字&gt;<br></code></pre></td></tr></table></figure></li>\n<li><p>安装依赖</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm install<br></code></pre></td></tr></table></figure></li>\n<li><p>运行 Hexo 本地服务器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo server<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"配置主题\">配置主题</h2>\n<p>这里以 <a\nhref=\"https://github.com/fluid-dev/hexo-theme-fluid\">fluid</a>\n主题为例（看了<a href=\"https://teruteru.space/\">teru\n姐姐的笔记</a>，这个主题真的很好看）</p>\n<ol type=\"1\">\n<li><p>进入 blog 文件夹</p></li>\n<li><p>安装主题</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure></li>\n</ol>\n","excerpt":"","more":"<p>参考</p>\n<ol type=\"1\">\n<li><a\nhref=\"https://mini-pi.github.io/2024/02/28/how-to-make-blog-wedsite/\">2024\n年，如何使用 github pages + Hexo + Next 搭建个人博客</a></li>\n<li><a href=\"https://hexo.io/zh-cn/docs/\">Hexo 文档</a></li>\n<li><a href=\"https://teruteru.space/\">teru 姐姐的笔记</a></li>\n<li><a href=\"https://github.com/dcldyhb/dcldyhb.github.io\">fluid\n主题</a></li>\n</ol>\n<p>使用 Github pages+Hexo 进行搭建</p>\n<h2 id=\"第一步github-仓库准备\">第一步：github 仓库准备</h2>\n<p>新建立一个 Repo，名字为你的名字+github.io</p>\n<h2 id=\"第二步本地化部署-hexo-环境\">第二步，本地化部署 Hexo 环境</h2>\n<ol type=\"1\">\n<li><p>安装 Hexo：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm install -g hexo-cli<br></code></pre></td></tr></table></figure>\n<p>在 MacOS 上，可能会出现权限问题，使用修改 npm\n全局安装目录的方式解决</p>\n<ol type=\"1\">\n<li><p>创建新的全局安装目录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">mkdir</span> ~/.npm-global<br></code></pre></td></tr></table></figure></li>\n<li><p>配置 npm 使用新的目录路径</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm config <span class=\"hljs-built_in\">set</span> prefix <span class=\"hljs-string\">&#x27;~/.npm-global&#x27;</span><br></code></pre></td></tr></table></figure></li>\n<li><p>更新环境变量 打开 shell 配置文件，对于 zsh 是\n<code>~/.zshrc</code>，对于 bash 是 <code>~/.bash_profile</code> 或\n<code>~/.bashrc</code>，以用 vim 打开 <code>~/.zshrc</code> 为例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim ~/.zshrc<br></code></pre></td></tr></table></figure>\n<p>在文件末尾添加以下行，以将新的 npm 全局目录添加到环境变量\n<code>PATH</code> 中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">export</span> PATH=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$PATH</span>:<span class=\"hljs-variable\">$HOME</span>/.npm-global/bin&quot;</span><br></code></pre></td></tr></table></figure></li>\n<li><p>保存并应用配置 保存文件，然后运行以下命令以使更改生效：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">source</span> ~/.zshrc <span class=\"hljs-comment\"># 或 source ~/.bash_profile</span><br></code></pre></td></tr></table></figure></li>\n<li><p>验证安装 通过下面的命令来检查 PATH\n变量是否包含了你新添加的路径</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$PATH</span><br></code></pre></td></tr></table></figure>\n<p>如果输出的内容里包含了 <code>/Users/yourname/.npm-global/bin</code>\n(或者 <code>$HOME/.npm-global/bin</code>)，就说明配置成功了。</p></li>\n</ol></li>\n<li><p>初始化 Hexo 框架</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo init &lt;你的blog文件夹名字&gt;<br></code></pre></td></tr></table></figure></li>\n<li><p>进入 blog 文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">cd</span> &lt;你的blog文件夹名字&gt;<br></code></pre></td></tr></table></figure></li>\n<li><p>安装依赖</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm install<br></code></pre></td></tr></table></figure></li>\n<li><p>运行 Hexo 本地服务器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo server<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"配置主题\">配置主题</h2>\n<p>这里以 <a\nhref=\"https://github.com/fluid-dev/hexo-theme-fluid\">fluid</a>\n主题为例（看了<a href=\"https://teruteru.space/\">teru\n姐姐的笔记</a>，这个主题真的很好看）</p>\n<ol type=\"1\">\n<li><p>进入 blog 文件夹</p></li>\n<li><p>安装主题</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"test","math":true,"_content":"\n## test1\n\nabc\n\n$$\nM_{\\lambda}(T)=\\frac{\\mathrm{d}E_{\\lambda}}{\\mathrm{d}\\lambda}\n$$\n\nabc\n\n$$\n\\frac{1}{2}\\int\n$$\n\nabc\n\n$$\nx+y=z\n$$\n\nabc\n\n$$\n\\left\\{\n    \\begin{aligned}\n        & u_{tt}-a^2u_{xx}=F(t,x),\\\\\n        & u(0,x)=\\varphi(x),\\\\\n        & u_t(0,x)=\\psi(x).\n    \\end{aligned}\n\\right.\n$$\n\n$$\nE=mc^2\n$$\n","source":"_posts/test.md","raw":"---\ntitle: test\nmath: true\n---\n\n## test1\n\nabc\n\n$$\nM_{\\lambda}(T)=\\frac{\\mathrm{d}E_{\\lambda}}{\\mathrm{d}\\lambda}\n$$\n\nabc\n\n$$\n\\frac{1}{2}\\int\n$$\n\nabc\n\n$$\nx+y=z\n$$\n\nabc\n\n$$\n\\left\\{\n    \\begin{aligned}\n        & u_{tt}-a^2u_{xx}=F(t,x),\\\\\n        & u(0,x)=\\varphi(x),\\\\\n        & u_t(0,x)=\\psi(x).\n    \\end{aligned}\n\\right.\n$$\n\n$$\nE=mc^2\n$$\n","slug":"test","published":1,"date":"2025-09-11T13:26:54.781Z","updated":"2025-09-11T17:03:40.385Z","comments":1,"layout":"post","photos":[],"_id":"cmffo52ns00036xzd4uewc1nc","content":"<h2 id=\"test1\">test1</h2>\n<p>abc</p>\n<p><span class=\"math display\">$$\nM_{\\lambda}(T)=\\frac{\\mathrm{d}E_{\\lambda}}{\\mathrm{d}\\lambda}\n$$</span></p>\n<p>abc</p>\n<p><span class=\"math display\">$$\n\\frac{1}{2}\\int\n$$</span></p>\n<p>abc</p>\n<p><span\nclass=\"math display\"><em>x</em> + <em>y</em> = <em>z</em></span></p>\n<p>abc</p>\n<p><span class=\"math display\">$$\n\\left\\{\n    \\begin{aligned}\n        &amp; u_{tt}-a^2u_{xx}=F(t,x),\\\\\n        &amp; u(0,x)=\\varphi(x),\\\\\n        &amp; u_t(0,x)=\\psi(x).\n    \\end{aligned}\n\\right.\n$$</span></p>\n<p><span\nclass=\"math display\"><em>E</em> = <em>m</em><em>c</em><sup>2</sup></span></p>\n","excerpt":"","more":"<h2 id=\"test1\">test1</h2>\n<p>abc</p>\n<p><span class=\"math display\">$$\nM_{\\lambda}(T)=\\frac{\\mathrm{d}E_{\\lambda}}{\\mathrm{d}\\lambda}\n$$</span></p>\n<p>abc</p>\n<p><span class=\"math display\">$$\n\\frac{1}{2}\\int\n$$</span></p>\n<p>abc</p>\n<p><span\nclass=\"math display\"><em>x</em> + <em>y</em> = <em>z</em></span></p>\n<p>abc</p>\n<p><span class=\"math display\">$$\n\\left\\{\n    \\begin{aligned}\n        &amp; u_{tt}-a^2u_{xx}=F(t,x),\\\\\n        &amp; u(0,x)=\\varphi(x),\\\\\n        &amp; u_t(0,x)=\\psi(x).\n    \\end{aligned}\n\\right.\n$$</span></p>\n<p><span\nclass=\"math display\"><em>E</em> = <em>m</em><em>c</em><sup>2</sup></span></p>\n"},{"title":"中缀计算式转换为后缀计算式","_content":"\n## **核心算法步骤**\n\n1. **初始化**\n   - 创建一个空栈（用于存放运算符和括号）。\n   - 创建一个空列表（用于保存后缀表达式结果）。\n2. **从左到右扫描中缀表达式**\n   逐个处理每个字符（忽略空格，若存在多位数需合并）。\n3. **处理操作数**\n   - 直接添加到结果列表（如数字、变量等）。\n4. **处理左括号 `(`**\n   - 直接入栈。\n5. **处理右括号 `)`**\n   - 弹出栈顶元素并添加到结果列表，**直到遇到左括号**。\n   - 弹出左括号但不添加到结果列表（丢弃括号）。\n6. **处理运算符（`+`, `-`, `\\*`, `/`, `^`等）**\n   - 比较当前运算符与栈顶运算符的优先级：\n     - **栈为空或栈顶为 `(`**：直接入栈。\n     - **当前运算符优先级 > 栈顶运算符**：入栈。\n     - **当前运算符优先级 ≤ 栈顶运算符**：弹出栈顶并添加到结果列表，重复此过程直到满足入栈条件，再入栈当前运算符。\n7. **扫描完成后**\n   - 将栈中剩余运算符依次弹出并添加到结果列表。\n\n---\n\n## **优先级规则（示例）**\n\n| 运算符    | 优先级 |\n| :-------- | :----- |\n| `(`       | 0      |\n| `+`, `-`  | 1      |\n| `*`, `/`  | 2      |\n| `^`（幂） | 3      |\n\n---\n\n## **示例：将 `3 + 4 \\* 2 / (1 - 5)` 转换为后缀表达式**\n\n1. **扫描 `3`** → 输出 `3`\n2. **扫描 `+`** → 栈空，`+` 入栈。\n3. **扫描 `4`** → 输出 `4`\n4. **扫描 `\\*`** → 栈顶为 `+`，`*` 优先级更高，入栈。\n5. **扫描 `2`** → 输出 `2`\n6. **扫描 `/`** → 栈顶为 `*`，优先级相同，弹出 `*` 并输出，`/` 入栈。\n7. **扫描 `(`** → 入栈。\n8. **扫描 `1`** → 输出 `1`\n9. **扫描 `-`** → 栈顶为 `(`，`-` 入栈。\n10. **扫描 `5`** → 输出 `5`\n11. **扫描 `)`** → 弹出 `-` 并输出，弹出 `(` 丢弃。\n12. **栈剩余操作符** → 依次弹出 `/` 和 `+` 并输出。\n\n**结果后缀表达式**：`3 4 2 * 1 5 - / +`\n\n---\n\n## **关键点**\n\n- **括号处理**：左括号入栈，右括号触发弹出直到左括号。\n- **优先级比较**：确保高优先级或同级的运算符先弹出。\n- **操作数顺序**：保持原顺序不变，仅调整运算符位置。\n\n通过以上步骤，即可系统地将中缀表达式转换为后缀表达式。\n","source":"_posts/中缀计算式转换为后缀计算式.md","raw":"---\ntitle: 中缀计算式转换为后缀计算式\n---\n\n## **核心算法步骤**\n\n1. **初始化**\n   - 创建一个空栈（用于存放运算符和括号）。\n   - 创建一个空列表（用于保存后缀表达式结果）。\n2. **从左到右扫描中缀表达式**\n   逐个处理每个字符（忽略空格，若存在多位数需合并）。\n3. **处理操作数**\n   - 直接添加到结果列表（如数字、变量等）。\n4. **处理左括号 `(`**\n   - 直接入栈。\n5. **处理右括号 `)`**\n   - 弹出栈顶元素并添加到结果列表，**直到遇到左括号**。\n   - 弹出左括号但不添加到结果列表（丢弃括号）。\n6. **处理运算符（`+`, `-`, `\\*`, `/`, `^`等）**\n   - 比较当前运算符与栈顶运算符的优先级：\n     - **栈为空或栈顶为 `(`**：直接入栈。\n     - **当前运算符优先级 > 栈顶运算符**：入栈。\n     - **当前运算符优先级 ≤ 栈顶运算符**：弹出栈顶并添加到结果列表，重复此过程直到满足入栈条件，再入栈当前运算符。\n7. **扫描完成后**\n   - 将栈中剩余运算符依次弹出并添加到结果列表。\n\n---\n\n## **优先级规则（示例）**\n\n| 运算符    | 优先级 |\n| :-------- | :----- |\n| `(`       | 0      |\n| `+`, `-`  | 1      |\n| `*`, `/`  | 2      |\n| `^`（幂） | 3      |\n\n---\n\n## **示例：将 `3 + 4 \\* 2 / (1 - 5)` 转换为后缀表达式**\n\n1. **扫描 `3`** → 输出 `3`\n2. **扫描 `+`** → 栈空，`+` 入栈。\n3. **扫描 `4`** → 输出 `4`\n4. **扫描 `\\*`** → 栈顶为 `+`，`*` 优先级更高，入栈。\n5. **扫描 `2`** → 输出 `2`\n6. **扫描 `/`** → 栈顶为 `*`，优先级相同，弹出 `*` 并输出，`/` 入栈。\n7. **扫描 `(`** → 入栈。\n8. **扫描 `1`** → 输出 `1`\n9. **扫描 `-`** → 栈顶为 `(`，`-` 入栈。\n10. **扫描 `5`** → 输出 `5`\n11. **扫描 `)`** → 弹出 `-` 并输出，弹出 `(` 丢弃。\n12. **栈剩余操作符** → 依次弹出 `/` 和 `+` 并输出。\n\n**结果后缀表达式**：`3 4 2 * 1 5 - / +`\n\n---\n\n## **关键点**\n\n- **括号处理**：左括号入栈，右括号触发弹出直到左括号。\n- **优先级比较**：确保高优先级或同级的运算符先弹出。\n- **操作数顺序**：保持原顺序不变，仅调整运算符位置。\n\n通过以上步骤，即可系统地将中缀表达式转换为后缀表达式。\n","slug":"中缀计算式转换为后缀计算式","published":1,"date":"2025-09-11T11:36:20.594Z","updated":"2025-09-11T11:36:20.594Z","comments":1,"layout":"post","photos":[],"_id":"cmffo52ns00046xzd2pyfbi79","content":"<h2 id=\"核心算法步骤\"><strong>核心算法步骤</strong></h2>\n<ol type=\"1\">\n<li><strong>初始化</strong>\n<ul>\n<li>创建一个空栈（用于存放运算符和括号）。</li>\n<li>创建一个空列表（用于保存后缀表达式结果）。</li>\n</ul></li>\n<li><strong>从左到右扫描中缀表达式</strong>\n逐个处理每个字符（忽略空格，若存在多位数需合并）。</li>\n<li><strong>处理操作数</strong>\n<ul>\n<li>直接添加到结果列表（如数字、变量等）。</li>\n</ul></li>\n<li><strong>处理左括号 <code>(</code></strong>\n<ul>\n<li>直接入栈。</li>\n</ul></li>\n<li><strong>处理右括号 <code>)</code></strong>\n<ul>\n<li>弹出栈顶元素并添加到结果列表，<strong>直到遇到左括号</strong>。</li>\n<li>弹出左括号但不添加到结果列表（丢弃括号）。</li>\n</ul></li>\n<li><strong>处理运算符（<code>+</code>, <code>-</code>, <code>\\*</code>,\n<code>/</code>, <code>^</code>等）</strong>\n<ul>\n<li>比较当前运算符与栈顶运算符的优先级：\n<ul>\n<li><strong>栈为空或栈顶为 <code>(</code></strong>：直接入栈。</li>\n<li><strong>当前运算符优先级 &gt; 栈顶运算符</strong>：入栈。</li>\n<li><strong>当前运算符优先级 ≤\n栈顶运算符</strong>：弹出栈顶并添加到结果列表，重复此过程直到满足入栈条件，再入栈当前运算符。</li>\n</ul></li>\n</ul></li>\n<li><strong>扫描完成后</strong>\n<ul>\n<li>将栈中剩余运算符依次弹出并添加到结果列表。</li>\n</ul></li>\n</ol>\n<hr />\n<h2 id=\"优先级规则示例\"><strong>优先级规则（示例）</strong></h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">运算符</th>\n<th style=\"text-align: left;\">优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><code>(</code></td>\n<td style=\"text-align: left;\">0</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>+</code>, <code>-</code></td>\n<td style=\"text-align: left;\">1</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>*</code>, <code>/</code></td>\n<td style=\"text-align: left;\">2</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>^</code>（幂）</td>\n<td style=\"text-align: left;\">3</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"示例将-3-4-2-1---5-转换为后缀表达式\"><strong>示例：将\n<code>3 + 4 \\* 2 / (1 - 5)</code> 转换为后缀表达式</strong></h2>\n<ol type=\"1\">\n<li><strong>扫描 <code>3</code></strong> → 输出 <code>3</code></li>\n<li><strong>扫描 <code>+</code></strong> → 栈空，<code>+</code>\n入栈。</li>\n<li><strong>扫描 <code>4</code></strong> → 输出 <code>4</code></li>\n<li><strong>扫描 <code>\\*</code></strong> → 栈顶为\n<code>+</code>，<code>*</code> 优先级更高，入栈。</li>\n<li><strong>扫描 <code>2</code></strong> → 输出 <code>2</code></li>\n<li><strong>扫描 <code>/</code></strong> → 栈顶为\n<code>*</code>，优先级相同，弹出 <code>*</code> 并输出，<code>/</code>\n入栈。</li>\n<li><strong>扫描 <code>(</code></strong> → 入栈。</li>\n<li><strong>扫描 <code>1</code></strong> → 输出 <code>1</code></li>\n<li><strong>扫描 <code>-</code></strong> → 栈顶为\n<code>(</code>，<code>-</code> 入栈。</li>\n<li><strong>扫描 <code>5</code></strong> → 输出 <code>5</code></li>\n<li><strong>扫描 <code>)</code></strong> → 弹出 <code>-</code>\n并输出，弹出 <code>(</code> 丢弃。</li>\n<li><strong>栈剩余操作符</strong> → 依次弹出 <code>/</code> 和\n<code>+</code> 并输出。</li>\n</ol>\n<p><strong>结果后缀表达式</strong>：<code>3 4 2 * 1 5 - / +</code></p>\n<hr />\n<h2 id=\"关键点\"><strong>关键点</strong></h2>\n<ul>\n<li><strong>括号处理</strong>：左括号入栈，右括号触发弹出直到左括号。</li>\n<li><strong>优先级比较</strong>：确保高优先级或同级的运算符先弹出。</li>\n<li><strong>操作数顺序</strong>：保持原顺序不变，仅调整运算符位置。</li>\n</ul>\n<p>通过以上步骤，即可系统地将中缀表达式转换为后缀表达式。</p>\n","excerpt":"","more":"<h2 id=\"核心算法步骤\"><strong>核心算法步骤</strong></h2>\n<ol type=\"1\">\n<li><strong>初始化</strong>\n<ul>\n<li>创建一个空栈（用于存放运算符和括号）。</li>\n<li>创建一个空列表（用于保存后缀表达式结果）。</li>\n</ul></li>\n<li><strong>从左到右扫描中缀表达式</strong>\n逐个处理每个字符（忽略空格，若存在多位数需合并）。</li>\n<li><strong>处理操作数</strong>\n<ul>\n<li>直接添加到结果列表（如数字、变量等）。</li>\n</ul></li>\n<li><strong>处理左括号 <code>(</code></strong>\n<ul>\n<li>直接入栈。</li>\n</ul></li>\n<li><strong>处理右括号 <code>)</code></strong>\n<ul>\n<li>弹出栈顶元素并添加到结果列表，<strong>直到遇到左括号</strong>。</li>\n<li>弹出左括号但不添加到结果列表（丢弃括号）。</li>\n</ul></li>\n<li><strong>处理运算符（<code>+</code>, <code>-</code>, <code>\\*</code>,\n<code>/</code>, <code>^</code>等）</strong>\n<ul>\n<li>比较当前运算符与栈顶运算符的优先级：\n<ul>\n<li><strong>栈为空或栈顶为 <code>(</code></strong>：直接入栈。</li>\n<li><strong>当前运算符优先级 &gt; 栈顶运算符</strong>：入栈。</li>\n<li><strong>当前运算符优先级 ≤\n栈顶运算符</strong>：弹出栈顶并添加到结果列表，重复此过程直到满足入栈条件，再入栈当前运算符。</li>\n</ul></li>\n</ul></li>\n<li><strong>扫描完成后</strong>\n<ul>\n<li>将栈中剩余运算符依次弹出并添加到结果列表。</li>\n</ul></li>\n</ol>\n<hr />\n<h2 id=\"优先级规则示例\"><strong>优先级规则（示例）</strong></h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">运算符</th>\n<th style=\"text-align: left;\">优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><code>(</code></td>\n<td style=\"text-align: left;\">0</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>+</code>, <code>-</code></td>\n<td style=\"text-align: left;\">1</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>*</code>, <code>/</code></td>\n<td style=\"text-align: left;\">2</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>^</code>（幂）</td>\n<td style=\"text-align: left;\">3</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"示例将-3-4-2-1---5-转换为后缀表达式\"><strong>示例：将\n<code>3 + 4 \\* 2 / (1 - 5)</code> 转换为后缀表达式</strong></h2>\n<ol type=\"1\">\n<li><strong>扫描 <code>3</code></strong> → 输出 <code>3</code></li>\n<li><strong>扫描 <code>+</code></strong> → 栈空，<code>+</code>\n入栈。</li>\n<li><strong>扫描 <code>4</code></strong> → 输出 <code>4</code></li>\n<li><strong>扫描 <code>\\*</code></strong> → 栈顶为\n<code>+</code>，<code>*</code> 优先级更高，入栈。</li>\n<li><strong>扫描 <code>2</code></strong> → 输出 <code>2</code></li>\n<li><strong>扫描 <code>/</code></strong> → 栈顶为\n<code>*</code>，优先级相同，弹出 <code>*</code> 并输出，<code>/</code>\n入栈。</li>\n<li><strong>扫描 <code>(</code></strong> → 入栈。</li>\n<li><strong>扫描 <code>1</code></strong> → 输出 <code>1</code></li>\n<li><strong>扫描 <code>-</code></strong> → 栈顶为\n<code>(</code>，<code>-</code> 入栈。</li>\n<li><strong>扫描 <code>5</code></strong> → 输出 <code>5</code></li>\n<li><strong>扫描 <code>)</code></strong> → 弹出 <code>-</code>\n并输出，弹出 <code>(</code> 丢弃。</li>\n<li><strong>栈剩余操作符</strong> → 依次弹出 <code>/</code> 和\n<code>+</code> 并输出。</li>\n</ol>\n<p><strong>结果后缀表达式</strong>：<code>3 4 2 * 1 5 - / +</code></p>\n<hr />\n<h2 id=\"关键点\"><strong>关键点</strong></h2>\n<ul>\n<li><strong>括号处理</strong>：左括号入栈，右括号触发弹出直到左括号。</li>\n<li><strong>优先级比较</strong>：确保高优先级或同级的运算符先弹出。</li>\n<li><strong>操作数顺序</strong>：保持原顺序不变，仅调整运算符位置。</li>\n</ul>\n<p>通过以上步骤，即可系统地将中缀表达式转换为后缀表达式。</p>\n"},{"title":"Git笔记","_content":"\n本文参照了 [廖雪峰的 Git 教程](https://www.liaoxuefeng.com/wiki/896043488029600) 和 [CS 自学指南](https://csdiy.wiki/%E5%BF%85%E5%AD%A6%E5%B7%A5%E5%85%B7/Git/) 的内容\n\n（学了好多才发现最好用的是 [GitHub Desktop](https://desktop.github.com/) ...）\n\n## Git 的安装和简单的配置\n\n### 安装 Git\n\n#### Windows 系统\n\n在 Windows 系统上安装 Git 有两种方法：\n\n1. 在 [Git 官网](https://git-scm.com/) 上直接下载 [Git 安装包](https://git-scm.com/downloads/win) 之后按照安装向导进行安装；\n\n2. 使用包管理器，\n\n   先下载一个包管理器，这里使用 [scoop](https://scoop.sh/) 作为示例，这里参考了 [CS 自学指南](https://csdiy.wiki/%E5%BF%85%E5%AD%A6%E5%B7%A5%E5%85%B7/Scoop/#scoop_1).\n\n   打开 power shell，执行以下命令：\n\n   ```powershell\n   # 设置 PowerShell 执行策略\n   Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n   # 下载安装脚本\n   irm get.scoop.sh -outfile 'install.ps1'\n   # 执行安装, --ScoopDir 参数指定 Scoop 安装路径\n   .\\install.ps1 -ScoopDir 'C:\\Scoop'\n   ```\n\n   然后继续输入以下指令安装 Git：\n\n   ```powershell\n   coop install git\n   ```\n\n安装完成后可以在终端中输入以下指令查看 Git 版本：\n\n```powershell\ngit -v\n```\n\n#### 在 macOS 上安装 Git\n\n在 macOS 上安装 Git 有两种方法：\n\n1. 使用 [Homebrew](https://brew.sh/) 包管理器，打开终端，输入以下命令：\n\n   ```bash\n   brew install git\n   ```\n\n2. 使用 XCode， 内置 了 Git 工具\n   运行 XCode，选择菜单 \"Xcode\" -> \"Preferences\" -> \"Downloads\"，然后选择一个 Command Line Tools 版本，系统会提示你安装命令行工具，点击 \"Instal\" 安装即可.\n\n---\n\n使用包管理器安装 Git 是最简单的方式，推荐使用这种方式.\n\n同时使用包管理器更新 Git 也非常方便.\n\n- `scoop update git` (Windows)\n- `brew upgrade git` (macOS)\n\n### 配置 Git\n\n安装完成之后对 Git 进行一些基本的配置\n\n在命令行中输入\n\n```powershell\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"email@example.com\"\n```\n\n其中 `Your Name` 替换为你的名字，`email@example.com` 替换为你的邮箱地址.\n\n`--global` 参数表明这台机器上的所有仓库都会使用这个配置，如果你想为某个特定的仓库设置不同的名字和邮箱，可以进入该仓库目录，去掉 `--global` 参数，重新执行上述命令即可.\n\n配置完之后可以使用以下命令查看配置信息：\n\n```bash\ngit config -l\n```\n\n## 创建版本库\n\n版本库也叫做仓库(repository)，是用于存储文件的地方，里面每个文件的变动 Git 都能记录.\n\n`cd` 到你**需要创建版本库的目录下**，输入以下命令：\n\n```bash\ngit init\n```\n\n这会在当前目录下创建一个名为 `.git` 的隐藏目录，里面存储了 Git 需要的所有信息.\n\n若此时使用 `ls` 命令查看当前的目录,看不到任何新建的文件夹，因为 `.git` 是一个隐藏目录.\n\n### 向版本库中添加文件\n\n首先创建一个 `Readme.md` 文件,内容为\n\n```markdown\n# Git 学习\n\nGit is a version control system.\n\nGit is free software.\n```\n\n这个文件一定要在刚才创建的版本库的目录或子目录下\n\n1. 在终端输入\n\n   ```bash\n   git add Readme.md\n   ```\n\n   这里输入的是路径而不是文件名，可以选择相对路径或者绝对路径.\n\n   如果没有输出任何内容，说明添加成功了.\n\n2. 提交这些文件到版本库中，输入以下命令：\n\n   ```bash\n   git commit -m \"Add Readme.md\"\n   ```\n\n   `-m` 参数后面跟的是提交信息，描述了这次提交的内容,有助于其他人或者未来的自己理解这次提交的目的.\n\n   一些工具可以使用 ai 生成提交信息,如 Github Desktop,这个也是十分好用的 Git 的图形化客户端.\n\n## 版本管理\n\n- 使用 `git status` 命令可以查看当前版本库的状态，显示哪些文件被修改了，哪些文件被添加了，哪些文件还没有被提交等信息.\n- 使用 `git diff` 命令可以查看文件的具体修改内容，显示哪些行被添加了，哪些行被删除了等信息.\n\n### 版本回退\n\n- 使用 `git log` 命令可以查看版本库的提交历史，显示每次提交的哈希值，作者，日期，提交信息等信息.\n\n以这个笔记的版本库为例，显示\n\n```bash\ncommit 493bb5004ef68c281f0fbf7f22e60e9111c94a86 (HEAD -> main, origin/main, origin/HEAD)\nAuthor: dcldyhb <1343605393@qq.com>\nDate:   Thu Aug 21 15:41:08 2025 +0800\n\n    Update .gitignore and workspace layout settings\n\n    Added duplicate entries for .obsidian and workspace.json in .gitignore. Modified workspace.json to set the left pane as collapsed by default.\n\ncommit d63e6e188c19e1f13fbf38ec735125e7c22d5484\nAuthor: dcldyhb <1343605393@qq.com>\nDate:   Thu Aug 21 15:39:11 2025 +0800\n\n    updated Git notes\n\ncommit 172fb0bb0c001e1451eab09d8abb04814c755d0d\nAuthor: dcldyhb <1343605393@qq.com>\nDate:   Fri Aug 15 01:06:28 2025 +0800\n\n    Update .gitignore and workspace settings\n```\n\n在 powee shell 中\n\n- 使用 <kbd>j</kbd> 和 <kbd>k</kbd> 键可以上下移动查看提交记录.\n- 使用 <kbd>q</kbd> 键可以退出日志查看.\n\n该命令会从最近到最远显示提交的记录，在这里我列出了最近的三个提交记录.\n\n最近的一次是 `UUpdate .gitignore and workspace layout settings`，上一次是 `update Git notes`，再上一次是 `Update .gitignore and workspace settings`.\n\n加上 `--pretty=oneline` 参数可以让输出显示为一行，方便查看.\n\n形如 `493bb5004ef68c281f0fbf7f22e60e9111c94a86` 的是每次提交的版本号，git 会为每次提交生成一个唯一的哈希值，这个哈希值可以用来标识这次提交.\n\ngit 使用 `HEAD` 来标识当前版本库的最新提交，这里是 `172fb0bb0c001e1451eab09d8abb04814c755d0d`，上一个版本是 `HEAD^`，也就是 `d63e6e188c19e1f13fbf38ec735125e7c22d5484`，再上一个版本是 `HEAD^^`，也就是 `172fb0bb0c001e1451eab09d8abb04814c755d0d`.\n\n我们使用 `git reset` 命令来回退到上一个版本.\n\n```bash\ngit reset --hard HEAD^\n```\n\n`--hard` 参数表明回到上个版本的已提交状态，`--soft` 参数表明回到上个版本的未提交状态，`--mixed` 参数表明回到上个版本的已暂存状态.\n\n我们同样可以使用该命令返回更晚的版本，只要记得版本号\n\n```bash\ngit reset --hard 493bb5004ef68c281f0fbf7f22e60e9111c94a86\n```\n\n这里的版本号不需要是完整的哈希值，只需要前几位就可以了，Git 会自动匹配到唯一的版本.\n\ngit 的版本回退很快，因为 Git 内部有一个指向当前版本的 `HEAD` 指针，回退只需要修改这个指针的指向即可.\n\n如果找不到可以使用 `git reflog` 命令查看所有的提交记录，包括已经被回退的版本.\n\n```bash\n172fb0b HEAD@{1}: reset: moving to HEAD^^\n493bb50 (HEAD -> main, origin/main, origin/HEAD) HEAD@{2}: commit: Update .gitignore and workspace layout settings\nd63e6e1 HEAD@{3}: commit: updated Git notes\n172fb0b HEAD@{4}: commit: Update .gitignore and workspace settings\n```\n\n这里发现 Update .gitignore and workspace layout settings 的版本号是 `493bb50`，可以使用 `git reset --hard 493bb50` 命令回到这个版本.\n\n### 工作区和暂存区\n\n#### 名词解释\n\n- **工作区（Working Directory）：** 电脑中的目录\n- **版本库（Repository）：** 工作区中的 `.git` 目录，默认为隐藏\n  存储有所有的版本信息，其中最重要的就是称为 `stage` （或 `index`）的暂存区，还有 Git 为我们自动创建的第一个分支 `master` 分支，以及指向当前分支的 `HEAD` 指针.\n","source":"_posts/Git笔记.md","raw":"---\ntitle: Git笔记\n---\n\n本文参照了 [廖雪峰的 Git 教程](https://www.liaoxuefeng.com/wiki/896043488029600) 和 [CS 自学指南](https://csdiy.wiki/%E5%BF%85%E5%AD%A6%E5%B7%A5%E5%85%B7/Git/) 的内容\n\n（学了好多才发现最好用的是 [GitHub Desktop](https://desktop.github.com/) ...）\n\n## Git 的安装和简单的配置\n\n### 安装 Git\n\n#### Windows 系统\n\n在 Windows 系统上安装 Git 有两种方法：\n\n1. 在 [Git 官网](https://git-scm.com/) 上直接下载 [Git 安装包](https://git-scm.com/downloads/win) 之后按照安装向导进行安装；\n\n2. 使用包管理器，\n\n   先下载一个包管理器，这里使用 [scoop](https://scoop.sh/) 作为示例，这里参考了 [CS 自学指南](https://csdiy.wiki/%E5%BF%85%E5%AD%A6%E5%B7%A5%E5%85%B7/Scoop/#scoop_1).\n\n   打开 power shell，执行以下命令：\n\n   ```powershell\n   # 设置 PowerShell 执行策略\n   Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n   # 下载安装脚本\n   irm get.scoop.sh -outfile 'install.ps1'\n   # 执行安装, --ScoopDir 参数指定 Scoop 安装路径\n   .\\install.ps1 -ScoopDir 'C:\\Scoop'\n   ```\n\n   然后继续输入以下指令安装 Git：\n\n   ```powershell\n   coop install git\n   ```\n\n安装完成后可以在终端中输入以下指令查看 Git 版本：\n\n```powershell\ngit -v\n```\n\n#### 在 macOS 上安装 Git\n\n在 macOS 上安装 Git 有两种方法：\n\n1. 使用 [Homebrew](https://brew.sh/) 包管理器，打开终端，输入以下命令：\n\n   ```bash\n   brew install git\n   ```\n\n2. 使用 XCode， 内置 了 Git 工具\n   运行 XCode，选择菜单 \"Xcode\" -> \"Preferences\" -> \"Downloads\"，然后选择一个 Command Line Tools 版本，系统会提示你安装命令行工具，点击 \"Instal\" 安装即可.\n\n---\n\n使用包管理器安装 Git 是最简单的方式，推荐使用这种方式.\n\n同时使用包管理器更新 Git 也非常方便.\n\n- `scoop update git` (Windows)\n- `brew upgrade git` (macOS)\n\n### 配置 Git\n\n安装完成之后对 Git 进行一些基本的配置\n\n在命令行中输入\n\n```powershell\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"email@example.com\"\n```\n\n其中 `Your Name` 替换为你的名字，`email@example.com` 替换为你的邮箱地址.\n\n`--global` 参数表明这台机器上的所有仓库都会使用这个配置，如果你想为某个特定的仓库设置不同的名字和邮箱，可以进入该仓库目录，去掉 `--global` 参数，重新执行上述命令即可.\n\n配置完之后可以使用以下命令查看配置信息：\n\n```bash\ngit config -l\n```\n\n## 创建版本库\n\n版本库也叫做仓库(repository)，是用于存储文件的地方，里面每个文件的变动 Git 都能记录.\n\n`cd` 到你**需要创建版本库的目录下**，输入以下命令：\n\n```bash\ngit init\n```\n\n这会在当前目录下创建一个名为 `.git` 的隐藏目录，里面存储了 Git 需要的所有信息.\n\n若此时使用 `ls` 命令查看当前的目录,看不到任何新建的文件夹，因为 `.git` 是一个隐藏目录.\n\n### 向版本库中添加文件\n\n首先创建一个 `Readme.md` 文件,内容为\n\n```markdown\n# Git 学习\n\nGit is a version control system.\n\nGit is free software.\n```\n\n这个文件一定要在刚才创建的版本库的目录或子目录下\n\n1. 在终端输入\n\n   ```bash\n   git add Readme.md\n   ```\n\n   这里输入的是路径而不是文件名，可以选择相对路径或者绝对路径.\n\n   如果没有输出任何内容，说明添加成功了.\n\n2. 提交这些文件到版本库中，输入以下命令：\n\n   ```bash\n   git commit -m \"Add Readme.md\"\n   ```\n\n   `-m` 参数后面跟的是提交信息，描述了这次提交的内容,有助于其他人或者未来的自己理解这次提交的目的.\n\n   一些工具可以使用 ai 生成提交信息,如 Github Desktop,这个也是十分好用的 Git 的图形化客户端.\n\n## 版本管理\n\n- 使用 `git status` 命令可以查看当前版本库的状态，显示哪些文件被修改了，哪些文件被添加了，哪些文件还没有被提交等信息.\n- 使用 `git diff` 命令可以查看文件的具体修改内容，显示哪些行被添加了，哪些行被删除了等信息.\n\n### 版本回退\n\n- 使用 `git log` 命令可以查看版本库的提交历史，显示每次提交的哈希值，作者，日期，提交信息等信息.\n\n以这个笔记的版本库为例，显示\n\n```bash\ncommit 493bb5004ef68c281f0fbf7f22e60e9111c94a86 (HEAD -> main, origin/main, origin/HEAD)\nAuthor: dcldyhb <1343605393@qq.com>\nDate:   Thu Aug 21 15:41:08 2025 +0800\n\n    Update .gitignore and workspace layout settings\n\n    Added duplicate entries for .obsidian and workspace.json in .gitignore. Modified workspace.json to set the left pane as collapsed by default.\n\ncommit d63e6e188c19e1f13fbf38ec735125e7c22d5484\nAuthor: dcldyhb <1343605393@qq.com>\nDate:   Thu Aug 21 15:39:11 2025 +0800\n\n    updated Git notes\n\ncommit 172fb0bb0c001e1451eab09d8abb04814c755d0d\nAuthor: dcldyhb <1343605393@qq.com>\nDate:   Fri Aug 15 01:06:28 2025 +0800\n\n    Update .gitignore and workspace settings\n```\n\n在 powee shell 中\n\n- 使用 <kbd>j</kbd> 和 <kbd>k</kbd> 键可以上下移动查看提交记录.\n- 使用 <kbd>q</kbd> 键可以退出日志查看.\n\n该命令会从最近到最远显示提交的记录，在这里我列出了最近的三个提交记录.\n\n最近的一次是 `UUpdate .gitignore and workspace layout settings`，上一次是 `update Git notes`，再上一次是 `Update .gitignore and workspace settings`.\n\n加上 `--pretty=oneline` 参数可以让输出显示为一行，方便查看.\n\n形如 `493bb5004ef68c281f0fbf7f22e60e9111c94a86` 的是每次提交的版本号，git 会为每次提交生成一个唯一的哈希值，这个哈希值可以用来标识这次提交.\n\ngit 使用 `HEAD` 来标识当前版本库的最新提交，这里是 `172fb0bb0c001e1451eab09d8abb04814c755d0d`，上一个版本是 `HEAD^`，也就是 `d63e6e188c19e1f13fbf38ec735125e7c22d5484`，再上一个版本是 `HEAD^^`，也就是 `172fb0bb0c001e1451eab09d8abb04814c755d0d`.\n\n我们使用 `git reset` 命令来回退到上一个版本.\n\n```bash\ngit reset --hard HEAD^\n```\n\n`--hard` 参数表明回到上个版本的已提交状态，`--soft` 参数表明回到上个版本的未提交状态，`--mixed` 参数表明回到上个版本的已暂存状态.\n\n我们同样可以使用该命令返回更晚的版本，只要记得版本号\n\n```bash\ngit reset --hard 493bb5004ef68c281f0fbf7f22e60e9111c94a86\n```\n\n这里的版本号不需要是完整的哈希值，只需要前几位就可以了，Git 会自动匹配到唯一的版本.\n\ngit 的版本回退很快，因为 Git 内部有一个指向当前版本的 `HEAD` 指针，回退只需要修改这个指针的指向即可.\n\n如果找不到可以使用 `git reflog` 命令查看所有的提交记录，包括已经被回退的版本.\n\n```bash\n172fb0b HEAD@{1}: reset: moving to HEAD^^\n493bb50 (HEAD -> main, origin/main, origin/HEAD) HEAD@{2}: commit: Update .gitignore and workspace layout settings\nd63e6e1 HEAD@{3}: commit: updated Git notes\n172fb0b HEAD@{4}: commit: Update .gitignore and workspace settings\n```\n\n这里发现 Update .gitignore and workspace layout settings 的版本号是 `493bb50`，可以使用 `git reset --hard 493bb50` 命令回到这个版本.\n\n### 工作区和暂存区\n\n#### 名词解释\n\n- **工作区（Working Directory）：** 电脑中的目录\n- **版本库（Repository）：** 工作区中的 `.git` 目录，默认为隐藏\n  存储有所有的版本信息，其中最重要的就是称为 `stage` （或 `index`）的暂存区，还有 Git 为我们自动创建的第一个分支 `master` 分支，以及指向当前分支的 `HEAD` 指针.\n","slug":"Git笔记","published":1,"date":"2025-09-11T11:36:20.593Z","updated":"2025-09-11T11:36:20.593Z","comments":1,"layout":"post","photos":[],"_id":"cmffo52ns00056xzde6m23ykb","content":"<p>本文参照了 <a\nhref=\"https://www.liaoxuefeng.com/wiki/896043488029600\">廖雪峰的 Git\n教程</a> 和 <a\nhref=\"https://csdiy.wiki/%E5%BF%85%E5%AD%A6%E5%B7%A5%E5%85%B7/Git/\">CS\n自学指南</a> 的内容</p>\n<p>（学了好多才发现最好用的是 <a\nhref=\"https://desktop.github.com/\">GitHub Desktop</a> …）</p>\n<h2 id=\"git-的安装和简单的配置\">Git 的安装和简单的配置</h2>\n<h3 id=\"安装-git\">安装 Git</h3>\n<h4 id=\"windows-系统\">Windows 系统</h4>\n<p>在 Windows 系统上安装 Git 有两种方法：</p>\n<ol type=\"1\">\n<li><p>在 <a href=\"https://git-scm.com/\">Git 官网</a> 上直接下载 <a\nhref=\"https://git-scm.com/downloads/win\">Git 安装包</a>\n之后按照安装向导进行安装；</p></li>\n<li><p>使用包管理器，</p>\n<p>先下载一个包管理器，这里使用 <a href=\"https://scoop.sh/\">scoop</a>\n作为示例，这里参考了 <a\nhref=\"https://csdiy.wiki/%E5%BF%85%E5%AD%A6%E5%B7%A5%E5%85%B7/Scoop/#scoop_1\">CS\n自学指南</a>.</p>\n<p>打开 power shell，执行以下命令：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-comment\"># 设置 PowerShell 执行策略</span><br><span class=\"hljs-built_in\">Set-ExecutionPolicy</span> <span class=\"hljs-literal\">-ExecutionPolicy</span> RemoteSigned <span class=\"hljs-literal\">-Scope</span> CurrentUser<br><span class=\"hljs-comment\"># 下载安装脚本</span><br><span class=\"hljs-built_in\">irm</span> get.scoop.sh <span class=\"hljs-literal\">-outfile</span> <span class=\"hljs-string\">&#x27;install.ps1&#x27;</span><br><span class=\"hljs-comment\"># 执行安装, --ScoopDir 参数指定 Scoop 安装路径</span><br>.\\install.ps1 <span class=\"hljs-literal\">-ScoopDir</span> <span class=\"hljs-string\">&#x27;C:\\Scoop&#x27;</span><br></code></pre></td></tr></table></figure>\n<p>然后继续输入以下指令安装 Git：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">coop install git<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>安装完成后可以在终端中输入以下指令查看 Git 版本：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">git <span class=\"hljs-literal\">-v</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"在-macos-上安装-git\">在 macOS 上安装 Git</h4>\n<p>在 macOS 上安装 Git 有两种方法：</p>\n<ol type=\"1\">\n<li><p>使用 <a href=\"https://brew.sh/\">Homebrew</a>\n包管理器，打开终端，输入以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">brew install git<br></code></pre></td></tr></table></figure></li>\n<li><p>使用 XCode， 内置 了 Git 工具 运行 XCode，选择菜单 “Xcode” -&gt;\n“Preferences” -&gt; “Downloads”，然后选择一个 Command Line Tools\n版本，系统会提示你安装命令行工具，点击 “Instal” 安装即可.</p></li>\n</ol>\n<hr />\n<p>使用包管理器安装 Git 是最简单的方式，推荐使用这种方式.</p>\n<p>同时使用包管理器更新 Git 也非常方便.</p>\n<ul>\n<li><code>scoop update git</code> (Windows)</li>\n<li><code>brew upgrade git</code> (macOS)</li>\n</ul>\n<h3 id=\"配置-git\">配置 Git</h3>\n<p>安装完成之后对 Git 进行一些基本的配置</p>\n<p>在命令行中输入</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">git config <span class=\"hljs-literal\">--global</span> user.name <span class=\"hljs-string\">&quot;Your Name&quot;</span><br>git config <span class=\"hljs-literal\">--global</span> user.email <span class=\"hljs-string\">&quot;email@example.com&quot;</span><br></code></pre></td></tr></table></figure>\n<p>其中 <code>Your Name</code>\n替换为你的名字，<code>email@example.com</code> 替换为你的邮箱地址.</p>\n<p><code>--global</code>\n参数表明这台机器上的所有仓库都会使用这个配置，如果你想为某个特定的仓库设置不同的名字和邮箱，可以进入该仓库目录，去掉\n<code>--global</code> 参数，重新执行上述命令即可.</p>\n<p>配置完之后可以使用以下命令查看配置信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config -l<br></code></pre></td></tr></table></figure>\n<h2 id=\"创建版本库\">创建版本库</h2>\n<p>版本库也叫做仓库(repository)，是用于存储文件的地方，里面每个文件的变动\nGit 都能记录.</p>\n<p><code>cd</code>\n到你<strong>需要创建版本库的目录下</strong>，输入以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git init<br></code></pre></td></tr></table></figure>\n<p>这会在当前目录下创建一个名为 <code>.git</code> 的隐藏目录，里面存储了\nGit 需要的所有信息.</p>\n<p>若此时使用 <code>ls</code>\n命令查看当前的目录,看不到任何新建的文件夹，因为 <code>.git</code>\n是一个隐藏目录.</p>\n<h3 id=\"向版本库中添加文件\">向版本库中添加文件</h3>\n<p>首先创建一个 <code>Readme.md</code> 文件,内容为</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-section\"># Git 学习</span><br><br>Git is a version control system.<br><br>Git is free software.<br></code></pre></td></tr></table></figure>\n<p>这个文件一定要在刚才创建的版本库的目录或子目录下</p>\n<ol type=\"1\">\n<li><p>在终端输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git add Readme.md<br></code></pre></td></tr></table></figure>\n<p>这里输入的是路径而不是文件名，可以选择相对路径或者绝对路径.</p>\n<p>如果没有输出任何内容，说明添加成功了.</p></li>\n<li><p>提交这些文件到版本库中，输入以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git commit -m <span class=\"hljs-string\">&quot;Add Readme.md&quot;</span><br></code></pre></td></tr></table></figure>\n<p><code>-m</code>\n参数后面跟的是提交信息，描述了这次提交的内容,有助于其他人或者未来的自己理解这次提交的目的.</p>\n<p>一些工具可以使用 ai 生成提交信息,如 Github Desktop,这个也是十分好用的\nGit 的图形化客户端.</p></li>\n</ol>\n<h2 id=\"版本管理\">版本管理</h2>\n<ul>\n<li>使用 <code>git status</code>\n命令可以查看当前版本库的状态，显示哪些文件被修改了，哪些文件被添加了，哪些文件还没有被提交等信息.</li>\n<li>使用 <code>git diff</code>\n命令可以查看文件的具体修改内容，显示哪些行被添加了，哪些行被删除了等信息.</li>\n</ul>\n<h3 id=\"版本回退\">版本回退</h3>\n<ul>\n<li>使用 <code>git log</code>\n命令可以查看版本库的提交历史，显示每次提交的哈希值，作者，日期，提交信息等信息.</li>\n</ul>\n<p>以这个笔记的版本库为例，显示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">commit 493bb5004ef68c281f0fbf7f22e60e9111c94a86 (HEAD -&gt; main, origin/main, origin/HEAD)<br>Author: dcldyhb &lt;1343605393@qq.com&gt;<br>Date:   Thu Aug 21 15:41:08 2025 +0800<br><br>    Update .gitignore and workspace layout settings<br><br>    Added duplicate entries <span class=\"hljs-keyword\">for</span> .obsidian and workspace.json <span class=\"hljs-keyword\">in</span> .gitignore. Modified workspace.json to <span class=\"hljs-built_in\">set</span> the left pane as collapsed by default.<br><br>commit d63e6e188c19e1f13fbf38ec735125e7c22d5484<br>Author: dcldyhb &lt;1343605393@qq.com&gt;<br>Date:   Thu Aug 21 15:39:11 2025 +0800<br><br>    updated Git notes<br><br>commit 172fb0bb0c001e1451eab09d8abb04814c755d0d<br>Author: dcldyhb &lt;1343605393@qq.com&gt;<br>Date:   Fri Aug 15 01:06:28 2025 +0800<br><br>    Update .gitignore and workspace settings<br></code></pre></td></tr></table></figure>\n<p>在 powee shell 中</p>\n<ul>\n<li>使用 <kbd>j</kbd> 和 <kbd>k</kbd> 键可以上下移动查看提交记录.</li>\n<li>使用 <kbd>q</kbd> 键可以退出日志查看.</li>\n</ul>\n<p>该命令会从最近到最远显示提交的记录，在这里我列出了最近的三个提交记录.</p>\n<p>最近的一次是\n<code>UUpdate .gitignore and workspace layout settings</code>，上一次是\n<code>update Git notes</code>，再上一次是\n<code>Update .gitignore and workspace settings</code>.</p>\n<p>加上 <code>--pretty=oneline</code>\n参数可以让输出显示为一行，方便查看.</p>\n<p>形如 <code>493bb5004ef68c281f0fbf7f22e60e9111c94a86</code>\n的是每次提交的版本号，git\n会为每次提交生成一个唯一的哈希值，这个哈希值可以用来标识这次提交.</p>\n<p>git 使用 <code>HEAD</code> 来标识当前版本库的最新提交，这里是\n<code>172fb0bb0c001e1451eab09d8abb04814c755d0d</code>，上一个版本是\n<code>HEAD^</code>，也就是\n<code>d63e6e188c19e1f13fbf38ec735125e7c22d5484</code>，再上一个版本是\n<code>HEAD^^</code>，也就是\n<code>172fb0bb0c001e1451eab09d8abb04814c755d0d</code>.</p>\n<p>我们使用 <code>git reset</code> 命令来回退到上一个版本.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git reset --hard HEAD^<br></code></pre></td></tr></table></figure>\n<p><code>--hard</code>\n参数表明回到上个版本的已提交状态，<code>--soft</code>\n参数表明回到上个版本的未提交状态，<code>--mixed</code>\n参数表明回到上个版本的已暂存状态.</p>\n<p>我们同样可以使用该命令返回更晚的版本，只要记得版本号</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git reset --hard 493bb5004ef68c281f0fbf7f22e60e9111c94a86<br></code></pre></td></tr></table></figure>\n<p>这里的版本号不需要是完整的哈希值，只需要前几位就可以了，Git\n会自动匹配到唯一的版本.</p>\n<p>git 的版本回退很快，因为 Git 内部有一个指向当前版本的\n<code>HEAD</code> 指针，回退只需要修改这个指针的指向即可.</p>\n<p>如果找不到可以使用 <code>git reflog</code>\n命令查看所有的提交记录，包括已经被回退的版本.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">172fb0b HEAD@&#123;1&#125;: reset: moving to HEAD^^<br>493bb50 (HEAD -&gt; main, origin/main, origin/HEAD) HEAD@&#123;2&#125;: commit: Update .gitignore and workspace layout settings<br>d63e6e1 HEAD@&#123;3&#125;: commit: updated Git notes<br>172fb0b HEAD@&#123;4&#125;: commit: Update .gitignore and workspace settings<br></code></pre></td></tr></table></figure>\n<p>这里发现 Update .gitignore and workspace layout settings 的版本号是\n<code>493bb50</code>，可以使用 <code>git reset --hard 493bb50</code>\n命令回到这个版本.</p>\n<h3 id=\"工作区和暂存区\">工作区和暂存区</h3>\n<h4 id=\"名词解释\">名词解释</h4>\n<ul>\n<li><strong>工作区（Working Directory）：</strong> 电脑中的目录</li>\n<li><strong>版本库（Repository）：</strong> 工作区中的 <code>.git</code>\n目录，默认为隐藏 存储有所有的版本信息，其中最重要的就是称为\n<code>stage</code> （或 <code>index</code>）的暂存区，还有 Git\n为我们自动创建的第一个分支 <code>master</code> 分支，以及指向当前分支的\n<code>HEAD</code> 指针.</li>\n</ul>\n","excerpt":"","more":"<p>本文参照了 <a\nhref=\"https://www.liaoxuefeng.com/wiki/896043488029600\">廖雪峰的 Git\n教程</a> 和 <a\nhref=\"https://csdiy.wiki/%E5%BF%85%E5%AD%A6%E5%B7%A5%E5%85%B7/Git/\">CS\n自学指南</a> 的内容</p>\n<p>（学了好多才发现最好用的是 <a\nhref=\"https://desktop.github.com/\">GitHub Desktop</a> …）</p>\n<h2 id=\"git-的安装和简单的配置\">Git 的安装和简单的配置</h2>\n<h3 id=\"安装-git\">安装 Git</h3>\n<h4 id=\"windows-系统\">Windows 系统</h4>\n<p>在 Windows 系统上安装 Git 有两种方法：</p>\n<ol type=\"1\">\n<li><p>在 <a href=\"https://git-scm.com/\">Git 官网</a> 上直接下载 <a\nhref=\"https://git-scm.com/downloads/win\">Git 安装包</a>\n之后按照安装向导进行安装；</p></li>\n<li><p>使用包管理器，</p>\n<p>先下载一个包管理器，这里使用 <a href=\"https://scoop.sh/\">scoop</a>\n作为示例，这里参考了 <a\nhref=\"https://csdiy.wiki/%E5%BF%85%E5%AD%A6%E5%B7%A5%E5%85%B7/Scoop/#scoop_1\">CS\n自学指南</a>.</p>\n<p>打开 power shell，执行以下命令：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-comment\"># 设置 PowerShell 执行策略</span><br><span class=\"hljs-built_in\">Set-ExecutionPolicy</span> <span class=\"hljs-literal\">-ExecutionPolicy</span> RemoteSigned <span class=\"hljs-literal\">-Scope</span> CurrentUser<br><span class=\"hljs-comment\"># 下载安装脚本</span><br><span class=\"hljs-built_in\">irm</span> get.scoop.sh <span class=\"hljs-literal\">-outfile</span> <span class=\"hljs-string\">&#x27;install.ps1&#x27;</span><br><span class=\"hljs-comment\"># 执行安装, --ScoopDir 参数指定 Scoop 安装路径</span><br>.\\install.ps1 <span class=\"hljs-literal\">-ScoopDir</span> <span class=\"hljs-string\">&#x27;C:\\Scoop&#x27;</span><br></code></pre></td></tr></table></figure>\n<p>然后继续输入以下指令安装 Git：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">coop install git<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>安装完成后可以在终端中输入以下指令查看 Git 版本：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">git <span class=\"hljs-literal\">-v</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"在-macos-上安装-git\">在 macOS 上安装 Git</h4>\n<p>在 macOS 上安装 Git 有两种方法：</p>\n<ol type=\"1\">\n<li><p>使用 <a href=\"https://brew.sh/\">Homebrew</a>\n包管理器，打开终端，输入以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">brew install git<br></code></pre></td></tr></table></figure></li>\n<li><p>使用 XCode， 内置 了 Git 工具 运行 XCode，选择菜单 “Xcode” -&gt;\n“Preferences” -&gt; “Downloads”，然后选择一个 Command Line Tools\n版本，系统会提示你安装命令行工具，点击 “Instal” 安装即可.</p></li>\n</ol>\n<hr />\n<p>使用包管理器安装 Git 是最简单的方式，推荐使用这种方式.</p>\n<p>同时使用包管理器更新 Git 也非常方便.</p>\n<ul>\n<li><code>scoop update git</code> (Windows)</li>\n<li><code>brew upgrade git</code> (macOS)</li>\n</ul>\n<h3 id=\"配置-git\">配置 Git</h3>\n<p>安装完成之后对 Git 进行一些基本的配置</p>\n<p>在命令行中输入</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">git config <span class=\"hljs-literal\">--global</span> user.name <span class=\"hljs-string\">&quot;Your Name&quot;</span><br>git config <span class=\"hljs-literal\">--global</span> user.email <span class=\"hljs-string\">&quot;email@example.com&quot;</span><br></code></pre></td></tr></table></figure>\n<p>其中 <code>Your Name</code>\n替换为你的名字，<code>email@example.com</code> 替换为你的邮箱地址.</p>\n<p><code>--global</code>\n参数表明这台机器上的所有仓库都会使用这个配置，如果你想为某个特定的仓库设置不同的名字和邮箱，可以进入该仓库目录，去掉\n<code>--global</code> 参数，重新执行上述命令即可.</p>\n<p>配置完之后可以使用以下命令查看配置信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config -l<br></code></pre></td></tr></table></figure>\n<h2 id=\"创建版本库\">创建版本库</h2>\n<p>版本库也叫做仓库(repository)，是用于存储文件的地方，里面每个文件的变动\nGit 都能记录.</p>\n<p><code>cd</code>\n到你<strong>需要创建版本库的目录下</strong>，输入以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git init<br></code></pre></td></tr></table></figure>\n<p>这会在当前目录下创建一个名为 <code>.git</code> 的隐藏目录，里面存储了\nGit 需要的所有信息.</p>\n<p>若此时使用 <code>ls</code>\n命令查看当前的目录,看不到任何新建的文件夹，因为 <code>.git</code>\n是一个隐藏目录.</p>\n<h3 id=\"向版本库中添加文件\">向版本库中添加文件</h3>\n<p>首先创建一个 <code>Readme.md</code> 文件,内容为</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-section\"># Git 学习</span><br><br>Git is a version control system.<br><br>Git is free software.<br></code></pre></td></tr></table></figure>\n<p>这个文件一定要在刚才创建的版本库的目录或子目录下</p>\n<ol type=\"1\">\n<li><p>在终端输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git add Readme.md<br></code></pre></td></tr></table></figure>\n<p>这里输入的是路径而不是文件名，可以选择相对路径或者绝对路径.</p>\n<p>如果没有输出任何内容，说明添加成功了.</p></li>\n<li><p>提交这些文件到版本库中，输入以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git commit -m <span class=\"hljs-string\">&quot;Add Readme.md&quot;</span><br></code></pre></td></tr></table></figure>\n<p><code>-m</code>\n参数后面跟的是提交信息，描述了这次提交的内容,有助于其他人或者未来的自己理解这次提交的目的.</p>\n<p>一些工具可以使用 ai 生成提交信息,如 Github Desktop,这个也是十分好用的\nGit 的图形化客户端.</p></li>\n</ol>\n<h2 id=\"版本管理\">版本管理</h2>\n<ul>\n<li>使用 <code>git status</code>\n命令可以查看当前版本库的状态，显示哪些文件被修改了，哪些文件被添加了，哪些文件还没有被提交等信息.</li>\n<li>使用 <code>git diff</code>\n命令可以查看文件的具体修改内容，显示哪些行被添加了，哪些行被删除了等信息.</li>\n</ul>\n<h3 id=\"版本回退\">版本回退</h3>\n<ul>\n<li>使用 <code>git log</code>\n命令可以查看版本库的提交历史，显示每次提交的哈希值，作者，日期，提交信息等信息.</li>\n</ul>\n<p>以这个笔记的版本库为例，显示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">commit 493bb5004ef68c281f0fbf7f22e60e9111c94a86 (HEAD -&gt; main, origin/main, origin/HEAD)<br>Author: dcldyhb &lt;1343605393@qq.com&gt;<br>Date:   Thu Aug 21 15:41:08 2025 +0800<br><br>    Update .gitignore and workspace layout settings<br><br>    Added duplicate entries <span class=\"hljs-keyword\">for</span> .obsidian and workspace.json <span class=\"hljs-keyword\">in</span> .gitignore. Modified workspace.json to <span class=\"hljs-built_in\">set</span> the left pane as collapsed by default.<br><br>commit d63e6e188c19e1f13fbf38ec735125e7c22d5484<br>Author: dcldyhb &lt;1343605393@qq.com&gt;<br>Date:   Thu Aug 21 15:39:11 2025 +0800<br><br>    updated Git notes<br><br>commit 172fb0bb0c001e1451eab09d8abb04814c755d0d<br>Author: dcldyhb &lt;1343605393@qq.com&gt;<br>Date:   Fri Aug 15 01:06:28 2025 +0800<br><br>    Update .gitignore and workspace settings<br></code></pre></td></tr></table></figure>\n<p>在 powee shell 中</p>\n<ul>\n<li>使用 <kbd>j</kbd> 和 <kbd>k</kbd> 键可以上下移动查看提交记录.</li>\n<li>使用 <kbd>q</kbd> 键可以退出日志查看.</li>\n</ul>\n<p>该命令会从最近到最远显示提交的记录，在这里我列出了最近的三个提交记录.</p>\n<p>最近的一次是\n<code>UUpdate .gitignore and workspace layout settings</code>，上一次是\n<code>update Git notes</code>，再上一次是\n<code>Update .gitignore and workspace settings</code>.</p>\n<p>加上 <code>--pretty=oneline</code>\n参数可以让输出显示为一行，方便查看.</p>\n<p>形如 <code>493bb5004ef68c281f0fbf7f22e60e9111c94a86</code>\n的是每次提交的版本号，git\n会为每次提交生成一个唯一的哈希值，这个哈希值可以用来标识这次提交.</p>\n<p>git 使用 <code>HEAD</code> 来标识当前版本库的最新提交，这里是\n<code>172fb0bb0c001e1451eab09d8abb04814c755d0d</code>，上一个版本是\n<code>HEAD^</code>，也就是\n<code>d63e6e188c19e1f13fbf38ec735125e7c22d5484</code>，再上一个版本是\n<code>HEAD^^</code>，也就是\n<code>172fb0bb0c001e1451eab09d8abb04814c755d0d</code>.</p>\n<p>我们使用 <code>git reset</code> 命令来回退到上一个版本.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git reset --hard HEAD^<br></code></pre></td></tr></table></figure>\n<p><code>--hard</code>\n参数表明回到上个版本的已提交状态，<code>--soft</code>\n参数表明回到上个版本的未提交状态，<code>--mixed</code>\n参数表明回到上个版本的已暂存状态.</p>\n<p>我们同样可以使用该命令返回更晚的版本，只要记得版本号</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git reset --hard 493bb5004ef68c281f0fbf7f22e60e9111c94a86<br></code></pre></td></tr></table></figure>\n<p>这里的版本号不需要是完整的哈希值，只需要前几位就可以了，Git\n会自动匹配到唯一的版本.</p>\n<p>git 的版本回退很快，因为 Git 内部有一个指向当前版本的\n<code>HEAD</code> 指针，回退只需要修改这个指针的指向即可.</p>\n<p>如果找不到可以使用 <code>git reflog</code>\n命令查看所有的提交记录，包括已经被回退的版本.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">172fb0b HEAD@&#123;1&#125;: reset: moving to HEAD^^<br>493bb50 (HEAD -&gt; main, origin/main, origin/HEAD) HEAD@&#123;2&#125;: commit: Update .gitignore and workspace layout settings<br>d63e6e1 HEAD@&#123;3&#125;: commit: updated Git notes<br>172fb0b HEAD@&#123;4&#125;: commit: Update .gitignore and workspace settings<br></code></pre></td></tr></table></figure>\n<p>这里发现 Update .gitignore and workspace layout settings 的版本号是\n<code>493bb50</code>，可以使用 <code>git reset --hard 493bb50</code>\n命令回到这个版本.</p>\n<h3 id=\"工作区和暂存区\">工作区和暂存区</h3>\n<h4 id=\"名词解释\">名词解释</h4>\n<ul>\n<li><strong>工作区（Working Directory）：</strong> 电脑中的目录</li>\n<li><strong>版本库（Repository）：</strong> 工作区中的 <code>.git</code>\n目录，默认为隐藏 存储有所有的版本信息，其中最重要的就是称为\n<code>stage</code> （或 <code>index</code>）的暂存区，还有 Git\n为我们自动创建的第一个分支 <code>master</code> 分支，以及指向当前分支的\n<code>HEAD</code> 指针.</li>\n</ul>\n"},{"title":"CSS笔记","_content":"","source":"_posts/CSS笔记.md","raw":"---\ntitle: CSS笔记\n---\n","slug":"CSS笔记","published":1,"date":"2025-09-11T11:36:20.592Z","updated":"2025-09-11T11:36:20.593Z","comments":1,"layout":"post","photos":[],"_id":"cmffo52nt00066xzd9ur34n8d","content":"\n","excerpt":"","more":"\n"},{"title":"HTML笔记","_content":"\n## 元素\n\n1. 开始标签 （Opening tag）：`<p>`\n2. 结束标签 （Closing tag）：`</p>`\n3. 内容（Content）：元素的内容，可以是输入的文本本身\n4. 元素（Element）：开始标签、结束标签与内容相结合，便是一个完整的元素\n   - 元素可以有属性，包含的是不想在真正的内容中出现的和元素有关的额外信息，有值的属性应该包含\n     1. 属性与元素名称（或上一个属性，如果元素有超过一个属性的话）之间的一个空格。\n     2. 属性名，后接一个等号\n     3. 一对引号包围的属性值\n\n### 嵌套元素\n\n元素可以嵌套在其他元素中。嵌套的元素必须正确地嵌套在开始标签和结束标签之间。\n\n```html\n<p>My cat is <strong>very</strong> cute.</p>\n```\n\n### 空元素\n\n空元素没有内容，只有开始标签，没有结束标签\n\n```html\n<img src=\"images/firefox-icon.png\" alt=\"My test image\" />\n```\n\n### 案例分析\n\n```html\n<!DOCTYPE html>\n<html lang=\"en-US\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>My test page</title>\n  </head>\n  <body>\n    <img src=\"images/firefox-icon.png\" alt=\"My test image\" />\n  </body>\n</html>\n```\n\n- `<!DOCTYPE html>`：文档类型声明，告诉浏览器这是一个 HTML5 文档，现在用于保证文档能够正常读取\n- `<html></html>`：HTML 元素，包含了整个文档的内容，有时也被称为根元素\n- `<head></head>`：head 元素，该元素作为想在 HTML 页面中包含但不想向用户显示的内容的容器。包括想在搜索结果中显示的关键字和页面描述、用于设置页面样式的 CSS、字符集声明等等。\n- `<meta charset=\"utf-8\">`：该元素指明文档使用 UTF-8 字符编码，UTF-8 包括世界绝大多数书写语言的字符。它基本上可以处理任何文本内容。以它为编码还可以避免以后出现某些问题，没有理由再选用其他编码。\n- `<meta name=\"viewport\" content=\"width=device-width\">`：视口元素可以确保页面以视口宽度进行渲染，避免移动端浏览器以比视口更宽的宽度渲染内容，导致内容缩小。\n- `<title></title>`：<title> 元素。该元素设置页面的标题，显示在浏览器标签页上，也作为收藏网页的描述文字。\n- `<body></body>`：<body> 元素。该元素包含期望让用户在访问页面时看到的全部内容，包括文本、图像、视频、游戏、可播放的音轨或其他内容。\n","source":"_posts/HTML笔记.md","raw":"---\ntitle: HTML笔记\n---\n\n## 元素\n\n1. 开始标签 （Opening tag）：`<p>`\n2. 结束标签 （Closing tag）：`</p>`\n3. 内容（Content）：元素的内容，可以是输入的文本本身\n4. 元素（Element）：开始标签、结束标签与内容相结合，便是一个完整的元素\n   - 元素可以有属性，包含的是不想在真正的内容中出现的和元素有关的额外信息，有值的属性应该包含\n     1. 属性与元素名称（或上一个属性，如果元素有超过一个属性的话）之间的一个空格。\n     2. 属性名，后接一个等号\n     3. 一对引号包围的属性值\n\n### 嵌套元素\n\n元素可以嵌套在其他元素中。嵌套的元素必须正确地嵌套在开始标签和结束标签之间。\n\n```html\n<p>My cat is <strong>very</strong> cute.</p>\n```\n\n### 空元素\n\n空元素没有内容，只有开始标签，没有结束标签\n\n```html\n<img src=\"images/firefox-icon.png\" alt=\"My test image\" />\n```\n\n### 案例分析\n\n```html\n<!DOCTYPE html>\n<html lang=\"en-US\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>My test page</title>\n  </head>\n  <body>\n    <img src=\"images/firefox-icon.png\" alt=\"My test image\" />\n  </body>\n</html>\n```\n\n- `<!DOCTYPE html>`：文档类型声明，告诉浏览器这是一个 HTML5 文档，现在用于保证文档能够正常读取\n- `<html></html>`：HTML 元素，包含了整个文档的内容，有时也被称为根元素\n- `<head></head>`：head 元素，该元素作为想在 HTML 页面中包含但不想向用户显示的内容的容器。包括想在搜索结果中显示的关键字和页面描述、用于设置页面样式的 CSS、字符集声明等等。\n- `<meta charset=\"utf-8\">`：该元素指明文档使用 UTF-8 字符编码，UTF-8 包括世界绝大多数书写语言的字符。它基本上可以处理任何文本内容。以它为编码还可以避免以后出现某些问题，没有理由再选用其他编码。\n- `<meta name=\"viewport\" content=\"width=device-width\">`：视口元素可以确保页面以视口宽度进行渲染，避免移动端浏览器以比视口更宽的宽度渲染内容，导致内容缩小。\n- `<title></title>`：<title> 元素。该元素设置页面的标题，显示在浏览器标签页上，也作为收藏网页的描述文字。\n- `<body></body>`：<body> 元素。该元素包含期望让用户在访问页面时看到的全部内容，包括文本、图像、视频、游戏、可播放的音轨或其他内容。\n","slug":"HTML笔记","published":1,"date":"2025-09-11T11:36:20.593Z","updated":"2025-09-11T11:36:20.594Z","comments":1,"layout":"post","photos":[],"_id":"cmffo52nt00076xzd68y219u6","content":"<h2 id=\"元素\">元素</h2>\n<ol type=\"1\">\n<li>开始标签 （Opening tag）：<code>&lt;p&gt;</code></li>\n<li>结束标签 （Closing tag）：<code>&lt;/p&gt;</code></li>\n<li>内容（Content）：元素的内容，可以是输入的文本本身</li>\n<li>元素（Element）：开始标签、结束标签与内容相结合，便是一个完整的元素\n<ul>\n<li>元素可以有属性，包含的是不想在真正的内容中出现的和元素有关的额外信息，有值的属性应该包含\n<ol type=\"1\">\n<li>属性与元素名称（或上一个属性，如果元素有超过一个属性的话）之间的一个空格。</li>\n<li>属性名，后接一个等号</li>\n<li>一对引号包围的属性值</li>\n</ol></li>\n</ul></li>\n</ol>\n<h3 id=\"嵌套元素\">嵌套元素</h3>\n<p>元素可以嵌套在其他元素中。嵌套的元素必须正确地嵌套在开始标签和结束标签之间。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>My cat is <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">strong</span>&gt;</span>very<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">strong</span>&gt;</span> cute.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"空元素\">空元素</h3>\n<p>空元素没有内容，只有开始标签，没有结束标签</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;images/firefox-icon.png&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;My test image&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"案例分析\">案例分析</h3>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en-US&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>My test page<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;images/firefox-icon.png&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;My test image&quot;</span> /&gt;</span><br>  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>&lt;!DOCTYPE html&gt;</code>：文档类型声明，告诉浏览器这是一个\nHTML5 文档，现在用于保证文档能够正常读取</li>\n<li><code>&lt;html&gt;&lt;/html&gt;</code>：HTML\n元素，包含了整个文档的内容，有时也被称为根元素</li>\n<li><code>&lt;head&gt;&lt;/head&gt;</code>：head 元素，该元素作为想在\nHTML\n页面中包含但不想向用户显示的内容的容器。包括想在搜索结果中显示的关键字和页面描述、用于设置页面样式的\nCSS、字符集声明等等。</li>\n<li><code>&lt;meta charset=\"utf-8\"&gt;</code>：该元素指明文档使用 UTF-8\n字符编码，UTF-8\n包括世界绝大多数书写语言的字符。它基本上可以处理任何文本内容。以它为编码还可以避免以后出现某些问题，没有理由再选用其他编码。</li>\n<li><code>&lt;meta name=\"viewport\" content=\"width=device-width\"&gt;</code>：视口元素可以确保页面以视口宽度进行渲染，避免移动端浏览器以比视口更宽的宽度渲染内容，导致内容缩小。</li>\n<li><code>&lt;title&gt;&lt;/title&gt;</code>：\n<title>\n元素。该元素设置页面的标题，显示在浏览器标签页上，也作为收藏网页的描述文字。</li>\n<li><code>&lt;body&gt;&lt;/body&gt;</code>：\n<body>\n元素。该元素包含期望让用户在访问页面时看到的全部内容，包括文本、图像、视频、游戏、可播放的音轨或其他内容。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"元素\">元素</h2>\n<ol type=\"1\">\n<li>开始标签 （Opening tag）：<code>&lt;p&gt;</code></li>\n<li>结束标签 （Closing tag）：<code>&lt;/p&gt;</code></li>\n<li>内容（Content）：元素的内容，可以是输入的文本本身</li>\n<li>元素（Element）：开始标签、结束标签与内容相结合，便是一个完整的元素\n<ul>\n<li>元素可以有属性，包含的是不想在真正的内容中出现的和元素有关的额外信息，有值的属性应该包含\n<ol type=\"1\">\n<li>属性与元素名称（或上一个属性，如果元素有超过一个属性的话）之间的一个空格。</li>\n<li>属性名，后接一个等号</li>\n<li>一对引号包围的属性值</li>\n</ol></li>\n</ul></li>\n</ol>\n<h3 id=\"嵌套元素\">嵌套元素</h3>\n<p>元素可以嵌套在其他元素中。嵌套的元素必须正确地嵌套在开始标签和结束标签之间。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>My cat is <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">strong</span>&gt;</span>very<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">strong</span>&gt;</span> cute.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"空元素\">空元素</h3>\n<p>空元素没有内容，只有开始标签，没有结束标签</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;images/firefox-icon.png&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;My test image&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"案例分析\">案例分析</h3>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en-US&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>My test page<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;images/firefox-icon.png&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;My test image&quot;</span> /&gt;</span><br>  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>&lt;!DOCTYPE html&gt;</code>：文档类型声明，告诉浏览器这是一个\nHTML5 文档，现在用于保证文档能够正常读取</li>\n<li><code>&lt;html&gt;&lt;/html&gt;</code>：HTML\n元素，包含了整个文档的内容，有时也被称为根元素</li>\n<li><code>&lt;head&gt;&lt;/head&gt;</code>：head 元素，该元素作为想在\nHTML\n页面中包含但不想向用户显示的内容的容器。包括想在搜索结果中显示的关键字和页面描述、用于设置页面样式的\nCSS、字符集声明等等。</li>\n<li><code>&lt;meta charset=\"utf-8\"&gt;</code>：该元素指明文档使用 UTF-8\n字符编码，UTF-8\n包括世界绝大多数书写语言的字符。它基本上可以处理任何文本内容。以它为编码还可以避免以后出现某些问题，没有理由再选用其他编码。</li>\n<li><code>&lt;meta name=\"viewport\" content=\"width=device-width\"&gt;</code>：视口元素可以确保页面以视口宽度进行渲染，避免移动端浏览器以比视口更宽的宽度渲染内容，导致内容缩小。</li>\n<li><code>&lt;title&gt;&lt;/title&gt;</code>：\n<title>\n元素。该元素设置页面的标题，显示在浏览器标签页上，也作为收藏网页的描述文字。</li>\n<li><code>&lt;body&gt;&lt;/body&gt;</code>：\n<body>\n元素。该元素包含期望让用户在访问页面时看到的全部内容，包括文本、图像、视频、游戏、可播放的音轨或其他内容。</li>\n</ul>\n"},{"title":"大学物理1笔记","math":true,"_content":"\n## 质点运动学\n\n### 时间、空间概念\n\n### 质点\n\n#### 牛顿的时空观\n\n- **时间**  \n  均匀流动的带子，与事件本身无关，事件是带子上的标记.\n\n- **空间**  \n  好比建筑物，人的存在与否不影响它的存在.\n\n  时间、空间与事物及过程完全割裂，这就是“绝对时空观”.\n\n#### 研究对象的理想化\n\n1. 把抽象的物质具体化，看得见，摸得着.\n2. 把研究的物质质点化.  \n   (点：具有该物体相同的质量)\n   - 物体的大小、形状可以忽略时\n   - 物体运动中，物体的各部分运动相同\n\n### 运动的绝对性和相对性\n\n### 参考系\n\n### 质点的位置坐标和位置矢量\n\n#### 直角坐标系\n\n质点位置$P(x,y,z)$\n位置矢量$\\vec{r}=\\vec{oP}$\n\n#### 位移\n\n#### 速度\n\n1. 平均速度：$\\overline{\\vec{v}} =\\dfrac{\\Delta \\vec{r}}{\\Delta t}$\n2. 瞬时速度：$\\vec{v}=\\dfrac{\\mathrm{d}\\vec{r}}{\\mathrm{d}t}$\n\n#### 直角坐标系中的速度、加速度\n\n#### 自然坐标系速度表示法\n\n#### 极坐标速度表示法\n\n#### 圆周运动\n\n### 伽利略变换\n\n![坐标系](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250225111725.png)\n\n$S'$ 相对于 $S$ 运动，速度为 $u$ ，则有\n\n$$\n\\begin{aligned}\n&\\vec{r} = \\vec{r'} + \\vec{R},\\quad dt=dt'\\\\\n&\\frac{\\mathrm{d}\\vec{r}}{\\mathrm{d}t} = \\frac{\\mathrm{d}\\vec{r'}}{\\mathrm{d}t'} + \\frac{\\mathrm{d}\\vec{R}}{\\mathrm{d}t'}, \\quad \\vec{v} =\\vec{u} +\\vec{v'}\\\\\n&\\frac{\\mathrm{d}^2\\vec{r}}{\\mathrm{d}t^2} = \\frac{\\mathrm{d}^2\\vec{r'}}{\\mathrm{d}t'^2} + \\frac{\\mathrm{d}^2\\vec{R}}{\\mathrm{d}t^2}, \\quad \\vec{a} = \\vec{a}_0 + \\vec{a'}\n\\end{aligned}\n$$\n\n## 质点运动学\n\n### 牛顿运动定律\n\n#### 牛顿第一定律\n\n#### 牛顿第二定律\n\n#### 牛顿第三定律\n\n### 相互作用力\n\n#### 万有引力的计算\n\n##### 引力质量\n\n##### 惯性质量和引力质量的联系\n\n#### 弹性力\n\n#### 摩擦力\n\n#### 流体阻力\n\n### 非惯性系、惯性力\n\n#### 惯性参考系\n\n#### 惯性离心力\n\n### 惯性力与自然界的运动\n\n#### 太阳和地球引力失重\n\n#### 潮汐力和潮汐\n\n### 科氏加速度和科氏力\n\n#### 科里奥利力的来源\n\n### 质心和质心运动定律\n\n#### 质心\n\n#### 质心坐标系\n\n## 功与能\n\n### 功、动能定理\n\n#### 功的基本概念\n\n#### 内力的功\n\n## 狭义相对论\n\n### 狭义相对论时空观\n\n#### 狭义相对性原理\n\n物理学定律与惯性系的选择无关,所有惯性系是等价的\n\n$$\n\\left\\{\n\\begin{array}{ll}\n  &S  &&m_1\\vec{v_1} + m_2\\vec{v_2} = m_1\\vec{v_10} + m_2\\vec{v_20}\\\\\n  &S' &&m'_1\\vec{v'_1} + m'_2\\vec{v'_2} = m'_1\\vec{v'_10} + m'_2\\vec{v'_20}\n\\end{array}\n\\right.\n$$\n\n#### 光速不变原理\n\n光速在任何惯性系中都是不变的,即光速是绝对的,与光源和观察者的运动状态无关\n由 Maxwell 方程可以推出\n\n#### 洛伦兹变换\n\n设$ $S'$ 系相对于 $S$ 系以速度 $u$ 沿 $x$ 轴正方向运动，两坐标轴原点 $o$ 与 $o'$ 在 $t=t'=0$ 时重合，则有\n\n- 正变换\n\n$$\n\\begin{cases}\n  x' = \\frac{x-ut}{\\sqrt{1-\\frac{u^2}{c^2}}}\\\\\n  y = y'\\\\\n  z = z'\\\\\n  t' = \\frac{t-\\frac{ux}{c^2}}{\\sqrt{1-\\frac{u^2}{c^2}}}\n\\end{cases}\n$$\n\n- 逆变换\n\n$$\n\\begin{cases}\n  x = \\frac{x'+ut'}{\\sqrt{1-\\frac{u^2}{c^2}}}\\\\\n  y' = y\\\\\n  z' = z\\\\\n  t = \\frac{t'+\\frac{ux'}{c^2}}{\\sqrt{1-\\frac{u^2}{c^2}}}\n\\end{cases}\n$$\n\n若令 $\\gamma = \\frac{1}{\\sqrt{1-\\frac{u^2}{c^2}}} >1$，则有\n\n- 正变换\n\n$$\n\\begin{cases}\n  x' = \\gamma(x-ut)\\\\\n  y' = y\\\\\n  z' = z\\\\\n  t' = \\gamma(t-\\frac{ux}{c^2})\n\\end{cases}\n$$\n\n- 逆变换\n\n$$\n\\begin{cases}\n  x = \\gamma(x'+ut')\\\\\n  y = y'\\\\\n  z = z'\\\\\n  t = \\gamma(t'+\\frac{ux'}{c^2})\n\\end{cases}\n$$\n\n### 狭义相对论的时空效应\n\n设在 $S'$ 系中，质点的时空坐标为 $(x', t')$，在 $S$ 系中，质点的坐标为 $(x, t)$，系 $S'$ 相对于系 $S$ 以速度 $u$ 沿 $x$ 轴正方向运动\n\n$$\n\\begin{cases}\n  \\Delta x = \\gamma \\left(\\Delta x -u\\Delta t\\right)\\\\\n  \\Delta x' = \\gamma \\left(\\Delta x' +u\\Delta t'\\right)\\\\\n\\end{cases}\n$$\n\n$$\n\\begin{cases}\n  \\Delta t = \\gamma \\left(\\Delta t -\\frac{u\\Delta x}{c^2}\\right)\\\\\n  \\Delta t' = \\gamma \\left(\\Delta t' +\\frac{u\\Delta x'}{c^2}\\right)\\\\\n\\end{cases}\n$$\n\n明确这两组公式中的变量哪些是 $0$ ，哪些是已知量是解题的关键\n\n#### 时间膨胀\n\n物体在 $S'$ 系中静止，则有\n\n$$\n\\Delta t = \\gamma \\Delta t'\n$$\n\n在 $S'$ 系中同时不同地发生的两件事，$S$ 系中不同时发生，时间间隔为 $\\Delta t = \\gamma \\frac{u \\Delta x'}{c^2}$\n\n#### 长度收缩\n\n设在 $S'$ 系中静止的物体的本征长度为 $L'$，在 $S$ 系中测得的长度 $L$ 为\n\n$$\nL = \\frac{L'}{\\gamma} = L' \\sqrt{1-\\frac{u^2}{c^2}}\n$$\n\n> **注意：**\n>\n> 在 $S$ 系测量则需要在 $S$ 系中同时确认两个点的空间坐标，$\\Delta t = 0$\n\n### 洛伦兹速度变换\n\n- 正变换\n\n$$\n\\begin{cases}\n  v_x' = \\frac{v_x - u}{1-\\frac{uv_x}{c^2}}\\\\\n  v_y' = \\frac{v_y}{\\gamma(1-\\frac{uv_x}{c^2})} = \\frac{v_y\\sqrt{1-\\frac{u^2}{c^2}}}{\\left(1-\\frac{uv_x}{c^2}\\right)}\\\\\n  v_z' = \\frac{v_z}{\\gamma(1-\\frac{uv_x}{c^2})} = \\frac{v_z\\sqrt{1-\\frac{u^2}{c^2}}}{\\left(1-\\frac{uv_x}{c^2}\\right)}\n\\end{cases}\n$$\n\n- 逆变换\n\n$$\n\\begin{cases}\n  v_x = \\frac{v_x' + u}{1+\\frac{uv_x'}{c^2}}\\\\\n  v_y = \\frac{v_y'}{\\gamma(1+\\frac{uv_x'}{c^2})} = \\frac{v_y'\\sqrt{1-\\frac{u^2}{c^2}}}{\\left(1+\\frac{uv_x'}{c^2}\\right)}\\\\\n  v_z = \\frac{v_z'}{\\gamma(1+\\frac{uv_x'}{c^2})} = \\frac{v_z'\\sqrt{1-\\frac{u^2}{c^2}}}{\\left(1+\\frac{uv_x'}{c^2}\\right)}\n\\end{cases}\n$$\n\n### 相对论中的质量和动量\n\n由实验研究表明，物体的质量随着速率增大而增大，记 $m_0$ 为物体在静止时的质量，称为静质量，$m$ 为物体在运动时的质量，称为动质量，则有\n\n$$\nm = \\frac{m_0}{\\sqrt{1-\\frac{v^2}{c^2}}}\n$$\n\n其动量为\n\n$$\n\\vec{p} = m\\vec{v} = \\frac{m_0\\vec{v}}{\\sqrt{1-\\frac{v^2}{c^2}}}\n$$\n\n### 相对论中的力学基本方程\n\n$$\n\\begin{aligned}\n  &\\vec{p} = m\\vec{u} = \\frac{m_0\\vec{u}}{\\sqrt{1-\\frac{u^2}{c^2}}}\\\\\n  &\\vec{p} = \\vec{u} \\mathrm{d}m + m\\mathrm{d}\\vec{u}\\\\\n  &\\vec{F}  = \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left(\\frac{m_0\\vec{u}}{\\sqrt{1-\\frac{u^2}{c^2}}}\\right)\n\\end{aligned}\n$$\n\n### 相对论中的能量\n\n$$\n\\begin{cases}\n  E_k = mc^2 - m_0c^2&\\text{动能}\\\\\n  E_0 = m_0c^2&\\text{静能}\\\\\n  E = mc^2 = E_0 +E_k&\\text{总能量}\n\\end{cases}\n$$\n\n质能关系\n\n$$\n\\Delta E = \\Delta m c^2\n$$\n\n能量与动量之间的关系\n\n$$\np = \\frac{E}{c}\n$$\n\n## 振动力学\n\n### 简谐振动动力学\n\n简谐运动定义：凡质点的运动遵从余弦（或正弦）规律时，其运动形式为简谐振动\n\n其运动方程为\n\n$$\nx(t) = A \\cos(\\omega t + \\varphi)\n$$\n\n简谐运动的动力学方程为\n\n$$\n\\frac{\\mathrm{d}^2x}{\\mathrm{d}t^2} + \\omega^2 x = 0\n$$\n\n其中 $\\omega = \\sqrt{\\frac{k}{m}}$，$k$ 为弹性系数，$m$ 为物体的质量\n\n### 简谐振动运动的物理量\n\n#### 周期、频率和角频率\n\n- **角频率：** $\\omega =\\sqrt{\\frac{k}{m}} = \\frac{2\\pi}{T} = 2\\pi \\nu$\n- **周期：** $T = \\frac{1}{\\nu} = \\frac{2\\pi}{\\omega} = 2\\pi\\sqrt{\\frac{m}{k}}$\n\n在 $x =A \\cos(\\omega t + \\varphi)$ 中，$A$ 为振幅，$\\varphi$ 为初相位\n\n- $v = \\frac{\\mathrm{d}x}{\\mathrm{d}t} = -A\\omega \\sin(\\omega t + \\varphi)$\n- $v_0 = -A\\omega\\sin\\varphi$\n- $E = E_k + E_p = \\frac{1}{2}mv^2 + \\frac{1}{2}kx^2 = \\frac{1}{2}kA^2$\n- $A = \\sqrt{x_0^2+\\frac{v_0^2}{\\omega^2}} = \\sqrt{\\frac{2E}{m\\omega^2}}$\n\n#### 相位\n\n$$\nx = A\\cos(\\omega t + \\varphi)\n$$\n\n- $\\left(\\omega t+\\varphi\\right)$ 是 $t$ 时刻的相位\n- $\\varphi$ 是 $t=0$ 时刻的相位\n- **相位差：** $\\Delta \\varphi =\\left(\\omega_2t+  \\varphi_2\\right)-\\left(\\omega_1t=\\varphi_1\\right)$\n  - 相位差为 $\\pm2k\\pi(k = 0 , 1 , \\ldots)$ 时，两个简谐振动的相位相同\n  - 相位差为 $\\pm(2k+1)\\pi(k = 0 , 1 , \\ldots)$ 时，两个简谐振动的相位相反\n  - 若 $\\Delta\\varphi = \\varphi_ -\\varphi_1>0$，则 $x_2$ 比 $x_1$ 较早到正最大，称 $x_2$ 比 $x_1$ 超前，或称 $x_1$ 比 $x_2$ 滞后\n    - 超前和落后以小于 $\\pi$ 的相位角来判断\n\n#### 振动状态和振动能量\n\n##### 振动速度\n\n$$\n\\begin{aligned}\n  v = \\frac{\\mathrm{d}x}{\\mathrm{d}t} &= -A\\omega \\sin(\\omega t + \\varphi)\\\\\n  &= -v_m \\cos(\\omega t + \\varphi + \\frac{\\pi}{2})\\\\\n\\end{aligned}\n$$\n\n其中 $v_m = A\\omega$ 称为速度振幅\n\n##### 振动加速度\n\n$$\n\\begin{aligned}\n  a = \\frac{\\mathrm{d}^2x}{\\mathrm{d}t^2} &= -A\\omega^2 \\cos(\\omega t + \\varphi)\\\\\n  &= -a_m \\sin(\\omega t + \\varphi + \\frac{\\pi}{2})\\\\\n\\end{aligned}\n$$\n\n其中 $a_m =A\\omega^2$ 称为加速度振幅\n\n##### 振动系统的能量\n\n- 振子动能\n\n$$\nE_k = \\frac{1}{2}mv^2 = \\frac{1}{2}mA^2\\omega^2\\sin^2(\\omega t + \\varphi)\n$$\n\n- 振子势能\n\n$$\nE_p = \\frac{1}{2}kx^2 = \\frac{1}{2}kA^2\\cos^2(\\omega t + \\varphi)\n$$\n\n- 振子总能量\n\n$$\nE = E_k + E_p = \\frac{1}{2}kA^2\n$$\n\n#### 旋转振幅矢量\n\n旋转矢量 $\\vec{A}$ 在 $x$ 轴上的投影点的运动规律为\n\n$$\nx = A \\cos(\\omega t + \\varphi)\n$$\n\n## 平衡态\n\n### 基本概念\n\n1. 热力学系统\n   - **孤立系统：** 与外界无能量和质量交换\n   - **封闭系统：** 与外界有能量无质量交换\n   - **开放系统：** 与外界由能量和质量交换\n   - **外界：** 处于系统之外的物体或物体组\n2. 系统状态的描述\n   - **宏观参量：** 可以直接测量的量，如压强 $p$、温度 $T$ 等由宏观参量描述的系统状态称为宏观状态\n   - **微观量：** 描述系统内微观粒子的物理量，一般无法直接测量，如分子的质量 $m$、直径 $d$、位置、速度 $v$、动量 $p$、能量 $\\epsilon$ 等。\n3. 平衡态\n   - 孤立系统达到的不随时间变化的状态称为热力学平衡态或平衡态\n   - 内部能量和质量没有宏观流动，达到同一温度的定态叫平衡态\n4. 定态\n   - 宏观性质不随时间变化的稳定状态称为定态\n5. **动态平衡：** **不受外界影响**的条件下系统的宏观性质不随时间变化，此系统处在热力学平衡态\n6. 涨落：\n   - 系统的宏观性质在平衡态下有微小的波动称为涨落\n   - 涨落是系统内微观粒子运动的结果\n\n### 热力学第一定律\n\n#### 温度\n\n达到热平衡的系统具有共同的内部属性：温度\n\n#### 热力学第零定律\n\n两个系统同时与第三个系统热平衡时，这两个物体之间也必达到热平衡\n\n处于热平衡的多个系统具有相同的温度\n\n#### 理想气体温标和状态方程\n\n##### 理想气体\n\n- 波义耳定律\n  - 温度不变时没压强和体积的乘积是一个常数\n- 理想气体\n  - 严格遵守波义耳定律的气体为理想气体\n\n##### 热力学温标\n\n理论上存在一个与测温质、测温属性无关的温标：热力学温标\n\n根据物理定律，温度为 $0^\\circ C$ 是，每下降 $1^\\circ C$，体积减少 $\\frac{1}{273}$，则当处于 $-273.15^\\circ C$ 时，体积为 $0$，即 $0K$，称为绝对零度\n\n摄氏温度 $t$ 与绝对温度 $T$ 的关系\n\n$$\nT = t + 273.15\n$$\n\n##### 理想气体状态方程\n\n$$\nPV = nRT = \\frac{m}{M}RT\n$$\n\n其中 $R=8.314J/(mol \\cdot K)$，$n$ 为物质的量，$P$ 为压强，$V$ 为体积，$T$ 为绝对温度\n\n#### 气体压强和温度的统计意义\n\n##### 气体的特征\n\n1. 无一定形状、体积，能充满整个容器空间\n2. 气体分子间距远大于分子的线度 L>>d，分子间引力很小，故气体具有高压缩性、高热膨胀率及高扩散性\n3. 气体分子以高速向四方自由运动，具有高动能\n4. 气体分子无规则热运动，频繁碰撞必产生压力\n\n##### 理想气体分子运动模型\n\n1. 大小不计\n2. 弹性碰撞\n3. 除碰撞外其他相互作用不计\n4. 不记重力\n\n两条统计假设\n\n1.\n\n$$\nn_\\text{单位体积的分子数} = \\frac{\\Delta N}{\\Delta V} =\\frac{\\mathrm{d}N}{\\mathrm{d}V} =\\frac{N_\\text{总分子数}}{V_\\text{总容积}}\n$$\n\n2.\n\n$$\n\\vec{u}_{x\\text{平均速度}} \\left(\\sum_i^N \\frac{u_{ix}}{N}\\right) = \\bar{u}_{y\\text{平均速度}} =\\bar{u}_{z\\text{平均速度}} =0\n$$\n\n##### 理想气体压强公式\n\n$$\n\\begin{aligned}\n  p = \\frac{1}{3}\\sum_imn_iu_i^2 = \\frac{1}{3}nm\\bar{u}^2\n\\end{aligned}\n$$\n\n##### 溫度的统计意义\n\n气体的平均动能\n\n$$\n\\bar{\\varepsilon}_t = \\frac{1}{2}m\\bar{u}^2 =\\frac{3}{2}kT\n$$\n\n对于系统而言，表示分子热运动的激烈程度\n\n### 麦克斯韦速率分布\n\n- 标量形式\n\n$$\nf(v)= 4\\pi v^2 \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{3}{2}} e^{-\\frac{mv^2}{2kT}}\n$$\n\n- 矢量形式\n\n$$\nf(\\vec{v})= \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{3}{2}} e^{-\\frac{m\\vert \\vec{v}\\vert ^2}{2kT}}\n$$\n\n其在三个方向上的分量为\n\n$$\n\\begin{cases}\n  f(v_x) = \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{1}{2}} e^{-\\frac{m}{2kT}v_x^2}\\\\\n  f(v_y) = \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{1}{2}} e^{-\\frac{m}{2kT}v_y^2}\\\\\n  f(v_z) = \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{1}{2}} e^{-\\frac{m}{2kT}v_z^2}\n\\end{cases}\n$$\n\n可以推出\n\n$$\n\\begin{cases}\n  \\frac{\\mathrm{d}N_x}{N} = f(v_x)\\mathrm{d}v_x = \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{1}{2}} e^{-\\frac{m}{2kT}v_x^2}\\mathrm{d}v_x\\\\\n  \\frac{\\mathrm{d}N_y}{N} = f(v_y)\\mathrm{d}v_y = \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{1}{2}} e^{-\\frac{m}{2kT}v_y^2}\\mathrm{d}v_y\\\\\n  \\frac{\\mathrm{d}N_z}{N} = f(v_z)\\mathrm{d}v_z = \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{1}{2}} e^{-\\frac{m}{2kT}v_z^2}\\mathrm{d}v_z\n\\end{cases}\n$$\n\n![Mexwell V](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505221129410.png)\n\n### 麦克斯韦速率分布应用\n\n#### 最可几速率\n\n$$\n\\begin{aligned}\n  &\\frac{\\mathrm{d}f(v)}{\\mathrm{d}v} = 0\\\\\n  \\Rightarrow &v_p=\\sqrt{\\frac{2kT}{m}} = \\sqrt{\\frac{2RT}{M}}\n\\end{aligned}\n$$\n\n#### 平均速率\n\n$$\n\\bar{v} = \\int_0^{\\infty} v f(v) \\mathrm{d}v = \\sqrt{\\frac{8kT}{\\pi m}} = \\sqrt{\\frac{8RT}{\\pi M}}\n$$\n\n#### 均方根速率\n\n$$\n\\sqrt{\\bar{v}^2} = \\sqrt{\\int_0^{\\infty} v^2 f(v) \\mathrm{d}v} = \\sqrt{\\frac{3kT}{m}} = \\sqrt{\\frac{3RT}{M}}\n$$\n\n![MaxwellDistributionApplication](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505221314126.png)\n\n#### 一些应用\n\n设箱体的分子密度为 $n$，求单位时间内单位面积碰撞到墙体的分子数\n\n$$\n\\begin{aligned}\n  N&=n\\bar{v}S\\\\\n  &=nS\\int_0^\\infty f(v_x)v_x\\,\\mathrm{d}v_x\\\\\n  &=\\boxed{\\frac{1}{4}nS\\bar{v}}\n\\end{aligned}\n$$\n\n#### 玻尔兹曼分布\n\n$$\n\\mathrm{d} N = n_0 e^{-\\frac{\\varepsilon_p}{k_BT}}\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z\n$$\n\n$$\nn_i = n_0 e^{-\\frac{E_i}{kT}}\n$$\n\n###### 空气中气体分子在重力场中的密度分布\n\n#### 能量均分定理\n\n##### 分子的自由度\n\n| 分子原子数 | 总自由度 |\n| :--------: | :------: |\n|     1      |    3     |\n|     2      |    5     |\n|     多     |    6     |\n\n对于多原子分子，其内能为\n\n$$\nU = \\frac{f}{2}NkT = \\frac{f}{2} PV\n$$\n\n其中 $f$ 为分子的自由度，$N$ 为分子数\n\n## 热力学第一定律\n\n$$\nQ = \\Delta E + W\n$$\n\n### 比热容\n\n#### 等容过程\n\n$$\n\\begin{align}\n  \\Delta V & = 0\\\\\n  A & = 0\\\\\n  \\Delta Q &= \\Delta E\\\\\n  C_V &= \\frac{\\Delta Q}{\\Delta T} = \\frac{\\mathrm{d}E}{\\mathrm{d}T} = \\frac{i}{2}R\n\\end{align}\n$$\n\n$$\n\\Delta E = \\frac{i}{2}R\\Delta T = \\frac{i}{2}V\\Delta P\n$$\n\n#### 等温过程\n\n$$\n\\begin{aligned}\n  \\Delta T & = 0\\\\\n  \\Delta E & = 0\\\\\n  \\Delta Q & = W \\\\\n  \\mathrm{d}Q &= \\mathrm{d}A \\\\\n  &= P\\mathrm{d}V \\\\\n  &= nRT \\frac{1}{V}\\,\\mathrm{d}V\n\\end{aligned}\n$$\n\n则 $Q = nRT \\ln\\frac{V_2}{V_1}$\n\n#### 等压过程\n\n$$\n\\begin{aligned}\n  \\mathrm{d}Q_P &= \\mathrm{d}E + P\\mathrm{d}V\\\\\n  Q_P &= \\Delta E + P\\Delta V\\\\\n  &= \\frac{i}{2} nR\\Delta T + nR\\Delta V\\\\\n  &= \\frac{i+2}{2} nR\\Delta T\\\\\n\\end{aligned}\n$$\n\n$$\nC_P = \\frac{\\Delta Q}{\\Delta T} = \\frac{i+2}{2}R = C_V +R\n$$\n\n热容比\n\n$$\n\\gamma = \\frac{C_P}{C_V} = 1+\\frac{R}{C_P} = \\frac{i+2}{i}\n$$\n\n#### 绝热过程\n\n绝热过程是指系统与外界没有热量交换的过程\n\n准静态绝热过程方程\n\n$$\nPV^\\gamma = \\text{const}\n$$\n","source":"_posts/大学物理1笔记.md","raw":"---\ntitle: 大学物理1笔记\nmath: true\n---\n\n## 质点运动学\n\n### 时间、空间概念\n\n### 质点\n\n#### 牛顿的时空观\n\n- **时间**  \n  均匀流动的带子，与事件本身无关，事件是带子上的标记.\n\n- **空间**  \n  好比建筑物，人的存在与否不影响它的存在.\n\n  时间、空间与事物及过程完全割裂，这就是“绝对时空观”.\n\n#### 研究对象的理想化\n\n1. 把抽象的物质具体化，看得见，摸得着.\n2. 把研究的物质质点化.  \n   (点：具有该物体相同的质量)\n   - 物体的大小、形状可以忽略时\n   - 物体运动中，物体的各部分运动相同\n\n### 运动的绝对性和相对性\n\n### 参考系\n\n### 质点的位置坐标和位置矢量\n\n#### 直角坐标系\n\n质点位置$P(x,y,z)$\n位置矢量$\\vec{r}=\\vec{oP}$\n\n#### 位移\n\n#### 速度\n\n1. 平均速度：$\\overline{\\vec{v}} =\\dfrac{\\Delta \\vec{r}}{\\Delta t}$\n2. 瞬时速度：$\\vec{v}=\\dfrac{\\mathrm{d}\\vec{r}}{\\mathrm{d}t}$\n\n#### 直角坐标系中的速度、加速度\n\n#### 自然坐标系速度表示法\n\n#### 极坐标速度表示法\n\n#### 圆周运动\n\n### 伽利略变换\n\n![坐标系](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250225111725.png)\n\n$S'$ 相对于 $S$ 运动，速度为 $u$ ，则有\n\n$$\n\\begin{aligned}\n&\\vec{r} = \\vec{r'} + \\vec{R},\\quad dt=dt'\\\\\n&\\frac{\\mathrm{d}\\vec{r}}{\\mathrm{d}t} = \\frac{\\mathrm{d}\\vec{r'}}{\\mathrm{d}t'} + \\frac{\\mathrm{d}\\vec{R}}{\\mathrm{d}t'}, \\quad \\vec{v} =\\vec{u} +\\vec{v'}\\\\\n&\\frac{\\mathrm{d}^2\\vec{r}}{\\mathrm{d}t^2} = \\frac{\\mathrm{d}^2\\vec{r'}}{\\mathrm{d}t'^2} + \\frac{\\mathrm{d}^2\\vec{R}}{\\mathrm{d}t^2}, \\quad \\vec{a} = \\vec{a}_0 + \\vec{a'}\n\\end{aligned}\n$$\n\n## 质点运动学\n\n### 牛顿运动定律\n\n#### 牛顿第一定律\n\n#### 牛顿第二定律\n\n#### 牛顿第三定律\n\n### 相互作用力\n\n#### 万有引力的计算\n\n##### 引力质量\n\n##### 惯性质量和引力质量的联系\n\n#### 弹性力\n\n#### 摩擦力\n\n#### 流体阻力\n\n### 非惯性系、惯性力\n\n#### 惯性参考系\n\n#### 惯性离心力\n\n### 惯性力与自然界的运动\n\n#### 太阳和地球引力失重\n\n#### 潮汐力和潮汐\n\n### 科氏加速度和科氏力\n\n#### 科里奥利力的来源\n\n### 质心和质心运动定律\n\n#### 质心\n\n#### 质心坐标系\n\n## 功与能\n\n### 功、动能定理\n\n#### 功的基本概念\n\n#### 内力的功\n\n## 狭义相对论\n\n### 狭义相对论时空观\n\n#### 狭义相对性原理\n\n物理学定律与惯性系的选择无关,所有惯性系是等价的\n\n$$\n\\left\\{\n\\begin{array}{ll}\n  &S  &&m_1\\vec{v_1} + m_2\\vec{v_2} = m_1\\vec{v_10} + m_2\\vec{v_20}\\\\\n  &S' &&m'_1\\vec{v'_1} + m'_2\\vec{v'_2} = m'_1\\vec{v'_10} + m'_2\\vec{v'_20}\n\\end{array}\n\\right.\n$$\n\n#### 光速不变原理\n\n光速在任何惯性系中都是不变的,即光速是绝对的,与光源和观察者的运动状态无关\n由 Maxwell 方程可以推出\n\n#### 洛伦兹变换\n\n设$ $S'$ 系相对于 $S$ 系以速度 $u$ 沿 $x$ 轴正方向运动，两坐标轴原点 $o$ 与 $o'$ 在 $t=t'=0$ 时重合，则有\n\n- 正变换\n\n$$\n\\begin{cases}\n  x' = \\frac{x-ut}{\\sqrt{1-\\frac{u^2}{c^2}}}\\\\\n  y = y'\\\\\n  z = z'\\\\\n  t' = \\frac{t-\\frac{ux}{c^2}}{\\sqrt{1-\\frac{u^2}{c^2}}}\n\\end{cases}\n$$\n\n- 逆变换\n\n$$\n\\begin{cases}\n  x = \\frac{x'+ut'}{\\sqrt{1-\\frac{u^2}{c^2}}}\\\\\n  y' = y\\\\\n  z' = z\\\\\n  t = \\frac{t'+\\frac{ux'}{c^2}}{\\sqrt{1-\\frac{u^2}{c^2}}}\n\\end{cases}\n$$\n\n若令 $\\gamma = \\frac{1}{\\sqrt{1-\\frac{u^2}{c^2}}} >1$，则有\n\n- 正变换\n\n$$\n\\begin{cases}\n  x' = \\gamma(x-ut)\\\\\n  y' = y\\\\\n  z' = z\\\\\n  t' = \\gamma(t-\\frac{ux}{c^2})\n\\end{cases}\n$$\n\n- 逆变换\n\n$$\n\\begin{cases}\n  x = \\gamma(x'+ut')\\\\\n  y = y'\\\\\n  z = z'\\\\\n  t = \\gamma(t'+\\frac{ux'}{c^2})\n\\end{cases}\n$$\n\n### 狭义相对论的时空效应\n\n设在 $S'$ 系中，质点的时空坐标为 $(x', t')$，在 $S$ 系中，质点的坐标为 $(x, t)$，系 $S'$ 相对于系 $S$ 以速度 $u$ 沿 $x$ 轴正方向运动\n\n$$\n\\begin{cases}\n  \\Delta x = \\gamma \\left(\\Delta x -u\\Delta t\\right)\\\\\n  \\Delta x' = \\gamma \\left(\\Delta x' +u\\Delta t'\\right)\\\\\n\\end{cases}\n$$\n\n$$\n\\begin{cases}\n  \\Delta t = \\gamma \\left(\\Delta t -\\frac{u\\Delta x}{c^2}\\right)\\\\\n  \\Delta t' = \\gamma \\left(\\Delta t' +\\frac{u\\Delta x'}{c^2}\\right)\\\\\n\\end{cases}\n$$\n\n明确这两组公式中的变量哪些是 $0$ ，哪些是已知量是解题的关键\n\n#### 时间膨胀\n\n物体在 $S'$ 系中静止，则有\n\n$$\n\\Delta t = \\gamma \\Delta t'\n$$\n\n在 $S'$ 系中同时不同地发生的两件事，$S$ 系中不同时发生，时间间隔为 $\\Delta t = \\gamma \\frac{u \\Delta x'}{c^2}$\n\n#### 长度收缩\n\n设在 $S'$ 系中静止的物体的本征长度为 $L'$，在 $S$ 系中测得的长度 $L$ 为\n\n$$\nL = \\frac{L'}{\\gamma} = L' \\sqrt{1-\\frac{u^2}{c^2}}\n$$\n\n> **注意：**\n>\n> 在 $S$ 系测量则需要在 $S$ 系中同时确认两个点的空间坐标，$\\Delta t = 0$\n\n### 洛伦兹速度变换\n\n- 正变换\n\n$$\n\\begin{cases}\n  v_x' = \\frac{v_x - u}{1-\\frac{uv_x}{c^2}}\\\\\n  v_y' = \\frac{v_y}{\\gamma(1-\\frac{uv_x}{c^2})} = \\frac{v_y\\sqrt{1-\\frac{u^2}{c^2}}}{\\left(1-\\frac{uv_x}{c^2}\\right)}\\\\\n  v_z' = \\frac{v_z}{\\gamma(1-\\frac{uv_x}{c^2})} = \\frac{v_z\\sqrt{1-\\frac{u^2}{c^2}}}{\\left(1-\\frac{uv_x}{c^2}\\right)}\n\\end{cases}\n$$\n\n- 逆变换\n\n$$\n\\begin{cases}\n  v_x = \\frac{v_x' + u}{1+\\frac{uv_x'}{c^2}}\\\\\n  v_y = \\frac{v_y'}{\\gamma(1+\\frac{uv_x'}{c^2})} = \\frac{v_y'\\sqrt{1-\\frac{u^2}{c^2}}}{\\left(1+\\frac{uv_x'}{c^2}\\right)}\\\\\n  v_z = \\frac{v_z'}{\\gamma(1+\\frac{uv_x'}{c^2})} = \\frac{v_z'\\sqrt{1-\\frac{u^2}{c^2}}}{\\left(1+\\frac{uv_x'}{c^2}\\right)}\n\\end{cases}\n$$\n\n### 相对论中的质量和动量\n\n由实验研究表明，物体的质量随着速率增大而增大，记 $m_0$ 为物体在静止时的质量，称为静质量，$m$ 为物体在运动时的质量，称为动质量，则有\n\n$$\nm = \\frac{m_0}{\\sqrt{1-\\frac{v^2}{c^2}}}\n$$\n\n其动量为\n\n$$\n\\vec{p} = m\\vec{v} = \\frac{m_0\\vec{v}}{\\sqrt{1-\\frac{v^2}{c^2}}}\n$$\n\n### 相对论中的力学基本方程\n\n$$\n\\begin{aligned}\n  &\\vec{p} = m\\vec{u} = \\frac{m_0\\vec{u}}{\\sqrt{1-\\frac{u^2}{c^2}}}\\\\\n  &\\vec{p} = \\vec{u} \\mathrm{d}m + m\\mathrm{d}\\vec{u}\\\\\n  &\\vec{F}  = \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left(\\frac{m_0\\vec{u}}{\\sqrt{1-\\frac{u^2}{c^2}}}\\right)\n\\end{aligned}\n$$\n\n### 相对论中的能量\n\n$$\n\\begin{cases}\n  E_k = mc^2 - m_0c^2&\\text{动能}\\\\\n  E_0 = m_0c^2&\\text{静能}\\\\\n  E = mc^2 = E_0 +E_k&\\text{总能量}\n\\end{cases}\n$$\n\n质能关系\n\n$$\n\\Delta E = \\Delta m c^2\n$$\n\n能量与动量之间的关系\n\n$$\np = \\frac{E}{c}\n$$\n\n## 振动力学\n\n### 简谐振动动力学\n\n简谐运动定义：凡质点的运动遵从余弦（或正弦）规律时，其运动形式为简谐振动\n\n其运动方程为\n\n$$\nx(t) = A \\cos(\\omega t + \\varphi)\n$$\n\n简谐运动的动力学方程为\n\n$$\n\\frac{\\mathrm{d}^2x}{\\mathrm{d}t^2} + \\omega^2 x = 0\n$$\n\n其中 $\\omega = \\sqrt{\\frac{k}{m}}$，$k$ 为弹性系数，$m$ 为物体的质量\n\n### 简谐振动运动的物理量\n\n#### 周期、频率和角频率\n\n- **角频率：** $\\omega =\\sqrt{\\frac{k}{m}} = \\frac{2\\pi}{T} = 2\\pi \\nu$\n- **周期：** $T = \\frac{1}{\\nu} = \\frac{2\\pi}{\\omega} = 2\\pi\\sqrt{\\frac{m}{k}}$\n\n在 $x =A \\cos(\\omega t + \\varphi)$ 中，$A$ 为振幅，$\\varphi$ 为初相位\n\n- $v = \\frac{\\mathrm{d}x}{\\mathrm{d}t} = -A\\omega \\sin(\\omega t + \\varphi)$\n- $v_0 = -A\\omega\\sin\\varphi$\n- $E = E_k + E_p = \\frac{1}{2}mv^2 + \\frac{1}{2}kx^2 = \\frac{1}{2}kA^2$\n- $A = \\sqrt{x_0^2+\\frac{v_0^2}{\\omega^2}} = \\sqrt{\\frac{2E}{m\\omega^2}}$\n\n#### 相位\n\n$$\nx = A\\cos(\\omega t + \\varphi)\n$$\n\n- $\\left(\\omega t+\\varphi\\right)$ 是 $t$ 时刻的相位\n- $\\varphi$ 是 $t=0$ 时刻的相位\n- **相位差：** $\\Delta \\varphi =\\left(\\omega_2t+  \\varphi_2\\right)-\\left(\\omega_1t=\\varphi_1\\right)$\n  - 相位差为 $\\pm2k\\pi(k = 0 , 1 , \\ldots)$ 时，两个简谐振动的相位相同\n  - 相位差为 $\\pm(2k+1)\\pi(k = 0 , 1 , \\ldots)$ 时，两个简谐振动的相位相反\n  - 若 $\\Delta\\varphi = \\varphi_ -\\varphi_1>0$，则 $x_2$ 比 $x_1$ 较早到正最大，称 $x_2$ 比 $x_1$ 超前，或称 $x_1$ 比 $x_2$ 滞后\n    - 超前和落后以小于 $\\pi$ 的相位角来判断\n\n#### 振动状态和振动能量\n\n##### 振动速度\n\n$$\n\\begin{aligned}\n  v = \\frac{\\mathrm{d}x}{\\mathrm{d}t} &= -A\\omega \\sin(\\omega t + \\varphi)\\\\\n  &= -v_m \\cos(\\omega t + \\varphi + \\frac{\\pi}{2})\\\\\n\\end{aligned}\n$$\n\n其中 $v_m = A\\omega$ 称为速度振幅\n\n##### 振动加速度\n\n$$\n\\begin{aligned}\n  a = \\frac{\\mathrm{d}^2x}{\\mathrm{d}t^2} &= -A\\omega^2 \\cos(\\omega t + \\varphi)\\\\\n  &= -a_m \\sin(\\omega t + \\varphi + \\frac{\\pi}{2})\\\\\n\\end{aligned}\n$$\n\n其中 $a_m =A\\omega^2$ 称为加速度振幅\n\n##### 振动系统的能量\n\n- 振子动能\n\n$$\nE_k = \\frac{1}{2}mv^2 = \\frac{1}{2}mA^2\\omega^2\\sin^2(\\omega t + \\varphi)\n$$\n\n- 振子势能\n\n$$\nE_p = \\frac{1}{2}kx^2 = \\frac{1}{2}kA^2\\cos^2(\\omega t + \\varphi)\n$$\n\n- 振子总能量\n\n$$\nE = E_k + E_p = \\frac{1}{2}kA^2\n$$\n\n#### 旋转振幅矢量\n\n旋转矢量 $\\vec{A}$ 在 $x$ 轴上的投影点的运动规律为\n\n$$\nx = A \\cos(\\omega t + \\varphi)\n$$\n\n## 平衡态\n\n### 基本概念\n\n1. 热力学系统\n   - **孤立系统：** 与外界无能量和质量交换\n   - **封闭系统：** 与外界有能量无质量交换\n   - **开放系统：** 与外界由能量和质量交换\n   - **外界：** 处于系统之外的物体或物体组\n2. 系统状态的描述\n   - **宏观参量：** 可以直接测量的量，如压强 $p$、温度 $T$ 等由宏观参量描述的系统状态称为宏观状态\n   - **微观量：** 描述系统内微观粒子的物理量，一般无法直接测量，如分子的质量 $m$、直径 $d$、位置、速度 $v$、动量 $p$、能量 $\\epsilon$ 等。\n3. 平衡态\n   - 孤立系统达到的不随时间变化的状态称为热力学平衡态或平衡态\n   - 内部能量和质量没有宏观流动，达到同一温度的定态叫平衡态\n4. 定态\n   - 宏观性质不随时间变化的稳定状态称为定态\n5. **动态平衡：** **不受外界影响**的条件下系统的宏观性质不随时间变化，此系统处在热力学平衡态\n6. 涨落：\n   - 系统的宏观性质在平衡态下有微小的波动称为涨落\n   - 涨落是系统内微观粒子运动的结果\n\n### 热力学第一定律\n\n#### 温度\n\n达到热平衡的系统具有共同的内部属性：温度\n\n#### 热力学第零定律\n\n两个系统同时与第三个系统热平衡时，这两个物体之间也必达到热平衡\n\n处于热平衡的多个系统具有相同的温度\n\n#### 理想气体温标和状态方程\n\n##### 理想气体\n\n- 波义耳定律\n  - 温度不变时没压强和体积的乘积是一个常数\n- 理想气体\n  - 严格遵守波义耳定律的气体为理想气体\n\n##### 热力学温标\n\n理论上存在一个与测温质、测温属性无关的温标：热力学温标\n\n根据物理定律，温度为 $0^\\circ C$ 是，每下降 $1^\\circ C$，体积减少 $\\frac{1}{273}$，则当处于 $-273.15^\\circ C$ 时，体积为 $0$，即 $0K$，称为绝对零度\n\n摄氏温度 $t$ 与绝对温度 $T$ 的关系\n\n$$\nT = t + 273.15\n$$\n\n##### 理想气体状态方程\n\n$$\nPV = nRT = \\frac{m}{M}RT\n$$\n\n其中 $R=8.314J/(mol \\cdot K)$，$n$ 为物质的量，$P$ 为压强，$V$ 为体积，$T$ 为绝对温度\n\n#### 气体压强和温度的统计意义\n\n##### 气体的特征\n\n1. 无一定形状、体积，能充满整个容器空间\n2. 气体分子间距远大于分子的线度 L>>d，分子间引力很小，故气体具有高压缩性、高热膨胀率及高扩散性\n3. 气体分子以高速向四方自由运动，具有高动能\n4. 气体分子无规则热运动，频繁碰撞必产生压力\n\n##### 理想气体分子运动模型\n\n1. 大小不计\n2. 弹性碰撞\n3. 除碰撞外其他相互作用不计\n4. 不记重力\n\n两条统计假设\n\n1.\n\n$$\nn_\\text{单位体积的分子数} = \\frac{\\Delta N}{\\Delta V} =\\frac{\\mathrm{d}N}{\\mathrm{d}V} =\\frac{N_\\text{总分子数}}{V_\\text{总容积}}\n$$\n\n2.\n\n$$\n\\vec{u}_{x\\text{平均速度}} \\left(\\sum_i^N \\frac{u_{ix}}{N}\\right) = \\bar{u}_{y\\text{平均速度}} =\\bar{u}_{z\\text{平均速度}} =0\n$$\n\n##### 理想气体压强公式\n\n$$\n\\begin{aligned}\n  p = \\frac{1}{3}\\sum_imn_iu_i^2 = \\frac{1}{3}nm\\bar{u}^2\n\\end{aligned}\n$$\n\n##### 溫度的统计意义\n\n气体的平均动能\n\n$$\n\\bar{\\varepsilon}_t = \\frac{1}{2}m\\bar{u}^2 =\\frac{3}{2}kT\n$$\n\n对于系统而言，表示分子热运动的激烈程度\n\n### 麦克斯韦速率分布\n\n- 标量形式\n\n$$\nf(v)= 4\\pi v^2 \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{3}{2}} e^{-\\frac{mv^2}{2kT}}\n$$\n\n- 矢量形式\n\n$$\nf(\\vec{v})= \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{3}{2}} e^{-\\frac{m\\vert \\vec{v}\\vert ^2}{2kT}}\n$$\n\n其在三个方向上的分量为\n\n$$\n\\begin{cases}\n  f(v_x) = \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{1}{2}} e^{-\\frac{m}{2kT}v_x^2}\\\\\n  f(v_y) = \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{1}{2}} e^{-\\frac{m}{2kT}v_y^2}\\\\\n  f(v_z) = \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{1}{2}} e^{-\\frac{m}{2kT}v_z^2}\n\\end{cases}\n$$\n\n可以推出\n\n$$\n\\begin{cases}\n  \\frac{\\mathrm{d}N_x}{N} = f(v_x)\\mathrm{d}v_x = \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{1}{2}} e^{-\\frac{m}{2kT}v_x^2}\\mathrm{d}v_x\\\\\n  \\frac{\\mathrm{d}N_y}{N} = f(v_y)\\mathrm{d}v_y = \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{1}{2}} e^{-\\frac{m}{2kT}v_y^2}\\mathrm{d}v_y\\\\\n  \\frac{\\mathrm{d}N_z}{N} = f(v_z)\\mathrm{d}v_z = \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{1}{2}} e^{-\\frac{m}{2kT}v_z^2}\\mathrm{d}v_z\n\\end{cases}\n$$\n\n![Mexwell V](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505221129410.png)\n\n### 麦克斯韦速率分布应用\n\n#### 最可几速率\n\n$$\n\\begin{aligned}\n  &\\frac{\\mathrm{d}f(v)}{\\mathrm{d}v} = 0\\\\\n  \\Rightarrow &v_p=\\sqrt{\\frac{2kT}{m}} = \\sqrt{\\frac{2RT}{M}}\n\\end{aligned}\n$$\n\n#### 平均速率\n\n$$\n\\bar{v} = \\int_0^{\\infty} v f(v) \\mathrm{d}v = \\sqrt{\\frac{8kT}{\\pi m}} = \\sqrt{\\frac{8RT}{\\pi M}}\n$$\n\n#### 均方根速率\n\n$$\n\\sqrt{\\bar{v}^2} = \\sqrt{\\int_0^{\\infty} v^2 f(v) \\mathrm{d}v} = \\sqrt{\\frac{3kT}{m}} = \\sqrt{\\frac{3RT}{M}}\n$$\n\n![MaxwellDistributionApplication](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505221314126.png)\n\n#### 一些应用\n\n设箱体的分子密度为 $n$，求单位时间内单位面积碰撞到墙体的分子数\n\n$$\n\\begin{aligned}\n  N&=n\\bar{v}S\\\\\n  &=nS\\int_0^\\infty f(v_x)v_x\\,\\mathrm{d}v_x\\\\\n  &=\\boxed{\\frac{1}{4}nS\\bar{v}}\n\\end{aligned}\n$$\n\n#### 玻尔兹曼分布\n\n$$\n\\mathrm{d} N = n_0 e^{-\\frac{\\varepsilon_p}{k_BT}}\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z\n$$\n\n$$\nn_i = n_0 e^{-\\frac{E_i}{kT}}\n$$\n\n###### 空气中气体分子在重力场中的密度分布\n\n#### 能量均分定理\n\n##### 分子的自由度\n\n| 分子原子数 | 总自由度 |\n| :--------: | :------: |\n|     1      |    3     |\n|     2      |    5     |\n|     多     |    6     |\n\n对于多原子分子，其内能为\n\n$$\nU = \\frac{f}{2}NkT = \\frac{f}{2} PV\n$$\n\n其中 $f$ 为分子的自由度，$N$ 为分子数\n\n## 热力学第一定律\n\n$$\nQ = \\Delta E + W\n$$\n\n### 比热容\n\n#### 等容过程\n\n$$\n\\begin{align}\n  \\Delta V & = 0\\\\\n  A & = 0\\\\\n  \\Delta Q &= \\Delta E\\\\\n  C_V &= \\frac{\\Delta Q}{\\Delta T} = \\frac{\\mathrm{d}E}{\\mathrm{d}T} = \\frac{i}{2}R\n\\end{align}\n$$\n\n$$\n\\Delta E = \\frac{i}{2}R\\Delta T = \\frac{i}{2}V\\Delta P\n$$\n\n#### 等温过程\n\n$$\n\\begin{aligned}\n  \\Delta T & = 0\\\\\n  \\Delta E & = 0\\\\\n  \\Delta Q & = W \\\\\n  \\mathrm{d}Q &= \\mathrm{d}A \\\\\n  &= P\\mathrm{d}V \\\\\n  &= nRT \\frac{1}{V}\\,\\mathrm{d}V\n\\end{aligned}\n$$\n\n则 $Q = nRT \\ln\\frac{V_2}{V_1}$\n\n#### 等压过程\n\n$$\n\\begin{aligned}\n  \\mathrm{d}Q_P &= \\mathrm{d}E + P\\mathrm{d}V\\\\\n  Q_P &= \\Delta E + P\\Delta V\\\\\n  &= \\frac{i}{2} nR\\Delta T + nR\\Delta V\\\\\n  &= \\frac{i+2}{2} nR\\Delta T\\\\\n\\end{aligned}\n$$\n\n$$\nC_P = \\frac{\\Delta Q}{\\Delta T} = \\frac{i+2}{2}R = C_V +R\n$$\n\n热容比\n\n$$\n\\gamma = \\frac{C_P}{C_V} = 1+\\frac{R}{C_P} = \\frac{i+2}{i}\n$$\n\n#### 绝热过程\n\n绝热过程是指系统与外界没有热量交换的过程\n\n准静态绝热过程方程\n\n$$\nPV^\\gamma = \\text{const}\n$$\n","slug":"大学物理1笔记","published":1,"date":"2025-09-11T11:36:20.594Z","updated":"2025-09-11T16:16:34.916Z","comments":1,"layout":"post","photos":[],"_id":"cmffo52nt00086xzd8iunh236","content":"<h2 id=\"质点运动学\">质点运动学</h2>\n<h3 id=\"时间空间概念\">时间、空间概念</h3>\n<h3 id=\"质点\">质点</h3>\n<h4 id=\"牛顿的时空观\">牛顿的时空观</h4>\n<ul>\n<li><p><strong>时间</strong><br />\n均匀流动的带子，与事件本身无关，事件是带子上的标记.</p></li>\n<li><p><strong>空间</strong><br />\n好比建筑物，人的存在与否不影响它的存在.</p>\n<p>时间、空间与事物及过程完全割裂，这就是“绝对时空观”.</p></li>\n</ul>\n<h4 id=\"研究对象的理想化\">研究对象的理想化</h4>\n<ol type=\"1\">\n<li>把抽象的物质具体化，看得见，摸得着.</li>\n<li>把研究的物质质点化.<br />\n(点：具有该物体相同的质量)\n<ul>\n<li>物体的大小、形状可以忽略时</li>\n<li>物体运动中，物体的各部分运动相同</li>\n</ul></li>\n</ol>\n<h3 id=\"运动的绝对性和相对性\">运动的绝对性和相对性</h3>\n<h3 id=\"参考系\">参考系</h3>\n<h3 id=\"质点的位置坐标和位置矢量\">质点的位置坐标和位置矢量</h3>\n<h4 id=\"直角坐标系\">直角坐标系</h4>\n<p>质点位置<span\nclass=\"math inline\"><em>P</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>\n位置矢量<span class=\"math inline\">$\\vec{r}=\\vec{oP}$</span></p>\n<h4 id=\"位移\">位移</h4>\n<h4 id=\"速度\">速度</h4>\n<ol type=\"1\">\n<li>平均速度：<span class=\"math inline\">$\\overline{\\vec{v}}\n=\\dfrac{\\Delta \\vec{r}}{\\Delta t}$</span></li>\n<li>瞬时速度：<span\nclass=\"math inline\">$\\vec{v}=\\dfrac{\\mathrm{d}\\vec{r}}{\\mathrm{d}t}$</span></li>\n</ol>\n<h4 id=\"直角坐标系中的速度加速度\">直角坐标系中的速度、加速度</h4>\n<h4 id=\"自然坐标系速度表示法\">自然坐标系速度表示法</h4>\n<h4 id=\"极坐标速度表示法\">极坐标速度表示法</h4>\n<h4 id=\"圆周运动\">圆周运动</h4>\n<h3 id=\"伽利略变换\">伽利略变换</h3>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250225111725.png\"\nalt=\"坐标系\" />\n<figcaption aria-hidden=\"true\">坐标系</figcaption>\n</figure>\n<p><span class=\"math inline\"><em>S</em><sup>′</sup></span> 相对于 <span\nclass=\"math inline\"><em>S</em></span> 运动，速度为 <span\nclass=\"math inline\"><em>u</em></span> ，则有</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n&amp;\\vec{r} = \\vec{r'} + \\vec{R},\\quad dt=dt'\\\\\n&amp;\\frac{\\mathrm{d}\\vec{r}}{\\mathrm{d}t} =\n\\frac{\\mathrm{d}\\vec{r'}}{\\mathrm{d}t'} +\n\\frac{\\mathrm{d}\\vec{R}}{\\mathrm{d}t'}, \\quad \\vec{v} =\\vec{u}\n+\\vec{v'}\\\\\n&amp;\\frac{\\mathrm{d}^2\\vec{r}}{\\mathrm{d}t^2} =\n\\frac{\\mathrm{d}^2\\vec{r'}}{\\mathrm{d}t'^2} +\n\\frac{\\mathrm{d}^2\\vec{R}}{\\mathrm{d}t^2}, \\quad \\vec{a} = \\vec{a}_0 +\n\\vec{a'}\n\\end{aligned}\n$$</span></p>\n<h2 id=\"质点运动学-1\">质点运动学</h2>\n<h3 id=\"牛顿运动定律\">牛顿运动定律</h3>\n<h4 id=\"牛顿第一定律\">牛顿第一定律</h4>\n<h4 id=\"牛顿第二定律\">牛顿第二定律</h4>\n<h4 id=\"牛顿第三定律\">牛顿第三定律</h4>\n<h3 id=\"相互作用力\">相互作用力</h3>\n<h4 id=\"万有引力的计算\">万有引力的计算</h4>\n<h5 id=\"引力质量\">引力质量</h5>\n<h5 id=\"惯性质量和引力质量的联系\">惯性质量和引力质量的联系</h5>\n<h4 id=\"弹性力\">弹性力</h4>\n<h4 id=\"摩擦力\">摩擦力</h4>\n<h4 id=\"流体阻力\">流体阻力</h4>\n<h3 id=\"非惯性系惯性力\">非惯性系、惯性力</h3>\n<h4 id=\"惯性参考系\">惯性参考系</h4>\n<h4 id=\"惯性离心力\">惯性离心力</h4>\n<h3 id=\"惯性力与自然界的运动\">惯性力与自然界的运动</h3>\n<h4 id=\"太阳和地球引力失重\">太阳和地球引力失重</h4>\n<h4 id=\"潮汐力和潮汐\">潮汐力和潮汐</h4>\n<h3 id=\"科氏加速度和科氏力\">科氏加速度和科氏力</h3>\n<h4 id=\"科里奥利力的来源\">科里奥利力的来源</h4>\n<h3 id=\"质心和质心运动定律\">质心和质心运动定律</h3>\n<h4 id=\"质心\">质心</h4>\n<h4 id=\"质心坐标系\">质心坐标系</h4>\n<h2 id=\"功与能\">功与能</h2>\n<h3 id=\"功动能定理\">功、动能定理</h3>\n<h4 id=\"功的基本概念\">功的基本概念</h4>\n<h4 id=\"内力的功\">内力的功</h4>\n<h2 id=\"狭义相对论\">狭义相对论</h2>\n<h3 id=\"狭义相对论时空观\">狭义相对论时空观</h3>\n<h4 id=\"狭义相对性原理\">狭义相对性原理</h4>\n<p>物理学定律与惯性系的选择无关,所有惯性系是等价的</p>\n<p><span class=\"math display\">$$\n\\left\\{\n\\begin{array}{ll}\n  &amp;S  &amp;&amp;m_1\\vec{v_1} + m_2\\vec{v_2} = m_1\\vec{v_10} +\nm_2\\vec{v_20}\\\\\n  &amp;S' &amp;&amp;m'_1\\vec{v'_1} + m'_2\\vec{v'_2} = m'_1\\vec{v'_10} +\nm'_2\\vec{v'_20}\n\\end{array}\n\\right.\n$$</span></p>\n<h4 id=\"光速不变原理\">光速不变原理</h4>\n<p>光速在任何惯性系中都是不变的,即光速是绝对的,与光源和观察者的运动状态无关\n由 Maxwell 方程可以推出</p>\n<h4 id=\"洛伦兹变换\">洛伦兹变换</h4>\n<p>设$ <span class=\"math inline\"><em>S</em><sup>′</sup></span> 系相对于\n<span class=\"math inline\"><em>S</em></span> 系以速度 <span\nclass=\"math inline\"><em>u</em></span> 沿 <span\nclass=\"math inline\"><em>x</em></span> 轴正方向运动，两坐标轴原点 <span\nclass=\"math inline\"><em>o</em></span> 与 <span\nclass=\"math inline\"><em>o</em><sup>′</sup></span> 在 <span\nclass=\"math inline\"><em>t</em> = <em>t</em><sup>′</sup> = 0</span>\n时重合，则有</p>\n<ul>\n<li>正变换</li>\n</ul>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  x' = \\frac{x-ut}{\\sqrt{1-\\frac{u^2}{c^2}}}\\\\\n  y = y'\\\\\n  z = z'\\\\\n  t' = \\frac{t-\\frac{ux}{c^2}}{\\sqrt{1-\\frac{u^2}{c^2}}}\n\\end{cases}\n$$</span></p>\n<ul>\n<li>逆变换</li>\n</ul>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  x = \\frac{x'+ut'}{\\sqrt{1-\\frac{u^2}{c^2}}}\\\\\n  y' = y\\\\\n  z' = z\\\\\n  t = \\frac{t'+\\frac{ux'}{c^2}}{\\sqrt{1-\\frac{u^2}{c^2}}}\n\\end{cases}\n$$</span></p>\n<p>若令 <span class=\"math inline\">$\\gamma =\n\\frac{1}{\\sqrt{1-\\frac{u^2}{c^2}}} &gt;1$</span>，则有</p>\n<ul>\n<li>正变换</li>\n</ul>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  x' = \\gamma(x-ut)\\\\\n  y' = y\\\\\n  z' = z\\\\\n  t' = \\gamma(t-\\frac{ux}{c^2})\n\\end{cases}\n$$</span></p>\n<ul>\n<li>逆变换</li>\n</ul>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  x = \\gamma(x'+ut')\\\\\n  y = y'\\\\\n  z = z'\\\\\n  t = \\gamma(t'+\\frac{ux'}{c^2})\n\\end{cases}\n$$</span></p>\n<h3 id=\"狭义相对论的时空效应\">狭义相对论的时空效应</h3>\n<p>设在 <span class=\"math inline\"><em>S</em><sup>′</sup></span>\n系中，质点的时空坐标为 <span\nclass=\"math inline\">(<em>x</em><sup>′</sup>, <em>t</em><sup>′</sup>)</span>，在\n<span class=\"math inline\"><em>S</em></span> 系中，质点的坐标为 <span\nclass=\"math inline\">(<em>x</em>, <em>t</em>)</span>，系 <span\nclass=\"math inline\"><em>S</em><sup>′</sup></span> 相对于系 <span\nclass=\"math inline\"><em>S</em></span> 以速度 <span\nclass=\"math inline\"><em>u</em></span> 沿 <span\nclass=\"math inline\"><em>x</em></span> 轴正方向运动</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\Delta x = \\gamma \\left(\\Delta x -u\\Delta t\\right)\\\\\n  \\Delta x' = \\gamma \\left(\\Delta x' +u\\Delta t'\\right)\\\\\n\\end{cases}\n$$</span></p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\Delta t = \\gamma \\left(\\Delta t -\\frac{u\\Delta x}{c^2}\\right)\\\\\n  \\Delta t' = \\gamma \\left(\\Delta t' +\\frac{u\\Delta x'}{c^2}\\right)\\\\\n\\end{cases}\n$$</span></p>\n<p>明确这两组公式中的变量哪些是 <span class=\"math inline\">0</span>\n，哪些是已知量是解题的关键</p>\n<h4 id=\"时间膨胀\">时间膨胀</h4>\n<p>物体在 <span class=\"math inline\"><em>S</em><sup>′</sup></span>\n系中静止，则有</p>\n<p><span\nclass=\"math display\"><em>Δ</em><em>t</em> = <em>γ</em><em>Δ</em><em>t</em><sup>′</sup></span></p>\n<p>在 <span class=\"math inline\"><em>S</em><sup>′</sup></span>\n系中同时不同地发生的两件事，<span class=\"math inline\"><em>S</em></span>\n系中不同时发生，时间间隔为 <span class=\"math inline\">$\\Delta t = \\gamma\n\\frac{u \\Delta x'}{c^2}$</span></p>\n<h4 id=\"长度收缩\">长度收缩</h4>\n<p>设在 <span class=\"math inline\"><em>S</em><sup>′</sup></span>\n系中静止的物体的本征长度为 <span\nclass=\"math inline\"><em>L</em><sup>′</sup></span>，在 <span\nclass=\"math inline\"><em>S</em></span> 系中测得的长度 <span\nclass=\"math inline\"><em>L</em></span> 为</p>\n<p><span class=\"math display\">$$\nL = \\frac{L'}{\\gamma} = L' \\sqrt{1-\\frac{u^2}{c^2}}\n$$</span></p>\n<blockquote>\n<p><strong>注意：</strong></p>\n<p>在 <span class=\"math inline\"><em>S</em></span> 系测量则需要在 <span\nclass=\"math inline\"><em>S</em></span>\n系中同时确认两个点的空间坐标，<span\nclass=\"math inline\"><em>Δ</em><em>t</em> = 0</span></p>\n</blockquote>\n<h3 id=\"洛伦兹速度变换\">洛伦兹速度变换</h3>\n<ul>\n<li>正变换</li>\n</ul>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  v_x' = \\frac{v_x - u}{1-\\frac{uv_x}{c^2}}\\\\\n  v_y' = \\frac{v_y}{\\gamma(1-\\frac{uv_x}{c^2})} =\n\\frac{v_y\\sqrt{1-\\frac{u^2}{c^2}}}{\\left(1-\\frac{uv_x}{c^2}\\right)}\\\\\n  v_z' = \\frac{v_z}{\\gamma(1-\\frac{uv_x}{c^2})} =\n\\frac{v_z\\sqrt{1-\\frac{u^2}{c^2}}}{\\left(1-\\frac{uv_x}{c^2}\\right)}\n\\end{cases}\n$$</span></p>\n<ul>\n<li>逆变换</li>\n</ul>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  v_x = \\frac{v_x' + u}{1+\\frac{uv_x'}{c^2}}\\\\\n  v_y = \\frac{v_y'}{\\gamma(1+\\frac{uv_x'}{c^2})} =\n\\frac{v_y'\\sqrt{1-\\frac{u^2}{c^2}}}{\\left(1+\\frac{uv_x'}{c^2}\\right)}\\\\\n  v_z = \\frac{v_z'}{\\gamma(1+\\frac{uv_x'}{c^2})} =\n\\frac{v_z'\\sqrt{1-\\frac{u^2}{c^2}}}{\\left(1+\\frac{uv_x'}{c^2}\\right)}\n\\end{cases}\n$$</span></p>\n<h3 id=\"相对论中的质量和动量\">相对论中的质量和动量</h3>\n<p>由实验研究表明，物体的质量随着速率增大而增大，记 <span\nclass=\"math inline\"><em>m</em><sub>0</sub></span>\n为物体在静止时的质量，称为静质量，<span\nclass=\"math inline\"><em>m</em></span>\n为物体在运动时的质量，称为动质量，则有</p>\n<p><span class=\"math display\">$$\nm = \\frac{m_0}{\\sqrt{1-\\frac{v^2}{c^2}}}\n$$</span></p>\n<p>其动量为</p>\n<p><span class=\"math display\">$$\n\\vec{p} = m\\vec{v} = \\frac{m_0\\vec{v}}{\\sqrt{1-\\frac{v^2}{c^2}}}\n$$</span></p>\n<h3 id=\"相对论中的力学基本方程\">相对论中的力学基本方程</h3>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  &amp;\\vec{p} = m\\vec{u} =\n\\frac{m_0\\vec{u}}{\\sqrt{1-\\frac{u^2}{c^2}}}\\\\\n  &amp;\\vec{p} = \\vec{u} \\mathrm{d}m + m\\mathrm{d}\\vec{u}\\\\\n  &amp;\\vec{F}  = \\frac{\\mathrm{d}}{\\mathrm{d}t}\n\\left(\\frac{m_0\\vec{u}}{\\sqrt{1-\\frac{u^2}{c^2}}}\\right)\n\\end{aligned}\n$$</span></p>\n<h3 id=\"相对论中的能量\">相对论中的能量</h3>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  E_k = mc^2 - m_0c^2&amp;\\text{动能}\\\\\n  E_0 = m_0c^2&amp;\\text{静能}\\\\\n  E = mc^2 = E_0 +E_k&amp;\\text{总能量}\n\\end{cases}\n$$</span></p>\n<p>质能关系</p>\n<p><span\nclass=\"math display\"><em>Δ</em><em>E</em> = <em>Δ</em><em>m</em><em>c</em><sup>2</sup></span></p>\n<p>能量与动量之间的关系</p>\n<p><span class=\"math display\">$$\np = \\frac{E}{c}\n$$</span></p>\n<h2 id=\"振动力学\">振动力学</h2>\n<h3 id=\"简谐振动动力学\">简谐振动动力学</h3>\n<p>简谐运动定义：凡质点的运动遵从余弦（或正弦）规律时，其运动形式为简谐振动</p>\n<p>其运动方程为</p>\n<p><span\nclass=\"math display\"><em>x</em>(<em>t</em>) = <em>A</em>cos (<em>ω</em><em>t</em> + <em>φ</em>)</span></p>\n<p>简谐运动的动力学方程为</p>\n<p><span class=\"math display\">$$\n\\frac{\\mathrm{d}^2x}{\\mathrm{d}t^2} + \\omega^2 x = 0\n$$</span></p>\n<p>其中 <span class=\"math inline\">$\\omega =\n\\sqrt{\\frac{k}{m}}$</span>，<span class=\"math inline\"><em>k</em></span>\n为弹性系数，<span class=\"math inline\"><em>m</em></span> 为物体的质量</p>\n<h3 id=\"简谐振动运动的物理量\">简谐振动运动的物理量</h3>\n<h4 id=\"周期频率和角频率\">周期、频率和角频率</h4>\n<ul>\n<li><strong>角频率：</strong> <span class=\"math inline\">$\\omega\n=\\sqrt{\\frac{k}{m}} = \\frac{2\\pi}{T} = 2\\pi \\nu$</span></li>\n<li><strong>周期：</strong> <span class=\"math inline\">$T = \\frac{1}{\\nu}\n= \\frac{2\\pi}{\\omega} = 2\\pi\\sqrt{\\frac{m}{k}}$</span></li>\n</ul>\n<p>在 <span\nclass=\"math inline\"><em>x</em> = <em>A</em>cos (<em>ω</em><em>t</em> + <em>φ</em>)</span>\n中，<span class=\"math inline\"><em>A</em></span> 为振幅，<span\nclass=\"math inline\"><em>φ</em></span> 为初相位</p>\n<ul>\n<li><span class=\"math inline\">$v = \\frac{\\mathrm{d}x}{\\mathrm{d}t} =\n-A\\omega \\sin(\\omega t + \\varphi)$</span></li>\n<li><span\nclass=\"math inline\"><em>v</em><sub>0</sub> = −<em>A</em><em>ω</em>sin <em>φ</em></span></li>\n<li><span class=\"math inline\">$E = E_k + E_p = \\frac{1}{2}mv^2 +\n\\frac{1}{2}kx^2 = \\frac{1}{2}kA^2$</span></li>\n<li><span class=\"math inline\">$A = \\sqrt{x_0^2+\\frac{v_0^2}{\\omega^2}} =\n\\sqrt{\\frac{2E}{m\\omega^2}}$</span></li>\n</ul>\n<h4 id=\"相位\">相位</h4>\n<p><span\nclass=\"math display\"><em>x</em> = <em>A</em>cos (<em>ω</em><em>t</em> + <em>φ</em>)</span></p>\n<ul>\n<li><span class=\"math inline\">(<em>ω</em><em>t</em> + <em>φ</em>)</span>\n是 <span class=\"math inline\"><em>t</em></span> 时刻的相位</li>\n<li><span class=\"math inline\"><em>φ</em></span> 是 <span\nclass=\"math inline\"><em>t</em> = 0</span> 时刻的相位</li>\n<li><strong>相位差：</strong> <span\nclass=\"math inline\"><em>Δ</em><em>φ</em> = (<em>ω</em><sub>2</sub><em>t</em> + <em>φ</em><sub>2</sub>) − (<em>ω</em><sub>1</sub><em>t</em> = <em>φ</em><sub>1</sub>)</span>\n<ul>\n<li>相位差为 <span\nclass=\"math inline\">±2<em>k</em><em>π</em>(<em>k</em> = 0, 1, …)</span>\n时，两个简谐振动的相位相同</li>\n<li>相位差为 <span\nclass=\"math inline\">±(2<em>k</em> + 1)<em>π</em>(<em>k</em> = 0, 1, …)</span>\n时，两个简谐振动的相位相反</li>\n<li>若 <span\nclass=\"math inline\"><em>Δ</em><em>φ</em> = <em>φ</em><sub>−</sub><em>φ</em><sub>1</sub> &gt; 0</span>，则\n<span class=\"math inline\"><em>x</em><sub>2</sub></span> 比 <span\nclass=\"math inline\"><em>x</em><sub>1</sub></span> 较早到正最大，称 <span\nclass=\"math inline\"><em>x</em><sub>2</sub></span> 比 <span\nclass=\"math inline\"><em>x</em><sub>1</sub></span> 超前，或称 <span\nclass=\"math inline\"><em>x</em><sub>1</sub></span> 比 <span\nclass=\"math inline\"><em>x</em><sub>2</sub></span> 滞后\n<ul>\n<li>超前和落后以小于 <span class=\"math inline\"><em>π</em></span>\n的相位角来判断</li>\n</ul></li>\n</ul></li>\n</ul>\n<h4 id=\"振动状态和振动能量\">振动状态和振动能量</h4>\n<h5 id=\"振动速度\">振动速度</h5>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  v = \\frac{\\mathrm{d}x}{\\mathrm{d}t} &amp;= -A\\omega \\sin(\\omega t +\n\\varphi)\\\\\n  &amp;= -v_m \\cos(\\omega t + \\varphi + \\frac{\\pi}{2})\\\\\n\\end{aligned}\n$$</span></p>\n<p>其中 <span\nclass=\"math inline\"><em>v</em><sub><em>m</em></sub> = <em>A</em><em>ω</em></span>\n称为速度振幅</p>\n<h5 id=\"振动加速度\">振动加速度</h5>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  a = \\frac{\\mathrm{d}^2x}{\\mathrm{d}t^2} &amp;= -A\\omega^2 \\cos(\\omega\nt + \\varphi)\\\\\n  &amp;= -a_m \\sin(\\omega t + \\varphi + \\frac{\\pi}{2})\\\\\n\\end{aligned}\n$$</span></p>\n<p>其中 <span\nclass=\"math inline\"><em>a</em><sub><em>m</em></sub> = <em>A</em><em>ω</em><sup>2</sup></span>\n称为加速度振幅</p>\n<h5 id=\"振动系统的能量\">振动系统的能量</h5>\n<ul>\n<li>振子动能</li>\n</ul>\n<p><span class=\"math display\">$$\nE_k = \\frac{1}{2}mv^2 = \\frac{1}{2}mA^2\\omega^2\\sin^2(\\omega t +\n\\varphi)\n$$</span></p>\n<ul>\n<li>振子势能</li>\n</ul>\n<p><span class=\"math display\">$$\nE_p = \\frac{1}{2}kx^2 = \\frac{1}{2}kA^2\\cos^2(\\omega t + \\varphi)\n$$</span></p>\n<ul>\n<li>振子总能量</li>\n</ul>\n<p><span class=\"math display\">$$\nE = E_k + E_p = \\frac{1}{2}kA^2\n$$</span></p>\n<h4 id=\"旋转振幅矢量\">旋转振幅矢量</h4>\n<p>旋转矢量 <span class=\"math inline\"><em>A⃗</em></span> 在 <span\nclass=\"math inline\"><em>x</em></span> 轴上的投影点的运动规律为</p>\n<p><span\nclass=\"math display\"><em>x</em> = <em>A</em>cos (<em>ω</em><em>t</em> + <em>φ</em>)</span></p>\n<h2 id=\"平衡态\">平衡态</h2>\n<h3 id=\"基本概念\">基本概念</h3>\n<ol type=\"1\">\n<li>热力学系统\n<ul>\n<li><strong>孤立系统：</strong> 与外界无能量和质量交换</li>\n<li><strong>封闭系统：</strong> 与外界有能量无质量交换</li>\n<li><strong>开放系统：</strong> 与外界由能量和质量交换</li>\n<li><strong>外界：</strong> 处于系统之外的物体或物体组</li>\n</ul></li>\n<li>系统状态的描述\n<ul>\n<li><strong>宏观参量：</strong> 可以直接测量的量，如压强 <span\nclass=\"math inline\"><em>p</em></span>、温度 <span\nclass=\"math inline\"><em>T</em></span>\n等由宏观参量描述的系统状态称为宏观状态</li>\n<li><strong>微观量：</strong>\n描述系统内微观粒子的物理量，一般无法直接测量，如分子的质量 <span\nclass=\"math inline\"><em>m</em></span>、直径 <span\nclass=\"math inline\"><em>d</em></span>、位置、速度 <span\nclass=\"math inline\"><em>v</em></span>、动量 <span\nclass=\"math inline\"><em>p</em></span>、能量 <span\nclass=\"math inline\"><em>ϵ</em></span> 等。</li>\n</ul></li>\n<li>平衡态\n<ul>\n<li>孤立系统达到的不随时间变化的状态称为热力学平衡态或平衡态</li>\n<li>内部能量和质量没有宏观流动，达到同一温度的定态叫平衡态</li>\n</ul></li>\n<li>定态\n<ul>\n<li>宏观性质不随时间变化的稳定状态称为定态</li>\n</ul></li>\n<li><strong>动态平衡：</strong>\n<strong>不受外界影响</strong>的条件下系统的宏观性质不随时间变化，此系统处在热力学平衡态</li>\n<li>涨落：\n<ul>\n<li>系统的宏观性质在平衡态下有微小的波动称为涨落</li>\n<li>涨落是系统内微观粒子运动的结果</li>\n</ul></li>\n</ol>\n<h3 id=\"热力学第一定律\">热力学第一定律</h3>\n<h4 id=\"温度\">温度</h4>\n<p>达到热平衡的系统具有共同的内部属性：温度</p>\n<h4 id=\"热力学第零定律\">热力学第零定律</h4>\n<p>两个系统同时与第三个系统热平衡时，这两个物体之间也必达到热平衡</p>\n<p>处于热平衡的多个系统具有相同的温度</p>\n<h4 id=\"理想气体温标和状态方程\">理想气体温标和状态方程</h4>\n<h5 id=\"理想气体\">理想气体</h5>\n<ul>\n<li>波义耳定律\n<ul>\n<li>温度不变时没压强和体积的乘积是一个常数</li>\n</ul></li>\n<li>理想气体\n<ul>\n<li>严格遵守波义耳定律的气体为理想气体</li>\n</ul></li>\n</ul>\n<h5 id=\"热力学温标\">热力学温标</h5>\n<p>理论上存在一个与测温质、测温属性无关的温标：热力学温标</p>\n<p>根据物理定律，温度为 <span\nclass=\"math inline\">0<sup>∘</sup><em>C</em></span> 是，每下降 <span\nclass=\"math inline\">1<sup>∘</sup><em>C</em></span>，体积减少 <span\nclass=\"math inline\">$\\frac{1}{273}$</span>，则当处于 <span\nclass=\"math inline\">−273.15<sup>∘</sup><em>C</em></span> 时，体积为\n<span class=\"math inline\">0</span>，即 <span\nclass=\"math inline\">0<em>K</em></span>，称为绝对零度</p>\n<p>摄氏温度 <span class=\"math inline\"><em>t</em></span> 与绝对温度 <span\nclass=\"math inline\"><em>T</em></span> 的关系</p>\n<p><span\nclass=\"math display\"><em>T</em> = <em>t</em> + 273.15</span></p>\n<h5 id=\"理想气体状态方程\">理想气体状态方程</h5>\n<p><span class=\"math display\">$$\nPV = nRT = \\frac{m}{M}RT\n$$</span></p>\n<p>其中 <span\nclass=\"math inline\"><em>R</em> = 8.314<em>J</em>/(<em>m</em><em>o</em><em>l</em> ⋅ <em>K</em>)</span>，<span\nclass=\"math inline\"><em>n</em></span> 为物质的量，<span\nclass=\"math inline\"><em>P</em></span> 为压强，<span\nclass=\"math inline\"><em>V</em></span> 为体积，<span\nclass=\"math inline\"><em>T</em></span> 为绝对温度</p>\n<h4 id=\"气体压强和温度的统计意义\">气体压强和温度的统计意义</h4>\n<h5 id=\"气体的特征\">气体的特征</h5>\n<ol type=\"1\">\n<li>无一定形状、体积，能充满整个容器空间</li>\n<li>气体分子间距远大于分子的线度\nL&gt;&gt;d，分子间引力很小，故气体具有高压缩性、高热膨胀率及高扩散性</li>\n<li>气体分子以高速向四方自由运动，具有高动能</li>\n<li>气体分子无规则热运动，频繁碰撞必产生压力</li>\n</ol>\n<h5 id=\"理想气体分子运动模型\">理想气体分子运动模型</h5>\n<ol type=\"1\">\n<li>大小不计</li>\n<li>弹性碰撞</li>\n<li>除碰撞外其他相互作用不计</li>\n<li>不记重力</li>\n</ol>\n<p>两条统计假设</p>\n<ol type=\"1\">\n<li></li>\n</ol>\n<p><span class=\"math display\">$$\nn_\\text{单位体积的分子数} = \\frac{\\Delta N}{\\Delta V}\n=\\frac{\\mathrm{d}N}{\\mathrm{d}V}\n=\\frac{N_\\text{总分子数}}{V_\\text{总容积}}\n$$</span></p>\n<ol start=\"2\" type=\"1\">\n<li></li>\n</ol>\n<p><span class=\"math display\">$$\n\\vec{u}_{x\\text{平均速度}} \\left(\\sum_i^N \\frac{u_{ix}}{N}\\right) =\n\\bar{u}_{y\\text{平均速度}} =\\bar{u}_{z\\text{平均速度}} =0\n$$</span></p>\n<h5 id=\"理想气体压强公式\">理想气体压强公式</h5>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  p = \\frac{1}{3}\\sum_imn_iu_i^2 = \\frac{1}{3}nm\\bar{u}^2\n\\end{aligned}\n$$</span></p>\n<h5 id=\"溫度的统计意义\">溫度的统计意义</h5>\n<p>气体的平均动能</p>\n<p><span class=\"math display\">$$\n\\bar{\\varepsilon}_t = \\frac{1}{2}m\\bar{u}^2 =\\frac{3}{2}kT\n$$</span></p>\n<p>对于系统而言，表示分子热运动的激烈程度</p>\n<h3 id=\"麦克斯韦速率分布\">麦克斯韦速率分布</h3>\n<ul>\n<li>标量形式</li>\n</ul>\n<p><span class=\"math display\">$$\nf(v)= 4\\pi v^2 \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{3}{2}}\ne^{-\\frac{mv^2}{2kT}}\n$$</span></p>\n<ul>\n<li>矢量形式</li>\n</ul>\n<p><span class=\"math display\">$$\nf(\\vec{v})= \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{3}{2}}\ne^{-\\frac{m\\vert \\vec{v}\\vert ^2}{2kT}}\n$$</span></p>\n<p>其在三个方向上的分量为</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  f(v_x) = \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{1}{2}}\ne^{-\\frac{m}{2kT}v_x^2}\\\\\n  f(v_y) = \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{1}{2}}\ne^{-\\frac{m}{2kT}v_y^2}\\\\\n  f(v_z) = \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{1}{2}}\ne^{-\\frac{m}{2kT}v_z^2}\n\\end{cases}\n$$</span></p>\n<p>可以推出</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\frac{\\mathrm{d}N_x}{N} = f(v_x)\\mathrm{d}v_x = \\left(\\frac{m}{2\\pi\nkT}\\right)^{\\frac{1}{2}} e^{-\\frac{m}{2kT}v_x^2}\\mathrm{d}v_x\\\\\n  \\frac{\\mathrm{d}N_y}{N} = f(v_y)\\mathrm{d}v_y = \\left(\\frac{m}{2\\pi\nkT}\\right)^{\\frac{1}{2}} e^{-\\frac{m}{2kT}v_y^2}\\mathrm{d}v_y\\\\\n  \\frac{\\mathrm{d}N_z}{N} = f(v_z)\\mathrm{d}v_z = \\left(\\frac{m}{2\\pi\nkT}\\right)^{\\frac{1}{2}} e^{-\\frac{m}{2kT}v_z^2}\\mathrm{d}v_z\n\\end{cases}\n$$</span></p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505221129410.png\"\nalt=\"Mexwell V\" />\n<figcaption aria-hidden=\"true\">Mexwell V</figcaption>\n</figure>\n<h3 id=\"麦克斯韦速率分布应用\">麦克斯韦速率分布应用</h3>\n<h4 id=\"最可几速率\">最可几速率</h4>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  &amp;\\frac{\\mathrm{d}f(v)}{\\mathrm{d}v} = 0\\\\\n  \\Rightarrow &amp;v_p=\\sqrt{\\frac{2kT}{m}} = \\sqrt{\\frac{2RT}{M}}\n\\end{aligned}\n$$</span></p>\n<h4 id=\"平均速率\">平均速率</h4>\n<p><span class=\"math display\">$$\n\\bar{v} = \\int_0^{\\infty} v f(v) \\mathrm{d}v = \\sqrt{\\frac{8kT}{\\pi m}}\n= \\sqrt{\\frac{8RT}{\\pi M}}\n$$</span></p>\n<h4 id=\"均方根速率\">均方根速率</h4>\n<p><span class=\"math display\">$$\n\\sqrt{\\bar{v}^2} = \\sqrt{\\int_0^{\\infty} v^2 f(v) \\mathrm{d}v} =\n\\sqrt{\\frac{3kT}{m}} = \\sqrt{\\frac{3RT}{M}}\n$$</span></p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505221314126.png\"\nalt=\"MaxwellDistributionApplication\" />\n<figcaption\naria-hidden=\"true\">MaxwellDistributionApplication</figcaption>\n</figure>\n<h4 id=\"一些应用\">一些应用</h4>\n<p>设箱体的分子密度为 <span\nclass=\"math inline\"><em>n</em></span>，求单位时间内单位面积碰撞到墙体的分子数</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  N&amp;=n\\bar{v}S\\\\\n  &amp;=nS\\int_0^\\infty f(v_x)v_x\\,\\mathrm{d}v_x\\\\\n  &amp;=\\boxed{\\frac{1}{4}nS\\bar{v}}\n\\end{aligned}\n$$</span></p>\n<h4 id=\"玻尔兹曼分布\">玻尔兹曼分布</h4>\n<p><span class=\"math display\">$$\n\\mathrm{d} N = n_0\ne^{-\\frac{\\varepsilon_p}{k_BT}}\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z\n$$</span></p>\n<p><span class=\"math display\">$$\nn_i = n_0 e^{-\\frac{E_i}{kT}}\n$$</span></p>\n<h6\nid=\"空气中气体分子在重力场中的密度分布\">空气中气体分子在重力场中的密度分布</h6>\n<h4 id=\"能量均分定理\">能量均分定理</h4>\n<h5 id=\"分子的自由度\">分子的自由度</h5>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">分子原子数</th>\n<th style=\"text-align: center;\">总自由度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">1</td>\n<td style=\"text-align: center;\">3</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">2</td>\n<td style=\"text-align: center;\">5</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">多</td>\n<td style=\"text-align: center;\">6</td>\n</tr>\n</tbody>\n</table>\n<p>对于多原子分子，其内能为</p>\n<p><span class=\"math display\">$$\nU = \\frac{f}{2}NkT = \\frac{f}{2} PV\n$$</span></p>\n<p>其中 <span class=\"math inline\"><em>f</em></span>\n为分子的自由度，<span class=\"math inline\"><em>N</em></span> 为分子数</p>\n<h2 id=\"热力学第一定律-1\">热力学第一定律</h2>\n<p><span\nclass=\"math display\"><em>Q</em> = <em>Δ</em><em>E</em> + <em>W</em></span></p>\n<h3 id=\"比热容\">比热容</h3>\n<h4 id=\"等容过程\">等容过程</h4>\n<p><span class=\"math display\">$$\n\\begin{align}\n  \\Delta V &amp; = 0\\\\\n  A &amp; = 0\\\\\n  \\Delta Q &amp;= \\Delta E\\\\\n  C_V &amp;= \\frac{\\Delta Q}{\\Delta T} = \\frac{\\mathrm{d}E}{\\mathrm{d}T}\n= \\frac{i}{2}R\n\\end{align}\n$$</span></p>\n<p><span class=\"math display\">$$\n\\Delta E = \\frac{i}{2}R\\Delta T = \\frac{i}{2}V\\Delta P\n$$</span></p>\n<h4 id=\"等温过程\">等温过程</h4>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  \\Delta T &amp; = 0\\\\\n  \\Delta E &amp; = 0\\\\\n  \\Delta Q &amp; = W \\\\\n  \\mathrm{d}Q &amp;= \\mathrm{d}A \\\\\n  &amp;= P\\mathrm{d}V \\\\\n  &amp;= nRT \\frac{1}{V}\\,\\mathrm{d}V\n\\end{aligned}\n$$</span></p>\n<p>则 <span class=\"math inline\">$Q = nRT \\ln\\frac{V_2}{V_1}$</span></p>\n<h4 id=\"等压过程\">等压过程</h4>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  \\mathrm{d}Q_P &amp;= \\mathrm{d}E + P\\mathrm{d}V\\\\\n  Q_P &amp;= \\Delta E + P\\Delta V\\\\\n  &amp;= \\frac{i}{2} nR\\Delta T + nR\\Delta V\\\\\n  &amp;= \\frac{i+2}{2} nR\\Delta T\\\\\n\\end{aligned}\n$$</span></p>\n<p><span class=\"math display\">$$\nC_P = \\frac{\\Delta Q}{\\Delta T} = \\frac{i+2}{2}R = C_V +R\n$$</span></p>\n<p>热容比</p>\n<p><span class=\"math display\">$$\n\\gamma = \\frac{C_P}{C_V} = 1+\\frac{R}{C_P} = \\frac{i+2}{i}\n$$</span></p>\n<h4 id=\"绝热过程\">绝热过程</h4>\n<p>绝热过程是指系统与外界没有热量交换的过程</p>\n<p>准静态绝热过程方程</p>\n<p><span\nclass=\"math display\"><em>P</em><em>V</em><sup><em>γ</em></sup> = const</span></p>\n","excerpt":"","more":"<h2 id=\"质点运动学\">质点运动学</h2>\n<h3 id=\"时间空间概念\">时间、空间概念</h3>\n<h3 id=\"质点\">质点</h3>\n<h4 id=\"牛顿的时空观\">牛顿的时空观</h4>\n<ul>\n<li><p><strong>时间</strong><br />\n均匀流动的带子，与事件本身无关，事件是带子上的标记.</p></li>\n<li><p><strong>空间</strong><br />\n好比建筑物，人的存在与否不影响它的存在.</p>\n<p>时间、空间与事物及过程完全割裂，这就是“绝对时空观”.</p></li>\n</ul>\n<h4 id=\"研究对象的理想化\">研究对象的理想化</h4>\n<ol type=\"1\">\n<li>把抽象的物质具体化，看得见，摸得着.</li>\n<li>把研究的物质质点化.<br />\n(点：具有该物体相同的质量)\n<ul>\n<li>物体的大小、形状可以忽略时</li>\n<li>物体运动中，物体的各部分运动相同</li>\n</ul></li>\n</ol>\n<h3 id=\"运动的绝对性和相对性\">运动的绝对性和相对性</h3>\n<h3 id=\"参考系\">参考系</h3>\n<h3 id=\"质点的位置坐标和位置矢量\">质点的位置坐标和位置矢量</h3>\n<h4 id=\"直角坐标系\">直角坐标系</h4>\n<p>质点位置<span\nclass=\"math inline\"><em>P</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>\n位置矢量<span class=\"math inline\">$\\vec{r}=\\vec{oP}$</span></p>\n<h4 id=\"位移\">位移</h4>\n<h4 id=\"速度\">速度</h4>\n<ol type=\"1\">\n<li>平均速度：<span class=\"math inline\">$\\overline{\\vec{v}}\n=\\dfrac{\\Delta \\vec{r}}{\\Delta t}$</span></li>\n<li>瞬时速度：<span\nclass=\"math inline\">$\\vec{v}=\\dfrac{\\mathrm{d}\\vec{r}}{\\mathrm{d}t}$</span></li>\n</ol>\n<h4 id=\"直角坐标系中的速度加速度\">直角坐标系中的速度、加速度</h4>\n<h4 id=\"自然坐标系速度表示法\">自然坐标系速度表示法</h4>\n<h4 id=\"极坐标速度表示法\">极坐标速度表示法</h4>\n<h4 id=\"圆周运动\">圆周运动</h4>\n<h3 id=\"伽利略变换\">伽利略变换</h3>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250225111725.png\"\nalt=\"坐标系\" />\n<figcaption aria-hidden=\"true\">坐标系</figcaption>\n</figure>\n<p><span class=\"math inline\"><em>S</em><sup>′</sup></span> 相对于 <span\nclass=\"math inline\"><em>S</em></span> 运动，速度为 <span\nclass=\"math inline\"><em>u</em></span> ，则有</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n&amp;\\vec{r} = \\vec{r'} + \\vec{R},\\quad dt=dt'\\\\\n&amp;\\frac{\\mathrm{d}\\vec{r}}{\\mathrm{d}t} =\n\\frac{\\mathrm{d}\\vec{r'}}{\\mathrm{d}t'} +\n\\frac{\\mathrm{d}\\vec{R}}{\\mathrm{d}t'}, \\quad \\vec{v} =\\vec{u}\n+\\vec{v'}\\\\\n&amp;\\frac{\\mathrm{d}^2\\vec{r}}{\\mathrm{d}t^2} =\n\\frac{\\mathrm{d}^2\\vec{r'}}{\\mathrm{d}t'^2} +\n\\frac{\\mathrm{d}^2\\vec{R}}{\\mathrm{d}t^2}, \\quad \\vec{a} = \\vec{a}_0 +\n\\vec{a'}\n\\end{aligned}\n$$</span></p>\n<h2 id=\"质点运动学-1\">质点运动学</h2>\n<h3 id=\"牛顿运动定律\">牛顿运动定律</h3>\n<h4 id=\"牛顿第一定律\">牛顿第一定律</h4>\n<h4 id=\"牛顿第二定律\">牛顿第二定律</h4>\n<h4 id=\"牛顿第三定律\">牛顿第三定律</h4>\n<h3 id=\"相互作用力\">相互作用力</h3>\n<h4 id=\"万有引力的计算\">万有引力的计算</h4>\n<h5 id=\"引力质量\">引力质量</h5>\n<h5 id=\"惯性质量和引力质量的联系\">惯性质量和引力质量的联系</h5>\n<h4 id=\"弹性力\">弹性力</h4>\n<h4 id=\"摩擦力\">摩擦力</h4>\n<h4 id=\"流体阻力\">流体阻力</h4>\n<h3 id=\"非惯性系惯性力\">非惯性系、惯性力</h3>\n<h4 id=\"惯性参考系\">惯性参考系</h4>\n<h4 id=\"惯性离心力\">惯性离心力</h4>\n<h3 id=\"惯性力与自然界的运动\">惯性力与自然界的运动</h3>\n<h4 id=\"太阳和地球引力失重\">太阳和地球引力失重</h4>\n<h4 id=\"潮汐力和潮汐\">潮汐力和潮汐</h4>\n<h3 id=\"科氏加速度和科氏力\">科氏加速度和科氏力</h3>\n<h4 id=\"科里奥利力的来源\">科里奥利力的来源</h4>\n<h3 id=\"质心和质心运动定律\">质心和质心运动定律</h3>\n<h4 id=\"质心\">质心</h4>\n<h4 id=\"质心坐标系\">质心坐标系</h4>\n<h2 id=\"功与能\">功与能</h2>\n<h3 id=\"功动能定理\">功、动能定理</h3>\n<h4 id=\"功的基本概念\">功的基本概念</h4>\n<h4 id=\"内力的功\">内力的功</h4>\n<h2 id=\"狭义相对论\">狭义相对论</h2>\n<h3 id=\"狭义相对论时空观\">狭义相对论时空观</h3>\n<h4 id=\"狭义相对性原理\">狭义相对性原理</h4>\n<p>物理学定律与惯性系的选择无关,所有惯性系是等价的</p>\n<p><span class=\"math display\">$$\n\\left\\{\n\\begin{array}{ll}\n  &amp;S  &amp;&amp;m_1\\vec{v_1} + m_2\\vec{v_2} = m_1\\vec{v_10} +\nm_2\\vec{v_20}\\\\\n  &amp;S' &amp;&amp;m'_1\\vec{v'_1} + m'_2\\vec{v'_2} = m'_1\\vec{v'_10} +\nm'_2\\vec{v'_20}\n\\end{array}\n\\right.\n$$</span></p>\n<h4 id=\"光速不变原理\">光速不变原理</h4>\n<p>光速在任何惯性系中都是不变的,即光速是绝对的,与光源和观察者的运动状态无关\n由 Maxwell 方程可以推出</p>\n<h4 id=\"洛伦兹变换\">洛伦兹变换</h4>\n<p>设$ <span class=\"math inline\"><em>S</em><sup>′</sup></span> 系相对于\n<span class=\"math inline\"><em>S</em></span> 系以速度 <span\nclass=\"math inline\"><em>u</em></span> 沿 <span\nclass=\"math inline\"><em>x</em></span> 轴正方向运动，两坐标轴原点 <span\nclass=\"math inline\"><em>o</em></span> 与 <span\nclass=\"math inline\"><em>o</em><sup>′</sup></span> 在 <span\nclass=\"math inline\"><em>t</em> = <em>t</em><sup>′</sup> = 0</span>\n时重合，则有</p>\n<ul>\n<li>正变换</li>\n</ul>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  x' = \\frac{x-ut}{\\sqrt{1-\\frac{u^2}{c^2}}}\\\\\n  y = y'\\\\\n  z = z'\\\\\n  t' = \\frac{t-\\frac{ux}{c^2}}{\\sqrt{1-\\frac{u^2}{c^2}}}\n\\end{cases}\n$$</span></p>\n<ul>\n<li>逆变换</li>\n</ul>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  x = \\frac{x'+ut'}{\\sqrt{1-\\frac{u^2}{c^2}}}\\\\\n  y' = y\\\\\n  z' = z\\\\\n  t = \\frac{t'+\\frac{ux'}{c^2}}{\\sqrt{1-\\frac{u^2}{c^2}}}\n\\end{cases}\n$$</span></p>\n<p>若令 <span class=\"math inline\">$\\gamma =\n\\frac{1}{\\sqrt{1-\\frac{u^2}{c^2}}} &gt;1$</span>，则有</p>\n<ul>\n<li>正变换</li>\n</ul>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  x' = \\gamma(x-ut)\\\\\n  y' = y\\\\\n  z' = z\\\\\n  t' = \\gamma(t-\\frac{ux}{c^2})\n\\end{cases}\n$$</span></p>\n<ul>\n<li>逆变换</li>\n</ul>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  x = \\gamma(x'+ut')\\\\\n  y = y'\\\\\n  z = z'\\\\\n  t = \\gamma(t'+\\frac{ux'}{c^2})\n\\end{cases}\n$$</span></p>\n<h3 id=\"狭义相对论的时空效应\">狭义相对论的时空效应</h3>\n<p>设在 <span class=\"math inline\"><em>S</em><sup>′</sup></span>\n系中，质点的时空坐标为 <span\nclass=\"math inline\">(<em>x</em><sup>′</sup>, <em>t</em><sup>′</sup>)</span>，在\n<span class=\"math inline\"><em>S</em></span> 系中，质点的坐标为 <span\nclass=\"math inline\">(<em>x</em>, <em>t</em>)</span>，系 <span\nclass=\"math inline\"><em>S</em><sup>′</sup></span> 相对于系 <span\nclass=\"math inline\"><em>S</em></span> 以速度 <span\nclass=\"math inline\"><em>u</em></span> 沿 <span\nclass=\"math inline\"><em>x</em></span> 轴正方向运动</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\Delta x = \\gamma \\left(\\Delta x -u\\Delta t\\right)\\\\\n  \\Delta x' = \\gamma \\left(\\Delta x' +u\\Delta t'\\right)\\\\\n\\end{cases}\n$$</span></p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\Delta t = \\gamma \\left(\\Delta t -\\frac{u\\Delta x}{c^2}\\right)\\\\\n  \\Delta t' = \\gamma \\left(\\Delta t' +\\frac{u\\Delta x'}{c^2}\\right)\\\\\n\\end{cases}\n$$</span></p>\n<p>明确这两组公式中的变量哪些是 <span class=\"math inline\">0</span>\n，哪些是已知量是解题的关键</p>\n<h4 id=\"时间膨胀\">时间膨胀</h4>\n<p>物体在 <span class=\"math inline\"><em>S</em><sup>′</sup></span>\n系中静止，则有</p>\n<p><span\nclass=\"math display\"><em>Δ</em><em>t</em> = <em>γ</em><em>Δ</em><em>t</em><sup>′</sup></span></p>\n<p>在 <span class=\"math inline\"><em>S</em><sup>′</sup></span>\n系中同时不同地发生的两件事，<span class=\"math inline\"><em>S</em></span>\n系中不同时发生，时间间隔为 <span class=\"math inline\">$\\Delta t = \\gamma\n\\frac{u \\Delta x'}{c^2}$</span></p>\n<h4 id=\"长度收缩\">长度收缩</h4>\n<p>设在 <span class=\"math inline\"><em>S</em><sup>′</sup></span>\n系中静止的物体的本征长度为 <span\nclass=\"math inline\"><em>L</em><sup>′</sup></span>，在 <span\nclass=\"math inline\"><em>S</em></span> 系中测得的长度 <span\nclass=\"math inline\"><em>L</em></span> 为</p>\n<p><span class=\"math display\">$$\nL = \\frac{L'}{\\gamma} = L' \\sqrt{1-\\frac{u^2}{c^2}}\n$$</span></p>\n<blockquote>\n<p><strong>注意：</strong></p>\n<p>在 <span class=\"math inline\"><em>S</em></span> 系测量则需要在 <span\nclass=\"math inline\"><em>S</em></span>\n系中同时确认两个点的空间坐标，<span\nclass=\"math inline\"><em>Δ</em><em>t</em> = 0</span></p>\n</blockquote>\n<h3 id=\"洛伦兹速度变换\">洛伦兹速度变换</h3>\n<ul>\n<li>正变换</li>\n</ul>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  v_x' = \\frac{v_x - u}{1-\\frac{uv_x}{c^2}}\\\\\n  v_y' = \\frac{v_y}{\\gamma(1-\\frac{uv_x}{c^2})} =\n\\frac{v_y\\sqrt{1-\\frac{u^2}{c^2}}}{\\left(1-\\frac{uv_x}{c^2}\\right)}\\\\\n  v_z' = \\frac{v_z}{\\gamma(1-\\frac{uv_x}{c^2})} =\n\\frac{v_z\\sqrt{1-\\frac{u^2}{c^2}}}{\\left(1-\\frac{uv_x}{c^2}\\right)}\n\\end{cases}\n$$</span></p>\n<ul>\n<li>逆变换</li>\n</ul>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  v_x = \\frac{v_x' + u}{1+\\frac{uv_x'}{c^2}}\\\\\n  v_y = \\frac{v_y'}{\\gamma(1+\\frac{uv_x'}{c^2})} =\n\\frac{v_y'\\sqrt{1-\\frac{u^2}{c^2}}}{\\left(1+\\frac{uv_x'}{c^2}\\right)}\\\\\n  v_z = \\frac{v_z'}{\\gamma(1+\\frac{uv_x'}{c^2})} =\n\\frac{v_z'\\sqrt{1-\\frac{u^2}{c^2}}}{\\left(1+\\frac{uv_x'}{c^2}\\right)}\n\\end{cases}\n$$</span></p>\n<h3 id=\"相对论中的质量和动量\">相对论中的质量和动量</h3>\n<p>由实验研究表明，物体的质量随着速率增大而增大，记 <span\nclass=\"math inline\"><em>m</em><sub>0</sub></span>\n为物体在静止时的质量，称为静质量，<span\nclass=\"math inline\"><em>m</em></span>\n为物体在运动时的质量，称为动质量，则有</p>\n<p><span class=\"math display\">$$\nm = \\frac{m_0}{\\sqrt{1-\\frac{v^2}{c^2}}}\n$$</span></p>\n<p>其动量为</p>\n<p><span class=\"math display\">$$\n\\vec{p} = m\\vec{v} = \\frac{m_0\\vec{v}}{\\sqrt{1-\\frac{v^2}{c^2}}}\n$$</span></p>\n<h3 id=\"相对论中的力学基本方程\">相对论中的力学基本方程</h3>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  &amp;\\vec{p} = m\\vec{u} =\n\\frac{m_0\\vec{u}}{\\sqrt{1-\\frac{u^2}{c^2}}}\\\\\n  &amp;\\vec{p} = \\vec{u} \\mathrm{d}m + m\\mathrm{d}\\vec{u}\\\\\n  &amp;\\vec{F}  = \\frac{\\mathrm{d}}{\\mathrm{d}t}\n\\left(\\frac{m_0\\vec{u}}{\\sqrt{1-\\frac{u^2}{c^2}}}\\right)\n\\end{aligned}\n$$</span></p>\n<h3 id=\"相对论中的能量\">相对论中的能量</h3>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  E_k = mc^2 - m_0c^2&amp;\\text{动能}\\\\\n  E_0 = m_0c^2&amp;\\text{静能}\\\\\n  E = mc^2 = E_0 +E_k&amp;\\text{总能量}\n\\end{cases}\n$$</span></p>\n<p>质能关系</p>\n<p><span\nclass=\"math display\"><em>Δ</em><em>E</em> = <em>Δ</em><em>m</em><em>c</em><sup>2</sup></span></p>\n<p>能量与动量之间的关系</p>\n<p><span class=\"math display\">$$\np = \\frac{E}{c}\n$$</span></p>\n<h2 id=\"振动力学\">振动力学</h2>\n<h3 id=\"简谐振动动力学\">简谐振动动力学</h3>\n<p>简谐运动定义：凡质点的运动遵从余弦（或正弦）规律时，其运动形式为简谐振动</p>\n<p>其运动方程为</p>\n<p><span\nclass=\"math display\"><em>x</em>(<em>t</em>) = <em>A</em>cos (<em>ω</em><em>t</em> + <em>φ</em>)</span></p>\n<p>简谐运动的动力学方程为</p>\n<p><span class=\"math display\">$$\n\\frac{\\mathrm{d}^2x}{\\mathrm{d}t^2} + \\omega^2 x = 0\n$$</span></p>\n<p>其中 <span class=\"math inline\">$\\omega =\n\\sqrt{\\frac{k}{m}}$</span>，<span class=\"math inline\"><em>k</em></span>\n为弹性系数，<span class=\"math inline\"><em>m</em></span> 为物体的质量</p>\n<h3 id=\"简谐振动运动的物理量\">简谐振动运动的物理量</h3>\n<h4 id=\"周期频率和角频率\">周期、频率和角频率</h4>\n<ul>\n<li><strong>角频率：</strong> <span class=\"math inline\">$\\omega\n=\\sqrt{\\frac{k}{m}} = \\frac{2\\pi}{T} = 2\\pi \\nu$</span></li>\n<li><strong>周期：</strong> <span class=\"math inline\">$T = \\frac{1}{\\nu}\n= \\frac{2\\pi}{\\omega} = 2\\pi\\sqrt{\\frac{m}{k}}$</span></li>\n</ul>\n<p>在 <span\nclass=\"math inline\"><em>x</em> = <em>A</em>cos (<em>ω</em><em>t</em> + <em>φ</em>)</span>\n中，<span class=\"math inline\"><em>A</em></span> 为振幅，<span\nclass=\"math inline\"><em>φ</em></span> 为初相位</p>\n<ul>\n<li><span class=\"math inline\">$v = \\frac{\\mathrm{d}x}{\\mathrm{d}t} =\n-A\\omega \\sin(\\omega t + \\varphi)$</span></li>\n<li><span\nclass=\"math inline\"><em>v</em><sub>0</sub> = −<em>A</em><em>ω</em>sin <em>φ</em></span></li>\n<li><span class=\"math inline\">$E = E_k + E_p = \\frac{1}{2}mv^2 +\n\\frac{1}{2}kx^2 = \\frac{1}{2}kA^2$</span></li>\n<li><span class=\"math inline\">$A = \\sqrt{x_0^2+\\frac{v_0^2}{\\omega^2}} =\n\\sqrt{\\frac{2E}{m\\omega^2}}$</span></li>\n</ul>\n<h4 id=\"相位\">相位</h4>\n<p><span\nclass=\"math display\"><em>x</em> = <em>A</em>cos (<em>ω</em><em>t</em> + <em>φ</em>)</span></p>\n<ul>\n<li><span class=\"math inline\">(<em>ω</em><em>t</em> + <em>φ</em>)</span>\n是 <span class=\"math inline\"><em>t</em></span> 时刻的相位</li>\n<li><span class=\"math inline\"><em>φ</em></span> 是 <span\nclass=\"math inline\"><em>t</em> = 0</span> 时刻的相位</li>\n<li><strong>相位差：</strong> <span\nclass=\"math inline\"><em>Δ</em><em>φ</em> = (<em>ω</em><sub>2</sub><em>t</em> + <em>φ</em><sub>2</sub>) − (<em>ω</em><sub>1</sub><em>t</em> = <em>φ</em><sub>1</sub>)</span>\n<ul>\n<li>相位差为 <span\nclass=\"math inline\">±2<em>k</em><em>π</em>(<em>k</em> = 0, 1, …)</span>\n时，两个简谐振动的相位相同</li>\n<li>相位差为 <span\nclass=\"math inline\">±(2<em>k</em> + 1)<em>π</em>(<em>k</em> = 0, 1, …)</span>\n时，两个简谐振动的相位相反</li>\n<li>若 <span\nclass=\"math inline\"><em>Δ</em><em>φ</em> = <em>φ</em><sub>−</sub><em>φ</em><sub>1</sub> &gt; 0</span>，则\n<span class=\"math inline\"><em>x</em><sub>2</sub></span> 比 <span\nclass=\"math inline\"><em>x</em><sub>1</sub></span> 较早到正最大，称 <span\nclass=\"math inline\"><em>x</em><sub>2</sub></span> 比 <span\nclass=\"math inline\"><em>x</em><sub>1</sub></span> 超前，或称 <span\nclass=\"math inline\"><em>x</em><sub>1</sub></span> 比 <span\nclass=\"math inline\"><em>x</em><sub>2</sub></span> 滞后\n<ul>\n<li>超前和落后以小于 <span class=\"math inline\"><em>π</em></span>\n的相位角来判断</li>\n</ul></li>\n</ul></li>\n</ul>\n<h4 id=\"振动状态和振动能量\">振动状态和振动能量</h4>\n<h5 id=\"振动速度\">振动速度</h5>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  v = \\frac{\\mathrm{d}x}{\\mathrm{d}t} &amp;= -A\\omega \\sin(\\omega t +\n\\varphi)\\\\\n  &amp;= -v_m \\cos(\\omega t + \\varphi + \\frac{\\pi}{2})\\\\\n\\end{aligned}\n$$</span></p>\n<p>其中 <span\nclass=\"math inline\"><em>v</em><sub><em>m</em></sub> = <em>A</em><em>ω</em></span>\n称为速度振幅</p>\n<h5 id=\"振动加速度\">振动加速度</h5>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  a = \\frac{\\mathrm{d}^2x}{\\mathrm{d}t^2} &amp;= -A\\omega^2 \\cos(\\omega\nt + \\varphi)\\\\\n  &amp;= -a_m \\sin(\\omega t + \\varphi + \\frac{\\pi}{2})\\\\\n\\end{aligned}\n$$</span></p>\n<p>其中 <span\nclass=\"math inline\"><em>a</em><sub><em>m</em></sub> = <em>A</em><em>ω</em><sup>2</sup></span>\n称为加速度振幅</p>\n<h5 id=\"振动系统的能量\">振动系统的能量</h5>\n<ul>\n<li>振子动能</li>\n</ul>\n<p><span class=\"math display\">$$\nE_k = \\frac{1}{2}mv^2 = \\frac{1}{2}mA^2\\omega^2\\sin^2(\\omega t +\n\\varphi)\n$$</span></p>\n<ul>\n<li>振子势能</li>\n</ul>\n<p><span class=\"math display\">$$\nE_p = \\frac{1}{2}kx^2 = \\frac{1}{2}kA^2\\cos^2(\\omega t + \\varphi)\n$$</span></p>\n<ul>\n<li>振子总能量</li>\n</ul>\n<p><span class=\"math display\">$$\nE = E_k + E_p = \\frac{1}{2}kA^2\n$$</span></p>\n<h4 id=\"旋转振幅矢量\">旋转振幅矢量</h4>\n<p>旋转矢量 <span class=\"math inline\"><em>A⃗</em></span> 在 <span\nclass=\"math inline\"><em>x</em></span> 轴上的投影点的运动规律为</p>\n<p><span\nclass=\"math display\"><em>x</em> = <em>A</em>cos (<em>ω</em><em>t</em> + <em>φ</em>)</span></p>\n<h2 id=\"平衡态\">平衡态</h2>\n<h3 id=\"基本概念\">基本概念</h3>\n<ol type=\"1\">\n<li>热力学系统\n<ul>\n<li><strong>孤立系统：</strong> 与外界无能量和质量交换</li>\n<li><strong>封闭系统：</strong> 与外界有能量无质量交换</li>\n<li><strong>开放系统：</strong> 与外界由能量和质量交换</li>\n<li><strong>外界：</strong> 处于系统之外的物体或物体组</li>\n</ul></li>\n<li>系统状态的描述\n<ul>\n<li><strong>宏观参量：</strong> 可以直接测量的量，如压强 <span\nclass=\"math inline\"><em>p</em></span>、温度 <span\nclass=\"math inline\"><em>T</em></span>\n等由宏观参量描述的系统状态称为宏观状态</li>\n<li><strong>微观量：</strong>\n描述系统内微观粒子的物理量，一般无法直接测量，如分子的质量 <span\nclass=\"math inline\"><em>m</em></span>、直径 <span\nclass=\"math inline\"><em>d</em></span>、位置、速度 <span\nclass=\"math inline\"><em>v</em></span>、动量 <span\nclass=\"math inline\"><em>p</em></span>、能量 <span\nclass=\"math inline\"><em>ϵ</em></span> 等。</li>\n</ul></li>\n<li>平衡态\n<ul>\n<li>孤立系统达到的不随时间变化的状态称为热力学平衡态或平衡态</li>\n<li>内部能量和质量没有宏观流动，达到同一温度的定态叫平衡态</li>\n</ul></li>\n<li>定态\n<ul>\n<li>宏观性质不随时间变化的稳定状态称为定态</li>\n</ul></li>\n<li><strong>动态平衡：</strong>\n<strong>不受外界影响</strong>的条件下系统的宏观性质不随时间变化，此系统处在热力学平衡态</li>\n<li>涨落：\n<ul>\n<li>系统的宏观性质在平衡态下有微小的波动称为涨落</li>\n<li>涨落是系统内微观粒子运动的结果</li>\n</ul></li>\n</ol>\n<h3 id=\"热力学第一定律\">热力学第一定律</h3>\n<h4 id=\"温度\">温度</h4>\n<p>达到热平衡的系统具有共同的内部属性：温度</p>\n<h4 id=\"热力学第零定律\">热力学第零定律</h4>\n<p>两个系统同时与第三个系统热平衡时，这两个物体之间也必达到热平衡</p>\n<p>处于热平衡的多个系统具有相同的温度</p>\n<h4 id=\"理想气体温标和状态方程\">理想气体温标和状态方程</h4>\n<h5 id=\"理想气体\">理想气体</h5>\n<ul>\n<li>波义耳定律\n<ul>\n<li>温度不变时没压强和体积的乘积是一个常数</li>\n</ul></li>\n<li>理想气体\n<ul>\n<li>严格遵守波义耳定律的气体为理想气体</li>\n</ul></li>\n</ul>\n<h5 id=\"热力学温标\">热力学温标</h5>\n<p>理论上存在一个与测温质、测温属性无关的温标：热力学温标</p>\n<p>根据物理定律，温度为 <span\nclass=\"math inline\">0<sup>∘</sup><em>C</em></span> 是，每下降 <span\nclass=\"math inline\">1<sup>∘</sup><em>C</em></span>，体积减少 <span\nclass=\"math inline\">$\\frac{1}{273}$</span>，则当处于 <span\nclass=\"math inline\">−273.15<sup>∘</sup><em>C</em></span> 时，体积为\n<span class=\"math inline\">0</span>，即 <span\nclass=\"math inline\">0<em>K</em></span>，称为绝对零度</p>\n<p>摄氏温度 <span class=\"math inline\"><em>t</em></span> 与绝对温度 <span\nclass=\"math inline\"><em>T</em></span> 的关系</p>\n<p><span\nclass=\"math display\"><em>T</em> = <em>t</em> + 273.15</span></p>\n<h5 id=\"理想气体状态方程\">理想气体状态方程</h5>\n<p><span class=\"math display\">$$\nPV = nRT = \\frac{m}{M}RT\n$$</span></p>\n<p>其中 <span\nclass=\"math inline\"><em>R</em> = 8.314<em>J</em>/(<em>m</em><em>o</em><em>l</em> ⋅ <em>K</em>)</span>，<span\nclass=\"math inline\"><em>n</em></span> 为物质的量，<span\nclass=\"math inline\"><em>P</em></span> 为压强，<span\nclass=\"math inline\"><em>V</em></span> 为体积，<span\nclass=\"math inline\"><em>T</em></span> 为绝对温度</p>\n<h4 id=\"气体压强和温度的统计意义\">气体压强和温度的统计意义</h4>\n<h5 id=\"气体的特征\">气体的特征</h5>\n<ol type=\"1\">\n<li>无一定形状、体积，能充满整个容器空间</li>\n<li>气体分子间距远大于分子的线度\nL&gt;&gt;d，分子间引力很小，故气体具有高压缩性、高热膨胀率及高扩散性</li>\n<li>气体分子以高速向四方自由运动，具有高动能</li>\n<li>气体分子无规则热运动，频繁碰撞必产生压力</li>\n</ol>\n<h5 id=\"理想气体分子运动模型\">理想气体分子运动模型</h5>\n<ol type=\"1\">\n<li>大小不计</li>\n<li>弹性碰撞</li>\n<li>除碰撞外其他相互作用不计</li>\n<li>不记重力</li>\n</ol>\n<p>两条统计假设</p>\n<ol type=\"1\">\n<li></li>\n</ol>\n<p><span class=\"math display\">$$\nn_\\text{单位体积的分子数} = \\frac{\\Delta N}{\\Delta V}\n=\\frac{\\mathrm{d}N}{\\mathrm{d}V}\n=\\frac{N_\\text{总分子数}}{V_\\text{总容积}}\n$$</span></p>\n<ol start=\"2\" type=\"1\">\n<li></li>\n</ol>\n<p><span class=\"math display\">$$\n\\vec{u}_{x\\text{平均速度}} \\left(\\sum_i^N \\frac{u_{ix}}{N}\\right) =\n\\bar{u}_{y\\text{平均速度}} =\\bar{u}_{z\\text{平均速度}} =0\n$$</span></p>\n<h5 id=\"理想气体压强公式\">理想气体压强公式</h5>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  p = \\frac{1}{3}\\sum_imn_iu_i^2 = \\frac{1}{3}nm\\bar{u}^2\n\\end{aligned}\n$$</span></p>\n<h5 id=\"溫度的统计意义\">溫度的统计意义</h5>\n<p>气体的平均动能</p>\n<p><span class=\"math display\">$$\n\\bar{\\varepsilon}_t = \\frac{1}{2}m\\bar{u}^2 =\\frac{3}{2}kT\n$$</span></p>\n<p>对于系统而言，表示分子热运动的激烈程度</p>\n<h3 id=\"麦克斯韦速率分布\">麦克斯韦速率分布</h3>\n<ul>\n<li>标量形式</li>\n</ul>\n<p><span class=\"math display\">$$\nf(v)= 4\\pi v^2 \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{3}{2}}\ne^{-\\frac{mv^2}{2kT}}\n$$</span></p>\n<ul>\n<li>矢量形式</li>\n</ul>\n<p><span class=\"math display\">$$\nf(\\vec{v})= \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{3}{2}}\ne^{-\\frac{m\\vert \\vec{v}\\vert ^2}{2kT}}\n$$</span></p>\n<p>其在三个方向上的分量为</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  f(v_x) = \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{1}{2}}\ne^{-\\frac{m}{2kT}v_x^2}\\\\\n  f(v_y) = \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{1}{2}}\ne^{-\\frac{m}{2kT}v_y^2}\\\\\n  f(v_z) = \\left(\\frac{m}{2\\pi kT}\\right)^{\\frac{1}{2}}\ne^{-\\frac{m}{2kT}v_z^2}\n\\end{cases}\n$$</span></p>\n<p>可以推出</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\frac{\\mathrm{d}N_x}{N} = f(v_x)\\mathrm{d}v_x = \\left(\\frac{m}{2\\pi\nkT}\\right)^{\\frac{1}{2}} e^{-\\frac{m}{2kT}v_x^2}\\mathrm{d}v_x\\\\\n  \\frac{\\mathrm{d}N_y}{N} = f(v_y)\\mathrm{d}v_y = \\left(\\frac{m}{2\\pi\nkT}\\right)^{\\frac{1}{2}} e^{-\\frac{m}{2kT}v_y^2}\\mathrm{d}v_y\\\\\n  \\frac{\\mathrm{d}N_z}{N} = f(v_z)\\mathrm{d}v_z = \\left(\\frac{m}{2\\pi\nkT}\\right)^{\\frac{1}{2}} e^{-\\frac{m}{2kT}v_z^2}\\mathrm{d}v_z\n\\end{cases}\n$$</span></p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505221129410.png\"\nalt=\"Mexwell V\" />\n<figcaption aria-hidden=\"true\">Mexwell V</figcaption>\n</figure>\n<h3 id=\"麦克斯韦速率分布应用\">麦克斯韦速率分布应用</h3>\n<h4 id=\"最可几速率\">最可几速率</h4>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  &amp;\\frac{\\mathrm{d}f(v)}{\\mathrm{d}v} = 0\\\\\n  \\Rightarrow &amp;v_p=\\sqrt{\\frac{2kT}{m}} = \\sqrt{\\frac{2RT}{M}}\n\\end{aligned}\n$$</span></p>\n<h4 id=\"平均速率\">平均速率</h4>\n<p><span class=\"math display\">$$\n\\bar{v} = \\int_0^{\\infty} v f(v) \\mathrm{d}v = \\sqrt{\\frac{8kT}{\\pi m}}\n= \\sqrt{\\frac{8RT}{\\pi M}}\n$$</span></p>\n<h4 id=\"均方根速率\">均方根速率</h4>\n<p><span class=\"math display\">$$\n\\sqrt{\\bar{v}^2} = \\sqrt{\\int_0^{\\infty} v^2 f(v) \\mathrm{d}v} =\n\\sqrt{\\frac{3kT}{m}} = \\sqrt{\\frac{3RT}{M}}\n$$</span></p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505221314126.png\"\nalt=\"MaxwellDistributionApplication\" />\n<figcaption\naria-hidden=\"true\">MaxwellDistributionApplication</figcaption>\n</figure>\n<h4 id=\"一些应用\">一些应用</h4>\n<p>设箱体的分子密度为 <span\nclass=\"math inline\"><em>n</em></span>，求单位时间内单位面积碰撞到墙体的分子数</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  N&amp;=n\\bar{v}S\\\\\n  &amp;=nS\\int_0^\\infty f(v_x)v_x\\,\\mathrm{d}v_x\\\\\n  &amp;=\\boxed{\\frac{1}{4}nS\\bar{v}}\n\\end{aligned}\n$$</span></p>\n<h4 id=\"玻尔兹曼分布\">玻尔兹曼分布</h4>\n<p><span class=\"math display\">$$\n\\mathrm{d} N = n_0\ne^{-\\frac{\\varepsilon_p}{k_BT}}\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z\n$$</span></p>\n<p><span class=\"math display\">$$\nn_i = n_0 e^{-\\frac{E_i}{kT}}\n$$</span></p>\n<h6\nid=\"空气中气体分子在重力场中的密度分布\">空气中气体分子在重力场中的密度分布</h6>\n<h4 id=\"能量均分定理\">能量均分定理</h4>\n<h5 id=\"分子的自由度\">分子的自由度</h5>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">分子原子数</th>\n<th style=\"text-align: center;\">总自由度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">1</td>\n<td style=\"text-align: center;\">3</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">2</td>\n<td style=\"text-align: center;\">5</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">多</td>\n<td style=\"text-align: center;\">6</td>\n</tr>\n</tbody>\n</table>\n<p>对于多原子分子，其内能为</p>\n<p><span class=\"math display\">$$\nU = \\frac{f}{2}NkT = \\frac{f}{2} PV\n$$</span></p>\n<p>其中 <span class=\"math inline\"><em>f</em></span>\n为分子的自由度，<span class=\"math inline\"><em>N</em></span> 为分子数</p>\n<h2 id=\"热力学第一定律-1\">热力学第一定律</h2>\n<p><span\nclass=\"math display\"><em>Q</em> = <em>Δ</em><em>E</em> + <em>W</em></span></p>\n<h3 id=\"比热容\">比热容</h3>\n<h4 id=\"等容过程\">等容过程</h4>\n<p><span class=\"math display\">$$\n\\begin{align}\n  \\Delta V &amp; = 0\\\\\n  A &amp; = 0\\\\\n  \\Delta Q &amp;= \\Delta E\\\\\n  C_V &amp;= \\frac{\\Delta Q}{\\Delta T} = \\frac{\\mathrm{d}E}{\\mathrm{d}T}\n= \\frac{i}{2}R\n\\end{align}\n$$</span></p>\n<p><span class=\"math display\">$$\n\\Delta E = \\frac{i}{2}R\\Delta T = \\frac{i}{2}V\\Delta P\n$$</span></p>\n<h4 id=\"等温过程\">等温过程</h4>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  \\Delta T &amp; = 0\\\\\n  \\Delta E &amp; = 0\\\\\n  \\Delta Q &amp; = W \\\\\n  \\mathrm{d}Q &amp;= \\mathrm{d}A \\\\\n  &amp;= P\\mathrm{d}V \\\\\n  &amp;= nRT \\frac{1}{V}\\,\\mathrm{d}V\n\\end{aligned}\n$$</span></p>\n<p>则 <span class=\"math inline\">$Q = nRT \\ln\\frac{V_2}{V_1}$</span></p>\n<h4 id=\"等压过程\">等压过程</h4>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  \\mathrm{d}Q_P &amp;= \\mathrm{d}E + P\\mathrm{d}V\\\\\n  Q_P &amp;= \\Delta E + P\\Delta V\\\\\n  &amp;= \\frac{i}{2} nR\\Delta T + nR\\Delta V\\\\\n  &amp;= \\frac{i+2}{2} nR\\Delta T\\\\\n\\end{aligned}\n$$</span></p>\n<p><span class=\"math display\">$$\nC_P = \\frac{\\Delta Q}{\\Delta T} = \\frac{i+2}{2}R = C_V +R\n$$</span></p>\n<p>热容比</p>\n<p><span class=\"math display\">$$\n\\gamma = \\frac{C_P}{C_V} = 1+\\frac{R}{C_P} = \\frac{i+2}{i}\n$$</span></p>\n<h4 id=\"绝热过程\">绝热过程</h4>\n<p>绝热过程是指系统与外界没有热量交换的过程</p>\n<p>准静态绝热过程方程</p>\n<p><span\nclass=\"math display\"><em>P</em><em>V</em><sup><em>γ</em></sup> = const</span></p>\n"},{"title":"大学物理2笔记","math":true,"_content":"\n等我重修再说\n","source":"_posts/大学物理2笔记.md","raw":"---\ntitle: 大学物理2笔记\nmath: true\n---\n\n等我重修再说\n","slug":"大学物理2笔记","published":1,"date":"2025-09-11T11:36:20.595Z","updated":"2025-09-11T16:15:54.255Z","comments":1,"layout":"post","photos":[],"_id":"cmffo52nt00096xzdht2j4d24","content":"<p>等我重修再说</p>\n","excerpt":"","more":"<p>等我重修再说</p>\n"},{"title":"大学物理3笔记","math":true,"_content":"\n## 基本常数\n\n| 名称         | 符号        | 数值                  | 单位                        |\n| ------------ | ----------- | --------------------- | --------------------------- |\n| 斯特番常数   | $\\sigma$    | $5.67\\times 10^{-8}$  | $W\\cdot m^{-2}\\cdot K^{-4}$ |\n| 维恩常数     | $b$         | $2.898\\times 10^{-3}$ | $m\\cdot K$                  |\n| 玻尔兹曼常数 | $k$         | $1.38\\times 10^{-23}$ | $J\\cdot K^{-1}$             |\n| 普朗克常数   | $h$         | $6.63\\times 10^{-34}$ | $J\\cdot s$                  |\n| 康普顿波长   | $\\lambda_c$ | $0.02426$             | $\\text{Å}$                  |\n| 里德伯常数   | $R$         | $1.097\\times 10^{7}$  | $m^{-1}$                    |\n\n## 算符\n\n| 名称       | 表达式                                                         |\n| ---------- | -------------------------------------------------------------- |\n| 能量算符   | $\\hat{E} = i\\hbar\\frac{\\partial}{\\partial t}$                  |\n| 动量算符   | $\\hat{p} = -i\\hbar\\nabla$                                      |\n| 哈密顿算符 | $\\hat{H} = -\\frac{\\hbar^2}{2m}\\nabla ^2 + U(\\boldsymbol{r},t)$ |\n| 角动量算符 | $\\hat{L} = \\hat{r}\\times \\hat{p}$                              |\n\n## 量子物理基础\n\n### 黑体辐射\n\n#### 热辐射的基本概念\n\n- 所有物在有限体温度下都会发射电磁波，这种与温度有关的辐射称为热辐射 (heat radiation).\n- 热辐射是连续谱.\n- 基本性质：温度越高，发射的能量越大，电磁波的短波成分能量越大.\n- 平衡热辐射：热辐射是热平衡状态下的辐射.\n\n##### 热辐射基本参数\n\n**单色辐出度 $M_{\\lambda}(W/m^3)$**\n\n物体单位表面在单位时间内发出的波长在 $\\lambda$ 附近单位波长间隔内的电磁波的能量，用于描述物体辐射能量的能力\n\n$$\nM_{\\lambda}(T)=\\frac{\\mathrm{d}E_{\\lambda}}{\\mathrm{d}\\lambda}\n$$\n\n**辐出度 $M(T)(W/m^2)$**\n\n物体从单位面积上发射的所有波长的辐射总功率\n\n$$\nM(t)=\\int _0^{+\\infty}M_{\\lambda}(T)\\,\\mathrm{d}\\lambda\n$$\n\n**吸收比 $\\alpha(T)$ 和反射比 $r(T)$**\n\n- **吸收比**：辐射从外界入射到物体表面时，吸收的能量和入射的能量之比，是吸收能力的量度.\n\n$$\n\\alpha(T)=\\frac{E^\\text{吸收}}{E^\\text{入射}}\n$$\n\n- **反射比**：辐射从外界入射到物体表面时，反射的能量和入射的能量之比，是反射能力的量度.\n\n$$\nr(T)=\\frac{E^\\text{反射}}{E^\\text{入射}}\n$$\n\n**单色吸收比 $\\alpha(\\lambda,T)$ 和单色反射比 $r(\\lambda,T)**$\n\n- **单色吸收比**：当辐射从外界入射到物体表面时，吸收的波长从 $\\lambda$ 到 $\\lambda +\\mathrm{d}\\lambda$ 波长间隔内的能量 $E_\\lambda^\\text{吸收}\\mathrm{d}\\lambda$ 和入射的能量 $E_\\lambda^\\text{入射}\\mathrm{d}\\lambda$ 之比.\n\n$$\n\\alpha(\\lambda,T)=\\frac{E_\\lambda^\\text{吸收}}{E_\\lambda^\\text{入射}}\n$$\n\n- **单色反射比**：当辐射从外界入射到物体表面时，反射的波长从 $\\lambda$ 到 $\\lambda +\\mathrm{d}\\lambda$ 波长间隔内的能量 $E_\\lambda^\\text{反射}\\mathrm{d}\\lambda$ 和入射的能量 $E_\\lambda^\\text{入射}\\mathrm{d}\\lambda$ 之比.\n\n$$\nr(\\lambda,T)=\\frac{E_\\lambda^\\text{反射}}{E_\\lambda^\\text{入射}}\n$$\n\n对于不透明物体，有 $\\alpha(\\lambda,T)+r(\\lambda,T)=1$.\n\n##### 基尔霍夫定律\n\n一个好的发射体一定是个好的吸收体（黑白盘子实验）\n![黑白盘实验](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/%E9%BB%91%E7%99%BD%E7%9B%98%E5%AE%9E%E9%AA%8C.png)\n\n温度一定时物体在某波长处的单色辐出度与单色吸收比的比值与物体及物体表面的性质无关，即\n\n$$\n\\frac{M_1(\\lambda,T)}{\\alpha_1(\\lambda,T)} = \\frac{M_2(\\lambda,T)}{\\alpha_2(\\lambda,T)}=\\ldots=M_0(\\lambda,T).\n$$\n\n其中 $M_0(\\lambda,T)$ 是一个只与波长和温度有关，与物体材料、表面状态无关的函数，称为黑体辐射强度，是黑体的单色辐出度.\n\n##### 黑体\n\n能完全吸收各种波长电磁波而无反射的物体是黑体\n黑体是理想模型，可以建立只有小孔的空腔，小孔是黑体，空腔内的辐射是黑体辐射\n\n###### 黑体辐射的基本规律\n\n温度一定时，黑体辐射的强度与波长有关，存在一定的波长 $\\lambda _{\\max}$ 使得辐射强度最大，称为黑体辐射的主波长.\n![黑体辐射图](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/%E9%BB%91%E4%BD%93%E8%BE%90%E5%B0%84%E5%9B%BE.png)\n\n- **斯特番-玻尔兹曼定律(J. Stefan, L. Boltzmann)**\n  实验证明，黑体的总辐出度 $M_0(T)$ 与温度 $T$ 的四次方成正比\n\n$$\nM_0(T)=\\sigma T^4\n$$\n\n其中 $\\sigma = 5.67\\times 10^{-8} W\\cdot m^{-2}\\cdot K^{-4}$，称为斯特番常数.\n1879 年斯特番实验总结得到，1884 年玻尔兹曼理论证明.\n表明热辐射对温度的敏感性 $\\propto T^4$.\n\n- 维恩位移定律(W. Wien)\n  黑体辐射中单色辐出值的极值波长 $\\lambda_m$ 与黑体温度 $T$ 之积为常数\n\n$$\n\\lambda_mT=b\n$$\n\n其中 $b=2.898\\times 10^{-3}m\\cdot K$ ，为 Wien 常数.\n\n##### 普朗克的能量子假说和黑体辐射公式\n\n###### 维恩公式\n\n$$\nM_0(\\nu,T)=\\alpha\\nu^3e^{-\\beta/T}\n$$\n\n- 在高频段与实验符合得很好，但是在低频段明显偏离实验曲线\n\n###### 瑞利-金斯公式\n\n$$\nM_0(\\nu,T)=\\frac{2\\pi \\nu^2}{c^2}kT\n$$\n\n- 其中 $k=1.38\\times 10^{-23} J\\cdot K^{-1}$ ，为玻尔兹曼常数.\n- 低频段与实验符合得很好，但是在高频段明显偏离实验曲线.\n- 且当 $\\nu\\to\\infty$ 时，$M_0(\\nu,T)\\to \\infty$，称为紫外灾难.\n\n###### 普朗克公式\n\n普朗克以适用于高频段的维恩公式和适用于低频段的瑞利-金斯公式为基础，提出了**普朗克黑体辐射公式**，是一个半经验公式.\n\n$$\nM_0(\\nu,T)=\\frac{2\\pi\\nu^2}{c^2}\\frac{h\\nu}{e^{\\frac{h\\nu}{kT}}-1}\n$$\n\n- 其中 $h=6.63\\times 10^{-34}J\\cdot s$ 为普朗克常量.\n\n- 普朗克公式在整个频段都符合实验结果.\n\n- 普朗克认为：空腔内壁的分子、原子的振动可以看成是许多带电的简谐振子，这些简谐振子可以辐射和吸收能量，并与空腔内的辐射达到平衡。从空腔小孔辐射出的电磁波，就是由这些空腔内壁的简谐振子辐射出的。他假定对于频率为 $\\nu$ 的振子，振子能量不是连续的，而是分立的，它的取值是某一最小能量 $h$ 的整数倍，即**当振子吸收或放出能量时，以 $h\\nu$ 为单位.**\n- 我们计 $\\varepsilon =h\\nu$ ，称为**能量子（quanta of enmergy）**\n\n- 由普朗克公式可以推出其他热辐射公式\n\n  $$\n  M_0(\\nu,T)=\\frac{2\\pi\\nu^2}{c^2}\\frac{h\\nu}{e^{\\frac{h\\nu}{kT}}-1}\\ \\\n  \\left\\{\n    \\begin{aligned}\n    &\\text{积分} \\rightarrow M=\\sigma T^4, \\ \\ \\text{斯特番-玻尔兹曼定律}\\\\\n    &\\text{求导} \\rightarrow \\lambda_mT=b. \\ \\ \\text{维恩位移定律}\\\\\n    &\\text{低频极限} \\rightarrow M_0(\\nu,T)=\\frac{2\\pi\\nu^2}{c^2}kT, \\ \\ \\text{瑞利-金斯公式}\\\\\n    &\\text{高频极限} \\rightarrow M_0(\\nu,T)=\\alpha\\nu^3e^{-\\beta/T}, \\ \\ \\text{维恩公式}\n    \\end{aligned}\n  \\right.\n  $$\n\n### 光电效应（Photoelectric effect）\n\n#### 实验模型\n\n![实验装置](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250228160736.png)\n\n当光照在金属表面，电子从金属中脱出的现象，称为光电效应\n\n#### 基本参数\n\n#### 饱和电流\n\n实验表明，当入射光强度不变，加速电势差 $U$ 越大，光电流 $I$ 也越大，当电势差增大到一定值时，光电流达到饱和值，此时的光电流称为**饱和电流**。若改变入射光强，**饱和电流的大小与入射光强成正比**，说明从阴极逸出的电子数全部飞到阳极，单位时间从金属表面逸出的电子数与入射光强成正比.\n\n#### 遏制电压差\n\n改变阴极与阳极之间的电压，当电压增大到一定值时，光电流减小到零，此时的电压差称为**遏制电压差**。遏制电压差的大小与入射光的频率有关，与光强无关.\n光电子从表面逸出的最大初速度 $v_m$ 满足：\n\n$$\n\\frac{1}{2} m v_m^2 = eU_0\n$$\n\n#### 爱因斯坦的光量子论\n\n电子辐射由以光速 $c$ 运动的局限于空间某小范围的光量子（光子），即光子流组成\n光子的能量为 $\\varepsilon = h\\nu$ ，动量为 $p = \\frac{h}{\\lambda}$\n\n- 光电效应的基本方程\n\n$$\nh \\nu=\\frac{1}{2} m v_{\\mathrm{m}}^{2}+A\n$$\n\n其中 $\\frac{1}{2}mv_{\\mathrm{m}}^{2}$ 是光电子的最大初动能.\n\n**解释：**\n光照射金属时，电子吸收光子，能量增加，一部分用于克服金属脱出功，一部分增加电子的初动能\n\n#### 光的波粒二象性\n\n- 一些情况下，光的波动性表现得很明显，如干涉、衍射、偏振等现象.\n- 一些情况下，光的粒子性表现得很明显，如光电效应、康普顿散射等现象.\n\n这被称为光的波粒二象性\n\n- 光不是牛顿经典粒子，也不是康普顿的经典波\n\n基本关系式\n\n$$\n\\left\\{\n  \\begin{aligned}\n    &\\varepsilon = h\\nu \\quad \\text{粒子性}\\\\\n    &p = \\frac{\\varepsilon}{c}=\\frac{h}{\\lambda} \\quad \\text{波动性}\n  \\end{aligned}\n\\right.\n$$\n\n### 康普顿散射\n\n在散射的 X 射线中，存在与入射光波长相等的波，也存在波长比入射光波长大的波，这种现象称为**康普顿散射** .\n\n#### 特点\n\n$$\n\\Delta \\lambda = \\lambda' - \\lambda = \\lambda _{c} (1-\\cos\\theta)\n$$\n\n其中\n\n- $\\lambda_c =\\frac{h}{m_{0}c}= 0.02426 \\text{Å}$ 被称为康普顿波长. 当光子的波长等于 $\\lambda_c$ 时，其能量等于电子的能量 $m_{c}c^{2} =1.511 \\text{MeV}$ .\n- $\\theta$ 为散射角.\n\n1. 波长改变量随散射角 $\\theta$ 的增大而增大\n2. 新成分的相对强度随散射角 $\\theta$ 的增大而增大\n3. 同一个散射角下，所有散射物质的波长差相等\n4. 随着原子序数的增加，原波长成分的相对强度增大，即对对于轻元素康普顿散射更为明显.\n\n其中 3、4 是由吴有训发现的\n\n#### 推导\n\n使用动量守恒和能量守恒进行推导（X 射线光子与静止的自由电子的碰撞）\n\n![康普顿散射推导](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250302131054.png)\n\n由能量守恒：\n\n$$\n\\begin{equation}\n  h\\nu + m_{e}c^{2} = h\\nu' +mc^{2}\n\\end{equation}\n$$\n\n其中 $m=\\frac{m_{e}}{\\sqrt{1-\\frac{v^2}{c^2}}}$\n\n由 $x$ 方向上的动量守恒\n\n$$\n\\begin{equation}\n  \\frac{h\\nu _0}{c} = \\frac{h\\nu}{c} \\cos{\\theta} + mv\\cos{\\varphi}\n\\end{equation}\n$$\n\n由 $y$ 方向上的动量守恒\n\n$$\n\\begin{equation}\n  0 = \\frac{h\\nu}{c} \\sin{\\theta} - mv\\sin{\\varphi}\n\\end{equation}\n$$\n\n解方程组即可得到康普顿散射的公式\n\n$$\n\\Delta \\lambda = \\lambda _{0} -\\lambda =\\frac{h}{m_{e}c} (1-\\cos{\\theta})\n$$\n\n### 波尔氢原子理论\n\n#### 原子模型的发展\n\n1. 汤姆逊的面包夹葡萄干模型\n2. 卢瑟福的 $\\alpha$ 粒子散射实验和原子的核结构模型\n\n#### 氢原子光谱\n\n##### 公式\n\n###### 里德伯公式\n\n$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{m^{2}}-\\frac{1}{n^{2}}\\right) \\quad(m=1,2,3,\\cdots;n=m+1,m+2,m+3,\\cdots)\n$$\n\n其中：\n\n- $\\widetilde{\\nu} = \\frac{1}{\\lambda}$ 为波长的倒数，即波数\n- $R=1.097\\times 10^{7}m^{-1}$ 为里德伯常数\n\n###### 赖曼系（ $m=1$ ，紫外区）\n\n$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{1^{2}}-\\frac{1}{n^{2}}\\right) \\quad(n=2,3,4,\\cdots)\n$$\n\n###### 巴尔末系（ $m=2$ ）\n\n$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{2^{2}}-\\frac{1}{n^{2}}\\right) \\quad(n=3,4,5,\\cdots)\n$$\n\n###### 帕邢系（ $m=3$ ，红外区）\n\n$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{3^{2}}-\\frac{1}{n^{2}}\\right) \\quad(n=4,5,6,\\cdots)\n$$\n\n###### 布拉开系 （ $m=4$ ，近红外区）\n\n$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{4^{2}}-\\frac{1}{n^{2}}\\right) \\quad(n=5,6,7,\\cdots)\n$$\n\n###### 普丰德系（ $m=5$ ，远红外区）\n\n$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{5^{2}}-\\frac{1}{n^{2}}\\right) \\quad(n=6,7,8,\\cdots)\n$$\n\n###### 汉弗莱系 （ $m=6$ ，远红外区）\n\n$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{6^{2}}-\\frac{1}{n^{2}}\\right) \\quad(n=7,8,9,\\cdots)\n$$\n\n##### 波尔的氢原子模型\n\n##### 波尔假设\n\n1. 原子中的电子只能在一些分离的轨道上运行，在每一个轨道上运动的电子处于不稳定的能量状态（定态 $EW_{n}$ ），不向外辐射能量\n2. **频率条件：** 当电子从一个定态跃迁另一个定态时，发射或吸收一个光子， $h\\nu\\_{nm}=\\vert E_n-E_m\\vert $\n3. **结论：**\n\n   $$\n   \\nu=\\frac{E_{n}-E_{m}}{h}=\\frac{m e^{4}}{8 \\varepsilon _{0}^{2} h^{3}}\\left(\\frac{1}{m^{2}}-\\frac{1}{n^{2}}\\right)\n   $$\n\n##### 波尔角动量量子化条件\n\n$$\nL=n \\frac{h}{2 \\pi}=n \\hbar,n=1,2,3,\\cdots\n$$\n\n其中， $n$ 为量子数， $\\hbar=\\frac{h}{2\\pi}$ 为约化普朗克常数.\n**定量计算：**\n由电子的向心力和轨道角动量的量子化得到\n\n$$\n\\left\\{\n  \\begin{aligned}\n    &m\\frac{v^{2}}{r}=\\frac{1}{4\\pi \\varepsilon _{0}}\\cdot \\frac{e^2}{r^2}\\\\\n    &L=mvr=n\\hbar\n  \\end{aligned}\n\\right.\n$$\n\n解得：\n\n$$\n\\left\\{\n  \\begin{aligned}\n    &r_n=n^2\\frac{4\\pi \\varepsilon _{0} \\hbar^{2}}{m e^{2}}=n^2r_1\\\\\n    &v_n=\\frac{e^{2}}{4\\pi \\varepsilon _{0} n \\hbar}=\\alpha \\frac{c}{n}\n  \\end{aligned}\n\\right.\n$$\n\n其中 $r_1 = \\frac{4\\pi \\varepsilon _{0} \\hbar^{2}}{m e^{2}} = 0.529\\text{Å}$ 为氢原子中电子的最小轨道\n\n**轨道能量：**\n\n$$\nE_n =\\frac{1}{2}mv_n^2 + (-\\frac{1}{4\\pi \\varepsilon _0}\\cdot \\frac{e^2}{r_n^2}) = -\\frac{me^4}{8\\varepsilon_0^2h^2n^2}=-\\frac{1}{n^2}E_1\n$$\n\n其中 $E_1 = 13.6eV$ 为氢原子基态能量\n\n##### 波尔的对应原理\n\n当 $n\\rightarrow +\\infty$ 时，$r_n \\rightarrow 0$ ，$E_n \\rightarrow 0$ ，$\\displaystyle \\Delta E = E_n - E_{n+1} = \\frac{me^4}{4 \\varepsilon _0h^2n^3}\\rightarrow 0$ ，即能级间距趋于零，能级连续，形成连续谱.\n\n## 量子动力学入门\n\n量子力学的两条路线\n\n1. 波动力学 普朗克、爱因斯坦、德布罗意、薛定谔\n2. 矩阵力学 普朗克、波尔、海森堡\n\n- 最后由玻恩给出统计解释\n- 波动力学和矩阵力学完全等价\n\n### 物质波\n\n#### 德布罗意假说\n\n德布罗意假设：实物具有波粒二象性\n\n| 量  | 粒子性 | 波动性              |\n| --- | ------ | ------------------- |\n| $E$ | $mc^2$ | $h\\nu$              |\n| $p$ | $mv$   | $\\frac{h}{\\lambda}$ |\n\n#### 德布罗意原子稳定性驻波思想\n\n原子中的电子在原子核库仑场中运动表现得波动性具有驻波得特征，驻波的稳定性使得电子不会坠落到原子核内\n\n##### 能量的量子化\n\n- $\\lambda = \\frac{2L}{n}$\n- $p=\\frac{h}{2L}n$\n- $E = \\frac{p^2}{2m} = \\frac{h^2}{8mL^2}n^2$\n\n##### 物质波的概念对波尔轨道角动量量子化条件的解释\n\n德布罗意认为电子在经典的圆轨道上运动，形成一个环形驻波\n\n![电子驻波](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250308170617.png)\n\n电子绕行原子一周，圆周长应等于波长的整数倍\n\n$$\n2\\pi r = n\\lambda\n$$\n\n$$\nL = rmv = \\frac{n\\lambda}{2\\pi} \\cdot \\frac{h}{\\lambda} = n\\hbar\n$$\n\n#### 物质波的实验验证\n\n![物质波的实验验证](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250308171040.png)\n\n##### 布拉格公式\n\n![布拉格公式推导](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503151817449.png)\n\n$$\n\\delta = 2d\\sin\\theta = n\\lambda \\quad (n=1,2,3,\\cdots)\n$$\n\n#### 微观粒子波动性的应用\n\n- 显微镜使用电子波提大大提高了分辨率\n\n### 波函数的统计解释\n\n#### 对电子是什么的两种经典观点\n\n1. 电子是波包\n   - 由两种不同频率的波合成一个波包\n   - 这种观点夸大了波动性，忽略了粒子性\n     1. 不同频率波在媒质中传播速度不同，波包会逐步扩展而消失，但是实际粒子并没有消失 说明波包是电子的某种实际结果\n     2. 在媒质界面上一部分反射，一部分折射，但实际例子或整个反射，或整个折射\n2. 经典粒子\n   - 粒子是基本的，波动性源于粒子与粒子的相互作用，或者粒子与狭缝周围原子的相互作用。\n   - 这种观点夸大了粒子性，抹杀了波动性\n     1. 电子的双缝衍射实验表明电子具有波动性\n     2. 电子的波动性并不是很多电子在空间聚集在一起时的相互作用的结果，而是单个电子就具有波动性，是电子自己和自己的干涉\n\n#### 对波函数的统计解释\n\n1926 年，玻恩提出了对波函数 $\\Psi(\\boldsymbol{r},t)$ 的统计解释，将实物粒子的波动性和粒子性有机地结合在一起。\n\n##### 对亮度的解释\n\n1. 波的观点\n   亮度是该点德布罗意波强度的大小\n2. 粒子的观点\n   亮度与该点附近出现的感光点的数目成正比，即与该点附近电子的数目成正比，即与该点附近电子的概率成正比\n\n##### 玻恩对波函数的统计解释\n\n波函数 $\\Psi$ 是描述粒子在空间概率分布的**概率振幅**，其模的平方 $\\vert \\Psi(\\boldsymbol{r},t)\\vert ^2 = \\Psi(\\boldsymbol{r},t) ^{*} \\Psi(\\boldsymbol{r},t)$ 表示 $t$ 时刻，在坐标 $\\boldsymbol{r}$ 附近单位体积中发现一个粒子的概率，被称为**概率密度**\n\n- 目前对波函数最好的解释是概率波\n- $t$ 时刻，一个粒子处于 $x\\rightarrow x+\\mathrm{d}x$ ，$y\\rightarrow y+\\mathrm{d}y$ ，$z\\rightarrow z+\\mathrm{d}z$ 的概率为 $\\vert \\Psi(x,y,z,t)\\vert ^2\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z$，记 $\\rho(x,y,z,t)=\\vert \\Psi(x,y,z,t)\\vert ^2$ 为概率密度.\n- 在空间 $\\Omega$ 中发现粒子的概率为 $\\displaystyle \\int_{\\Omega}\\rho(x,y,z,t) \\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z$\n\n#### 波函数满足的条件\n\n1. 单值性\n   - 在空间的任何地方，概率密度只能有一个，所以一般波函数在任何地方都是单值的；\n2. 有限性\n   - 粒子必然在空间的某处出现，概率综合为 1，所以在空间的任何有限体积元 $\\mathrm{d}V$ 中，概率密度 $\\rho(x,y,z,t)$ 有限；\n   - **归一化条件**：$\\displaystyle \\int_\\Omega \\vert \\Psi(\\boldsymbol{r},t)\\vert ^{2}\\,\\mathrm{d} V =1$ ，其中 $\\Omega$ 为全空间；\n   - 归一化条件并不能排除在某些孤立奇点上 $\\vert \\Psi(\\boldsymbol{r},t)\\vert ^2 \\rightarrow \\infty$\n3. 连续性\n   - 波函数一阶导数连续（即使在势能函数有限大小间断点处）\n\n### 不确定度关系\n\n#### 形式 1（位置-动量不确定关系）\n\n当粒子处在 $x$ 方向的一个有限范围 $\\Delta x$ 内时，其动量 $p_x$ 的有一个不完全确定的数值范围 $\\Delta p_x$ ，两者的乘积满足：\n\n$$\n\\Delta x \\Delta p \\geq \\frac{\\hbar}{2}\n$$\n\n若记 $k=\\frac{2\\pi}{\\lambda}$ ，则\n\n$$\n\\Delta x \\Delta k \\geq \\frac{1}{2}\n$$\n\n- **含义**：微观粒子的位置和动量不能同时准确地测定\n- 规律\n  1. 当 $\\Delta x$ 越小，$\\Delta p$ 越大\n  2. 当 $\\Delta p$ 越小，$\\Delta x$ 越大\n\n电子的单缝衍射为例\n\n- 进入单缝之前的 $\\Delta x$ 趋向无穷大\n\n#### 形式 2\n\n若粒子在能量状态 $E$ 附近停留时间 $\\Delta t$ ，则其能量 $E$ 有一个不完全确定的数值范围 $\\Delta E$ ，两者的乘积满足：\n\n$$\n\\Delta t \\Delta E \\geq \\frac{\\hbar}{2}\n$$\n\n只有当粒子的停留时间为无穷大（定态）时，其能量才是确定的（$\\Delta E = 0$ ）\n\n#### 电子单缝衍射的结论\n\n![电子单缝衍射实验示意图](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281611015.png)\n\n- 电子通过单缝之后，动量在 $x$ 方向上的分量 $P_x$ 的大小为\n\n$$\n- p \\cdot \\sin{\\theta_1} \\leq p_x = p \\cdot \\sin{\\theta} \\leq p \\cdot \\sin{\\theta_1}\n$$\n\n- 电子通过单缝后，动量在 $x$ 方向分量的不确定量为\n\n$$\n\\Delta p_x = 2p \\cdot \\sin{\\theta_1} =\\frac{2p\\lambda}{\\Delta x}\n$$\n\n带入德布罗意关系 $p\\lambda =h$，得到\n\n$$\n\\Delta x \\cdot \\Delta p_x =2h\n$$\n\n这里的讨论只反映不确定度关系的实质，并不表示准确的量值关系\n\n## 量子力学\n\n### 薛定谔方程\n\n- 建立的是描写波函数随时间变化的方程，它必须是波函数应满足的含有对时间微商的微分方程\n- 是一个假设，无法被推导出来\n\n#### 满足的条件\n\n1. 方程是线性的\n   如果 $\\Psi_1$ 和 $\\Psi_2$ 是薛定谔方程的解，则 $a\\Psi_1 + b\\Psi_2$ 也是薛定谔方程的解\n   这是由态叠加原理决定的\n2. 方程的系数不应当包含状态参量，如动量、能量等\n   否则这个方程只能被粒子的部分状态满足\n\n#### 自由粒子的薛定谔方程\n\n动量为 $p$ 、质量为 $m$ 、能量为 $E$ 的粒子在 $x$ 方向上自由运动的薛定谔方程为\n\n$$\n\\Psi \\left(x,t\\right) =\\Psi _0 e^{-\\frac{i}{\\hbar}\\left(Et-px\\right)}\n$$\n\n**对时间求偏导**\n\n$$\n\\frac{\\partial \\Psi (x,t)}{\\partial t} = -\\frac{i}{\\hbar}E\\Psi (x,t)\n$$\n\n左右两边同乘 $i\\hbar$\n\n$$\ni\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} = E\\Psi (x,t)\n$$\n\n我们记算符 $\\hat{E}$ 为能量算符\n\n$$\n\\boxed{\\hat{E} \\equiv i\\hbar \\frac{\\partial}{\\partial t}}\n$$\n\n则\n\n$$\n\\hat{E} \\Psi (x,t) = E\\Psi (x,t)\n$$\n\n**对 $x$ 求偏导**\n\n$$\n\\frac{\\partial \\Psi (x,t)}{\\partial x} = \\frac{i}{\\hbar}p_x\\Psi (x,t)\n$$\n\n左右两边同乘 $-i\\hbar$\n\n$$\n-i\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial x} = p_x\\Psi (x,t)\n$$\n\n我们记算符 $\\hat{p_x}$ 为动量算符\n\n$$\n\\boxed{\\hat{p_x} \\equiv -i\\hbar \\frac{\\partial}{\\partial x}}\n$$\n\n则\n\n$$\n\\hat{p_x} \\Psi (x,t) = p_x\\Psi (x,t)\n$$\n\n**对 $x$ 做二次偏导**\n\n$$\n\\frac{\\partial^2 \\Psi (x,t)}{\\partial x^2} = -\\frac{p_x^2}{\\hbar^2}\\Psi (x,t)\n$$\n\n**综合考虑**\n\n$$\n\\left\\{\n  \\begin{aligned}\n    &i\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} = E\\Psi (x,t)\\\\\n    &\\frac{\\partial ^2 \\Psi (x,t)}{\\partial x^2} = -\\frac{p_x^2}{\\hbar^2}\\Psi (x,t)\n    \\end{aligned}\n\\right.\n$$\n\n由 $E = \\frac{p_x^2}{2m}$，有\n\n$$\ni\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} = E\\Psi (x,t) = -\\frac{p_x^2}{2m}\\Psi (x,t)=-\\frac{\\hbar^2}{2m}\\frac{\\partial^2 \\Psi (x,t)}{\\partial x^2}\n$$\n\n**即**\n\n$$\n\\boxed{i\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} = -\\frac{\\hbar^2}{2m}\\frac{\\partial^2 \\Psi (x,t)}{\\partial x^2}}\n$$\n\n这就是自由粒子的薛定谔方程\n\n#### 薛定谔方程的一般形式\n\n将自由粒子运动算符推广到非自由粒子运动，粒子所处的势场为 $U(x,t)$\n对于保守系统，其能量等于**哈密顿量**\n\n$$\nE = H = \\frac{p^2}{2m} + U(x,t)\n$$\n\n哈密顿量算符化，称为**哈密顿算符**\n\n$$\n\\hat{H} = \\frac{\\hat p_x^2}{2m} + U(x,t)=\\frac{-\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} + U(x,t)\n$$\n\n**薛定谔方程**：对于保守系统，其能量算符作用在波函数上，等于哈密顿算符作用在波函数上\n\n$$\n\\boxed{\\hat{E} \\Psi (x,t) = \\hat{H} \\Psi (x,t)}\n$$\n\n将其展开\n\n$$\n\\boxed{i\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} = \\left(\\frac{-\\hbar^2}{2m}\\frac{\\partial ^2}{\\partial x^2} + U(x,t)\\right) \\Psi (x,t)}\n$$\n\n推广到三维势场\n\n$$\n\\boxed{i\\hbar \\frac{\\partial \\Psi (\\boldsymbol{r},t)}{\\partial t} = \\left(-\\frac{\\hbar^2}{2m}\\nabla^2 + U(\\boldsymbol{r},t)\\right) \\Psi (\\boldsymbol{r},t)}\n$$\n\n#### 定态薛定谔方程\n\n若微观粒子在稳定的势场中，则其势能函数 $U$ 与时间无关，称这类问题为定态问题\n\n$$\n\\hat{H} = -\\frac{\\hbar^2}{2m}\\nabla^2 + U(\\boldsymbol{r})\n$$\n\n$$\n\\\ni\\hbar \\frac{\\partial}{\\partial t}\\Psi (\\boldsymbol{r},t) = \\hat{H} \\Psi (\\boldsymbol{r},t)\n$$\n\n此时哈密顿算符与时间无关，薛定谔方程可以用分离变量法求解，波函数 $\\Psi$ 分解为空间函数和时间函数的乘积\n\n设 $\\Psi (\\boldsymbol{r},t) = \\Phi(\\boldsymbol{r})T(t)$\n\n$$\ni\\hbar \\frac{\\mathrm{d} T(t)}{\\mathrm{d} t}\\Phi(\\boldsymbol{r}) = \\left[\\hat{H} \\Phi(\\boldsymbol{r})\\right] T(t)\n$$\n\n$$\ni\\hbar \\frac{1}{T(t)}\\mathrm{d} t = \\frac{1}{\\Phi(\\boldsymbol{r})}\\hat{H} \\Phi(\\boldsymbol{r}) = const = E\n$$\n\n其中 $E$ 为本征值，$\\Phi$ 为本征函数\n得到分别只含有变量 $t$ 和 $\\boldsymbol{r}$ 的两个方程\n\n$$\n\\left\\{\n\\begin{aligned}\n  &i \\hbar \\frac{\\mathrm{d} T(t)}{\\mathrm{d} t} = ET(t)  &&\\text{(1)}\\\\\n  &\\hat{H} \\Phi(\\boldsymbol{r}) = E\\Phi(\\boldsymbol{r})  &&\\text{(2)}\n\\end{aligned}\n\\right.\n$$\n\n方程(1)的解为\n\n$$\nT(t) = e^{-\\frac{i}{\\hbar}Et}\n$$\n\n方程(2)是关于变量 $x$、$y$、$z$ 的微分方程，称为**定态薛定谔方程**，又称为哈密顿算符的本征方程\n\n$$\n\\boxed{\\left[-\\frac{\\hbar^2}{2m}\\nabla^2 + U(x,y,z)\\right] \\Phi(x,y,z) = E\\Phi(x,y,z)}\n$$\n\n其解与外力场 $U$ 和边界条件有关\n波函数是两者的乘积\n\n$$\n\\boxed{\\Psi (\\boldsymbol{r},t) = \\Phi(\\boldsymbol{r})e^{-i\\frac{1}{\\hbar}Et}}\n$$\n\n- 粒子在空间中出现的几率密度与时间无关——**定态**\n\n$$\n\\vert\\Psi (\\boldsymbol{r},t)\\vert^2 =\\vert\\Phi(\\boldsymbol{r}) e^{-i\\frac{1}{\\hbar}Et}\\vert^2 = \\vert\\Phi(\\boldsymbol{r})\\vert^2\n$$\n\n#### 薛定谔方程的应用\n\n##### 一维无限深方势阱\n\n金属中的电子由于金属表面势能（能垒）的束缚而被限制在一个有限的空间范围内运动\n如果金属表面的能垒很高，可以将金属表面看成一个刚性的盒子。若只考虑一维运动，则其势能函数为\n\n$$\nU(x) =\n\\left\\{\n  \\begin{aligned}\n    &0 \\quad (0 \\leq x \\leq L)\\\\\n    &\\infty \\quad (x < 0 \\text{ or } x > L)\n  \\end{aligned}\n\\right.\n$$\n\n称为**一维无限深方势阱**\n\n![无限深方势阱](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504111721435.png)\n\n- 势阱内\n\n$$\n-\\frac{\\hbar^2}{2m}\\frac{\\mathrm{d}^2}{\\mathrm{d} x^2} \\Phi_i(x) = E\\Phi_i(x)\n$$\n\n令 $k =\\sqrt{\\frac{2mE}{\\hbar^2}}$，得\n\n$$\n\\frac{\\mathrm{d}^2\\Phi_i}{\\mathrm{d} x^2} + k^2\\Phi_i = 0\n$$\n\n其解为\n\n$$\n\\Phi_i(x)=C\\sin(kx+\\delta)\n$$\n\n其中 $C$ 和 $\\delta$ 为常数，由波函数的自然条件确定\n\n- 势阱外\n\n$$\n-\\frac{\\hbar^2}{2m}(\\frac{\\mathrm{d}^2}{\\mathrm{d}x^2}+\\infty)\\Phi_e(x) = E\\Phi_e(x)\n$$\n\n其解为\n\n$$\n\\Phi_e(x)=0\n$$\n\n- 波函数在肼壁上连续的条件为\n\n$$\n\\left\\{\n  \\begin{aligned}\n    &\\Phi_i(0) = \\Phi_e(0) \\\\\n    &\\Phi_i(L) = \\Phi_e(L) \\\\\n  \\end{aligned}\n\\right.\n$$\n\n由边界条件可得\n\n$$\n\\begin{cases}\n  \\Phi_i(0)= 0 && \\text{(1)}\\\\\n  \\Phi_i(L) = 0 && \\text{(2)}\n\\end{cases}\n$$\n\n由 $(1)$ 可得 $\\delta = 0$、\n\n由 $(2)$ 可得 $kL = n\\pi$，其中 $n\\in \\mathbb{N}^*$，即 $k = \\frac{n\\pi}{L}$\n\n$$\n\\Phi(x) =\\sqrt{\\frac{2}{L}}\\sin\\left(\\frac{n\\pi}{L}x\\right)\n$$\n\n- **粒子的能量:** $E = \\frac{\\hbar^2k^2}{2m} = \\frac{n^2\\pi^2\\hbar^2}{2mL^2}$，$n$ 为能量量子数\n  - 能量取分立值（能级），这是**能量量子化**的表现\n\n$$\n\\Delta E = E_{n+1} - E_n = \\frac{\\hbar^2}{2m}\\left(\\left(\\frac{(n+1)\\pi}{L}\\right)^2 - \\left(\\frac{n\\pi}{L}\\right)^2\\right) = (2n+1)\\frac{\\hbar^2\\pi^2}{2mL^2}\n$$\n\n- 当 $a\\uparrow$ 时 $\\Delta E \\downarrow$，并且当 $n \\rightarrow \\infty$ 时， $\\Delta E \\rightarrow 0$，即能级间隔趋于零，能级连续，形成连续谱\n- 最低能量（零点能）$E_1=\\frac{\\pi^2\\hbar^2}{amL^2}>0$，具有波动性\n- 在势阱中形成驻波\n\n$$\n\\Phi(x) =C\\sin\\left(\\frac{n\\pi}{L}x\\right)\n$$\n\n由归一化条件\n\n$$\n\\int_{-\\infty}^{+\\infty} \\vert \\Phi(x) \\vert^2\\,\\mathrm{d}x = \\int_{0}^{L} C^2\\sin^2\\left(\\frac{n\\pi}{L}x\\right)\\,\\mathrm{d}x = C^2 \\cdot \\frac{L}{2} = 1\n$$\n\n解得\n\n$$\nC = \\sqrt{\\frac{2}{L}}\n$$\n\n故定态波函数为\n\n$$\n\\Phi(x) =\n\\left\\{\n  \\begin{aligned}\n    &\\sqrt{\\frac{2}{L}}\\sin\\left(\\frac{n\\pi}{L}x\\right) && (0 \\leq x \\leq L)\\\\\n    &0 && (x < 0 \\text{ or } x > L)\n  \\end{aligned}\n\\right.\n$$\n\n###### 一维无线深方势阱中粒子的波函数和概率密度\n\n$$\n\\Phi (x,t) = \\sqrt{\\frac{2}{L}} \\sin\\left(\\frac{n\\pi}{L}x\\right), \\quad (0 \\leq x \\leq L)\n$$\n\n![波函数和概率密度](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504131458204.png)\n\n可以看出\n\n- 势阱中的粒子波函数为驻波\n- 基态 $n=1$ 除了 $x=0$ 和 $x=L$ 处为节点外，其余无节点\n- 第 $n$ 量子态有 $n-1$ 个 node\n\n###### 一维无限深势阱中粒子的波函数是正交归一的\n\n设不同能级的波函数为 $\\Phi_n(x)$ 和 $\\Phi_m(x)$\n\n- 正交性\n\n$$\n\\int_{-\\infty}^{+\\infty} \\Phi_n(x) \\Phi_m(x)\\,\\mathrm{d}x = \\int _{-\\infty }^{+\\infty }\\sqrt{\\frac{2}{L}}\\sin\\frac{m\\pi }{L} x\\cdot \\sqrt{\\frac{2}{L}}\\sin\\frac{n\\pi }{L}\\,\\mathrm{d} x=\\frac{1}{L}\\int _{0}^{L}\\left(\\cos\\frac{m-n}{L} -\\cos\\frac{m+n}{L}\\right)\\,\\mathrm{d} x=0\n$$\n\n- 归一性\n\n$$\n\\int_{-\\infty}^{+\\infty} \\Phi_n(x) \\Phi_n(x)\\,\\mathrm{d}x = \\int _{-\\infty }^{+\\infty }\\sqrt{\\frac{2}{L}}\\sin\\frac{n\\pi }{L} x\\cdot \\sqrt{\\frac{2}{L}}\\sin\\frac{n\\pi }{L}\\,\\mathrm{d} x=\\frac{1}{L}\\int _{0}^{L}\\left(\\cos 0 -\\cos\\frac{2n\\pi }{L}\\right)\\,\\mathrm{d} x=1\n$$\n\n##### 波尔对应原理\n\n- 在大量子数极限下，量子规律必须转化为经典规律，这也被称为**量子物理的对应原理**\n\n比如\n\n- 本征能量\n\n$$\nE = E_n = \\frac{\\hbar^2 \\pi^2 n^2}{2mL^2} = n^2 \\frac{h^2}{8mL^2}\n$$\n\n- 相邻能级的间隔为\n\n$$\n\\Delta E_n = (2n+1)\\frac{h^2}{8mL^2}\n$$\n\n- 相对能级间隔\n\n$$\n\\frac{\\Delta E_n}{E_n} = \\frac{2n+1}{n^2}\n$$\n\n- 当 $n\\rightarrow \\infty$ 时， $\\Delta E_n \\rightarrow 0$ ，即能级间隔趋于零，能级连续，形成连续谱\n\n粒子在势阱中的概率分布为\n\n$$\n\\rho(x) = \\vert \\Phi(x) \\vert^2 =\n\\left\\{\n  \\begin{aligned}\n    &\\frac{2}{L}\\sin^2(\\frac{n\\pi}{L}x) && (0 \\leq x \\leq L)\\\\\n    &0 && (x < 0 \\text{ or } x > L)\n  \\end{aligned}\n\\right.\n$$\n\n##### 德布罗意的驻波思想\n\n- 一个频率为 $\\nu$ 、波长 $\\lambda$ 沿 $x$ 方向传播的单色平面波的表达式为\n\n$$\n\\Psi(x,t) = \\Psi_0 e^{-i \\frac{2\\pi}{h}(Et -Px)}\n$$\n\n- 全波函数为\n\n$$\n\\begin{aligned}\n\\Psi ( x,t) =\\Phi ( x) e^{-\\frac{i}{\\hbar } Et} &=\\sqrt{\\frac{2}{L}} e^{-i\\frac{Et}{\\hbar }}\\sin\\frac{n\\pi }{L} x\\\\\n&=\\frac{1}{2i}\\sqrt{\\frac{2}{L}} e^{-i\\frac{Et}{\\hbar }}\\left( e^{i\\frac{n\\pi }{L} x} -e^{-i\\frac{n\\pi }{L} x}\\right)\\\\\n&=\\frac{1}{2i}\\sqrt{\\frac{2}{L}} e^{-i\\frac{Et}{\\hbar }}\\left( e^{i\\frac{p_{n}}{\\hbar }} -e^{-i\\frac{p_{n}}{\\hbar } x}\\right)\n\\end{aligned}\n$$\n\n可以将波函数视为频率相同、波长相同、传播方向相反的两单色平面波的叠加\n\n则由德布罗意的物质波理论，一个动量为 $p$、质量为 $m$、能量为 $E$ 的自由粒子，沿着 $x$ 轴运动的波函数为\n\n$$\n\\Psi ( x,t) =\\Psi _{0} e^{-\\frac{i}{\\hbar }( Et-px)}\n$$\n\n波函数也为频率相同、波长相同、传播方向相反的两单色平面波的叠加形成驻波\n\n- 势阱中粒子的动量和波长\n  - 动量：$p_n =\\sqrt{2mE_n} = \\pm\\frac{n\\hbar}{2L} = \\pm n \\frac{ h}{2L}$\n  - 波长：$\\lambda_n = \\frac{\\hbar}{p_n}=\\frac{2L}{n}$\n    说明势阱中粒子的每一个能量本征态正好对应德布罗意波的一个特征波长的驻波\n- 符合德布罗意的驻波理论\n\n##### 一维方势垒和隧穿效应\n\n![Tunel effect](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504181642705.png)\n\n设\n\n$$\nV(x)=\n\\begin{cases}\n    0, & x < x_1 \\quad \\text{or} \\quad x > x_2 \\\\\n    V_0, & x_1 < x < x_2\n\\end{cases}\n$$\n\n称为方势垒\n\n现有一能量为 $E$ 的粒子从左向右入射\n\n在经典力学中，若 $E < V_0$，则粒子无法穿过势垒，$E > V_0$ 时，粒子能够完全穿过势垒\n\n但是在量子力学中，粒子是一种物质波，情况完全不一样，需要通过求解薛定谔方程来确定\n\n$$\n\\frac{d^2\\psi(x)}{dx^2}=\\frac{2m}{\\hbar^2}(V_0-E)\\psi(x)\n$$\n\n在这里我们设 $V_0>E$，令 $k=\\sqrt{\\frac{2mE}{\\hbar^2}}$ 和 $k' = \\sqrt{\\frac{2m(V_0-E)}{\\hbar^2}}$\n\n则薛定谔方程可化为\n\n$$\n\\begin{cases}\n  \\frac{d^2\\psi_1(x)}{dx^2} = -k^2\\psi_1(x), & x < x_1 \\\\\n  \\frac{d^2\\psi_2(x)}{dx^2} = k'^2\\psi_2(x), & x_1 < x < x_2 \\\\\n  \\frac{d^2\\psi_3(x)}{dx^2} = -k^2\\psi_3(x), & x > x_2\n\\end{cases}\n$$\n\n解得\n\n$$\n\\begin{cases}\n  \\psi_1 = A e^{ikx} + A' e^{-ikx}, & x < x_1 \\\\\n  \\psi_2 = B e^{k'x} + B' e^{-k'x}, & x_1 < x < x_2 \\\\\n  \\psi_3 = C e^{ikx} , & x > x_2\n\\end{cases}\n$$\n\n由连续性（在这里我们令 $x_1=0$，$x_2=a$）\n\n$$\n\\begin{cases}\n  \\psi_1(0) = \\psi_2(0) \\rightarrow A + A' = B + B' \\\\\n  \\psi_1'(0) = \\psi_2'(0) \\rightarrow ik(A - A') = k' (B - B') \\\\\n  \\psi_2(a) = \\psi_3(a) \\rightarrow B e^{k'a} + B' e^{-k'a} = C e^{ika} \\\\\n  \\psi_2'(a) = \\psi_3'(a) \\rightarrow k' B e^{k'a} - k' B' e^{-k'a} = ikC e^{ika}\n\\end{cases}\n$$\n\n求解并经过计算得到\n\n- **反射系数：** $\\displaystyle R =\\frac{\\vert A'\\vert^2}{\\vert A\\vert^2} =\\frac{(k^2+k'^2)^2\\sinh^2(k'a)}{\\left(k^2+k'^2\\right)\\sinh^2(k'a) + 4k^2k'^2}$\n- **透射系数：** $\\displaystyle T =\\frac{\\vert C\\vert^2}{\\vert A\\vert^2} =\\frac{4k^2k'^2}{\\left(k^2+k'^2\\right)\\sinh^2(k'a) + 4k^2k'^2}$\n\n显然有 $\\boxed{T+R=1}$\n\n## 定态问题\n\n## 量子力学的基本假设\n\n### 波函数假设\n\n微观粒子的状态可以被一个波函数完全描述，从这个波函数可以得到体系的所有性质\n\n波函数一般满足连续性、有限性和单值性三个条件\n\n1. 物质波可以用一个随时间、空间变化的波函数 $\\Psi(\\boldsymbol{r},t)$ 来描述\n2. 自由粒子的波函数是单色平面波 $\\Psi(x,t) = \\Psi_0 e^{-i\\frac{2\\pi}{h}(Et - Px)} = \\Psi_0 e^{-i\\frac{1}{\\hbar}(Et - Px)}$\n3. 波恩：德布罗意波是描述粒子在空间概率分布的概率波\n   波函数的模的平方 $\\vert \\Psi(\\boldsymbol{r},t)\\vert^2$ 表示 $t$ 时刻，在坐标 $\\boldsymbol{r}$ 处粒子出现的概率密度\n4. 波函数满足**单值、有限、连续**的条件，称为**波函数的标准条件**\n5. **归一化条件：** 在整个空间中发现粒子的概率为 $1$，即 $\\displaystyle \\int_{\\Omega} \\vert \\Psi(\\boldsymbol{r},t)\\vert^2\\,\\mathrm{d}V = 1$，其中 $\\Omega$ 为全空间\n\n### 力学算符假设\n\n量子力学中的力学量用线性厄米（Hermite）算符表示。如果经典力学中有相关的力学量，则在量子力学中也有相应表示这个力学量的算符\n\n算符能将波函数变换为另一个波函数\n\n- 动量算符 $\\hat{p} = -i\\hbar \\nabla$\n- 位置算符 $\\hat{\\boldsymbol{r}} = \\boldsymbol{r}$\n- 能量算符 $\\hat{H} = \\frac{\\hat{p}^2}{2m} + U(\\boldsymbol{r}) = -\\frac{\\hbar ^2}{2m}\\nabla ^2 + U(\\boldsymbol{r})$\n- 角动量算符 $\\hat{\\boldsymbol{L}} =\\hat{\\boldsymbol{r}} \\times \\hat{\\boldsymbol{p}} =\\left\\vert\\begin{smallmatrix}\\boldsymbol{i} & \\boldsymbol{j} & \\boldsymbol{k} \\newline x & y & z \\newline p_x & p_y & p_z \\end{smallmatrix}\\right\\vert$\n  - $\\hat{L}_x = y\\hat{p}_z-z\\hat{p}_y$\n  - $\\hat{L}_y = z\\hat{p}_x-x\\hat{p}_z$\n  - $\\hat{L}_z = x\\hat{p}_y-y\\hat{p}_x$\n\n#### 厄米（Hermite）算符\n\n$\\hat{A}$ 是厄米算符的充分必要条件是\n\n$$\n\\int \\Psi^* \\hat{A} \\varphi \\,\\mathrm{d}V = \\int \\Psi \\left(\\hat{A} \\Psi^* \\right) \\,\\mathrm{d}V\n$$\n\n其中 $\\Psi$ 和 $\\varphi$ 是在无穷远处趋向 $0$ 的任意函数\n\n- 如果 $\\hat{A}$ 和 $\\hat{B}$ 都是厄米算符，则 $\\hat{A}\\hat{B} + \\hat{B}\\hat{A}$ 也是厄米算符\n\n**证明：**\n\n$$\n\\begin{aligned}\n&\\int _{-\\infty }^{+\\infty }\\Psi ^{*}\\left(\\hat{A}\\hat{B} + \\hat{B}\\hat{A}\\right)\\varphi\\,\\mathrm{d}x \\\\\n= &\\int _{-\\infty }^{+\\infty }\\Psi ^{*}\\hat{A}(\\hat{B}\\varphi)\\,\\mathrm{d}x + \\int _{-\\infty }^{+\\infty }\\Psi ^{*}\\hat{B}(\\hat{A}\\varphi)\\,\\mathrm{d}x\\\\\n= &\\int _{-\\infty }^{+\\infty }(\\hat{A}\\Psi) ^{*}(\\hat{B}\\varphi)\\,\\mathrm{d}x + \\int _{-\\infty }^{+\\infty }(\\hat{B}\\Psi) ^{*}(\\hat{A}\\varphi)\\,\\mathrm{d}x\\\\\n= &\\int _{-\\infty}^{+\\infty}\\left[\\varphi\\left(\\hat{B}\\hat{A}\\Psi\\right)^*+\\varphi\\left(\\hat{A}\\hat{B}\\Psi\\right)^*\\right]\\\\\n= &\\int _{-\\infty}^{+\\infty}\\varphi\\left[\\left(\\hat{A}\\hat{B}+\\hat{B}\\hat{A}\\right) \\Psi\\right]^*\\,\\mathrm{d}x\n\\end{aligned}\n$$\n\n- 如果 $\\hat{A}$ 和 $\\hat{B}$ 都是厄米算符，则 $i\\left(\\hat{A}\\hat{B} -\\hat{B}\\hat{A}\\right)$ 也是厄米算符\n\n##### 厄米算符的性质\n\n1. 对于系统的任何量子态，其厄米算符的平均值 $\\bar{F}=\\displaystyle\\int _{-\\infty}^{+\\infty} \\Psi ^*\\hat{F}\\Psi \\,\\mathrm{d}V$ 是实数\n2. **厄米算符的本征值是实数**，所以量子力学中的任何力学算符都是厄米算符\n3. **厄米算符属于不同本征值的本征函数彼此正交**\n   - **厄米算符的本征函数是正交统一的完全集**\n   - 任何物理上合理的波函数都可以用这个正交统一的完全集展开\n\n**证明：**\n\n- 平均值为实数\n\n$$\n\\bar{F} = \\int _{-\\infty}^{+\\infty} \\Psi ^*\\hat{F}\\Psi \\,\\mathrm{d}V = \\int _{-\\infty}^{+\\infty} \\left(\\hat{F}\\Psi\\right)^* \\Psi \\,\\mathrm{d}V = \\left(\\int _{-\\infty}^{+\\infty} \\Psi ^*\\hat{F}\\Psi \\,\\mathrm{d}V\\right)^* = \\bar{F}^*\n$$\n\n故 $\\bar{F}$ 是实数\n\n- 本征值是实数\n\n  由厄米算符的定义\n\n$$\n\\int _{-\\infty}^{+\\infty} \\Psi ^*\\hat{F}\\Psi_n \\,\\mathrm{d}V = \\int _{-\\infty}^{+\\infty} \\left(\\hat{F}\\Psi\\right)^* \\Psi \\,\\mathrm{d}V\n$$\n\n设 $\\hat{F}\\Psi= F\\Psi$，则\n\n$$\n\\begin{aligned}\n\t\\int _{-\\infty} ^{+\\infty} \\Psi ^*F\\Psi\\mathrm{d}\\,V &= \\int _{-\\infty}^{+\\infty} \\left(F\\Psi\\right)^* \\Psi\\,\\mathrm{d}V\\\\\n\t\\Rightarrow F\\int _{-\\infty} ^{+\\infty} \\Psi ^*\\Psi\\mathrm{d}\\,V &= F^*\\int _{-\\infty}^{+\\infty} \\Psi^* \\Psi\\,\\mathrm{d}V\n\\end{aligned}\n$$\n\n则 $F=F^*$，故本征值为实数\n\n- 属于不同本征值的本征函数正交\n\n  由厄米算符的定义\n\n$$\n\\begin{aligned}\n  \\int \\Psi _{m}^{*}\\hat{F} \\Psi _{n} \\, \\mathrm{d}V&=\\int (\\hat{F} \\Psi _{m})^{*} \\Psi _{n} \\, \\mathrm{d} V\\\\\nF_{n}\\int \\Psi m^{*} \\Psi _{n}\\,\\mathrm{d} V&=F_{m}^{*}\\int \\Psi _{m}^{*} \\Psi _{n} \\, \\mathrm{d} V\\\\\n( F_{n} -F_{m})\\int \\Psi _{m}^{*} \\Psi _{n} \\,\\mathrm{d} V&=0\n\\end{aligned}\n$$\n\n$\\displaystyle m\\neq n$，则 $\\displaystyle \\int \\Psi _m^n \\Psi _n \\, \\mathrm{d} V=1$，则 $\\displaystyle F_n =F_m$\n\n这里有 $\\displaystyle \\int \\Psi _m^*\\Psi _n \\, \\mathrm{d}V = \\delta _{nm} =\\begin{cases} 0 &,n\\neq m\\\\ 1 &,n=m\\end{cases}$\n\n- 波函数可以用正交统一的完全集展开 $\\displaystyle\\Psi = \\sum _n c_n\\Psi _n$\n\n  使用数学归纳法，假设当 $n$ 时成立\n\n$$\n\\begin{aligned}\n  & \\Psi &&= \\sum _{n} c_n\\Psi _n \\\\\n  & \\Psi _m^*\\Psi &&= \\sum _{n} c_n\\Psi _m^*\\Psi _n\\\\\n  & \\int\\Psi _m^*\\Psi \\,\\mathrm{d}V &&= \\sum _{n} c_n\\int \\Psi _m^*\\Psi _n \\,\\mathrm{d}V \\\\\n  &                                   &&= \\sum _n c_n \\delta _{mn}\\\\\n  &                                  &&= c_m\\\\\n\\end{aligned}\n$$\n\n可以得到 $\\displaystyle c_m = \\int \\Psi _m^*\\Psi \\,\\mathrm{d}V$ ，当 $m$ 时成立\n\n### 测量假设\n\n当一个量子系统处于量子态 $\\Psi$ 时，对力学量 $\\hat{F}$ 的测量结果一定是该力学算符的本征值之一，结果为 $F_n$ 的概率为 $\\left\\vert c_n\\right\\vert ^2 = \\left\\vert\\int \\phi_n^*\\Psi\\,\\mathrm{d}V\\right\\vert^2$\n\n这里 $\\hat{F}\\varphi _n = F_n\\varphi _n$ 是力学量 $\\hat{F}$ 的本征方程，测量完成后，该量子系统坍缩至 $\\varphi _n$\n\n**结论**\n\n- 根据测量假设，当一个量子系统处在量子态 $\\Psi$ 时，对力学量 $\\hat{F}$ 的测量结果的统计平均值为\n\n$$\n\\bar{F} = \\sum _n F_n \\left\\vert c_n \\right\\vert ^2 = \\sum _n F_n \\left\\vert \\int\\phi_n^*\\Psi\\,\\mathrm{d}V\\right\\vert ^2 =\\boxed{\\int \\Psi^* \\hat{F} \\Psi\\,\\mathrm{d}V}\n$$\n\n**证明：**\n\n$$\n\\begin{aligned}\n   &\\int \\Psi ^* \\hat{F} \\Psi \\mathrm{d}V\\\\\n   =&\\int \\left(\\sum_m c_m\\Psi_m\\right)^*\\hat{F}\\left(\\sum_n c_n\\Psi_n\\right)\\mathrm{d}V\\\\\n   =&\\int \\left(\\sum_m c_m\\Psi_m\\right)^*\\left(\\sum_n c_n \\hat{F}\\Psi_n\\right)\\mathrm{d}V\\\\\n   =&\\int \\left(\\sum_m c_m\\Psi_m\\right)^*\\left(\\sum_n c_n F_n\\Psi_n\\right)\\mathrm{d}V\\\\\n   =&\\sum_{mn}c_m c_n F_n \\int \\left(\\Psi_m^*\\Psi_n\\right)\\mathrm{d}V\\\\\n   =&\\sum_{mn}c_m c_n F_n \\delta _{mn}\\\\\n   =&\\sum_n\\left\\vert c_n \\right\\vert ^2 F_n\n\\end{aligned}\n$$\n\n- 测量假设推论：当一个量子系统处于量子态 $\\Psi$ 时，且满足 $\\displaystyle \\sum _n \\vert c_n\\vert^2=1$ 时，对力学量的测量结果一定是该力学算符的本征值之一，测量结果为 $F_n$ 的概率为 $\\vert c_n \\vert^2$，测量完成之后，该量子系统探索至 $\\phi_n$\n\n#### 动量本征方程\n\n$$\n-i\\hbar\\nabla\\Phi _{\\boldsymbol{r}}(\\boldsymbol{r}) = \\hat{p}\\Phi _{\\boldsymbol{r}}(\\boldsymbol{r}) = p\\Phi _{\\boldsymbol{r}}(\\boldsymbol{r})\n$$\n\n其在三个坐标轴上的分量为\n\n$$\n\\begin{cases}\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{r}}}{\\partial x} = p_x\\Phi _{\\boldsymbol{r}}\\\\\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{r}}}{\\partial y} = p_y\\Phi _{\\boldsymbol{r}}\\\\\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{r}}}{\\partial z} = p_z\\Phi _{\\boldsymbol{r}}\n\\end{cases}\n$$\n\n其解为\n\n$$\n\\Phi _{\\boldsymbol{p}}(\\boldsymbol{r}) = \\frac{1}{(2\\pi\\hbar)^\\frac{3}{2}}e^{\\frac{i}{\\hbar}\\boldsymbol{p}\\cdot \\boldsymbol{r}}\n$$\n\n测量结果为 $p$ 的概率密度为\n\n$$\n\\vert c_p \\vert^2 = \\left\\vert \\int \\Phi_p^*\\Psi\\,\\mathrm{d}v\\right\\vert^2 = \\left\\vert \\int \\frac{1}{(2\\pi\\hbar)^\\frac{3}{2}}e^{-\\frac{i}{\\hbar}\\boldsymbol{p}\\cdot \\boldsymbol{r}}\\Psi\\,\\mathrm{d}v\\right\\vert^2\n$$\n\n统计平均值为\n\n$$\n\\bar{p} = \\sum_{n} p_i\\vert c_{p_i} \\vert ^2\n$$\n\n#### 动能本征方程\n\n$$\n-i\\hbar \\nabla \\Phi _{\\boldsymbol{p}}(\\boldsymbol{r}) = \\hat{p}\\Phi _{\\boldsymbol{p}}(\\boldsymbol{r})\n$$\n\n其在三个坐标轴的分量为\n\n$$\n\\begin{cases}\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{p}}}{\\partial x} = p_x\\Phi _{\\boldsymbol{p}}\\\\\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{p}}}{\\partial y} = p_y\\Phi _{\\boldsymbol{p}}\\\\\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{p}}}{\\partial z} = p_z\\Phi _{\\boldsymbol{p}}\n\\end{cases}\n$$\n\n记动能算符为 $\\hat{T}$\n\n$$\n\\hat{T}\\Phi _{\\boldsymbol{p}}(\\boldsymbol{r}) = -\\frac{\\hbar^2}{2m}\\nabla ^2\\Phi _{\\boldsymbol{p}}(\\boldsymbol{r})= \\frac{\\hat{p}^2}{2m}\\Phi _{\\boldsymbol{p}}(\\boldsymbol{r})\n$$\n\n所以**动量的本征函数等于动能的本征函数**\n\n同样当一个量子系统处于量子态 $\\Psi$ 时，测量动能为 $\\frac{p^2}{2m}$ 的概率为\n\n$$\n\\vert c_{\\frac{p^2}{2m}} \\vert^2 = \\left\\vert \\int \\Phi_{\\frac{p^2}{2m}}^*\\Psi\\,\\mathrm{d}v\\right\\vert^2 = \\left\\vert \\int \\frac{1}{(2\\pi\\hbar)^\\frac{3}{2}}e^{-\\frac{i}{\\hbar}\\boldsymbol{p}\\cdot \\boldsymbol{r}}\\Psi\\,\\mathrm{d}v\\right\\vert^2\n$$\n\n统计平均值为\n\n$$\n\\bar{\\frac{p^2}{2m}} = \\sum_{n} \\frac{p_i^2}{2m}\\vert c_{\\frac{p_i^2}{2m}} \\vert ^2\n$$\n\n### 态叠加原理\n\n如果 $\\Psi_1 , \\Psi_2 \\ldots$ 是体系的一系列可能的状，则 $\\displaystyle\\Psi = \\sum _i ^n c_n\\Psi_n$ 也是体系的一个可能的状态。对于处于 $\\Psi$ 态的体系，该体系分别部分地处在 $\\Psi_1 , \\Psi_2 \\ldots \\Psi_n \\ldots$ 态中\n\n### 薛定谔方程\n\n波函数随时间演化满足**薛定谔方程**\n\n$$\n\\boxed{i\\hbar \\frac{\\partial \\Psi (\\boldsymbol{r},t)}{\\partial t} = \\hat{H} \\Psi (\\boldsymbol{r},t)}\n$$\n\n#### 定态问题\n\n若粒子处于稳定的势场中，则势能函数 $U$ 与时间无关，称这类问题为定态问题\n\n$$\n\\Psi(\\boldsymbol{r} , t) = \\Phi(\\boldsymbol{r})e^{-i\\frac{1}{\\hbar}Et}\n$$\n\n$$\n\\left[ -\\frac{\\hbar^2}{2m}\\nabla^2   + U(\\boldsymbol{r})\\right] \\Phi(\\boldsymbol{r}) = E\\Phi(\\boldsymbol{r})\n$$\n\n也称为哈密顿算符的本征方程\n\n### 同类粒子的不可分辨性原理\n\n在量子力学中，内禀属行完全相同的粒子是**不可分辨**的，对任意这两个粒子进行交换，不会改变系统的状态\n\n经典力学中，能够得到粒子的运动方程和轨道方程 $\\vec{r} = \\vec{r}(t)$，然而在量子力学中，只能得到粒子在空间中分布的概率密度 $\\rho=\\vert\\Psi(\\boldsymbol{r},t)\\vert^2$，而不能得到粒子在空间中的轨道方程，因此得不到粒子的轨道方程\n\n对于内禀性相同的粒子，因为没有轨道方程，所以无法分辨，对于任意的两个这样的粒子进行交换，不会改变系统的状态，即粒子在空间中出现的概率密度不会改变\n\n$$\n\\begin{aligned}\n  &&\\left\\vert\\Psi(1,\\ldots , i , \\ldots , j \\ldots n)\\right\\vert &= \\left\\vert\\Psi(1,\\ldots , j , \\ldots , i \\ldots n)\\right\\vert\\\\\n  \\Rightarrow&&\\Psi(1,\\ldots , i , \\ldots , j \\ldots n) &= e^{i\\theta}\\Psi(1,\\ldots , j , \\ldots , i \\ldots n)\n\\end{aligned}\n$$\n\n实验表明，所有粒子可以分为两类\n\n1. **玻色子：** $\\theta=0$，交换粒子后波函数不变\n2. **费米子：** $\\theta=\\pi$，交换粒子后波函数反对称\n\n### 算符之间的对易关系\n\n两个算符 $\\hat{A}$ 和 $\\hat{B}$ 的对易子记为 $\\left[\\hat{A} , \\hat{B}\\right] = \\hat{A}\\hat{B}-\\hat{B}\\hat{A}$\n\n#### 动量算符和坐标算符之间的对易关系\n\n$$\n\\left[x,\\hat{p}_{x}\\right] = -i\\hbar\n$$\n\n**证明：**\n\n将 $\\left[x,\\hat{p}_x\\right] = x\\hat{p}_X - \\hat{p}_x x$ 作用于任意波函数 $\\Psi$ 上\n\n$$\n\\begin{aligned}\n  \\left[x,\\hat{p}_{x}\\right]\\Psi &= \\left(x\\hat{p}_{x} - \\hat{p}_x x\\right)\\Psi\\\\\n  &=-i\\hbar\\left(x\\frac{\\partial}{\\partial x} - \\frac{\\partial}{\\partial x}x\\right)\\Psi\\\\\n  &=-i\\hbar\\left[x\\frac{\\partial \\Psi}{\\partial x}-\\frac{\\partial}{\\partial x}\\left(x\\Psi\\right)\\right]\\\\\n  &=i\\hbar\\Psi\n\\end{aligned}\n$$\n\n故 $\\left[x,\\hat{p}_{x}\\right] = -i\\hbar$\n\n### 共同本征函数\n\n#### 两个算符对易\n\n如果两个算符 $\\hat{A}$ 和 $\\hat{B}$ 满足对易子为 $0$ ，即 $\\left[\\hat{A},\\hat{B}\\right] = \\hat{A}\\hat{B} - \\hat{B}\\hat{A} = 0$，则称这两个算符**对易**\n\n#### 对易的一个定理\n\n若两个力学量算符有一组共同完备的本征函数系，则二算符对易\n\n**证明：**\n\n假设\n\n$$\n\\begin{cases}\n  \\hat{F}\\varphi _n = F_n \\varphi _n\\\\\n  \\hat{G}\\varphi _n = G_n \\varphi _n\n\\end{cases}\n$$\n\n$\\varphi$ 组成完备系，则任意量子态 $\\Phi(x)$ 可以按其展开为 $\\Phi(x) = \\sum _n c_i \\varphi _i (x)$\n\n则\n\n$$\n\\begin{aligned}\n  \\left(\\hat{F}\\hat{G}-\\hat{G}\\hat{F}\\right)\\Psi(x)\n  &= \\left(\\hat{F}\\hat{G}-\\hat{G}\\hat{F}\\right)\\sum _n c_n \\varphi _n (x)\\\\\n  &= \\sum _n c_n \\left(\\hat{F}\\hat{G}-\\hat{G}\\hat{F}\\right)\\varphi _n (x)\\\\\n  &= \\sum _n c_n \\left(F_nG_n - G_nF_n\\right)\\varphi _n (x)\\\\\n  & = 0\n\\end{aligned}\n$$\n\n由于 $\\Psi(x)$ 是任意的函数，则 $\\hat{F}\\hat{G} = \\hat{G}\\hat{F}$\n\n- **其逆定理：** 若两个力学算符对易，则这两个算符有组成完备系的共同本征函数\n\n**证明：**\n\n已知 $\\hat{F}\\hat{G} = \\hat{G}\\hat{F}$，$\\hat{F}\\phi_n=F\\phi_n$\n\n$$\n\\hat{F}\\hat{G}\\varphi _n = \\hat{G}\\hat{F}\\varphi _n= F\\hat{G}\\varphi _n\n$$\n\n即\n\n$$\n\\hat{F}\\left(\\hat{G}\\varphi _n\\right) = F\\left(\\hat{G}\\varphi _n\\right)\n$$\n\n说明 $\\hat{G}\\varphi _n$ 也是 $\\hat{F}$ 的本征函数，本征值为 $F$\n故 $\\hat{G}\\varphi _n$ 和 $\\varphi _n$ 表示统一个量子态，$\\hat{G}\\varphi _n = G\\varphi$\n\n### 力学量完全集合\n\n- **定义：**能够完全确定状态的一组两两对易的力学量算符的最小（数目）集称为**力学量完全集**\n- 力学量完全集中的力学量数目一般与体系自由度数相同\n- 由力学量的完全集所确定的本征函数系构成该体系态空间的一组完备的本征函数，即体系中的任何状态均可用它展开\n\n### 角动量算符之间的对易关系\n\n#### 角动量算符\n\n- $\\displaystyle \\left[\\hat{L}_{x} , \\hat{L}_y\\right] = i\\hbar \\hat{L}_z$\n- $\\displaystyle \\left[\\hat{L}_{y} , \\hat{L}_z\\right] = i\\hbar \\hat{L}_x$\n- $\\displaystyle \\left[\\hat{L}_{z} , \\hat{L}_x\\right] = i\\hbar \\hat{L}_y$\n\n#### 角动量平方算符\n\n$$\n\\begin{aligned}\n\\hat{L} ^2 =\\hat{L} \\cdot \\hat{L} &= \\hat{L}_x^2 + \\hat{L}_y^2 + \\hat{L}_z^2\\\\\n  &= -\\hbar ^2 \\left[ \\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial}{\\partial\\theta}\\right)+\\frac{1}{\\sin\\theta^2}\\frac{\\partial^2}{\\partial \\varphi^2}\\right]\n\\end{aligned}\n$$\n\n$$\n\\left[\\hat{L}^2 , \\hat{L}_x\\right] = \\left[\\hat{L}^2 , \\hat{L}_y\\right] = \\left[\\hat{L}^2 , \\hat{L}_z\\right] = 0\n$$\n\n##### 角动量算符的本征方程\n\n$$\n\\begin{aligned}\n  &&-\\hbar ^2 \\left[ \\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial}{\\partial\\theta}\\right)+\\frac{1}{\\sin^2\\theta}\\frac{\\partial^2}{\\partial \\varphi^2}\\right]Y &= \\mu \\hbar ^2 Y\\\\\n  \\Rightarrow &&\\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial Y}{\\partial\\theta}\\right)+\\frac{1}{\\sin^2\\theta}\\frac{\\partial^2}{\\partial \\varphi^2}Y +\\mu Y &= 0\n\\end{aligned}\n$$\n\n令 $Y(\\theta , \\varphi) =\\Theta(\\theta) f(\\varphi)$，得到\n\n$$\n\\begin{aligned}\n  &\\frac{sin\\theta}{\\Theta}\\frac{\\partial}{\\partial \\theta}\\left(\\sin\\theta\\frac{\\partial\\Theta}{\\partial \\theta }\\right) + \\mu\\sin^2\\theta = -\\frac{1}{f}\\frac{\\partial ^2 f}{\\partial\\varphi ^2} = const = \\lambda\\\\\n  \\Rightarrow &\n  \\begin{cases}\n    \\frac{1}{\\sin\\theta}\\frac{\\mathrm d}{\\mathrm{d}\\theta}\\left(\\sin\\theta\\frac{\\mathrm{d}\\Theta}{\\mathrm{d}\\theta}\\right) +\\left(\\mu -\\frac{\\lambda}{\\sin^2\\theta}\\right)\\Theta = 0\\\\\n    \\frac{\\mathrm{d}^2 f}{\\mathrm{d}\\varphi ^2} +\\lambda f = 0\n  \\end{cases}\n\\end{aligned}\n$$\n\n先处理关于 $\\varphi$ 的方程\n\n令 $\\lambda = m_l ^2 , m_l = 0, \\pm 1, \\pm 2, \\ldots$，则\n\n$$\nf(\\varphi) = A\\cos(m_l \\varphi) + B\\sin(m_l \\varphi)\n$$\n\n再处理关于 $\\theta$ 的方程\n\n$$\n\\begin{aligned}\n  &\\frac{1}{\\sin\\theta}\\frac{\\mathrm d}{\\mathrm{d}\\theta}\\left(\\sin\\theta\\frac{\\mathrm{d}\\Theta}{\\mathrm{d}\\theta}\\right) +\\left(\\mu -\\frac{\\lambda}{\\sin^2\\theta}\\right)\\Theta = 0\\\\\n  \\Rightarrow & \\frac{1}{\\sin\\theta}\\frac{\\mathrm d}{\\mathrm{d}\\theta}\\left(\\sin\\theta\\frac{\\mathrm{d}\\Theta}{\\mathrm{d}\\theta}\\right) +\\left(\\mu -\\frac{m_l^2}{\\sin^2\\theta}\\right)\\Theta = 0\\\\\n\\end{aligned}\n$$\n\n令 $x = \\cos \\theta ,y(x) = \\Theta(\\theta)$，则\n\n$$\n\\frac{1}{1-x^2}\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2} -2x\\frac{\\mathrm{d}y}{\\mathrm{d}x}+ \\left(\\mu -\\frac{m_l^2}{1-x^2}\\right)y = 0 \\quad\\left(\\text{连带勒让德方程}\\right)\n$$\n\n- **本征值：**$\\mu = l(l+1)$，$l=0,1,2,\\ldots$\n- $\\Theta(\\theta) = P_l^m\\left(\\theta\\right)$\n\n则角动量平方算符的本征方程变为\n\n$$\n\\hat{L}^2 Y_{l,m_l} = -\\hbar ^2 \\left[\\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial}{\\partial\\theta}\\right)+\\frac{1}{\\sin^2\\theta}\\frac{\\partial^2}{\\partial \\varphi^2}\\right]Y_{l,m_l} = l(l+1)\\hbar ^2 Y_{l,m_l}\n$$\n\n其解为\n\n$$\nY_{L,m_l}(\\theta , \\varphi) = (-1)^{m_l}\\sqrt{\\frac{(2l+1)(l-\\vert m_l\\vert)!}{4\\pi (l+\\vert m_l\\vert)!}}P_l^{m_l}(\\cos\\theta)e^{im_l\\varphi}\n$$\n\n其中 $l = 0 , 1 , 2 , \\ldots$ ，$m_l = -l , -l +1 , \\ldots , l$\n该函数同时也为角动量算符 $\\hat{L}_z$ 的本征函数\n\n##### 统计平均值\n\n当一个量子系统处于量子态 $\\Psi$ 时，且满足 $\\displaystyle \\Psi\\left(\\theta , \\varphi\\right) = \\sum_{l}\\sum_{m_l=-1}^l c_{l,m_l}Y_{l,m_l}\\left(\\theta , \\varphi\\right)$ ，$\\sum_{l}\\sum_{m_l = -1}^l =\\left\\vert c_{l,l_m}\\right\\vert^2 = 1$ 时，对测量结果为 $l(l+1)\\hbar ^2$ 的概率为 $\\left\\vert c_{l,m_l}\\right\\vert^2$，测量完成之后，该量子系统坍缩至 $Y_{l,m_l}$\n\n统计平均值为\n\n$$\n\\bar{L}^2 = \\sum_{l}l(l+1)\\hbar ^2 \\sum_{m_l=-l}^{l} \\left\\vert c_{l,m_l}\\right\\vert^2\n$$\n\n对角动量 $z$ 分量进行测量的结果一定是该力学量算符的本征值之一，测量结果为 $m_l\\hbar$ 的概率为 $\\left\\vert c_{l,m_l}\\right\\vert^2$ ，测量完成之后，该量子系统坍缩至 $Y_{l,m_l}$\n\n统计平均值为\n\n$$\n\\bar{L}_z = \\sum_{l}  \\sum_{m_l=-l}^{l} m_l\\hbar\\left\\vert c_{l,m_l}\\right\\vert^2\n$$\n\n这里角动量平方算符和角动量算符的本征方程分别为\n\n$$\n\\hat{L}^2 Y_{l,m_l} = l(l+1)\\hbar ^2 Y_{l,m_l}\n$$\n\n$$\n\\hat{L}_z Y_{l,m_l} = m_l\\hbar Y_{l,m_l}\n$$\n\n## 算符与电子自旋\n\n### 未归一化的量子态下的算符平均值\n\n$$\n\\bar{A} = \\frac{\\iiint \\Psi^*(x,y,z)\\hat{A}\\Psi(x,y,z)\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z}{\\iiint \\Psi^*(x,y,z)\\Psi(x,y,z)\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z}\n$$\n\n### 线性算符\n\n线性算符 $\\hat{F}$ 满足\n\n$$\n\\hat{F}\\left(a\\Psi_1 + b\\Psi_2\\right) = a\\hat{F}\\Psi_1 + b\\hat{F}\\Psi_2\n$$\n\n位置算符 $\\hat{x} = x$ 和动量算符 $\\hat{p_x} = -i\\hbar\\frac{\\partial}{\\partial x}$ 均为线性算符\n\n由于态叠加原理，哈密顿算符 $\\hat{H}$ 也是线性算符，薛定谔方程是线性微分方程，则若 $\\Psi_1$ 和 $\\Psi_2$ 是薛定谔方程的解，则 $c_1\\Psi_1 + c_2\\Psi_2$ 也是薛定谔方程的解\n\n对于定态薛定谔方程也满足这个条件\n\n态叠加原理要求算符是线性的厄米算符\n\n### 厄米算符\n\n#### 厄米算符的本征值是实数\n\n#### 厄米算符的平均值是实数\n\n#### 厄米算符本征值具有正交性\n\n当两个函数 $\\Psi_q$ 和 $\\Psi_2$ 满足下列关系\n\n$$\n\\int \\Psi_1^*\\Psi_2\\,\\mathrm{d}x \\equiv \\int \\left\\langle\\Psi_1\\vert\\Psi_2\\right\\rangle =0\n$$\n\n则我们称这两个函数相互正交，$\\left\\langle\\Psi_1\\vert\\Psi_2\\right\\rangle$ 称为内积\n\n厄米算符两个不同本征值的本征函数总是正交的\n\n**证明：**\n\n（待补充 o_O）\n\n将这些正交的本征函数归一化，$\\displaystyle \\int \\Psi_1^*\\Psi_2\\,\\mathrm{d}x = 1$，所以**厄米算符**有一组正交化的本征函数\n\n$$\n\\int \\Psi_k^*\\Psi_l\\,\\mathrm{d}x =\\delta_{kl} =\n\\begin{cases}\n  0 &,k\\neq l\\\\\n  1 &,k=l\n\\end{cases}\n$$\n\n所以厄米算符的分立谱的所有本征函数都是正交归一化的\n\n### 动量算符的厄米性\n\n**证明：**\n\n（待补充）\n\n### 算符运算初步\n\n#### 算符之和\n\n$$\n\\hat{A} + \\hat{B} = \\hat{C}\n$$\n\n$$\n\\hat{C}\\Psi = \\left(\\hat{A}+\\hat{B}\\right)\\Psi=\\hat{A}\\Psi + \\hat{B}\\Psi\n$$\n\n#### 算符之积\n\n$$\n\\hat{A}\\hat{B} = \\hat{C}\n$$\n\n$$\n\\hat{C}\\Psi = \\hat{A}\\left(\\hat{B}\\Psi\\right)\n$$\n\n一般情况下，算符之积**不满足**交换律，即\n\n$$\n\\hat{A}\\hat{B} \\neq \\hat{B}\\hat{A}\n$$\n\n#### 算符的对易性\n\n如果 $\\hat{A}\\hat{B} = \\hat{B}\\hat{A}$，则称 $\\hat{A}$ 和 $\\hat{B}$ 是**对易的**\n\n记为 $\\left[\\hat{A},\\hat{B}\\right] \\equiv \\hat{A}\\hat{B} - \\hat{B}\\hat{A} = 0$，称 $\\left[\\hat{A},\\hat{B}\\right]$ 为 $\\hat{A}$ 和 $\\hat{B}$ 的**对易子**\n\n### 电子自旋\n\n#### 电子自旋角动量及其空间量子化\n\n##### 斯特恩-盖拉赫实验\n\n![Stern-Garlach experiment](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192235176.png)\n\n![磁力线](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192240318.png)\n\n磁铁的特殊形状使得磁极之间的磁力线不是均匀的，从而产生非匀强磁场\n\n在非匀强磁场之中，银原子和磁场的相互作用能为\n\n$$\nW = -\\boldsymbol{M}\\cdot\\boldsymbol{B}\n$$\n\n对 $z$ 方向求微分\n\n$$\nF_z = -\\frac{\\partial W}{\\partial z} = M_z \\frac{\\partial B}{\\partial z}\n$$\n\n实验结果为\n\n![result](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192317946.png)\n\n加入磁场之后，银原子分裂为两束。银原子的角动量数 $l=0$，且最外层为 $s$ 电子，无轨道角动量，说明会银原子有自由度，且有两个取值\n\n###### 斯特恩-盖拉赫实验的意义\n\n1. 证明了角动量空间量子化的存在\n   - 原子沉积层不是连续的一片，而是分开的线，说明了角动量空间量子化的存在\n2. 发现了新的矛盾\n   - $l=0$，应当有一条沉积线，但是实验结果却又两条沉积线，这说明原来对原子中的电子运动的描述是不完全的\n3. 提供了原子的“态分离”技术\n\n###### 理论解释\n\n1925 年乌伦贝克和古兹米特根据斯特恩-盖拉赫实验的结果，**提出了电子不是指点，具有固有的自旋角动量 $\\boldsymbol{S}$ 和相应的自旋磁矩 $\\boldsymbol{\\mu_s}$** 的观点\n\n![电子自旋角动量和磁矩](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192340149.png)\n\n由于电子带负电，其自旋磁矩和根据右手螺旋定律得到的方向相反\n\n相对于外磁场方向，$\\boldsymbol{B}$ 有朝上和朝下两种取向\n\n但是若将电子视为 $r=10^{-16}m$ 的小球，按照 $\\boldsymbol{S}\\sim\\hbar$ 估计得到的电子表面速度 $>c$\n\n电子在任意一个方向测量其自旋角动量的结果都是 $\\pm\\hbar$\n\n##### 泡利不相容原理\n\n1. 费米子和玻色子\n   1. **费米子：** 自旋量子数为半奇数的粒子\n   2. **玻色子：** 自旋量子数为整数的粒子\n2. 泡利不相容原理\n   - 不能有两个电子具有相同的 $n,m,l,m_l,m_s$\n3. 玻色凝聚\n   - 玻色子不受泡利不相容原理的限制，一个单粒子态可容纳多个玻色子\n\n##### 电子的自旋算符和自旋波函数\n\n###### 自旋算符\n\n自旋角动量是纯量子概念，但也是一个力学量\n\n自旋角动量与电子的坐标和动量无关，是电子内部状态的表征，是描述电子状态的第四个自由度\n\n自旋算符记为 $\\hat{S}$\n\n- $\\hat{\\boldsymbol{S}}\\times\\hat{\\boldsymbol{S}} =i\\hbar\\hat{\\boldsymbol{S}}$\n- $[\\hat{\\boldsymbol{S}_x},\\hat{\\boldsymbol{S}}_y] = i\\hbar \\hat{\\boldsymbol{S}}_z$\n- $[\\hat{\\boldsymbol{S}}_y,\\hat{\\boldsymbol{S}}_z] = i\\hbar \\hat{\\boldsymbol{S}}_x$\n- $[\\hat{\\boldsymbol{S}}_z,\\hat{\\boldsymbol{S}}_x] = i\\hbar \\hat{\\boldsymbol{S}}_y$\n\n由于**自旋角动量**在空间任意方向上的投影都只能取 $\\pm\\frac{\\hbar}{2}$，则 $\\hat{\\boldsymbol{S}}_x$，$\\hat{\\boldsymbol{S}}_y$ 和 $\\hat{\\boldsymbol{S}}_z$ 的本征值都是 $\\pm\\frac{\\hbar}{2}$，其平方为 $\\frac{\\hbar}{2}^2$\n\n###### 含自旋的状态波函数\n\n电子的含自旋的波函数为\n\n$$\n\\Psi =\\Psi(x,y,z,S_z,t)\n$$\n\n由于 $S_z$ 只有两个取值 $\\pm\\frac{\\hbar}{2}$，所以可以写为两个分量\n\n$$\n\\begin{cases}\n  \\psi_1=\\psi(x,y,z,\\frac{\\hbar}{2},t)\\\\\n  \\psi_2=\\psi(x,y,z,-\\frac{\\hbar}{2},t)\n\\end{cases}\n$$\n\n写作列矩阵\n\n$$\n\\Psi = \\begin{pmatrix}\n  \\psi_1(\\boldsymbol{r},t)\\\\\n  \\psi_2(\\boldsymbol{r},t)\n\\end{pmatrix}\n$$\n\n这里的正负号是规定好的\n\n若已知电子处于 $S_z = \\frac{\\hbar}{2}$ 或 $S_z = -\\frac{\\hbar}{2}$ 的状态，则其波函数分别可以写为：\n\n$$\n\\Psi = \\begin{pmatrix}\n  \\psi_1(\\boldsymbol{r},t)\\\\\n  0\n\\end{pmatrix}\n\\qquad\n\\Psi = \\begin{pmatrix}\n  0\\\\\n  \\psi_2(\\boldsymbol{r},t)\n\\end{pmatrix}\n$$\n\n###### 自旋算符的矩阵表示，Pauli 矩阵\n\n**$\\hat{S}_z$ 的矩阵形式**\n\n$$\n\\hat{S}_z = \\frac{\\hbar}{2}\n\\begin{pmatrix}\n  1 & 0\\\\\n  0 & -1\n\\end{pmatrix}\n$$\n\n**Pauli 算符**\n\n对于 $\\hat{S}_z$ 的矩阵形式，我们定义 Pauli 算符，使得\n\n$$\n\\hat{S}_z = \\frac{\\hbar}{2}\\hat{\\sigma}\n$$\n\n从自旋算符与 Pauli 矩阵之间的关系，可以得到自旋算符的矩阵表示\n\n$$\n\\hat{S}_x = \\frac{\\hbar}{2}\\begin{pmatrix}\n  0 & 1\\\\\n  1 & 0\n\\end{pmatrix}\n\\quad\n\\hat{S}_y = \\frac{\\hbar}{2}\\begin{pmatrix}\n  0 & -i\\\\\n  i & 0\n\\end{pmatrix}\n\\quad\n\\hat{S}_z = \\frac{\\hbar}{2}\\begin{pmatrix}\n  1 & 0\\\\\n  0 & -1\n\\end{pmatrix}\n$$\n\n###### 自旋波函数\n\n波函数 $\\Psi = \\begin{pmatrix}\\psi_1\\newline \\psi_2\\end{pmatrix}$ 中，一般情况下，$\\Psi_1\\neq\\Psi_2$，两者对 $(x,y,z)$ 的依赖是不相同的，因为自旋对轨道运动有一定的影响，但是当影响足够小时，可以忽略，此时认为 $\\Psi_1$ 和 $\\Psi_2$ 的函数形式相同，$\\Psi$ 可以写作如下的形式\n\n$$\n\\Psi(\\boldsymbol{r},S_z,t) =\\psi(\\boldsymbol{r},t)\\chi(S_z)\n$$\n\n其中 $\\chi(S_z)$ 是 $\\hat{S}_z$ 的本征函数，称为自旋波函数\n\n$$\n\\chi_{\\frac{1}{2}}(S_z) = \\begin{pmatrix}\n  1\\\\\n  0\n\\end{pmatrix}\n\\quad\n\\chi_{-\\frac{1}{2}}(S_z) = \\begin{pmatrix}\n  0\\\\\n  1\n\\end{pmatrix}\n$$\n\n这两个自旋波函数相互正交\n\n### 无限深势阱\n\n### 谐振子\n\n#### 势能\n\n若先择线性谐振子平衡位置为坐标原点和势能零点，则一维线性谐振子得到势能可以表示为\n\n$$\nU(x) = \\frac{1}{2}kx^2 = \\frac{1}{2}m\\omega^2x^2\n$$\n\n##### 谐振子的定态薛定谔方程\n\n一维谐振子的哈密顿量为\n\n$$\n\\hat{H} = -\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} + \\frac{1}{2}m\\omega^2x^2\n$$\n\n满足的定态薛定谔方程为\n\n$$\n\\left[-\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} + \\frac{1}{2}m\\omega^2x^2\\right]\\Phi(x) = E\\Phi(x)\n$$\n\n一维谐振子的能量是量子化的\n","source":"_posts/大学物理3笔记.md","raw":"---\ntitle: 大学物理3笔记\nmath: true\n---\n\n## 基本常数\n\n| 名称         | 符号        | 数值                  | 单位                        |\n| ------------ | ----------- | --------------------- | --------------------------- |\n| 斯特番常数   | $\\sigma$    | $5.67\\times 10^{-8}$  | $W\\cdot m^{-2}\\cdot K^{-4}$ |\n| 维恩常数     | $b$         | $2.898\\times 10^{-3}$ | $m\\cdot K$                  |\n| 玻尔兹曼常数 | $k$         | $1.38\\times 10^{-23}$ | $J\\cdot K^{-1}$             |\n| 普朗克常数   | $h$         | $6.63\\times 10^{-34}$ | $J\\cdot s$                  |\n| 康普顿波长   | $\\lambda_c$ | $0.02426$             | $\\text{Å}$                  |\n| 里德伯常数   | $R$         | $1.097\\times 10^{7}$  | $m^{-1}$                    |\n\n## 算符\n\n| 名称       | 表达式                                                         |\n| ---------- | -------------------------------------------------------------- |\n| 能量算符   | $\\hat{E} = i\\hbar\\frac{\\partial}{\\partial t}$                  |\n| 动量算符   | $\\hat{p} = -i\\hbar\\nabla$                                      |\n| 哈密顿算符 | $\\hat{H} = -\\frac{\\hbar^2}{2m}\\nabla ^2 + U(\\boldsymbol{r},t)$ |\n| 角动量算符 | $\\hat{L} = \\hat{r}\\times \\hat{p}$                              |\n\n## 量子物理基础\n\n### 黑体辐射\n\n#### 热辐射的基本概念\n\n- 所有物在有限体温度下都会发射电磁波，这种与温度有关的辐射称为热辐射 (heat radiation).\n- 热辐射是连续谱.\n- 基本性质：温度越高，发射的能量越大，电磁波的短波成分能量越大.\n- 平衡热辐射：热辐射是热平衡状态下的辐射.\n\n##### 热辐射基本参数\n\n**单色辐出度 $M_{\\lambda}(W/m^3)$**\n\n物体单位表面在单位时间内发出的波长在 $\\lambda$ 附近单位波长间隔内的电磁波的能量，用于描述物体辐射能量的能力\n\n$$\nM_{\\lambda}(T)=\\frac{\\mathrm{d}E_{\\lambda}}{\\mathrm{d}\\lambda}\n$$\n\n**辐出度 $M(T)(W/m^2)$**\n\n物体从单位面积上发射的所有波长的辐射总功率\n\n$$\nM(t)=\\int _0^{+\\infty}M_{\\lambda}(T)\\,\\mathrm{d}\\lambda\n$$\n\n**吸收比 $\\alpha(T)$ 和反射比 $r(T)$**\n\n- **吸收比**：辐射从外界入射到物体表面时，吸收的能量和入射的能量之比，是吸收能力的量度.\n\n$$\n\\alpha(T)=\\frac{E^\\text{吸收}}{E^\\text{入射}}\n$$\n\n- **反射比**：辐射从外界入射到物体表面时，反射的能量和入射的能量之比，是反射能力的量度.\n\n$$\nr(T)=\\frac{E^\\text{反射}}{E^\\text{入射}}\n$$\n\n**单色吸收比 $\\alpha(\\lambda,T)$ 和单色反射比 $r(\\lambda,T)**$\n\n- **单色吸收比**：当辐射从外界入射到物体表面时，吸收的波长从 $\\lambda$ 到 $\\lambda +\\mathrm{d}\\lambda$ 波长间隔内的能量 $E_\\lambda^\\text{吸收}\\mathrm{d}\\lambda$ 和入射的能量 $E_\\lambda^\\text{入射}\\mathrm{d}\\lambda$ 之比.\n\n$$\n\\alpha(\\lambda,T)=\\frac{E_\\lambda^\\text{吸收}}{E_\\lambda^\\text{入射}}\n$$\n\n- **单色反射比**：当辐射从外界入射到物体表面时，反射的波长从 $\\lambda$ 到 $\\lambda +\\mathrm{d}\\lambda$ 波长间隔内的能量 $E_\\lambda^\\text{反射}\\mathrm{d}\\lambda$ 和入射的能量 $E_\\lambda^\\text{入射}\\mathrm{d}\\lambda$ 之比.\n\n$$\nr(\\lambda,T)=\\frac{E_\\lambda^\\text{反射}}{E_\\lambda^\\text{入射}}\n$$\n\n对于不透明物体，有 $\\alpha(\\lambda,T)+r(\\lambda,T)=1$.\n\n##### 基尔霍夫定律\n\n一个好的发射体一定是个好的吸收体（黑白盘子实验）\n![黑白盘实验](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/%E9%BB%91%E7%99%BD%E7%9B%98%E5%AE%9E%E9%AA%8C.png)\n\n温度一定时物体在某波长处的单色辐出度与单色吸收比的比值与物体及物体表面的性质无关，即\n\n$$\n\\frac{M_1(\\lambda,T)}{\\alpha_1(\\lambda,T)} = \\frac{M_2(\\lambda,T)}{\\alpha_2(\\lambda,T)}=\\ldots=M_0(\\lambda,T).\n$$\n\n其中 $M_0(\\lambda,T)$ 是一个只与波长和温度有关，与物体材料、表面状态无关的函数，称为黑体辐射强度，是黑体的单色辐出度.\n\n##### 黑体\n\n能完全吸收各种波长电磁波而无反射的物体是黑体\n黑体是理想模型，可以建立只有小孔的空腔，小孔是黑体，空腔内的辐射是黑体辐射\n\n###### 黑体辐射的基本规律\n\n温度一定时，黑体辐射的强度与波长有关，存在一定的波长 $\\lambda _{\\max}$ 使得辐射强度最大，称为黑体辐射的主波长.\n![黑体辐射图](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/%E9%BB%91%E4%BD%93%E8%BE%90%E5%B0%84%E5%9B%BE.png)\n\n- **斯特番-玻尔兹曼定律(J. Stefan, L. Boltzmann)**\n  实验证明，黑体的总辐出度 $M_0(T)$ 与温度 $T$ 的四次方成正比\n\n$$\nM_0(T)=\\sigma T^4\n$$\n\n其中 $\\sigma = 5.67\\times 10^{-8} W\\cdot m^{-2}\\cdot K^{-4}$，称为斯特番常数.\n1879 年斯特番实验总结得到，1884 年玻尔兹曼理论证明.\n表明热辐射对温度的敏感性 $\\propto T^4$.\n\n- 维恩位移定律(W. Wien)\n  黑体辐射中单色辐出值的极值波长 $\\lambda_m$ 与黑体温度 $T$ 之积为常数\n\n$$\n\\lambda_mT=b\n$$\n\n其中 $b=2.898\\times 10^{-3}m\\cdot K$ ，为 Wien 常数.\n\n##### 普朗克的能量子假说和黑体辐射公式\n\n###### 维恩公式\n\n$$\nM_0(\\nu,T)=\\alpha\\nu^3e^{-\\beta/T}\n$$\n\n- 在高频段与实验符合得很好，但是在低频段明显偏离实验曲线\n\n###### 瑞利-金斯公式\n\n$$\nM_0(\\nu,T)=\\frac{2\\pi \\nu^2}{c^2}kT\n$$\n\n- 其中 $k=1.38\\times 10^{-23} J\\cdot K^{-1}$ ，为玻尔兹曼常数.\n- 低频段与实验符合得很好，但是在高频段明显偏离实验曲线.\n- 且当 $\\nu\\to\\infty$ 时，$M_0(\\nu,T)\\to \\infty$，称为紫外灾难.\n\n###### 普朗克公式\n\n普朗克以适用于高频段的维恩公式和适用于低频段的瑞利-金斯公式为基础，提出了**普朗克黑体辐射公式**，是一个半经验公式.\n\n$$\nM_0(\\nu,T)=\\frac{2\\pi\\nu^2}{c^2}\\frac{h\\nu}{e^{\\frac{h\\nu}{kT}}-1}\n$$\n\n- 其中 $h=6.63\\times 10^{-34}J\\cdot s$ 为普朗克常量.\n\n- 普朗克公式在整个频段都符合实验结果.\n\n- 普朗克认为：空腔内壁的分子、原子的振动可以看成是许多带电的简谐振子，这些简谐振子可以辐射和吸收能量，并与空腔内的辐射达到平衡。从空腔小孔辐射出的电磁波，就是由这些空腔内壁的简谐振子辐射出的。他假定对于频率为 $\\nu$ 的振子，振子能量不是连续的，而是分立的，它的取值是某一最小能量 $h$ 的整数倍，即**当振子吸收或放出能量时，以 $h\\nu$ 为单位.**\n- 我们计 $\\varepsilon =h\\nu$ ，称为**能量子（quanta of enmergy）**\n\n- 由普朗克公式可以推出其他热辐射公式\n\n  $$\n  M_0(\\nu,T)=\\frac{2\\pi\\nu^2}{c^2}\\frac{h\\nu}{e^{\\frac{h\\nu}{kT}}-1}\\ \\\n  \\left\\{\n    \\begin{aligned}\n    &\\text{积分} \\rightarrow M=\\sigma T^4, \\ \\ \\text{斯特番-玻尔兹曼定律}\\\\\n    &\\text{求导} \\rightarrow \\lambda_mT=b. \\ \\ \\text{维恩位移定律}\\\\\n    &\\text{低频极限} \\rightarrow M_0(\\nu,T)=\\frac{2\\pi\\nu^2}{c^2}kT, \\ \\ \\text{瑞利-金斯公式}\\\\\n    &\\text{高频极限} \\rightarrow M_0(\\nu,T)=\\alpha\\nu^3e^{-\\beta/T}, \\ \\ \\text{维恩公式}\n    \\end{aligned}\n  \\right.\n  $$\n\n### 光电效应（Photoelectric effect）\n\n#### 实验模型\n\n![实验装置](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250228160736.png)\n\n当光照在金属表面，电子从金属中脱出的现象，称为光电效应\n\n#### 基本参数\n\n#### 饱和电流\n\n实验表明，当入射光强度不变，加速电势差 $U$ 越大，光电流 $I$ 也越大，当电势差增大到一定值时，光电流达到饱和值，此时的光电流称为**饱和电流**。若改变入射光强，**饱和电流的大小与入射光强成正比**，说明从阴极逸出的电子数全部飞到阳极，单位时间从金属表面逸出的电子数与入射光强成正比.\n\n#### 遏制电压差\n\n改变阴极与阳极之间的电压，当电压增大到一定值时，光电流减小到零，此时的电压差称为**遏制电压差**。遏制电压差的大小与入射光的频率有关，与光强无关.\n光电子从表面逸出的最大初速度 $v_m$ 满足：\n\n$$\n\\frac{1}{2} m v_m^2 = eU_0\n$$\n\n#### 爱因斯坦的光量子论\n\n电子辐射由以光速 $c$ 运动的局限于空间某小范围的光量子（光子），即光子流组成\n光子的能量为 $\\varepsilon = h\\nu$ ，动量为 $p = \\frac{h}{\\lambda}$\n\n- 光电效应的基本方程\n\n$$\nh \\nu=\\frac{1}{2} m v_{\\mathrm{m}}^{2}+A\n$$\n\n其中 $\\frac{1}{2}mv_{\\mathrm{m}}^{2}$ 是光电子的最大初动能.\n\n**解释：**\n光照射金属时，电子吸收光子，能量增加，一部分用于克服金属脱出功，一部分增加电子的初动能\n\n#### 光的波粒二象性\n\n- 一些情况下，光的波动性表现得很明显，如干涉、衍射、偏振等现象.\n- 一些情况下，光的粒子性表现得很明显，如光电效应、康普顿散射等现象.\n\n这被称为光的波粒二象性\n\n- 光不是牛顿经典粒子，也不是康普顿的经典波\n\n基本关系式\n\n$$\n\\left\\{\n  \\begin{aligned}\n    &\\varepsilon = h\\nu \\quad \\text{粒子性}\\\\\n    &p = \\frac{\\varepsilon}{c}=\\frac{h}{\\lambda} \\quad \\text{波动性}\n  \\end{aligned}\n\\right.\n$$\n\n### 康普顿散射\n\n在散射的 X 射线中，存在与入射光波长相等的波，也存在波长比入射光波长大的波，这种现象称为**康普顿散射** .\n\n#### 特点\n\n$$\n\\Delta \\lambda = \\lambda' - \\lambda = \\lambda _{c} (1-\\cos\\theta)\n$$\n\n其中\n\n- $\\lambda_c =\\frac{h}{m_{0}c}= 0.02426 \\text{Å}$ 被称为康普顿波长. 当光子的波长等于 $\\lambda_c$ 时，其能量等于电子的能量 $m_{c}c^{2} =1.511 \\text{MeV}$ .\n- $\\theta$ 为散射角.\n\n1. 波长改变量随散射角 $\\theta$ 的增大而增大\n2. 新成分的相对强度随散射角 $\\theta$ 的增大而增大\n3. 同一个散射角下，所有散射物质的波长差相等\n4. 随着原子序数的增加，原波长成分的相对强度增大，即对对于轻元素康普顿散射更为明显.\n\n其中 3、4 是由吴有训发现的\n\n#### 推导\n\n使用动量守恒和能量守恒进行推导（X 射线光子与静止的自由电子的碰撞）\n\n![康普顿散射推导](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250302131054.png)\n\n由能量守恒：\n\n$$\n\\begin{equation}\n  h\\nu + m_{e}c^{2} = h\\nu' +mc^{2}\n\\end{equation}\n$$\n\n其中 $m=\\frac{m_{e}}{\\sqrt{1-\\frac{v^2}{c^2}}}$\n\n由 $x$ 方向上的动量守恒\n\n$$\n\\begin{equation}\n  \\frac{h\\nu _0}{c} = \\frac{h\\nu}{c} \\cos{\\theta} + mv\\cos{\\varphi}\n\\end{equation}\n$$\n\n由 $y$ 方向上的动量守恒\n\n$$\n\\begin{equation}\n  0 = \\frac{h\\nu}{c} \\sin{\\theta} - mv\\sin{\\varphi}\n\\end{equation}\n$$\n\n解方程组即可得到康普顿散射的公式\n\n$$\n\\Delta \\lambda = \\lambda _{0} -\\lambda =\\frac{h}{m_{e}c} (1-\\cos{\\theta})\n$$\n\n### 波尔氢原子理论\n\n#### 原子模型的发展\n\n1. 汤姆逊的面包夹葡萄干模型\n2. 卢瑟福的 $\\alpha$ 粒子散射实验和原子的核结构模型\n\n#### 氢原子光谱\n\n##### 公式\n\n###### 里德伯公式\n\n$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{m^{2}}-\\frac{1}{n^{2}}\\right) \\quad(m=1,2,3,\\cdots;n=m+1,m+2,m+3,\\cdots)\n$$\n\n其中：\n\n- $\\widetilde{\\nu} = \\frac{1}{\\lambda}$ 为波长的倒数，即波数\n- $R=1.097\\times 10^{7}m^{-1}$ 为里德伯常数\n\n###### 赖曼系（ $m=1$ ，紫外区）\n\n$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{1^{2}}-\\frac{1}{n^{2}}\\right) \\quad(n=2,3,4,\\cdots)\n$$\n\n###### 巴尔末系（ $m=2$ ）\n\n$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{2^{2}}-\\frac{1}{n^{2}}\\right) \\quad(n=3,4,5,\\cdots)\n$$\n\n###### 帕邢系（ $m=3$ ，红外区）\n\n$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{3^{2}}-\\frac{1}{n^{2}}\\right) \\quad(n=4,5,6,\\cdots)\n$$\n\n###### 布拉开系 （ $m=4$ ，近红外区）\n\n$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{4^{2}}-\\frac{1}{n^{2}}\\right) \\quad(n=5,6,7,\\cdots)\n$$\n\n###### 普丰德系（ $m=5$ ，远红外区）\n\n$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{5^{2}}-\\frac{1}{n^{2}}\\right) \\quad(n=6,7,8,\\cdots)\n$$\n\n###### 汉弗莱系 （ $m=6$ ，远红外区）\n\n$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{6^{2}}-\\frac{1}{n^{2}}\\right) \\quad(n=7,8,9,\\cdots)\n$$\n\n##### 波尔的氢原子模型\n\n##### 波尔假设\n\n1. 原子中的电子只能在一些分离的轨道上运行，在每一个轨道上运动的电子处于不稳定的能量状态（定态 $EW_{n}$ ），不向外辐射能量\n2. **频率条件：** 当电子从一个定态跃迁另一个定态时，发射或吸收一个光子， $h\\nu\\_{nm}=\\vert E_n-E_m\\vert $\n3. **结论：**\n\n   $$\n   \\nu=\\frac{E_{n}-E_{m}}{h}=\\frac{m e^{4}}{8 \\varepsilon _{0}^{2} h^{3}}\\left(\\frac{1}{m^{2}}-\\frac{1}{n^{2}}\\right)\n   $$\n\n##### 波尔角动量量子化条件\n\n$$\nL=n \\frac{h}{2 \\pi}=n \\hbar,n=1,2,3,\\cdots\n$$\n\n其中， $n$ 为量子数， $\\hbar=\\frac{h}{2\\pi}$ 为约化普朗克常数.\n**定量计算：**\n由电子的向心力和轨道角动量的量子化得到\n\n$$\n\\left\\{\n  \\begin{aligned}\n    &m\\frac{v^{2}}{r}=\\frac{1}{4\\pi \\varepsilon _{0}}\\cdot \\frac{e^2}{r^2}\\\\\n    &L=mvr=n\\hbar\n  \\end{aligned}\n\\right.\n$$\n\n解得：\n\n$$\n\\left\\{\n  \\begin{aligned}\n    &r_n=n^2\\frac{4\\pi \\varepsilon _{0} \\hbar^{2}}{m e^{2}}=n^2r_1\\\\\n    &v_n=\\frac{e^{2}}{4\\pi \\varepsilon _{0} n \\hbar}=\\alpha \\frac{c}{n}\n  \\end{aligned}\n\\right.\n$$\n\n其中 $r_1 = \\frac{4\\pi \\varepsilon _{0} \\hbar^{2}}{m e^{2}} = 0.529\\text{Å}$ 为氢原子中电子的最小轨道\n\n**轨道能量：**\n\n$$\nE_n =\\frac{1}{2}mv_n^2 + (-\\frac{1}{4\\pi \\varepsilon _0}\\cdot \\frac{e^2}{r_n^2}) = -\\frac{me^4}{8\\varepsilon_0^2h^2n^2}=-\\frac{1}{n^2}E_1\n$$\n\n其中 $E_1 = 13.6eV$ 为氢原子基态能量\n\n##### 波尔的对应原理\n\n当 $n\\rightarrow +\\infty$ 时，$r_n \\rightarrow 0$ ，$E_n \\rightarrow 0$ ，$\\displaystyle \\Delta E = E_n - E_{n+1} = \\frac{me^4}{4 \\varepsilon _0h^2n^3}\\rightarrow 0$ ，即能级间距趋于零，能级连续，形成连续谱.\n\n## 量子动力学入门\n\n量子力学的两条路线\n\n1. 波动力学 普朗克、爱因斯坦、德布罗意、薛定谔\n2. 矩阵力学 普朗克、波尔、海森堡\n\n- 最后由玻恩给出统计解释\n- 波动力学和矩阵力学完全等价\n\n### 物质波\n\n#### 德布罗意假说\n\n德布罗意假设：实物具有波粒二象性\n\n| 量  | 粒子性 | 波动性              |\n| --- | ------ | ------------------- |\n| $E$ | $mc^2$ | $h\\nu$              |\n| $p$ | $mv$   | $\\frac{h}{\\lambda}$ |\n\n#### 德布罗意原子稳定性驻波思想\n\n原子中的电子在原子核库仑场中运动表现得波动性具有驻波得特征，驻波的稳定性使得电子不会坠落到原子核内\n\n##### 能量的量子化\n\n- $\\lambda = \\frac{2L}{n}$\n- $p=\\frac{h}{2L}n$\n- $E = \\frac{p^2}{2m} = \\frac{h^2}{8mL^2}n^2$\n\n##### 物质波的概念对波尔轨道角动量量子化条件的解释\n\n德布罗意认为电子在经典的圆轨道上运动，形成一个环形驻波\n\n![电子驻波](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250308170617.png)\n\n电子绕行原子一周，圆周长应等于波长的整数倍\n\n$$\n2\\pi r = n\\lambda\n$$\n\n$$\nL = rmv = \\frac{n\\lambda}{2\\pi} \\cdot \\frac{h}{\\lambda} = n\\hbar\n$$\n\n#### 物质波的实验验证\n\n![物质波的实验验证](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250308171040.png)\n\n##### 布拉格公式\n\n![布拉格公式推导](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503151817449.png)\n\n$$\n\\delta = 2d\\sin\\theta = n\\lambda \\quad (n=1,2,3,\\cdots)\n$$\n\n#### 微观粒子波动性的应用\n\n- 显微镜使用电子波提大大提高了分辨率\n\n### 波函数的统计解释\n\n#### 对电子是什么的两种经典观点\n\n1. 电子是波包\n   - 由两种不同频率的波合成一个波包\n   - 这种观点夸大了波动性，忽略了粒子性\n     1. 不同频率波在媒质中传播速度不同，波包会逐步扩展而消失，但是实际粒子并没有消失 说明波包是电子的某种实际结果\n     2. 在媒质界面上一部分反射，一部分折射，但实际例子或整个反射，或整个折射\n2. 经典粒子\n   - 粒子是基本的，波动性源于粒子与粒子的相互作用，或者粒子与狭缝周围原子的相互作用。\n   - 这种观点夸大了粒子性，抹杀了波动性\n     1. 电子的双缝衍射实验表明电子具有波动性\n     2. 电子的波动性并不是很多电子在空间聚集在一起时的相互作用的结果，而是单个电子就具有波动性，是电子自己和自己的干涉\n\n#### 对波函数的统计解释\n\n1926 年，玻恩提出了对波函数 $\\Psi(\\boldsymbol{r},t)$ 的统计解释，将实物粒子的波动性和粒子性有机地结合在一起。\n\n##### 对亮度的解释\n\n1. 波的观点\n   亮度是该点德布罗意波强度的大小\n2. 粒子的观点\n   亮度与该点附近出现的感光点的数目成正比，即与该点附近电子的数目成正比，即与该点附近电子的概率成正比\n\n##### 玻恩对波函数的统计解释\n\n波函数 $\\Psi$ 是描述粒子在空间概率分布的**概率振幅**，其模的平方 $\\vert \\Psi(\\boldsymbol{r},t)\\vert ^2 = \\Psi(\\boldsymbol{r},t) ^{*} \\Psi(\\boldsymbol{r},t)$ 表示 $t$ 时刻，在坐标 $\\boldsymbol{r}$ 附近单位体积中发现一个粒子的概率，被称为**概率密度**\n\n- 目前对波函数最好的解释是概率波\n- $t$ 时刻，一个粒子处于 $x\\rightarrow x+\\mathrm{d}x$ ，$y\\rightarrow y+\\mathrm{d}y$ ，$z\\rightarrow z+\\mathrm{d}z$ 的概率为 $\\vert \\Psi(x,y,z,t)\\vert ^2\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z$，记 $\\rho(x,y,z,t)=\\vert \\Psi(x,y,z,t)\\vert ^2$ 为概率密度.\n- 在空间 $\\Omega$ 中发现粒子的概率为 $\\displaystyle \\int_{\\Omega}\\rho(x,y,z,t) \\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z$\n\n#### 波函数满足的条件\n\n1. 单值性\n   - 在空间的任何地方，概率密度只能有一个，所以一般波函数在任何地方都是单值的；\n2. 有限性\n   - 粒子必然在空间的某处出现，概率综合为 1，所以在空间的任何有限体积元 $\\mathrm{d}V$ 中，概率密度 $\\rho(x,y,z,t)$ 有限；\n   - **归一化条件**：$\\displaystyle \\int_\\Omega \\vert \\Psi(\\boldsymbol{r},t)\\vert ^{2}\\,\\mathrm{d} V =1$ ，其中 $\\Omega$ 为全空间；\n   - 归一化条件并不能排除在某些孤立奇点上 $\\vert \\Psi(\\boldsymbol{r},t)\\vert ^2 \\rightarrow \\infty$\n3. 连续性\n   - 波函数一阶导数连续（即使在势能函数有限大小间断点处）\n\n### 不确定度关系\n\n#### 形式 1（位置-动量不确定关系）\n\n当粒子处在 $x$ 方向的一个有限范围 $\\Delta x$ 内时，其动量 $p_x$ 的有一个不完全确定的数值范围 $\\Delta p_x$ ，两者的乘积满足：\n\n$$\n\\Delta x \\Delta p \\geq \\frac{\\hbar}{2}\n$$\n\n若记 $k=\\frac{2\\pi}{\\lambda}$ ，则\n\n$$\n\\Delta x \\Delta k \\geq \\frac{1}{2}\n$$\n\n- **含义**：微观粒子的位置和动量不能同时准确地测定\n- 规律\n  1. 当 $\\Delta x$ 越小，$\\Delta p$ 越大\n  2. 当 $\\Delta p$ 越小，$\\Delta x$ 越大\n\n电子的单缝衍射为例\n\n- 进入单缝之前的 $\\Delta x$ 趋向无穷大\n\n#### 形式 2\n\n若粒子在能量状态 $E$ 附近停留时间 $\\Delta t$ ，则其能量 $E$ 有一个不完全确定的数值范围 $\\Delta E$ ，两者的乘积满足：\n\n$$\n\\Delta t \\Delta E \\geq \\frac{\\hbar}{2}\n$$\n\n只有当粒子的停留时间为无穷大（定态）时，其能量才是确定的（$\\Delta E = 0$ ）\n\n#### 电子单缝衍射的结论\n\n![电子单缝衍射实验示意图](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281611015.png)\n\n- 电子通过单缝之后，动量在 $x$ 方向上的分量 $P_x$ 的大小为\n\n$$\n- p \\cdot \\sin{\\theta_1} \\leq p_x = p \\cdot \\sin{\\theta} \\leq p \\cdot \\sin{\\theta_1}\n$$\n\n- 电子通过单缝后，动量在 $x$ 方向分量的不确定量为\n\n$$\n\\Delta p_x = 2p \\cdot \\sin{\\theta_1} =\\frac{2p\\lambda}{\\Delta x}\n$$\n\n带入德布罗意关系 $p\\lambda =h$，得到\n\n$$\n\\Delta x \\cdot \\Delta p_x =2h\n$$\n\n这里的讨论只反映不确定度关系的实质，并不表示准确的量值关系\n\n## 量子力学\n\n### 薛定谔方程\n\n- 建立的是描写波函数随时间变化的方程，它必须是波函数应满足的含有对时间微商的微分方程\n- 是一个假设，无法被推导出来\n\n#### 满足的条件\n\n1. 方程是线性的\n   如果 $\\Psi_1$ 和 $\\Psi_2$ 是薛定谔方程的解，则 $a\\Psi_1 + b\\Psi_2$ 也是薛定谔方程的解\n   这是由态叠加原理决定的\n2. 方程的系数不应当包含状态参量，如动量、能量等\n   否则这个方程只能被粒子的部分状态满足\n\n#### 自由粒子的薛定谔方程\n\n动量为 $p$ 、质量为 $m$ 、能量为 $E$ 的粒子在 $x$ 方向上自由运动的薛定谔方程为\n\n$$\n\\Psi \\left(x,t\\right) =\\Psi _0 e^{-\\frac{i}{\\hbar}\\left(Et-px\\right)}\n$$\n\n**对时间求偏导**\n\n$$\n\\frac{\\partial \\Psi (x,t)}{\\partial t} = -\\frac{i}{\\hbar}E\\Psi (x,t)\n$$\n\n左右两边同乘 $i\\hbar$\n\n$$\ni\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} = E\\Psi (x,t)\n$$\n\n我们记算符 $\\hat{E}$ 为能量算符\n\n$$\n\\boxed{\\hat{E} \\equiv i\\hbar \\frac{\\partial}{\\partial t}}\n$$\n\n则\n\n$$\n\\hat{E} \\Psi (x,t) = E\\Psi (x,t)\n$$\n\n**对 $x$ 求偏导**\n\n$$\n\\frac{\\partial \\Psi (x,t)}{\\partial x} = \\frac{i}{\\hbar}p_x\\Psi (x,t)\n$$\n\n左右两边同乘 $-i\\hbar$\n\n$$\n-i\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial x} = p_x\\Psi (x,t)\n$$\n\n我们记算符 $\\hat{p_x}$ 为动量算符\n\n$$\n\\boxed{\\hat{p_x} \\equiv -i\\hbar \\frac{\\partial}{\\partial x}}\n$$\n\n则\n\n$$\n\\hat{p_x} \\Psi (x,t) = p_x\\Psi (x,t)\n$$\n\n**对 $x$ 做二次偏导**\n\n$$\n\\frac{\\partial^2 \\Psi (x,t)}{\\partial x^2} = -\\frac{p_x^2}{\\hbar^2}\\Psi (x,t)\n$$\n\n**综合考虑**\n\n$$\n\\left\\{\n  \\begin{aligned}\n    &i\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} = E\\Psi (x,t)\\\\\n    &\\frac{\\partial ^2 \\Psi (x,t)}{\\partial x^2} = -\\frac{p_x^2}{\\hbar^2}\\Psi (x,t)\n    \\end{aligned}\n\\right.\n$$\n\n由 $E = \\frac{p_x^2}{2m}$，有\n\n$$\ni\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} = E\\Psi (x,t) = -\\frac{p_x^2}{2m}\\Psi (x,t)=-\\frac{\\hbar^2}{2m}\\frac{\\partial^2 \\Psi (x,t)}{\\partial x^2}\n$$\n\n**即**\n\n$$\n\\boxed{i\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} = -\\frac{\\hbar^2}{2m}\\frac{\\partial^2 \\Psi (x,t)}{\\partial x^2}}\n$$\n\n这就是自由粒子的薛定谔方程\n\n#### 薛定谔方程的一般形式\n\n将自由粒子运动算符推广到非自由粒子运动，粒子所处的势场为 $U(x,t)$\n对于保守系统，其能量等于**哈密顿量**\n\n$$\nE = H = \\frac{p^2}{2m} + U(x,t)\n$$\n\n哈密顿量算符化，称为**哈密顿算符**\n\n$$\n\\hat{H} = \\frac{\\hat p_x^2}{2m} + U(x,t)=\\frac{-\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} + U(x,t)\n$$\n\n**薛定谔方程**：对于保守系统，其能量算符作用在波函数上，等于哈密顿算符作用在波函数上\n\n$$\n\\boxed{\\hat{E} \\Psi (x,t) = \\hat{H} \\Psi (x,t)}\n$$\n\n将其展开\n\n$$\n\\boxed{i\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} = \\left(\\frac{-\\hbar^2}{2m}\\frac{\\partial ^2}{\\partial x^2} + U(x,t)\\right) \\Psi (x,t)}\n$$\n\n推广到三维势场\n\n$$\n\\boxed{i\\hbar \\frac{\\partial \\Psi (\\boldsymbol{r},t)}{\\partial t} = \\left(-\\frac{\\hbar^2}{2m}\\nabla^2 + U(\\boldsymbol{r},t)\\right) \\Psi (\\boldsymbol{r},t)}\n$$\n\n#### 定态薛定谔方程\n\n若微观粒子在稳定的势场中，则其势能函数 $U$ 与时间无关，称这类问题为定态问题\n\n$$\n\\hat{H} = -\\frac{\\hbar^2}{2m}\\nabla^2 + U(\\boldsymbol{r})\n$$\n\n$$\n\\\ni\\hbar \\frac{\\partial}{\\partial t}\\Psi (\\boldsymbol{r},t) = \\hat{H} \\Psi (\\boldsymbol{r},t)\n$$\n\n此时哈密顿算符与时间无关，薛定谔方程可以用分离变量法求解，波函数 $\\Psi$ 分解为空间函数和时间函数的乘积\n\n设 $\\Psi (\\boldsymbol{r},t) = \\Phi(\\boldsymbol{r})T(t)$\n\n$$\ni\\hbar \\frac{\\mathrm{d} T(t)}{\\mathrm{d} t}\\Phi(\\boldsymbol{r}) = \\left[\\hat{H} \\Phi(\\boldsymbol{r})\\right] T(t)\n$$\n\n$$\ni\\hbar \\frac{1}{T(t)}\\mathrm{d} t = \\frac{1}{\\Phi(\\boldsymbol{r})}\\hat{H} \\Phi(\\boldsymbol{r}) = const = E\n$$\n\n其中 $E$ 为本征值，$\\Phi$ 为本征函数\n得到分别只含有变量 $t$ 和 $\\boldsymbol{r}$ 的两个方程\n\n$$\n\\left\\{\n\\begin{aligned}\n  &i \\hbar \\frac{\\mathrm{d} T(t)}{\\mathrm{d} t} = ET(t)  &&\\text{(1)}\\\\\n  &\\hat{H} \\Phi(\\boldsymbol{r}) = E\\Phi(\\boldsymbol{r})  &&\\text{(2)}\n\\end{aligned}\n\\right.\n$$\n\n方程(1)的解为\n\n$$\nT(t) = e^{-\\frac{i}{\\hbar}Et}\n$$\n\n方程(2)是关于变量 $x$、$y$、$z$ 的微分方程，称为**定态薛定谔方程**，又称为哈密顿算符的本征方程\n\n$$\n\\boxed{\\left[-\\frac{\\hbar^2}{2m}\\nabla^2 + U(x,y,z)\\right] \\Phi(x,y,z) = E\\Phi(x,y,z)}\n$$\n\n其解与外力场 $U$ 和边界条件有关\n波函数是两者的乘积\n\n$$\n\\boxed{\\Psi (\\boldsymbol{r},t) = \\Phi(\\boldsymbol{r})e^{-i\\frac{1}{\\hbar}Et}}\n$$\n\n- 粒子在空间中出现的几率密度与时间无关——**定态**\n\n$$\n\\vert\\Psi (\\boldsymbol{r},t)\\vert^2 =\\vert\\Phi(\\boldsymbol{r}) e^{-i\\frac{1}{\\hbar}Et}\\vert^2 = \\vert\\Phi(\\boldsymbol{r})\\vert^2\n$$\n\n#### 薛定谔方程的应用\n\n##### 一维无限深方势阱\n\n金属中的电子由于金属表面势能（能垒）的束缚而被限制在一个有限的空间范围内运动\n如果金属表面的能垒很高，可以将金属表面看成一个刚性的盒子。若只考虑一维运动，则其势能函数为\n\n$$\nU(x) =\n\\left\\{\n  \\begin{aligned}\n    &0 \\quad (0 \\leq x \\leq L)\\\\\n    &\\infty \\quad (x < 0 \\text{ or } x > L)\n  \\end{aligned}\n\\right.\n$$\n\n称为**一维无限深方势阱**\n\n![无限深方势阱](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504111721435.png)\n\n- 势阱内\n\n$$\n-\\frac{\\hbar^2}{2m}\\frac{\\mathrm{d}^2}{\\mathrm{d} x^2} \\Phi_i(x) = E\\Phi_i(x)\n$$\n\n令 $k =\\sqrt{\\frac{2mE}{\\hbar^2}}$，得\n\n$$\n\\frac{\\mathrm{d}^2\\Phi_i}{\\mathrm{d} x^2} + k^2\\Phi_i = 0\n$$\n\n其解为\n\n$$\n\\Phi_i(x)=C\\sin(kx+\\delta)\n$$\n\n其中 $C$ 和 $\\delta$ 为常数，由波函数的自然条件确定\n\n- 势阱外\n\n$$\n-\\frac{\\hbar^2}{2m}(\\frac{\\mathrm{d}^2}{\\mathrm{d}x^2}+\\infty)\\Phi_e(x) = E\\Phi_e(x)\n$$\n\n其解为\n\n$$\n\\Phi_e(x)=0\n$$\n\n- 波函数在肼壁上连续的条件为\n\n$$\n\\left\\{\n  \\begin{aligned}\n    &\\Phi_i(0) = \\Phi_e(0) \\\\\n    &\\Phi_i(L) = \\Phi_e(L) \\\\\n  \\end{aligned}\n\\right.\n$$\n\n由边界条件可得\n\n$$\n\\begin{cases}\n  \\Phi_i(0)= 0 && \\text{(1)}\\\\\n  \\Phi_i(L) = 0 && \\text{(2)}\n\\end{cases}\n$$\n\n由 $(1)$ 可得 $\\delta = 0$、\n\n由 $(2)$ 可得 $kL = n\\pi$，其中 $n\\in \\mathbb{N}^*$，即 $k = \\frac{n\\pi}{L}$\n\n$$\n\\Phi(x) =\\sqrt{\\frac{2}{L}}\\sin\\left(\\frac{n\\pi}{L}x\\right)\n$$\n\n- **粒子的能量:** $E = \\frac{\\hbar^2k^2}{2m} = \\frac{n^2\\pi^2\\hbar^2}{2mL^2}$，$n$ 为能量量子数\n  - 能量取分立值（能级），这是**能量量子化**的表现\n\n$$\n\\Delta E = E_{n+1} - E_n = \\frac{\\hbar^2}{2m}\\left(\\left(\\frac{(n+1)\\pi}{L}\\right)^2 - \\left(\\frac{n\\pi}{L}\\right)^2\\right) = (2n+1)\\frac{\\hbar^2\\pi^2}{2mL^2}\n$$\n\n- 当 $a\\uparrow$ 时 $\\Delta E \\downarrow$，并且当 $n \\rightarrow \\infty$ 时， $\\Delta E \\rightarrow 0$，即能级间隔趋于零，能级连续，形成连续谱\n- 最低能量（零点能）$E_1=\\frac{\\pi^2\\hbar^2}{amL^2}>0$，具有波动性\n- 在势阱中形成驻波\n\n$$\n\\Phi(x) =C\\sin\\left(\\frac{n\\pi}{L}x\\right)\n$$\n\n由归一化条件\n\n$$\n\\int_{-\\infty}^{+\\infty} \\vert \\Phi(x) \\vert^2\\,\\mathrm{d}x = \\int_{0}^{L} C^2\\sin^2\\left(\\frac{n\\pi}{L}x\\right)\\,\\mathrm{d}x = C^2 \\cdot \\frac{L}{2} = 1\n$$\n\n解得\n\n$$\nC = \\sqrt{\\frac{2}{L}}\n$$\n\n故定态波函数为\n\n$$\n\\Phi(x) =\n\\left\\{\n  \\begin{aligned}\n    &\\sqrt{\\frac{2}{L}}\\sin\\left(\\frac{n\\pi}{L}x\\right) && (0 \\leq x \\leq L)\\\\\n    &0 && (x < 0 \\text{ or } x > L)\n  \\end{aligned}\n\\right.\n$$\n\n###### 一维无线深方势阱中粒子的波函数和概率密度\n\n$$\n\\Phi (x,t) = \\sqrt{\\frac{2}{L}} \\sin\\left(\\frac{n\\pi}{L}x\\right), \\quad (0 \\leq x \\leq L)\n$$\n\n![波函数和概率密度](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504131458204.png)\n\n可以看出\n\n- 势阱中的粒子波函数为驻波\n- 基态 $n=1$ 除了 $x=0$ 和 $x=L$ 处为节点外，其余无节点\n- 第 $n$ 量子态有 $n-1$ 个 node\n\n###### 一维无限深势阱中粒子的波函数是正交归一的\n\n设不同能级的波函数为 $\\Phi_n(x)$ 和 $\\Phi_m(x)$\n\n- 正交性\n\n$$\n\\int_{-\\infty}^{+\\infty} \\Phi_n(x) \\Phi_m(x)\\,\\mathrm{d}x = \\int _{-\\infty }^{+\\infty }\\sqrt{\\frac{2}{L}}\\sin\\frac{m\\pi }{L} x\\cdot \\sqrt{\\frac{2}{L}}\\sin\\frac{n\\pi }{L}\\,\\mathrm{d} x=\\frac{1}{L}\\int _{0}^{L}\\left(\\cos\\frac{m-n}{L} -\\cos\\frac{m+n}{L}\\right)\\,\\mathrm{d} x=0\n$$\n\n- 归一性\n\n$$\n\\int_{-\\infty}^{+\\infty} \\Phi_n(x) \\Phi_n(x)\\,\\mathrm{d}x = \\int _{-\\infty }^{+\\infty }\\sqrt{\\frac{2}{L}}\\sin\\frac{n\\pi }{L} x\\cdot \\sqrt{\\frac{2}{L}}\\sin\\frac{n\\pi }{L}\\,\\mathrm{d} x=\\frac{1}{L}\\int _{0}^{L}\\left(\\cos 0 -\\cos\\frac{2n\\pi }{L}\\right)\\,\\mathrm{d} x=1\n$$\n\n##### 波尔对应原理\n\n- 在大量子数极限下，量子规律必须转化为经典规律，这也被称为**量子物理的对应原理**\n\n比如\n\n- 本征能量\n\n$$\nE = E_n = \\frac{\\hbar^2 \\pi^2 n^2}{2mL^2} = n^2 \\frac{h^2}{8mL^2}\n$$\n\n- 相邻能级的间隔为\n\n$$\n\\Delta E_n = (2n+1)\\frac{h^2}{8mL^2}\n$$\n\n- 相对能级间隔\n\n$$\n\\frac{\\Delta E_n}{E_n} = \\frac{2n+1}{n^2}\n$$\n\n- 当 $n\\rightarrow \\infty$ 时， $\\Delta E_n \\rightarrow 0$ ，即能级间隔趋于零，能级连续，形成连续谱\n\n粒子在势阱中的概率分布为\n\n$$\n\\rho(x) = \\vert \\Phi(x) \\vert^2 =\n\\left\\{\n  \\begin{aligned}\n    &\\frac{2}{L}\\sin^2(\\frac{n\\pi}{L}x) && (0 \\leq x \\leq L)\\\\\n    &0 && (x < 0 \\text{ or } x > L)\n  \\end{aligned}\n\\right.\n$$\n\n##### 德布罗意的驻波思想\n\n- 一个频率为 $\\nu$ 、波长 $\\lambda$ 沿 $x$ 方向传播的单色平面波的表达式为\n\n$$\n\\Psi(x,t) = \\Psi_0 e^{-i \\frac{2\\pi}{h}(Et -Px)}\n$$\n\n- 全波函数为\n\n$$\n\\begin{aligned}\n\\Psi ( x,t) =\\Phi ( x) e^{-\\frac{i}{\\hbar } Et} &=\\sqrt{\\frac{2}{L}} e^{-i\\frac{Et}{\\hbar }}\\sin\\frac{n\\pi }{L} x\\\\\n&=\\frac{1}{2i}\\sqrt{\\frac{2}{L}} e^{-i\\frac{Et}{\\hbar }}\\left( e^{i\\frac{n\\pi }{L} x} -e^{-i\\frac{n\\pi }{L} x}\\right)\\\\\n&=\\frac{1}{2i}\\sqrt{\\frac{2}{L}} e^{-i\\frac{Et}{\\hbar }}\\left( e^{i\\frac{p_{n}}{\\hbar }} -e^{-i\\frac{p_{n}}{\\hbar } x}\\right)\n\\end{aligned}\n$$\n\n可以将波函数视为频率相同、波长相同、传播方向相反的两单色平面波的叠加\n\n则由德布罗意的物质波理论，一个动量为 $p$、质量为 $m$、能量为 $E$ 的自由粒子，沿着 $x$ 轴运动的波函数为\n\n$$\n\\Psi ( x,t) =\\Psi _{0} e^{-\\frac{i}{\\hbar }( Et-px)}\n$$\n\n波函数也为频率相同、波长相同、传播方向相反的两单色平面波的叠加形成驻波\n\n- 势阱中粒子的动量和波长\n  - 动量：$p_n =\\sqrt{2mE_n} = \\pm\\frac{n\\hbar}{2L} = \\pm n \\frac{ h}{2L}$\n  - 波长：$\\lambda_n = \\frac{\\hbar}{p_n}=\\frac{2L}{n}$\n    说明势阱中粒子的每一个能量本征态正好对应德布罗意波的一个特征波长的驻波\n- 符合德布罗意的驻波理论\n\n##### 一维方势垒和隧穿效应\n\n![Tunel effect](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504181642705.png)\n\n设\n\n$$\nV(x)=\n\\begin{cases}\n    0, & x < x_1 \\quad \\text{or} \\quad x > x_2 \\\\\n    V_0, & x_1 < x < x_2\n\\end{cases}\n$$\n\n称为方势垒\n\n现有一能量为 $E$ 的粒子从左向右入射\n\n在经典力学中，若 $E < V_0$，则粒子无法穿过势垒，$E > V_0$ 时，粒子能够完全穿过势垒\n\n但是在量子力学中，粒子是一种物质波，情况完全不一样，需要通过求解薛定谔方程来确定\n\n$$\n\\frac{d^2\\psi(x)}{dx^2}=\\frac{2m}{\\hbar^2}(V_0-E)\\psi(x)\n$$\n\n在这里我们设 $V_0>E$，令 $k=\\sqrt{\\frac{2mE}{\\hbar^2}}$ 和 $k' = \\sqrt{\\frac{2m(V_0-E)}{\\hbar^2}}$\n\n则薛定谔方程可化为\n\n$$\n\\begin{cases}\n  \\frac{d^2\\psi_1(x)}{dx^2} = -k^2\\psi_1(x), & x < x_1 \\\\\n  \\frac{d^2\\psi_2(x)}{dx^2} = k'^2\\psi_2(x), & x_1 < x < x_2 \\\\\n  \\frac{d^2\\psi_3(x)}{dx^2} = -k^2\\psi_3(x), & x > x_2\n\\end{cases}\n$$\n\n解得\n\n$$\n\\begin{cases}\n  \\psi_1 = A e^{ikx} + A' e^{-ikx}, & x < x_1 \\\\\n  \\psi_2 = B e^{k'x} + B' e^{-k'x}, & x_1 < x < x_2 \\\\\n  \\psi_3 = C e^{ikx} , & x > x_2\n\\end{cases}\n$$\n\n由连续性（在这里我们令 $x_1=0$，$x_2=a$）\n\n$$\n\\begin{cases}\n  \\psi_1(0) = \\psi_2(0) \\rightarrow A + A' = B + B' \\\\\n  \\psi_1'(0) = \\psi_2'(0) \\rightarrow ik(A - A') = k' (B - B') \\\\\n  \\psi_2(a) = \\psi_3(a) \\rightarrow B e^{k'a} + B' e^{-k'a} = C e^{ika} \\\\\n  \\psi_2'(a) = \\psi_3'(a) \\rightarrow k' B e^{k'a} - k' B' e^{-k'a} = ikC e^{ika}\n\\end{cases}\n$$\n\n求解并经过计算得到\n\n- **反射系数：** $\\displaystyle R =\\frac{\\vert A'\\vert^2}{\\vert A\\vert^2} =\\frac{(k^2+k'^2)^2\\sinh^2(k'a)}{\\left(k^2+k'^2\\right)\\sinh^2(k'a) + 4k^2k'^2}$\n- **透射系数：** $\\displaystyle T =\\frac{\\vert C\\vert^2}{\\vert A\\vert^2} =\\frac{4k^2k'^2}{\\left(k^2+k'^2\\right)\\sinh^2(k'a) + 4k^2k'^2}$\n\n显然有 $\\boxed{T+R=1}$\n\n## 定态问题\n\n## 量子力学的基本假设\n\n### 波函数假设\n\n微观粒子的状态可以被一个波函数完全描述，从这个波函数可以得到体系的所有性质\n\n波函数一般满足连续性、有限性和单值性三个条件\n\n1. 物质波可以用一个随时间、空间变化的波函数 $\\Psi(\\boldsymbol{r},t)$ 来描述\n2. 自由粒子的波函数是单色平面波 $\\Psi(x,t) = \\Psi_0 e^{-i\\frac{2\\pi}{h}(Et - Px)} = \\Psi_0 e^{-i\\frac{1}{\\hbar}(Et - Px)}$\n3. 波恩：德布罗意波是描述粒子在空间概率分布的概率波\n   波函数的模的平方 $\\vert \\Psi(\\boldsymbol{r},t)\\vert^2$ 表示 $t$ 时刻，在坐标 $\\boldsymbol{r}$ 处粒子出现的概率密度\n4. 波函数满足**单值、有限、连续**的条件，称为**波函数的标准条件**\n5. **归一化条件：** 在整个空间中发现粒子的概率为 $1$，即 $\\displaystyle \\int_{\\Omega} \\vert \\Psi(\\boldsymbol{r},t)\\vert^2\\,\\mathrm{d}V = 1$，其中 $\\Omega$ 为全空间\n\n### 力学算符假设\n\n量子力学中的力学量用线性厄米（Hermite）算符表示。如果经典力学中有相关的力学量，则在量子力学中也有相应表示这个力学量的算符\n\n算符能将波函数变换为另一个波函数\n\n- 动量算符 $\\hat{p} = -i\\hbar \\nabla$\n- 位置算符 $\\hat{\\boldsymbol{r}} = \\boldsymbol{r}$\n- 能量算符 $\\hat{H} = \\frac{\\hat{p}^2}{2m} + U(\\boldsymbol{r}) = -\\frac{\\hbar ^2}{2m}\\nabla ^2 + U(\\boldsymbol{r})$\n- 角动量算符 $\\hat{\\boldsymbol{L}} =\\hat{\\boldsymbol{r}} \\times \\hat{\\boldsymbol{p}} =\\left\\vert\\begin{smallmatrix}\\boldsymbol{i} & \\boldsymbol{j} & \\boldsymbol{k} \\newline x & y & z \\newline p_x & p_y & p_z \\end{smallmatrix}\\right\\vert$\n  - $\\hat{L}_x = y\\hat{p}_z-z\\hat{p}_y$\n  - $\\hat{L}_y = z\\hat{p}_x-x\\hat{p}_z$\n  - $\\hat{L}_z = x\\hat{p}_y-y\\hat{p}_x$\n\n#### 厄米（Hermite）算符\n\n$\\hat{A}$ 是厄米算符的充分必要条件是\n\n$$\n\\int \\Psi^* \\hat{A} \\varphi \\,\\mathrm{d}V = \\int \\Psi \\left(\\hat{A} \\Psi^* \\right) \\,\\mathrm{d}V\n$$\n\n其中 $\\Psi$ 和 $\\varphi$ 是在无穷远处趋向 $0$ 的任意函数\n\n- 如果 $\\hat{A}$ 和 $\\hat{B}$ 都是厄米算符，则 $\\hat{A}\\hat{B} + \\hat{B}\\hat{A}$ 也是厄米算符\n\n**证明：**\n\n$$\n\\begin{aligned}\n&\\int _{-\\infty }^{+\\infty }\\Psi ^{*}\\left(\\hat{A}\\hat{B} + \\hat{B}\\hat{A}\\right)\\varphi\\,\\mathrm{d}x \\\\\n= &\\int _{-\\infty }^{+\\infty }\\Psi ^{*}\\hat{A}(\\hat{B}\\varphi)\\,\\mathrm{d}x + \\int _{-\\infty }^{+\\infty }\\Psi ^{*}\\hat{B}(\\hat{A}\\varphi)\\,\\mathrm{d}x\\\\\n= &\\int _{-\\infty }^{+\\infty }(\\hat{A}\\Psi) ^{*}(\\hat{B}\\varphi)\\,\\mathrm{d}x + \\int _{-\\infty }^{+\\infty }(\\hat{B}\\Psi) ^{*}(\\hat{A}\\varphi)\\,\\mathrm{d}x\\\\\n= &\\int _{-\\infty}^{+\\infty}\\left[\\varphi\\left(\\hat{B}\\hat{A}\\Psi\\right)^*+\\varphi\\left(\\hat{A}\\hat{B}\\Psi\\right)^*\\right]\\\\\n= &\\int _{-\\infty}^{+\\infty}\\varphi\\left[\\left(\\hat{A}\\hat{B}+\\hat{B}\\hat{A}\\right) \\Psi\\right]^*\\,\\mathrm{d}x\n\\end{aligned}\n$$\n\n- 如果 $\\hat{A}$ 和 $\\hat{B}$ 都是厄米算符，则 $i\\left(\\hat{A}\\hat{B} -\\hat{B}\\hat{A}\\right)$ 也是厄米算符\n\n##### 厄米算符的性质\n\n1. 对于系统的任何量子态，其厄米算符的平均值 $\\bar{F}=\\displaystyle\\int _{-\\infty}^{+\\infty} \\Psi ^*\\hat{F}\\Psi \\,\\mathrm{d}V$ 是实数\n2. **厄米算符的本征值是实数**，所以量子力学中的任何力学算符都是厄米算符\n3. **厄米算符属于不同本征值的本征函数彼此正交**\n   - **厄米算符的本征函数是正交统一的完全集**\n   - 任何物理上合理的波函数都可以用这个正交统一的完全集展开\n\n**证明：**\n\n- 平均值为实数\n\n$$\n\\bar{F} = \\int _{-\\infty}^{+\\infty} \\Psi ^*\\hat{F}\\Psi \\,\\mathrm{d}V = \\int _{-\\infty}^{+\\infty} \\left(\\hat{F}\\Psi\\right)^* \\Psi \\,\\mathrm{d}V = \\left(\\int _{-\\infty}^{+\\infty} \\Psi ^*\\hat{F}\\Psi \\,\\mathrm{d}V\\right)^* = \\bar{F}^*\n$$\n\n故 $\\bar{F}$ 是实数\n\n- 本征值是实数\n\n  由厄米算符的定义\n\n$$\n\\int _{-\\infty}^{+\\infty} \\Psi ^*\\hat{F}\\Psi_n \\,\\mathrm{d}V = \\int _{-\\infty}^{+\\infty} \\left(\\hat{F}\\Psi\\right)^* \\Psi \\,\\mathrm{d}V\n$$\n\n设 $\\hat{F}\\Psi= F\\Psi$，则\n\n$$\n\\begin{aligned}\n\t\\int _{-\\infty} ^{+\\infty} \\Psi ^*F\\Psi\\mathrm{d}\\,V &= \\int _{-\\infty}^{+\\infty} \\left(F\\Psi\\right)^* \\Psi\\,\\mathrm{d}V\\\\\n\t\\Rightarrow F\\int _{-\\infty} ^{+\\infty} \\Psi ^*\\Psi\\mathrm{d}\\,V &= F^*\\int _{-\\infty}^{+\\infty} \\Psi^* \\Psi\\,\\mathrm{d}V\n\\end{aligned}\n$$\n\n则 $F=F^*$，故本征值为实数\n\n- 属于不同本征值的本征函数正交\n\n  由厄米算符的定义\n\n$$\n\\begin{aligned}\n  \\int \\Psi _{m}^{*}\\hat{F} \\Psi _{n} \\, \\mathrm{d}V&=\\int (\\hat{F} \\Psi _{m})^{*} \\Psi _{n} \\, \\mathrm{d} V\\\\\nF_{n}\\int \\Psi m^{*} \\Psi _{n}\\,\\mathrm{d} V&=F_{m}^{*}\\int \\Psi _{m}^{*} \\Psi _{n} \\, \\mathrm{d} V\\\\\n( F_{n} -F_{m})\\int \\Psi _{m}^{*} \\Psi _{n} \\,\\mathrm{d} V&=0\n\\end{aligned}\n$$\n\n$\\displaystyle m\\neq n$，则 $\\displaystyle \\int \\Psi _m^n \\Psi _n \\, \\mathrm{d} V=1$，则 $\\displaystyle F_n =F_m$\n\n这里有 $\\displaystyle \\int \\Psi _m^*\\Psi _n \\, \\mathrm{d}V = \\delta _{nm} =\\begin{cases} 0 &,n\\neq m\\\\ 1 &,n=m\\end{cases}$\n\n- 波函数可以用正交统一的完全集展开 $\\displaystyle\\Psi = \\sum _n c_n\\Psi _n$\n\n  使用数学归纳法，假设当 $n$ 时成立\n\n$$\n\\begin{aligned}\n  & \\Psi &&= \\sum _{n} c_n\\Psi _n \\\\\n  & \\Psi _m^*\\Psi &&= \\sum _{n} c_n\\Psi _m^*\\Psi _n\\\\\n  & \\int\\Psi _m^*\\Psi \\,\\mathrm{d}V &&= \\sum _{n} c_n\\int \\Psi _m^*\\Psi _n \\,\\mathrm{d}V \\\\\n  &                                   &&= \\sum _n c_n \\delta _{mn}\\\\\n  &                                  &&= c_m\\\\\n\\end{aligned}\n$$\n\n可以得到 $\\displaystyle c_m = \\int \\Psi _m^*\\Psi \\,\\mathrm{d}V$ ，当 $m$ 时成立\n\n### 测量假设\n\n当一个量子系统处于量子态 $\\Psi$ 时，对力学量 $\\hat{F}$ 的测量结果一定是该力学算符的本征值之一，结果为 $F_n$ 的概率为 $\\left\\vert c_n\\right\\vert ^2 = \\left\\vert\\int \\phi_n^*\\Psi\\,\\mathrm{d}V\\right\\vert^2$\n\n这里 $\\hat{F}\\varphi _n = F_n\\varphi _n$ 是力学量 $\\hat{F}$ 的本征方程，测量完成后，该量子系统坍缩至 $\\varphi _n$\n\n**结论**\n\n- 根据测量假设，当一个量子系统处在量子态 $\\Psi$ 时，对力学量 $\\hat{F}$ 的测量结果的统计平均值为\n\n$$\n\\bar{F} = \\sum _n F_n \\left\\vert c_n \\right\\vert ^2 = \\sum _n F_n \\left\\vert \\int\\phi_n^*\\Psi\\,\\mathrm{d}V\\right\\vert ^2 =\\boxed{\\int \\Psi^* \\hat{F} \\Psi\\,\\mathrm{d}V}\n$$\n\n**证明：**\n\n$$\n\\begin{aligned}\n   &\\int \\Psi ^* \\hat{F} \\Psi \\mathrm{d}V\\\\\n   =&\\int \\left(\\sum_m c_m\\Psi_m\\right)^*\\hat{F}\\left(\\sum_n c_n\\Psi_n\\right)\\mathrm{d}V\\\\\n   =&\\int \\left(\\sum_m c_m\\Psi_m\\right)^*\\left(\\sum_n c_n \\hat{F}\\Psi_n\\right)\\mathrm{d}V\\\\\n   =&\\int \\left(\\sum_m c_m\\Psi_m\\right)^*\\left(\\sum_n c_n F_n\\Psi_n\\right)\\mathrm{d}V\\\\\n   =&\\sum_{mn}c_m c_n F_n \\int \\left(\\Psi_m^*\\Psi_n\\right)\\mathrm{d}V\\\\\n   =&\\sum_{mn}c_m c_n F_n \\delta _{mn}\\\\\n   =&\\sum_n\\left\\vert c_n \\right\\vert ^2 F_n\n\\end{aligned}\n$$\n\n- 测量假设推论：当一个量子系统处于量子态 $\\Psi$ 时，且满足 $\\displaystyle \\sum _n \\vert c_n\\vert^2=1$ 时，对力学量的测量结果一定是该力学算符的本征值之一，测量结果为 $F_n$ 的概率为 $\\vert c_n \\vert^2$，测量完成之后，该量子系统探索至 $\\phi_n$\n\n#### 动量本征方程\n\n$$\n-i\\hbar\\nabla\\Phi _{\\boldsymbol{r}}(\\boldsymbol{r}) = \\hat{p}\\Phi _{\\boldsymbol{r}}(\\boldsymbol{r}) = p\\Phi _{\\boldsymbol{r}}(\\boldsymbol{r})\n$$\n\n其在三个坐标轴上的分量为\n\n$$\n\\begin{cases}\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{r}}}{\\partial x} = p_x\\Phi _{\\boldsymbol{r}}\\\\\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{r}}}{\\partial y} = p_y\\Phi _{\\boldsymbol{r}}\\\\\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{r}}}{\\partial z} = p_z\\Phi _{\\boldsymbol{r}}\n\\end{cases}\n$$\n\n其解为\n\n$$\n\\Phi _{\\boldsymbol{p}}(\\boldsymbol{r}) = \\frac{1}{(2\\pi\\hbar)^\\frac{3}{2}}e^{\\frac{i}{\\hbar}\\boldsymbol{p}\\cdot \\boldsymbol{r}}\n$$\n\n测量结果为 $p$ 的概率密度为\n\n$$\n\\vert c_p \\vert^2 = \\left\\vert \\int \\Phi_p^*\\Psi\\,\\mathrm{d}v\\right\\vert^2 = \\left\\vert \\int \\frac{1}{(2\\pi\\hbar)^\\frac{3}{2}}e^{-\\frac{i}{\\hbar}\\boldsymbol{p}\\cdot \\boldsymbol{r}}\\Psi\\,\\mathrm{d}v\\right\\vert^2\n$$\n\n统计平均值为\n\n$$\n\\bar{p} = \\sum_{n} p_i\\vert c_{p_i} \\vert ^2\n$$\n\n#### 动能本征方程\n\n$$\n-i\\hbar \\nabla \\Phi _{\\boldsymbol{p}}(\\boldsymbol{r}) = \\hat{p}\\Phi _{\\boldsymbol{p}}(\\boldsymbol{r})\n$$\n\n其在三个坐标轴的分量为\n\n$$\n\\begin{cases}\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{p}}}{\\partial x} = p_x\\Phi _{\\boldsymbol{p}}\\\\\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{p}}}{\\partial y} = p_y\\Phi _{\\boldsymbol{p}}\\\\\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{p}}}{\\partial z} = p_z\\Phi _{\\boldsymbol{p}}\n\\end{cases}\n$$\n\n记动能算符为 $\\hat{T}$\n\n$$\n\\hat{T}\\Phi _{\\boldsymbol{p}}(\\boldsymbol{r}) = -\\frac{\\hbar^2}{2m}\\nabla ^2\\Phi _{\\boldsymbol{p}}(\\boldsymbol{r})= \\frac{\\hat{p}^2}{2m}\\Phi _{\\boldsymbol{p}}(\\boldsymbol{r})\n$$\n\n所以**动量的本征函数等于动能的本征函数**\n\n同样当一个量子系统处于量子态 $\\Psi$ 时，测量动能为 $\\frac{p^2}{2m}$ 的概率为\n\n$$\n\\vert c_{\\frac{p^2}{2m}} \\vert^2 = \\left\\vert \\int \\Phi_{\\frac{p^2}{2m}}^*\\Psi\\,\\mathrm{d}v\\right\\vert^2 = \\left\\vert \\int \\frac{1}{(2\\pi\\hbar)^\\frac{3}{2}}e^{-\\frac{i}{\\hbar}\\boldsymbol{p}\\cdot \\boldsymbol{r}}\\Psi\\,\\mathrm{d}v\\right\\vert^2\n$$\n\n统计平均值为\n\n$$\n\\bar{\\frac{p^2}{2m}} = \\sum_{n} \\frac{p_i^2}{2m}\\vert c_{\\frac{p_i^2}{2m}} \\vert ^2\n$$\n\n### 态叠加原理\n\n如果 $\\Psi_1 , \\Psi_2 \\ldots$ 是体系的一系列可能的状，则 $\\displaystyle\\Psi = \\sum _i ^n c_n\\Psi_n$ 也是体系的一个可能的状态。对于处于 $\\Psi$ 态的体系，该体系分别部分地处在 $\\Psi_1 , \\Psi_2 \\ldots \\Psi_n \\ldots$ 态中\n\n### 薛定谔方程\n\n波函数随时间演化满足**薛定谔方程**\n\n$$\n\\boxed{i\\hbar \\frac{\\partial \\Psi (\\boldsymbol{r},t)}{\\partial t} = \\hat{H} \\Psi (\\boldsymbol{r},t)}\n$$\n\n#### 定态问题\n\n若粒子处于稳定的势场中，则势能函数 $U$ 与时间无关，称这类问题为定态问题\n\n$$\n\\Psi(\\boldsymbol{r} , t) = \\Phi(\\boldsymbol{r})e^{-i\\frac{1}{\\hbar}Et}\n$$\n\n$$\n\\left[ -\\frac{\\hbar^2}{2m}\\nabla^2   + U(\\boldsymbol{r})\\right] \\Phi(\\boldsymbol{r}) = E\\Phi(\\boldsymbol{r})\n$$\n\n也称为哈密顿算符的本征方程\n\n### 同类粒子的不可分辨性原理\n\n在量子力学中，内禀属行完全相同的粒子是**不可分辨**的，对任意这两个粒子进行交换，不会改变系统的状态\n\n经典力学中，能够得到粒子的运动方程和轨道方程 $\\vec{r} = \\vec{r}(t)$，然而在量子力学中，只能得到粒子在空间中分布的概率密度 $\\rho=\\vert\\Psi(\\boldsymbol{r},t)\\vert^2$，而不能得到粒子在空间中的轨道方程，因此得不到粒子的轨道方程\n\n对于内禀性相同的粒子，因为没有轨道方程，所以无法分辨，对于任意的两个这样的粒子进行交换，不会改变系统的状态，即粒子在空间中出现的概率密度不会改变\n\n$$\n\\begin{aligned}\n  &&\\left\\vert\\Psi(1,\\ldots , i , \\ldots , j \\ldots n)\\right\\vert &= \\left\\vert\\Psi(1,\\ldots , j , \\ldots , i \\ldots n)\\right\\vert\\\\\n  \\Rightarrow&&\\Psi(1,\\ldots , i , \\ldots , j \\ldots n) &= e^{i\\theta}\\Psi(1,\\ldots , j , \\ldots , i \\ldots n)\n\\end{aligned}\n$$\n\n实验表明，所有粒子可以分为两类\n\n1. **玻色子：** $\\theta=0$，交换粒子后波函数不变\n2. **费米子：** $\\theta=\\pi$，交换粒子后波函数反对称\n\n### 算符之间的对易关系\n\n两个算符 $\\hat{A}$ 和 $\\hat{B}$ 的对易子记为 $\\left[\\hat{A} , \\hat{B}\\right] = \\hat{A}\\hat{B}-\\hat{B}\\hat{A}$\n\n#### 动量算符和坐标算符之间的对易关系\n\n$$\n\\left[x,\\hat{p}_{x}\\right] = -i\\hbar\n$$\n\n**证明：**\n\n将 $\\left[x,\\hat{p}_x\\right] = x\\hat{p}_X - \\hat{p}_x x$ 作用于任意波函数 $\\Psi$ 上\n\n$$\n\\begin{aligned}\n  \\left[x,\\hat{p}_{x}\\right]\\Psi &= \\left(x\\hat{p}_{x} - \\hat{p}_x x\\right)\\Psi\\\\\n  &=-i\\hbar\\left(x\\frac{\\partial}{\\partial x} - \\frac{\\partial}{\\partial x}x\\right)\\Psi\\\\\n  &=-i\\hbar\\left[x\\frac{\\partial \\Psi}{\\partial x}-\\frac{\\partial}{\\partial x}\\left(x\\Psi\\right)\\right]\\\\\n  &=i\\hbar\\Psi\n\\end{aligned}\n$$\n\n故 $\\left[x,\\hat{p}_{x}\\right] = -i\\hbar$\n\n### 共同本征函数\n\n#### 两个算符对易\n\n如果两个算符 $\\hat{A}$ 和 $\\hat{B}$ 满足对易子为 $0$ ，即 $\\left[\\hat{A},\\hat{B}\\right] = \\hat{A}\\hat{B} - \\hat{B}\\hat{A} = 0$，则称这两个算符**对易**\n\n#### 对易的一个定理\n\n若两个力学量算符有一组共同完备的本征函数系，则二算符对易\n\n**证明：**\n\n假设\n\n$$\n\\begin{cases}\n  \\hat{F}\\varphi _n = F_n \\varphi _n\\\\\n  \\hat{G}\\varphi _n = G_n \\varphi _n\n\\end{cases}\n$$\n\n$\\varphi$ 组成完备系，则任意量子态 $\\Phi(x)$ 可以按其展开为 $\\Phi(x) = \\sum _n c_i \\varphi _i (x)$\n\n则\n\n$$\n\\begin{aligned}\n  \\left(\\hat{F}\\hat{G}-\\hat{G}\\hat{F}\\right)\\Psi(x)\n  &= \\left(\\hat{F}\\hat{G}-\\hat{G}\\hat{F}\\right)\\sum _n c_n \\varphi _n (x)\\\\\n  &= \\sum _n c_n \\left(\\hat{F}\\hat{G}-\\hat{G}\\hat{F}\\right)\\varphi _n (x)\\\\\n  &= \\sum _n c_n \\left(F_nG_n - G_nF_n\\right)\\varphi _n (x)\\\\\n  & = 0\n\\end{aligned}\n$$\n\n由于 $\\Psi(x)$ 是任意的函数，则 $\\hat{F}\\hat{G} = \\hat{G}\\hat{F}$\n\n- **其逆定理：** 若两个力学算符对易，则这两个算符有组成完备系的共同本征函数\n\n**证明：**\n\n已知 $\\hat{F}\\hat{G} = \\hat{G}\\hat{F}$，$\\hat{F}\\phi_n=F\\phi_n$\n\n$$\n\\hat{F}\\hat{G}\\varphi _n = \\hat{G}\\hat{F}\\varphi _n= F\\hat{G}\\varphi _n\n$$\n\n即\n\n$$\n\\hat{F}\\left(\\hat{G}\\varphi _n\\right) = F\\left(\\hat{G}\\varphi _n\\right)\n$$\n\n说明 $\\hat{G}\\varphi _n$ 也是 $\\hat{F}$ 的本征函数，本征值为 $F$\n故 $\\hat{G}\\varphi _n$ 和 $\\varphi _n$ 表示统一个量子态，$\\hat{G}\\varphi _n = G\\varphi$\n\n### 力学量完全集合\n\n- **定义：**能够完全确定状态的一组两两对易的力学量算符的最小（数目）集称为**力学量完全集**\n- 力学量完全集中的力学量数目一般与体系自由度数相同\n- 由力学量的完全集所确定的本征函数系构成该体系态空间的一组完备的本征函数，即体系中的任何状态均可用它展开\n\n### 角动量算符之间的对易关系\n\n#### 角动量算符\n\n- $\\displaystyle \\left[\\hat{L}_{x} , \\hat{L}_y\\right] = i\\hbar \\hat{L}_z$\n- $\\displaystyle \\left[\\hat{L}_{y} , \\hat{L}_z\\right] = i\\hbar \\hat{L}_x$\n- $\\displaystyle \\left[\\hat{L}_{z} , \\hat{L}_x\\right] = i\\hbar \\hat{L}_y$\n\n#### 角动量平方算符\n\n$$\n\\begin{aligned}\n\\hat{L} ^2 =\\hat{L} \\cdot \\hat{L} &= \\hat{L}_x^2 + \\hat{L}_y^2 + \\hat{L}_z^2\\\\\n  &= -\\hbar ^2 \\left[ \\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial}{\\partial\\theta}\\right)+\\frac{1}{\\sin\\theta^2}\\frac{\\partial^2}{\\partial \\varphi^2}\\right]\n\\end{aligned}\n$$\n\n$$\n\\left[\\hat{L}^2 , \\hat{L}_x\\right] = \\left[\\hat{L}^2 , \\hat{L}_y\\right] = \\left[\\hat{L}^2 , \\hat{L}_z\\right] = 0\n$$\n\n##### 角动量算符的本征方程\n\n$$\n\\begin{aligned}\n  &&-\\hbar ^2 \\left[ \\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial}{\\partial\\theta}\\right)+\\frac{1}{\\sin^2\\theta}\\frac{\\partial^2}{\\partial \\varphi^2}\\right]Y &= \\mu \\hbar ^2 Y\\\\\n  \\Rightarrow &&\\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial Y}{\\partial\\theta}\\right)+\\frac{1}{\\sin^2\\theta}\\frac{\\partial^2}{\\partial \\varphi^2}Y +\\mu Y &= 0\n\\end{aligned}\n$$\n\n令 $Y(\\theta , \\varphi) =\\Theta(\\theta) f(\\varphi)$，得到\n\n$$\n\\begin{aligned}\n  &\\frac{sin\\theta}{\\Theta}\\frac{\\partial}{\\partial \\theta}\\left(\\sin\\theta\\frac{\\partial\\Theta}{\\partial \\theta }\\right) + \\mu\\sin^2\\theta = -\\frac{1}{f}\\frac{\\partial ^2 f}{\\partial\\varphi ^2} = const = \\lambda\\\\\n  \\Rightarrow &\n  \\begin{cases}\n    \\frac{1}{\\sin\\theta}\\frac{\\mathrm d}{\\mathrm{d}\\theta}\\left(\\sin\\theta\\frac{\\mathrm{d}\\Theta}{\\mathrm{d}\\theta}\\right) +\\left(\\mu -\\frac{\\lambda}{\\sin^2\\theta}\\right)\\Theta = 0\\\\\n    \\frac{\\mathrm{d}^2 f}{\\mathrm{d}\\varphi ^2} +\\lambda f = 0\n  \\end{cases}\n\\end{aligned}\n$$\n\n先处理关于 $\\varphi$ 的方程\n\n令 $\\lambda = m_l ^2 , m_l = 0, \\pm 1, \\pm 2, \\ldots$，则\n\n$$\nf(\\varphi) = A\\cos(m_l \\varphi) + B\\sin(m_l \\varphi)\n$$\n\n再处理关于 $\\theta$ 的方程\n\n$$\n\\begin{aligned}\n  &\\frac{1}{\\sin\\theta}\\frac{\\mathrm d}{\\mathrm{d}\\theta}\\left(\\sin\\theta\\frac{\\mathrm{d}\\Theta}{\\mathrm{d}\\theta}\\right) +\\left(\\mu -\\frac{\\lambda}{\\sin^2\\theta}\\right)\\Theta = 0\\\\\n  \\Rightarrow & \\frac{1}{\\sin\\theta}\\frac{\\mathrm d}{\\mathrm{d}\\theta}\\left(\\sin\\theta\\frac{\\mathrm{d}\\Theta}{\\mathrm{d}\\theta}\\right) +\\left(\\mu -\\frac{m_l^2}{\\sin^2\\theta}\\right)\\Theta = 0\\\\\n\\end{aligned}\n$$\n\n令 $x = \\cos \\theta ,y(x) = \\Theta(\\theta)$，则\n\n$$\n\\frac{1}{1-x^2}\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2} -2x\\frac{\\mathrm{d}y}{\\mathrm{d}x}+ \\left(\\mu -\\frac{m_l^2}{1-x^2}\\right)y = 0 \\quad\\left(\\text{连带勒让德方程}\\right)\n$$\n\n- **本征值：**$\\mu = l(l+1)$，$l=0,1,2,\\ldots$\n- $\\Theta(\\theta) = P_l^m\\left(\\theta\\right)$\n\n则角动量平方算符的本征方程变为\n\n$$\n\\hat{L}^2 Y_{l,m_l} = -\\hbar ^2 \\left[\\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial}{\\partial\\theta}\\right)+\\frac{1}{\\sin^2\\theta}\\frac{\\partial^2}{\\partial \\varphi^2}\\right]Y_{l,m_l} = l(l+1)\\hbar ^2 Y_{l,m_l}\n$$\n\n其解为\n\n$$\nY_{L,m_l}(\\theta , \\varphi) = (-1)^{m_l}\\sqrt{\\frac{(2l+1)(l-\\vert m_l\\vert)!}{4\\pi (l+\\vert m_l\\vert)!}}P_l^{m_l}(\\cos\\theta)e^{im_l\\varphi}\n$$\n\n其中 $l = 0 , 1 , 2 , \\ldots$ ，$m_l = -l , -l +1 , \\ldots , l$\n该函数同时也为角动量算符 $\\hat{L}_z$ 的本征函数\n\n##### 统计平均值\n\n当一个量子系统处于量子态 $\\Psi$ 时，且满足 $\\displaystyle \\Psi\\left(\\theta , \\varphi\\right) = \\sum_{l}\\sum_{m_l=-1}^l c_{l,m_l}Y_{l,m_l}\\left(\\theta , \\varphi\\right)$ ，$\\sum_{l}\\sum_{m_l = -1}^l =\\left\\vert c_{l,l_m}\\right\\vert^2 = 1$ 时，对测量结果为 $l(l+1)\\hbar ^2$ 的概率为 $\\left\\vert c_{l,m_l}\\right\\vert^2$，测量完成之后，该量子系统坍缩至 $Y_{l,m_l}$\n\n统计平均值为\n\n$$\n\\bar{L}^2 = \\sum_{l}l(l+1)\\hbar ^2 \\sum_{m_l=-l}^{l} \\left\\vert c_{l,m_l}\\right\\vert^2\n$$\n\n对角动量 $z$ 分量进行测量的结果一定是该力学量算符的本征值之一，测量结果为 $m_l\\hbar$ 的概率为 $\\left\\vert c_{l,m_l}\\right\\vert^2$ ，测量完成之后，该量子系统坍缩至 $Y_{l,m_l}$\n\n统计平均值为\n\n$$\n\\bar{L}_z = \\sum_{l}  \\sum_{m_l=-l}^{l} m_l\\hbar\\left\\vert c_{l,m_l}\\right\\vert^2\n$$\n\n这里角动量平方算符和角动量算符的本征方程分别为\n\n$$\n\\hat{L}^2 Y_{l,m_l} = l(l+1)\\hbar ^2 Y_{l,m_l}\n$$\n\n$$\n\\hat{L}_z Y_{l,m_l} = m_l\\hbar Y_{l,m_l}\n$$\n\n## 算符与电子自旋\n\n### 未归一化的量子态下的算符平均值\n\n$$\n\\bar{A} = \\frac{\\iiint \\Psi^*(x,y,z)\\hat{A}\\Psi(x,y,z)\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z}{\\iiint \\Psi^*(x,y,z)\\Psi(x,y,z)\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z}\n$$\n\n### 线性算符\n\n线性算符 $\\hat{F}$ 满足\n\n$$\n\\hat{F}\\left(a\\Psi_1 + b\\Psi_2\\right) = a\\hat{F}\\Psi_1 + b\\hat{F}\\Psi_2\n$$\n\n位置算符 $\\hat{x} = x$ 和动量算符 $\\hat{p_x} = -i\\hbar\\frac{\\partial}{\\partial x}$ 均为线性算符\n\n由于态叠加原理，哈密顿算符 $\\hat{H}$ 也是线性算符，薛定谔方程是线性微分方程，则若 $\\Psi_1$ 和 $\\Psi_2$ 是薛定谔方程的解，则 $c_1\\Psi_1 + c_2\\Psi_2$ 也是薛定谔方程的解\n\n对于定态薛定谔方程也满足这个条件\n\n态叠加原理要求算符是线性的厄米算符\n\n### 厄米算符\n\n#### 厄米算符的本征值是实数\n\n#### 厄米算符的平均值是实数\n\n#### 厄米算符本征值具有正交性\n\n当两个函数 $\\Psi_q$ 和 $\\Psi_2$ 满足下列关系\n\n$$\n\\int \\Psi_1^*\\Psi_2\\,\\mathrm{d}x \\equiv \\int \\left\\langle\\Psi_1\\vert\\Psi_2\\right\\rangle =0\n$$\n\n则我们称这两个函数相互正交，$\\left\\langle\\Psi_1\\vert\\Psi_2\\right\\rangle$ 称为内积\n\n厄米算符两个不同本征值的本征函数总是正交的\n\n**证明：**\n\n（待补充 o_O）\n\n将这些正交的本征函数归一化，$\\displaystyle \\int \\Psi_1^*\\Psi_2\\,\\mathrm{d}x = 1$，所以**厄米算符**有一组正交化的本征函数\n\n$$\n\\int \\Psi_k^*\\Psi_l\\,\\mathrm{d}x =\\delta_{kl} =\n\\begin{cases}\n  0 &,k\\neq l\\\\\n  1 &,k=l\n\\end{cases}\n$$\n\n所以厄米算符的分立谱的所有本征函数都是正交归一化的\n\n### 动量算符的厄米性\n\n**证明：**\n\n（待补充）\n\n### 算符运算初步\n\n#### 算符之和\n\n$$\n\\hat{A} + \\hat{B} = \\hat{C}\n$$\n\n$$\n\\hat{C}\\Psi = \\left(\\hat{A}+\\hat{B}\\right)\\Psi=\\hat{A}\\Psi + \\hat{B}\\Psi\n$$\n\n#### 算符之积\n\n$$\n\\hat{A}\\hat{B} = \\hat{C}\n$$\n\n$$\n\\hat{C}\\Psi = \\hat{A}\\left(\\hat{B}\\Psi\\right)\n$$\n\n一般情况下，算符之积**不满足**交换律，即\n\n$$\n\\hat{A}\\hat{B} \\neq \\hat{B}\\hat{A}\n$$\n\n#### 算符的对易性\n\n如果 $\\hat{A}\\hat{B} = \\hat{B}\\hat{A}$，则称 $\\hat{A}$ 和 $\\hat{B}$ 是**对易的**\n\n记为 $\\left[\\hat{A},\\hat{B}\\right] \\equiv \\hat{A}\\hat{B} - \\hat{B}\\hat{A} = 0$，称 $\\left[\\hat{A},\\hat{B}\\right]$ 为 $\\hat{A}$ 和 $\\hat{B}$ 的**对易子**\n\n### 电子自旋\n\n#### 电子自旋角动量及其空间量子化\n\n##### 斯特恩-盖拉赫实验\n\n![Stern-Garlach experiment](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192235176.png)\n\n![磁力线](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192240318.png)\n\n磁铁的特殊形状使得磁极之间的磁力线不是均匀的，从而产生非匀强磁场\n\n在非匀强磁场之中，银原子和磁场的相互作用能为\n\n$$\nW = -\\boldsymbol{M}\\cdot\\boldsymbol{B}\n$$\n\n对 $z$ 方向求微分\n\n$$\nF_z = -\\frac{\\partial W}{\\partial z} = M_z \\frac{\\partial B}{\\partial z}\n$$\n\n实验结果为\n\n![result](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192317946.png)\n\n加入磁场之后，银原子分裂为两束。银原子的角动量数 $l=0$，且最外层为 $s$ 电子，无轨道角动量，说明会银原子有自由度，且有两个取值\n\n###### 斯特恩-盖拉赫实验的意义\n\n1. 证明了角动量空间量子化的存在\n   - 原子沉积层不是连续的一片，而是分开的线，说明了角动量空间量子化的存在\n2. 发现了新的矛盾\n   - $l=0$，应当有一条沉积线，但是实验结果却又两条沉积线，这说明原来对原子中的电子运动的描述是不完全的\n3. 提供了原子的“态分离”技术\n\n###### 理论解释\n\n1925 年乌伦贝克和古兹米特根据斯特恩-盖拉赫实验的结果，**提出了电子不是指点，具有固有的自旋角动量 $\\boldsymbol{S}$ 和相应的自旋磁矩 $\\boldsymbol{\\mu_s}$** 的观点\n\n![电子自旋角动量和磁矩](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192340149.png)\n\n由于电子带负电，其自旋磁矩和根据右手螺旋定律得到的方向相反\n\n相对于外磁场方向，$\\boldsymbol{B}$ 有朝上和朝下两种取向\n\n但是若将电子视为 $r=10^{-16}m$ 的小球，按照 $\\boldsymbol{S}\\sim\\hbar$ 估计得到的电子表面速度 $>c$\n\n电子在任意一个方向测量其自旋角动量的结果都是 $\\pm\\hbar$\n\n##### 泡利不相容原理\n\n1. 费米子和玻色子\n   1. **费米子：** 自旋量子数为半奇数的粒子\n   2. **玻色子：** 自旋量子数为整数的粒子\n2. 泡利不相容原理\n   - 不能有两个电子具有相同的 $n,m,l,m_l,m_s$\n3. 玻色凝聚\n   - 玻色子不受泡利不相容原理的限制，一个单粒子态可容纳多个玻色子\n\n##### 电子的自旋算符和自旋波函数\n\n###### 自旋算符\n\n自旋角动量是纯量子概念，但也是一个力学量\n\n自旋角动量与电子的坐标和动量无关，是电子内部状态的表征，是描述电子状态的第四个自由度\n\n自旋算符记为 $\\hat{S}$\n\n- $\\hat{\\boldsymbol{S}}\\times\\hat{\\boldsymbol{S}} =i\\hbar\\hat{\\boldsymbol{S}}$\n- $[\\hat{\\boldsymbol{S}_x},\\hat{\\boldsymbol{S}}_y] = i\\hbar \\hat{\\boldsymbol{S}}_z$\n- $[\\hat{\\boldsymbol{S}}_y,\\hat{\\boldsymbol{S}}_z] = i\\hbar \\hat{\\boldsymbol{S}}_x$\n- $[\\hat{\\boldsymbol{S}}_z,\\hat{\\boldsymbol{S}}_x] = i\\hbar \\hat{\\boldsymbol{S}}_y$\n\n由于**自旋角动量**在空间任意方向上的投影都只能取 $\\pm\\frac{\\hbar}{2}$，则 $\\hat{\\boldsymbol{S}}_x$，$\\hat{\\boldsymbol{S}}_y$ 和 $\\hat{\\boldsymbol{S}}_z$ 的本征值都是 $\\pm\\frac{\\hbar}{2}$，其平方为 $\\frac{\\hbar}{2}^2$\n\n###### 含自旋的状态波函数\n\n电子的含自旋的波函数为\n\n$$\n\\Psi =\\Psi(x,y,z,S_z,t)\n$$\n\n由于 $S_z$ 只有两个取值 $\\pm\\frac{\\hbar}{2}$，所以可以写为两个分量\n\n$$\n\\begin{cases}\n  \\psi_1=\\psi(x,y,z,\\frac{\\hbar}{2},t)\\\\\n  \\psi_2=\\psi(x,y,z,-\\frac{\\hbar}{2},t)\n\\end{cases}\n$$\n\n写作列矩阵\n\n$$\n\\Psi = \\begin{pmatrix}\n  \\psi_1(\\boldsymbol{r},t)\\\\\n  \\psi_2(\\boldsymbol{r},t)\n\\end{pmatrix}\n$$\n\n这里的正负号是规定好的\n\n若已知电子处于 $S_z = \\frac{\\hbar}{2}$ 或 $S_z = -\\frac{\\hbar}{2}$ 的状态，则其波函数分别可以写为：\n\n$$\n\\Psi = \\begin{pmatrix}\n  \\psi_1(\\boldsymbol{r},t)\\\\\n  0\n\\end{pmatrix}\n\\qquad\n\\Psi = \\begin{pmatrix}\n  0\\\\\n  \\psi_2(\\boldsymbol{r},t)\n\\end{pmatrix}\n$$\n\n###### 自旋算符的矩阵表示，Pauli 矩阵\n\n**$\\hat{S}_z$ 的矩阵形式**\n\n$$\n\\hat{S}_z = \\frac{\\hbar}{2}\n\\begin{pmatrix}\n  1 & 0\\\\\n  0 & -1\n\\end{pmatrix}\n$$\n\n**Pauli 算符**\n\n对于 $\\hat{S}_z$ 的矩阵形式，我们定义 Pauli 算符，使得\n\n$$\n\\hat{S}_z = \\frac{\\hbar}{2}\\hat{\\sigma}\n$$\n\n从自旋算符与 Pauli 矩阵之间的关系，可以得到自旋算符的矩阵表示\n\n$$\n\\hat{S}_x = \\frac{\\hbar}{2}\\begin{pmatrix}\n  0 & 1\\\\\n  1 & 0\n\\end{pmatrix}\n\\quad\n\\hat{S}_y = \\frac{\\hbar}{2}\\begin{pmatrix}\n  0 & -i\\\\\n  i & 0\n\\end{pmatrix}\n\\quad\n\\hat{S}_z = \\frac{\\hbar}{2}\\begin{pmatrix}\n  1 & 0\\\\\n  0 & -1\n\\end{pmatrix}\n$$\n\n###### 自旋波函数\n\n波函数 $\\Psi = \\begin{pmatrix}\\psi_1\\newline \\psi_2\\end{pmatrix}$ 中，一般情况下，$\\Psi_1\\neq\\Psi_2$，两者对 $(x,y,z)$ 的依赖是不相同的，因为自旋对轨道运动有一定的影响，但是当影响足够小时，可以忽略，此时认为 $\\Psi_1$ 和 $\\Psi_2$ 的函数形式相同，$\\Psi$ 可以写作如下的形式\n\n$$\n\\Psi(\\boldsymbol{r},S_z,t) =\\psi(\\boldsymbol{r},t)\\chi(S_z)\n$$\n\n其中 $\\chi(S_z)$ 是 $\\hat{S}_z$ 的本征函数，称为自旋波函数\n\n$$\n\\chi_{\\frac{1}{2}}(S_z) = \\begin{pmatrix}\n  1\\\\\n  0\n\\end{pmatrix}\n\\quad\n\\chi_{-\\frac{1}{2}}(S_z) = \\begin{pmatrix}\n  0\\\\\n  1\n\\end{pmatrix}\n$$\n\n这两个自旋波函数相互正交\n\n### 无限深势阱\n\n### 谐振子\n\n#### 势能\n\n若先择线性谐振子平衡位置为坐标原点和势能零点，则一维线性谐振子得到势能可以表示为\n\n$$\nU(x) = \\frac{1}{2}kx^2 = \\frac{1}{2}m\\omega^2x^2\n$$\n\n##### 谐振子的定态薛定谔方程\n\n一维谐振子的哈密顿量为\n\n$$\n\\hat{H} = -\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} + \\frac{1}{2}m\\omega^2x^2\n$$\n\n满足的定态薛定谔方程为\n\n$$\n\\left[-\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} + \\frac{1}{2}m\\omega^2x^2\\right]\\Phi(x) = E\\Phi(x)\n$$\n\n一维谐振子的能量是量子化的\n","slug":"大学物理3笔记","published":1,"date":"2025-09-11T11:36:20.595Z","updated":"2025-09-11T16:15:57.624Z","comments":1,"layout":"post","photos":[],"_id":"cmffo52nu000a6xzd0npza4ii","content":"<h2 id=\"基本常数\">基本常数</h2>\n<table>\n\n<thead>\n<tr>\n<th>名称</th>\n<th>符号</th>\n<th>数值</th>\n<th>单位</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>斯特番常数</td>\n<td><span class=\"math inline\"><em>σ</em></span></td>\n<td><span class=\"math inline\">5.67 × 10<sup>−8</sup></span></td>\n<td><span\nclass=\"math inline\"><em>W</em> ⋅ <em>m</em><sup>−2</sup> ⋅ <em>K</em><sup>−4</sup></span></td>\n</tr>\n<tr>\n<td>维恩常数</td>\n<td><span class=\"math inline\"><em>b</em></span></td>\n<td><span class=\"math inline\">2.898 × 10<sup>−3</sup></span></td>\n<td><span class=\"math inline\"><em>m</em> ⋅ <em>K</em></span></td>\n</tr>\n<tr>\n<td>玻尔兹曼常数</td>\n<td><span class=\"math inline\"><em>k</em></span></td>\n<td><span class=\"math inline\">1.38 × 10<sup>−23</sup></span></td>\n<td><span\nclass=\"math inline\"><em>J</em> ⋅ <em>K</em><sup>−1</sup></span></td>\n</tr>\n<tr>\n<td>普朗克常数</td>\n<td><span class=\"math inline\"><em>h</em></span></td>\n<td><span class=\"math inline\">6.63 × 10<sup>−34</sup></span></td>\n<td><span class=\"math inline\"><em>J</em> ⋅ <em>s</em></span></td>\n</tr>\n<tr>\n<td>康普顿波长</td>\n<td><span\nclass=\"math inline\"><em>λ</em><sub><em>c</em></sub></span></td>\n<td><span class=\"math inline\">0.02426</span></td>\n<td><span class=\"math inline\">Å</span></td>\n</tr>\n<tr>\n<td>里德伯常数</td>\n<td><span class=\"math inline\"><em>R</em></span></td>\n<td><span class=\"math inline\">1.097 × 10<sup>7</sup></span></td>\n<td><span class=\"math inline\"><em>m</em><sup>−1</sup></span></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"算符\">算符</h2>\n<table>\n\n<thead>\n<tr>\n<th>名称</th>\n<th>表达式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>能量算符</td>\n<td><span class=\"math inline\">$\\hat{E} = i\\hbar\\frac{\\partial}{\\partial\nt}$</span></td>\n</tr>\n<tr>\n<td>动量算符</td>\n<td><span class=\"math inline\"><em>p̂</em> = −<em>i</em>ℏ∇</span></td>\n</tr>\n<tr>\n<td>哈密顿算符</td>\n<td><span class=\"math inline\">$\\hat{H} = -\\frac{\\hbar^2}{2m}\\nabla ^2 +\nU(\\boldsymbol{r},t)$</span></td>\n</tr>\n<tr>\n<td>角动量算符</td>\n<td><span\nclass=\"math inline\"><em>L̂</em> = <em>r̂</em> × <em>p̂</em></span></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"量子物理基础\">量子物理基础</h2>\n<h3 id=\"黑体辐射\">黑体辐射</h3>\n<h4 id=\"热辐射的基本概念\">热辐射的基本概念</h4>\n<ul>\n<li>所有物在有限体温度下都会发射电磁波，这种与温度有关的辐射称为热辐射\n(heat radiation).</li>\n<li>热辐射是连续谱.</li>\n<li>基本性质：温度越高，发射的能量越大，电磁波的短波成分能量越大.</li>\n<li>平衡热辐射：热辐射是热平衡状态下的辐射.</li>\n</ul>\n<h5 id=\"热辐射基本参数\">热辐射基本参数</h5>\n<p><strong>单色辐出度 <span\nclass=\"math inline\"><em>M</em><sub><em>λ</em></sub>(<em>W</em>/<em>m</em><sup>3</sup>)</span></strong></p>\n<p>物体单位表面在单位时间内发出的波长在 <span\nclass=\"math inline\"><em>λ</em></span>\n附近单位波长间隔内的电磁波的能量，用于描述物体辐射能量的能力</p>\n<p><span class=\"math display\">$$\nM_{\\lambda}(T)=\\frac{\\mathrm{d}E_{\\lambda}}{\\mathrm{d}\\lambda}\n$$</span></p>\n<p><strong>辐出度 <span\nclass=\"math inline\"><em>M</em>(<em>T</em>)(<em>W</em>/<em>m</em><sup>2</sup>)</span></strong></p>\n<p>物体从单位面积上发射的所有波长的辐射总功率</p>\n<p><span\nclass=\"math display\"><em>M</em>(<em>t</em>) = ∫<sub>0</sub><sup>+∞</sup><em>M</em><sub><em>λ</em></sub>(<em>T</em>) d<em>λ</em></span></p>\n<p><strong>吸收比 <span\nclass=\"math inline\"><em>α</em>(<em>T</em>)</span> 和反射比 <span\nclass=\"math inline\"><em>r</em>(<em>T</em>)</span></strong></p>\n<ul>\n<li><strong>吸收比</strong>：辐射从外界入射到物体表面时，吸收的能量和入射的能量之比，是吸收能力的量度.</li>\n</ul>\n<p><span class=\"math display\">$$\n\\alpha(T)=\\frac{E^\\text{吸收}}{E^\\text{入射}}\n$$</span></p>\n<ul>\n<li><strong>反射比</strong>：辐射从外界入射到物体表面时，反射的能量和入射的能量之比，是反射能力的量度.</li>\n</ul>\n<p><span class=\"math display\">$$\nr(T)=\\frac{E^\\text{反射}}{E^\\text{入射}}\n$$</span></p>\n<p>**单色吸收比 <span\nclass=\"math inline\"><em>α</em>(<em>λ</em>, <em>T</em>)</span>\n和单色反射比 <span\nclass=\"math inline\"><em>r</em>(<em>λ</em>, <em>T</em>) * *</span></p>\n<ul>\n<li><strong>单色吸收比</strong>：当辐射从外界入射到物体表面时，吸收的波长从\n<span class=\"math inline\"><em>λ</em></span> 到 <span\nclass=\"math inline\"><em>λ</em> + d<em>λ</em></span> 波长间隔内的能量\n<span\nclass=\"math inline\"><em>E</em><sub><em>λ</em></sub><sup>吸收</sup>d<em>λ</em></span>\n和入射的能量 <span\nclass=\"math inline\"><em>E</em><sub><em>λ</em></sub><sup>入射</sup>d<em>λ</em></span>\n之比.</li>\n</ul>\n<p><span class=\"math display\">$$\n\\alpha(\\lambda,T)=\\frac{E_\\lambda^\\text{吸收}}{E_\\lambda^\\text{入射}}\n$$</span></p>\n<ul>\n<li><strong>单色反射比</strong>：当辐射从外界入射到物体表面时，反射的波长从\n<span class=\"math inline\"><em>λ</em></span> 到 <span\nclass=\"math inline\"><em>λ</em> + d<em>λ</em></span> 波长间隔内的能量\n<span\nclass=\"math inline\"><em>E</em><sub><em>λ</em></sub><sup>反射</sup>d<em>λ</em></span>\n和入射的能量 <span\nclass=\"math inline\"><em>E</em><sub><em>λ</em></sub><sup>入射</sup>d<em>λ</em></span>\n之比.</li>\n</ul>\n<p><span class=\"math display\">$$\nr(\\lambda,T)=\\frac{E_\\lambda^\\text{反射}}{E_\\lambda^\\text{入射}}\n$$</span></p>\n<p>对于不透明物体，有 <span\nclass=\"math inline\"><em>α</em>(<em>λ</em>, <em>T</em>) + <em>r</em>(<em>λ</em>, <em>T</em>) = 1</span>.</p>\n<h5 id=\"基尔霍夫定律\">基尔霍夫定律</h5>\n<p>一个好的发射体一定是个好的吸收体（黑白盘子实验） <img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/%E9%BB%91%E7%99%BD%E7%9B%98%E5%AE%9E%E9%AA%8C.png\"\nalt=\"黑白盘实验\" /></p>\n<p>温度一定时物体在某波长处的单色辐出度与单色吸收比的比值与物体及物体表面的性质无关，即</p>\n<p><span class=\"math display\">$$\n\\frac{M_1(\\lambda,T)}{\\alpha_1(\\lambda,T)} =\n\\frac{M_2(\\lambda,T)}{\\alpha_2(\\lambda,T)}=\\ldots=M_0(\\lambda,T).\n$$</span></p>\n<p>其中 <span\nclass=\"math inline\"><em>M</em><sub>0</sub>(<em>λ</em>, <em>T</em>)</span>\n是一个只与波长和温度有关，与物体材料、表面状态无关的函数，称为黑体辐射强度，是黑体的单色辐出度.</p>\n<h5 id=\"黑体\">黑体</h5>\n<p>能完全吸收各种波长电磁波而无反射的物体是黑体\n黑体是理想模型，可以建立只有小孔的空腔，小孔是黑体，空腔内的辐射是黑体辐射</p>\n<h6 id=\"黑体辐射的基本规律\">黑体辐射的基本规律</h6>\n<p>温度一定时，黑体辐射的强度与波长有关，存在一定的波长 <span\nclass=\"math inline\"><em>λ</em><sub>max</sub></span>\n使得辐射强度最大，称为黑体辐射的主波长. <img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/%E9%BB%91%E4%BD%93%E8%BE%90%E5%B0%84%E5%9B%BE.png\"\nalt=\"黑体辐射图\" /></p>\n<ul>\n<li><strong>斯特番-玻尔兹曼定律(J. Stefan, L. Boltzmann)</strong>\n实验证明，黑体的总辐出度 <span\nclass=\"math inline\"><em>M</em><sub>0</sub>(<em>T</em>)</span> 与温度\n<span class=\"math inline\"><em>T</em></span> 的四次方成正比</li>\n</ul>\n<p><span\nclass=\"math display\"><em>M</em><sub>0</sub>(<em>T</em>) = <em>σ</em><em>T</em><sup>4</sup></span></p>\n<p>其中 <span\nclass=\"math inline\"><em>σ</em> = 5.67 × 10<sup>−8</sup><em>W</em> ⋅ <em>m</em><sup>−2</sup> ⋅ <em>K</em><sup>−4</sup></span>，称为斯特番常数.\n1879 年斯特番实验总结得到，1884 年玻尔兹曼理论证明.\n表明热辐射对温度的敏感性 <span\nclass=\"math inline\"> ∝ <em>T</em><sup>4</sup></span>.</p>\n<ul>\n<li>维恩位移定律(W. Wien) 黑体辐射中单色辐出值的极值波长 <span\nclass=\"math inline\"><em>λ</em><sub><em>m</em></sub></span> 与黑体温度\n<span class=\"math inline\"><em>T</em></span> 之积为常数</li>\n</ul>\n<p><span\nclass=\"math display\"><em>λ</em><sub><em>m</em></sub><em>T</em> = <em>b</em></span></p>\n<p>其中 <span\nclass=\"math inline\"><em>b</em> = 2.898 × 10<sup>−3</sup><em>m</em> ⋅ <em>K</em></span>\n，为 Wien 常数.</p>\n<h5\nid=\"普朗克的能量子假说和黑体辐射公式\">普朗克的能量子假说和黑体辐射公式</h5>\n<h6 id=\"维恩公式\">维恩公式</h6>\n<p><span\nclass=\"math display\"><em>M</em><sub>0</sub>(<em>ν</em>, <em>T</em>) = <em>α</em><em>ν</em><sup>3</sup><em>e</em><sup>−<em>β</em>/<em>T</em></sup></span></p>\n<ul>\n<li>在高频段与实验符合得很好，但是在低频段明显偏离实验曲线</li>\n</ul>\n<h6 id=\"瑞利-金斯公式\">瑞利-金斯公式</h6>\n<p><span class=\"math display\">$$\nM_0(\\nu,T)=\\frac{2\\pi \\nu^2}{c^2}kT\n$$</span></p>\n<ul>\n<li>其中 <span\nclass=\"math inline\"><em>k</em> = 1.38 × 10<sup>−23</sup><em>J</em> ⋅ <em>K</em><sup>−1</sup></span>\n，为玻尔兹曼常数.</li>\n<li>低频段与实验符合得很好，但是在高频段明显偏离实验曲线.</li>\n<li>且当 <span class=\"math inline\"><em>ν</em> → ∞</span> 时，<span\nclass=\"math inline\"><em>M</em><sub>0</sub>(<em>ν</em>, <em>T</em>) → ∞</span>，称为紫外灾难.</li>\n</ul>\n<h6 id=\"普朗克公式\">普朗克公式</h6>\n<p>普朗克以适用于高频段的维恩公式和适用于低频段的瑞利-金斯公式为基础，提出了<strong>普朗克黑体辐射公式</strong>，是一个半经验公式.</p>\n<p><span class=\"math display\">$$\nM_0(\\nu,T)=\\frac{2\\pi\\nu^2}{c^2}\\frac{h\\nu}{e^{\\frac{h\\nu}{kT}}-1}\n$$</span></p>\n<ul>\n<li><p>其中 <span\nclass=\"math inline\"><em>h</em> = 6.63 × 10<sup>−34</sup><em>J</em> ⋅ <em>s</em></span>\n为普朗克常量.</p></li>\n<li><p>普朗克公式在整个频段都符合实验结果.</p></li>\n<li><p>普朗克认为：空腔内壁的分子、原子的振动可以看成是许多带电的简谐振子，这些简谐振子可以辐射和吸收能量，并与空腔内的辐射达到平衡。从空腔小孔辐射出的电磁波，就是由这些空腔内壁的简谐振子辐射出的。他假定对于频率为\n<span class=\"math inline\"><em>ν</em></span>\n的振子，振子能量不是连续的，而是分立的，它的取值是某一最小能量 <span\nclass=\"math inline\"><em>h</em></span>\n的整数倍，即<strong>当振子吸收或放出能量时，以 <span\nclass=\"math inline\"><em>h</em><em>ν</em></span>\n为单位.</strong></p></li>\n<li><p>我们计 <span\nclass=\"math inline\"><em>ε</em> = <em>h</em><em>ν</em></span>\n，称为<strong>能量子（quanta of enmergy）</strong></p></li>\n<li><p>由普朗克公式可以推出其他热辐射公式</p>\n<p><span class=\"math display\">$$\nM_0(\\nu,T)=\\frac{2\\pi\\nu^2}{c^2}\\frac{h\\nu}{e^{\\frac{h\\nu}{kT}}-1}\\ \\\n\\left\\{\n  \\begin{aligned}\n  &amp;\\text{积分} \\rightarrow M=\\sigma T^4, \\ \\\n\\text{斯特番-玻尔兹曼定律}\\\\\n  &amp;\\text{求导} \\rightarrow \\lambda_mT=b. \\ \\ \\text{维恩位移定律}\\\\\n  &amp;\\text{低频极限} \\rightarrow M_0(\\nu,T)=\\frac{2\\pi\\nu^2}{c^2}kT, \\\n\\ \\text{瑞利-金斯公式}\\\\\n  &amp;\\text{高频极限} \\rightarrow M_0(\\nu,T)=\\alpha\\nu^3e^{-\\beta/T}, \\\n\\ \\text{维恩公式}\n  \\end{aligned}\n\\right.\n$$</span></p></li>\n</ul>\n<h3 id=\"光电效应photoelectric-effect\">光电效应（Photoelectric\neffect）</h3>\n<h4 id=\"实验模型\">实验模型</h4>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250228160736.png\"\nalt=\"实验装置\" />\n<figcaption aria-hidden=\"true\">实验装置</figcaption>\n</figure>\n<p>当光照在金属表面，电子从金属中脱出的现象，称为光电效应</p>\n<h4 id=\"基本参数\">基本参数</h4>\n<h4 id=\"饱和电流\">饱和电流</h4>\n<p>实验表明，当入射光强度不变，加速电势差 <span\nclass=\"math inline\"><em>U</em></span> 越大，光电流 <span\nclass=\"math inline\"><em>I</em></span>\n也越大，当电势差增大到一定值时，光电流达到饱和值，此时的光电流称为<strong>饱和电流</strong>。若改变入射光强，<strong>饱和电流的大小与入射光强成正比</strong>，说明从阴极逸出的电子数全部飞到阳极，单位时间从金属表面逸出的电子数与入射光强成正比.</p>\n<h4 id=\"遏制电压差\">遏制电压差</h4>\n<p>改变阴极与阳极之间的电压，当电压增大到一定值时，光电流减小到零，此时的电压差称为<strong>遏制电压差</strong>。遏制电压差的大小与入射光的频率有关，与光强无关.\n光电子从表面逸出的最大初速度 <span\nclass=\"math inline\"><em>v</em><sub><em>m</em></sub></span> 满足：</p>\n<p><span class=\"math display\">$$\n\\frac{1}{2} m v_m^2 = eU_0\n$$</span></p>\n<h4 id=\"爱因斯坦的光量子论\">爱因斯坦的光量子论</h4>\n<p>电子辐射由以光速 <span class=\"math inline\"><em>c</em></span>\n运动的局限于空间某小范围的光量子（光子），即光子流组成 光子的能量为\n<span class=\"math inline\"><em>ε</em> = <em>h</em><em>ν</em></span>\n，动量为 <span class=\"math inline\">$p = \\frac{h}{\\lambda}$</span></p>\n<ul>\n<li>光电效应的基本方程</li>\n</ul>\n<p><span class=\"math display\">$$\nh \\nu=\\frac{1}{2} m v_{\\mathrm{m}}^{2}+A\n$$</span></p>\n<p>其中 <span\nclass=\"math inline\">$\\frac{1}{2}mv_{\\mathrm{m}}^{2}$</span>\n是光电子的最大初动能.</p>\n<p><strong>解释：</strong>\n光照射金属时，电子吸收光子，能量增加，一部分用于克服金属脱出功，一部分增加电子的初动能</p>\n<h4 id=\"光的波粒二象性\">光的波粒二象性</h4>\n<ul>\n<li>一些情况下，光的波动性表现得很明显，如干涉、衍射、偏振等现象.</li>\n<li>一些情况下，光的粒子性表现得很明显，如光电效应、康普顿散射等现象.</li>\n</ul>\n<p>这被称为光的波粒二象性</p>\n<ul>\n<li>光不是牛顿经典粒子，也不是康普顿的经典波</li>\n</ul>\n<p>基本关系式</p>\n<p><span class=\"math display\">$$\n\\left\\{\n  \\begin{aligned}\n    &amp;\\varepsilon = h\\nu \\quad \\text{粒子性}\\\\\n    &amp;p = \\frac{\\varepsilon}{c}=\\frac{h}{\\lambda} \\quad \\text{波动性}\n  \\end{aligned}\n\\right.\n$$</span></p>\n<h3 id=\"康普顿散射\">康普顿散射</h3>\n<p>在散射的 X\n射线中，存在与入射光波长相等的波，也存在波长比入射光波长大的波，这种现象称为<strong>康普顿散射</strong>\n.</p>\n<h4 id=\"特点\">特点</h4>\n<p><span\nclass=\"math display\"><em>Δ</em><em>λ</em> = <em>λ</em><sup>′</sup> − <em>λ</em> = <em>λ</em><sub><em>c</em></sub>(1 − cos <em>θ</em>)</span></p>\n<p>其中</p>\n<ul>\n<li><span class=\"math inline\">$\\lambda_c =\\frac{h}{m_{0}c}= 0.02426\n\\text{Å}$</span> 被称为康普顿波长. 当光子的波长等于 <span\nclass=\"math inline\"><em>λ</em><sub><em>c</em></sub></span>\n时，其能量等于电子的能量 <span\nclass=\"math inline\"><em>m</em><sub><em>c</em></sub><em>c</em><sup>2</sup> = 1.511MeV</span>\n.</li>\n<li><span class=\"math inline\"><em>θ</em></span> 为散射角.</li>\n</ul>\n<ol type=\"1\">\n<li>波长改变量随散射角 <span class=\"math inline\"><em>θ</em></span>\n的增大而增大</li>\n<li>新成分的相对强度随散射角 <span class=\"math inline\"><em>θ</em></span>\n的增大而增大</li>\n<li>同一个散射角下，所有散射物质的波长差相等</li>\n<li>随着原子序数的增加，原波长成分的相对强度增大，即对对于轻元素康普顿散射更为明显.</li>\n</ol>\n<p>其中 3、4 是由吴有训发现的</p>\n<h4 id=\"推导\">推导</h4>\n<p>使用动量守恒和能量守恒进行推导（X\n射线光子与静止的自由电子的碰撞）</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250302131054.png\"\nalt=\"康普顿散射推导\" />\n<figcaption aria-hidden=\"true\">康普顿散射推导</figcaption>\n</figure>\n<p>由能量守恒：</p>\n<p><span\nclass=\"math display\"><em>h</em><em>ν</em> + <em>m</em><sub><em>e</em></sub><em>c</em><sup>2</sup> = <em>h</em><em>ν</em><sup>′</sup> + <em>m</em><em>c</em><sup>2</sup></span></p>\n<p>其中 <span\nclass=\"math inline\">$m=\\frac{m_{e}}{\\sqrt{1-\\frac{v^2}{c^2}}}$</span></p>\n<p>由 <span class=\"math inline\"><em>x</em></span> 方向上的动量守恒</p>\n<p><span class=\"math display\">$$\n\\begin{equation}\n  \\frac{h\\nu _0}{c} = \\frac{h\\nu}{c} \\cos{\\theta} + mv\\cos{\\varphi}\n\\end{equation}\n$$</span></p>\n<p>由 <span class=\"math inline\"><em>y</em></span> 方向上的动量守恒</p>\n<p><span class=\"math display\">$$\n\\begin{equation}\n  0 = \\frac{h\\nu}{c} \\sin{\\theta} - mv\\sin{\\varphi}\n\\end{equation}\n$$</span></p>\n<p>解方程组即可得到康普顿散射的公式</p>\n<p><span class=\"math display\">$$\n\\Delta \\lambda = \\lambda _{0} -\\lambda =\\frac{h}{m_{e}c}\n(1-\\cos{\\theta})\n$$</span></p>\n<h3 id=\"波尔氢原子理论\">波尔氢原子理论</h3>\n<h4 id=\"原子模型的发展\">原子模型的发展</h4>\n<ol type=\"1\">\n<li>汤姆逊的面包夹葡萄干模型</li>\n<li>卢瑟福的 <span class=\"math inline\"><em>α</em></span>\n粒子散射实验和原子的核结构模型</li>\n</ol>\n<h4 id=\"氢原子光谱\">氢原子光谱</h4>\n<h5 id=\"公式\">公式</h5>\n<h6 id=\"里德伯公式\">里德伯公式</h6>\n<p><span class=\"math display\">$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{m^{2}}-\\frac{1}{n^{2}}\\right)\n\\quad(m=1,2,3,\\cdots;n=m+1,m+2,m+3,\\cdots)\n$$</span></p>\n<p>其中：</p>\n<ul>\n<li><span class=\"math inline\">$\\widetilde{\\nu} =\n\\frac{1}{\\lambda}$</span> 为波长的倒数，即波数</li>\n<li><span\nclass=\"math inline\"><em>R</em> = 1.097 × 10<sup>7</sup><em>m</em><sup>−1</sup></span>\n为里德伯常数</li>\n</ul>\n<h6 id=\"赖曼系-m1-紫外区\">赖曼系（ <span\nclass=\"math inline\"><em>m</em> = 1</span> ，紫外区）</h6>\n<p><span class=\"math display\">$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{1^{2}}-\\frac{1}{n^{2}}\\right)\n\\quad(n=2,3,4,\\cdots)\n$$</span></p>\n<h6 id=\"巴尔末系-m2\">巴尔末系（ <span\nclass=\"math inline\"><em>m</em> = 2</span> ）</h6>\n<p><span class=\"math display\">$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{2^{2}}-\\frac{1}{n^{2}}\\right)\n\\quad(n=3,4,5,\\cdots)\n$$</span></p>\n<h6 id=\"帕邢系-m3-红外区\">帕邢系（ <span\nclass=\"math inline\"><em>m</em> = 3</span> ，红外区）</h6>\n<p><span class=\"math display\">$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{3^{2}}-\\frac{1}{n^{2}}\\right)\n\\quad(n=4,5,6,\\cdots)\n$$</span></p>\n<h6 id=\"布拉开系-m4-近红外区\">布拉开系 （ <span\nclass=\"math inline\"><em>m</em> = 4</span> ，近红外区）</h6>\n<p><span class=\"math display\">$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{4^{2}}-\\frac{1}{n^{2}}\\right)\n\\quad(n=5,6,7,\\cdots)\n$$</span></p>\n<h6 id=\"普丰德系-m5-远红外区\">普丰德系（ <span\nclass=\"math inline\"><em>m</em> = 5</span> ，远红外区）</h6>\n<p><span class=\"math display\">$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{5^{2}}-\\frac{1}{n^{2}}\\right)\n\\quad(n=6,7,8,\\cdots)\n$$</span></p>\n<h6 id=\"汉弗莱系-m6-远红外区\">汉弗莱系 （ <span\nclass=\"math inline\"><em>m</em> = 6</span> ，远红外区）</h6>\n<p><span class=\"math display\">$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{6^{2}}-\\frac{1}{n^{2}}\\right)\n\\quad(n=7,8,9,\\cdots)\n$$</span></p>\n<h5 id=\"波尔的氢原子模型\">波尔的氢原子模型</h5>\n<h5 id=\"波尔假设\">波尔假设</h5>\n<ol type=\"1\">\n<li><p>原子中的电子只能在一些分离的轨道上运行，在每一个轨道上运动的电子处于不稳定的能量状态（定态\n<span\nclass=\"math inline\"><em>E</em><em>W</em><sub><em>n</em></sub></span>\n），不向外辐射能量</p></li>\n<li><p><strong>频率条件：</strong>\n当电子从一个定态跃迁另一个定态时，发射或吸收一个光子，\n$h_{nm}=E_n-E_m$</p></li>\n<li><p><strong>结论：</strong></p>\n<p><span class=\"math display\">$$\n\\nu=\\frac{E_{n}-E_{m}}{h}=\\frac{m e^{4}}{8 \\varepsilon _{0}^{2}\nh^{3}}\\left(\\frac{1}{m^{2}}-\\frac{1}{n^{2}}\\right)\n$$</span></p></li>\n</ol>\n<h5 id=\"波尔角动量量子化条件\">波尔角动量量子化条件</h5>\n<p><span class=\"math display\">$$\nL=n \\frac{h}{2 \\pi}=n \\hbar,n=1,2,3,\\cdots\n$$</span></p>\n<p>其中， <span class=\"math inline\"><em>n</em></span> 为量子数， <span\nclass=\"math inline\">$\\hbar=\\frac{h}{2\\pi}$</span> 为约化普朗克常数.\n<strong>定量计算：</strong> 由电子的向心力和轨道角动量的量子化得到</p>\n<p><span class=\"math display\">$$\n\\left\\{\n  \\begin{aligned}\n    &amp;m\\frac{v^{2}}{r}=\\frac{1}{4\\pi \\varepsilon _{0}}\\cdot\n\\frac{e^2}{r^2}\\\\\n    &amp;L=mvr=n\\hbar\n  \\end{aligned}\n\\right.\n$$</span></p>\n<p>解得：</p>\n<p><span class=\"math display\">$$\n\\left\\{\n  \\begin{aligned}\n    &amp;r_n=n^2\\frac{4\\pi \\varepsilon _{0} \\hbar^{2}}{m e^{2}}=n^2r_1\\\\\n    &amp;v_n=\\frac{e^{2}}{4\\pi \\varepsilon _{0} n \\hbar}=\\alpha\n\\frac{c}{n}\n  \\end{aligned}\n\\right.\n$$</span></p>\n<p>其中 <span class=\"math inline\">$r_1 = \\frac{4\\pi \\varepsilon _{0}\n\\hbar^{2}}{m e^{2}} = 0.529\\text{Å}$</span> 为氢原子中电子的最小轨道</p>\n<p><strong>轨道能量：</strong></p>\n<p><span class=\"math display\">$$\nE_n =\\frac{1}{2}mv_n^2 + (-\\frac{1}{4\\pi \\varepsilon _0}\\cdot\n\\frac{e^2}{r_n^2}) =\n-\\frac{me^4}{8\\varepsilon_0^2h^2n^2}=-\\frac{1}{n^2}E_1\n$$</span></p>\n<p>其中 <span\nclass=\"math inline\"><em>E</em><sub>1</sub> = 13.6<em>e</em><em>V</em></span>\n为氢原子基态能量</p>\n<h5 id=\"波尔的对应原理\">波尔的对应原理</h5>\n<p>当 <span class=\"math inline\"><em>n</em> → +∞</span> 时，<span\nclass=\"math inline\"><em>r</em><sub><em>n</em></sub> → 0</span> ，<span\nclass=\"math inline\"><em>E</em><sub><em>n</em></sub> → 0</span> ，<span\nclass=\"math inline\">$\\displaystyle \\Delta E = E_n - E_{n+1} =\n\\frac{me^4}{4 \\varepsilon _0h^2n^3}\\rightarrow 0$</span>\n，即能级间距趋于零，能级连续，形成连续谱.</p>\n<h2 id=\"量子动力学入门\">量子动力学入门</h2>\n<p>量子力学的两条路线</p>\n<ol type=\"1\">\n<li>波动力学 普朗克、爱因斯坦、德布罗意、薛定谔</li>\n<li>矩阵力学 普朗克、波尔、海森堡</li>\n</ol>\n<ul>\n<li>最后由玻恩给出统计解释</li>\n<li>波动力学和矩阵力学完全等价</li>\n</ul>\n<h3 id=\"物质波\">物质波</h3>\n<h4 id=\"德布罗意假说\">德布罗意假说</h4>\n<p>德布罗意假设：实物具有波粒二象性</p>\n<table>\n<thead>\n<tr>\n<th>量</th>\n<th>粒子性</th>\n<th>波动性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"math inline\"><em>E</em></span></td>\n<td><span\nclass=\"math inline\"><em>m</em><em>c</em><sup>2</sup></span></td>\n<td><span class=\"math inline\"><em>h</em><em>ν</em></span></td>\n</tr>\n<tr>\n<td><span class=\"math inline\"><em>p</em></span></td>\n<td><span class=\"math inline\"><em>m</em><em>v</em></span></td>\n<td><span class=\"math inline\">$\\frac{h}{\\lambda}$</span></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"德布罗意原子稳定性驻波思想\">德布罗意原子稳定性驻波思想</h4>\n<p>原子中的电子在原子核库仑场中运动表现得波动性具有驻波得特征，驻波的稳定性使得电子不会坠落到原子核内</p>\n<h5 id=\"能量的量子化\">能量的量子化</h5>\n<ul>\n<li><span class=\"math inline\">$\\lambda = \\frac{2L}{n}$</span></li>\n<li><span class=\"math inline\">$p=\\frac{h}{2L}n$</span></li>\n<li><span class=\"math inline\">$E = \\frac{p^2}{2m} =\n\\frac{h^2}{8mL^2}n^2$</span></li>\n</ul>\n<h5\nid=\"物质波的概念对波尔轨道角动量量子化条件的解释\">物质波的概念对波尔轨道角动量量子化条件的解释</h5>\n<p>德布罗意认为电子在经典的圆轨道上运动，形成一个环形驻波</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250308170617.png\"\nalt=\"电子驻波\" />\n<figcaption aria-hidden=\"true\">电子驻波</figcaption>\n</figure>\n<p>电子绕行原子一周，圆周长应等于波长的整数倍</p>\n<p><span\nclass=\"math display\">2<em>π</em><em>r</em> = <em>n</em><em>λ</em></span></p>\n<p><span class=\"math display\">$$\nL = rmv = \\frac{n\\lambda}{2\\pi} \\cdot \\frac{h}{\\lambda} = n\\hbar\n$$</span></p>\n<h4 id=\"物质波的实验验证\">物质波的实验验证</h4>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250308171040.png\"\nalt=\"物质波的实验验证\" />\n<figcaption aria-hidden=\"true\">物质波的实验验证</figcaption>\n</figure>\n<h5 id=\"布拉格公式\">布拉格公式</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503151817449.png\"\nalt=\"布拉格公式推导\" />\n<figcaption aria-hidden=\"true\">布拉格公式推导</figcaption>\n</figure>\n<p><span\nclass=\"math display\"><em>δ</em> = 2<em>d</em>sin <em>θ</em> = <em>n</em><em>λ</em>  (<em>n</em> = 1, 2, 3, ⋯)</span></p>\n<h4 id=\"微观粒子波动性的应用\">微观粒子波动性的应用</h4>\n<ul>\n<li>显微镜使用电子波提大大提高了分辨率</li>\n</ul>\n<h3 id=\"波函数的统计解释\">波函数的统计解释</h3>\n<h4 id=\"对电子是什么的两种经典观点\">对电子是什么的两种经典观点</h4>\n<ol type=\"1\">\n<li>电子是波包\n<ul>\n<li>由两种不同频率的波合成一个波包</li>\n<li>这种观点夸大了波动性，忽略了粒子性\n<ol type=\"1\">\n<li>不同频率波在媒质中传播速度不同，波包会逐步扩展而消失，但是实际粒子并没有消失\n说明波包是电子的某种实际结果</li>\n<li>在媒质界面上一部分反射，一部分折射，但实际例子或整个反射，或整个折射</li>\n</ol></li>\n</ul></li>\n<li>经典粒子\n<ul>\n<li>粒子是基本的，波动性源于粒子与粒子的相互作用，或者粒子与狭缝周围原子的相互作用。</li>\n<li>这种观点夸大了粒子性，抹杀了波动性\n<ol type=\"1\">\n<li>电子的双缝衍射实验表明电子具有波动性</li>\n<li>电子的波动性并不是很多电子在空间聚集在一起时的相互作用的结果，而是单个电子就具有波动性，是电子自己和自己的干涉</li>\n</ol></li>\n</ul></li>\n</ol>\n<h4 id=\"对波函数的统计解释\">对波函数的统计解释</h4>\n<p>1926 年，玻恩提出了对波函数 <span\nclass=\"math inline\"><em>Ψ</em>(<strong>r</strong>, <em>t</em>)</span>\n的统计解释，将实物粒子的波动性和粒子性有机地结合在一起。</p>\n<h5 id=\"对亮度的解释\">对亮度的解释</h5>\n<ol type=\"1\">\n<li>波的观点 亮度是该点德布罗意波强度的大小</li>\n<li>粒子的观点\n亮度与该点附近出现的感光点的数目成正比，即与该点附近电子的数目成正比，即与该点附近电子的概率成正比</li>\n</ol>\n<h5 id=\"玻恩对波函数的统计解释\">玻恩对波函数的统计解释</h5>\n<p>波函数 <span class=\"math inline\"><em>Ψ</em></span>\n是描述粒子在空间概率分布的<strong>概率振幅</strong>，其模的平方 <span\nclass=\"math inline\">|<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup> = <em>Ψ</em>(<strong>r</strong>, <em>t</em>)<sup>*</sup><em>Ψ</em>(<strong>r</strong>, <em>t</em>)</span>\n表示 <span class=\"math inline\"><em>t</em></span> 时刻，在坐标 <span\nclass=\"math inline\"><strong>r</strong></span>\n附近单位体积中发现一个粒子的概率，被称为<strong>概率密度</strong></p>\n<ul>\n<li>目前对波函数最好的解释是概率波</li>\n<li><span class=\"math inline\"><em>t</em></span> 时刻，一个粒子处于 <span\nclass=\"math inline\"><em>x</em> → <em>x</em> + d<em>x</em></span> ，<span\nclass=\"math inline\"><em>y</em> → <em>y</em> + d<em>y</em></span> ，<span\nclass=\"math inline\"><em>z</em> → <em>z</em> + d<em>z</em></span>\n的概率为 <span\nclass=\"math inline\">|<em>Ψ</em>(<em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>)|<sup>2</sup>d<em>x</em>d<em>y</em>d<em>z</em></span>，记\n<span\nclass=\"math inline\"><em>ρ</em>(<em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>) = |<em>Ψ</em>(<em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>)|<sup>2</sup></span>\n为概率密度.</li>\n<li>在空间 <span class=\"math inline\"><em>Ω</em></span>\n中发现粒子的概率为 <span\nclass=\"math inline\">∫<sub><em>Ω</em></sub><em>ρ</em>(<em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>) d<em>x</em>d<em>y</em>d<em>z</em></span></li>\n</ul>\n<h4 id=\"波函数满足的条件\">波函数满足的条件</h4>\n<ol type=\"1\">\n<li>单值性\n<ul>\n<li>在空间的任何地方，概率密度只能有一个，所以一般波函数在任何地方都是单值的；</li>\n</ul></li>\n<li>有限性\n<ul>\n<li>粒子必然在空间的某处出现，概率综合为 1，所以在空间的任何有限体积元\n<span class=\"math inline\">d<em>V</em></span> 中，概率密度 <span\nclass=\"math inline\"><em>ρ</em>(<em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>)</span>\n有限；</li>\n<li><strong>归一化条件</strong>：<span\nclass=\"math inline\">∫<sub><em>Ω</em></sub>|<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup> d<em>V</em> = 1</span>\n，其中 <span class=\"math inline\"><em>Ω</em></span> 为全空间；</li>\n<li>归一化条件并不能排除在某些孤立奇点上 <span\nclass=\"math inline\">|<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup> → ∞</span></li>\n</ul></li>\n<li>连续性\n<ul>\n<li>波函数一阶导数连续（即使在势能函数有限大小间断点处）</li>\n</ul></li>\n</ol>\n<h3 id=\"不确定度关系\">不确定度关系</h3>\n<h4 id=\"形式-1位置-动量不确定关系\">形式 1（位置-动量不确定关系）</h4>\n<p>当粒子处在 <span class=\"math inline\"><em>x</em></span>\n方向的一个有限范围 <span class=\"math inline\"><em>Δ</em><em>x</em></span>\n内时，其动量 <span\nclass=\"math inline\"><em>p</em><sub><em>x</em></sub></span>\n的有一个不完全确定的数值范围 <span\nclass=\"math inline\"><em>Δ</em><em>p</em><sub><em>x</em></sub></span>\n，两者的乘积满足：</p>\n<p><span class=\"math display\">$$\n\\Delta x \\Delta p \\geq \\frac{\\hbar}{2}\n$$</span></p>\n<p>若记 <span class=\"math inline\">$k=\\frac{2\\pi}{\\lambda}$</span>\n，则</p>\n<p><span class=\"math display\">$$\n\\Delta x \\Delta k \\geq \\frac{1}{2}\n$$</span></p>\n<ul>\n<li><strong>含义</strong>：微观粒子的位置和动量不能同时准确地测定</li>\n<li>规律\n<ol type=\"1\">\n<li>当 <span class=\"math inline\"><em>Δ</em><em>x</em></span> 越小，<span\nclass=\"math inline\"><em>Δ</em><em>p</em></span> 越大</li>\n<li>当 <span class=\"math inline\"><em>Δ</em><em>p</em></span> 越小，<span\nclass=\"math inline\"><em>Δ</em><em>x</em></span> 越大</li>\n</ol></li>\n</ul>\n<p>电子的单缝衍射为例</p>\n<ul>\n<li>进入单缝之前的 <span class=\"math inline\"><em>Δ</em><em>x</em></span>\n趋向无穷大</li>\n</ul>\n<h4 id=\"形式-2\">形式 2</h4>\n<p>若粒子在能量状态 <span class=\"math inline\"><em>E</em></span>\n附近停留时间 <span class=\"math inline\"><em>Δ</em><em>t</em></span>\n，则其能量 <span class=\"math inline\"><em>E</em></span>\n有一个不完全确定的数值范围 <span\nclass=\"math inline\"><em>Δ</em><em>E</em></span> ，两者的乘积满足：</p>\n<p><span class=\"math display\">$$\n\\Delta t \\Delta E \\geq \\frac{\\hbar}{2}\n$$</span></p>\n<p>只有当粒子的停留时间为无穷大（定态）时，其能量才是确定的（<span\nclass=\"math inline\"><em>Δ</em><em>E</em> = 0</span> ）</p>\n<h4 id=\"电子单缝衍射的结论\">电子单缝衍射的结论</h4>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281611015.png\"\nalt=\"电子单缝衍射实验示意图\" />\n<figcaption aria-hidden=\"true\">电子单缝衍射实验示意图</figcaption>\n</figure>\n<ul>\n<li>电子通过单缝之后，动量在 <span class=\"math inline\"><em>x</em></span>\n方向上的分量 <span\nclass=\"math inline\"><em>P</em><sub><em>x</em></sub></span> 的大小为</li>\n</ul>\n<p><span\nclass=\"math display\">−<em>p</em> ⋅ sin <em>θ</em><sub>1</sub> ≤ <em>p</em><sub><em>x</em></sub> = <em>p</em> ⋅ sin <em>θ</em> ≤ <em>p</em> ⋅ sin <em>θ</em><sub>1</sub></span></p>\n<ul>\n<li>电子通过单缝后，动量在 <span class=\"math inline\"><em>x</em></span>\n方向分量的不确定量为</li>\n</ul>\n<p><span class=\"math display\">$$\n\\Delta p_x = 2p \\cdot \\sin{\\theta_1} =\\frac{2p\\lambda}{\\Delta x}\n$$</span></p>\n<p>带入德布罗意关系 <span\nclass=\"math inline\"><em>p</em><em>λ</em> = <em>h</em></span>，得到</p>\n<p><span\nclass=\"math display\"><em>Δ</em><em>x</em> ⋅ <em>Δ</em><em>p</em><sub><em>x</em></sub> = 2<em>h</em></span></p>\n<p>这里的讨论只反映不确定度关系的实质，并不表示准确的量值关系</p>\n<h2 id=\"量子力学\">量子力学</h2>\n<h3 id=\"薛定谔方程\">薛定谔方程</h3>\n<ul>\n<li>建立的是描写波函数随时间变化的方程，它必须是波函数应满足的含有对时间微商的微分方程</li>\n<li>是一个假设，无法被推导出来</li>\n</ul>\n<h4 id=\"满足的条件\">满足的条件</h4>\n<ol type=\"1\">\n<li>方程是线性的 如果 <span\nclass=\"math inline\"><em>Ψ</em><sub>1</sub></span> 和 <span\nclass=\"math inline\"><em>Ψ</em><sub>2</sub></span> 是薛定谔方程的解，则\n<span\nclass=\"math inline\"><em>a</em><em>Ψ</em><sub>1</sub> + <em>b</em><em>Ψ</em><sub>2</sub></span>\n也是薛定谔方程的解 这是由态叠加原理决定的</li>\n<li>方程的系数不应当包含状态参量，如动量、能量等\n否则这个方程只能被粒子的部分状态满足</li>\n</ol>\n<h4 id=\"自由粒子的薛定谔方程\">自由粒子的薛定谔方程</h4>\n<p>动量为 <span class=\"math inline\"><em>p</em></span> 、质量为 <span\nclass=\"math inline\"><em>m</em></span> 、能量为 <span\nclass=\"math inline\"><em>E</em></span> 的粒子在 <span\nclass=\"math inline\"><em>x</em></span> 方向上自由运动的薛定谔方程为</p>\n<p><span class=\"math display\">$$\n\\Psi \\left(x,t\\right) =\\Psi _0 e^{-\\frac{i}{\\hbar}\\left(Et-px\\right)}\n$$</span></p>\n<p><strong>对时间求偏导</strong></p>\n<p><span class=\"math display\">$$\n\\frac{\\partial \\Psi (x,t)}{\\partial t} = -\\frac{i}{\\hbar}E\\Psi (x,t)\n$$</span></p>\n<p>左右两边同乘 <span class=\"math inline\"><em>i</em>ℏ</span></p>\n<p><span class=\"math display\">$$\ni\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} = E\\Psi (x,t)\n$$</span></p>\n<p>我们记算符 <span class=\"math inline\"><em>Ê</em></span> 为能量算符</p>\n<p><span class=\"math display\">$$\n\\boxed{\\hat{E} \\equiv i\\hbar \\frac{\\partial}{\\partial t}}\n$$</span></p>\n<p>则</p>\n<p><span\nclass=\"math display\"><em>Ê</em><em>Ψ</em>(<em>x</em>, <em>t</em>) = <em>E</em><em>Ψ</em>(<em>x</em>, <em>t</em>)</span></p>\n<p><strong>对 <span class=\"math inline\"><em>x</em></span>\n求偏导</strong></p>\n<p><span class=\"math display\">$$\n\\frac{\\partial \\Psi (x,t)}{\\partial x} = \\frac{i}{\\hbar}p_x\\Psi (x,t)\n$$</span></p>\n<p>左右两边同乘 <span class=\"math inline\">−<em>i</em>ℏ</span></p>\n<p><span class=\"math display\">$$\n-i\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial x} = p_x\\Psi (x,t)\n$$</span></p>\n<p>我们记算符 <span class=\"math inline\">$\\hat{p_x}$</span>\n为动量算符</p>\n<p><span class=\"math display\">$$\n\\boxed{\\hat{p_x} \\equiv -i\\hbar \\frac{\\partial}{\\partial x}}\n$$</span></p>\n<p>则</p>\n<p><span class=\"math display\">$$\n\\hat{p_x} \\Psi (x,t) = p_x\\Psi (x,t)\n$$</span></p>\n<p><strong>对 <span class=\"math inline\"><em>x</em></span>\n做二次偏导</strong></p>\n<p><span class=\"math display\">$$\n\\frac{\\partial^2 \\Psi (x,t)}{\\partial x^2} = -\\frac{p_x^2}{\\hbar^2}\\Psi\n(x,t)\n$$</span></p>\n<p><strong>综合考虑</strong></p>\n<p><span class=\"math display\">$$\n\\left\\{\n  \\begin{aligned}\n    &amp;i\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} = E\\Psi (x,t)\\\\\n    &amp;\\frac{\\partial ^2 \\Psi (x,t)}{\\partial x^2} =\n-\\frac{p_x^2}{\\hbar^2}\\Psi (x,t)\n    \\end{aligned}\n\\right.\n$$</span></p>\n<p>由 <span class=\"math inline\">$E = \\frac{p_x^2}{2m}$</span>，有</p>\n<p><span class=\"math display\">$$\ni\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} = E\\Psi (x,t) =\n-\\frac{p_x^2}{2m}\\Psi (x,t)=-\\frac{\\hbar^2}{2m}\\frac{\\partial^2 \\Psi\n(x,t)}{\\partial x^2}\n$$</span></p>\n<p><strong>即</strong></p>\n<p><span class=\"math display\">$$\n\\boxed{i\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} =\n-\\frac{\\hbar^2}{2m}\\frac{\\partial^2 \\Psi (x,t)}{\\partial x^2}}\n$$</span></p>\n<p>这就是自由粒子的薛定谔方程</p>\n<h4 id=\"薛定谔方程的一般形式\">薛定谔方程的一般形式</h4>\n<p>将自由粒子运动算符推广到非自由粒子运动，粒子所处的势场为 <span\nclass=\"math inline\"><em>U</em>(<em>x</em>, <em>t</em>)</span>\n对于保守系统，其能量等于<strong>哈密顿量</strong></p>\n<p><span class=\"math display\">$$\nE = H = \\frac{p^2}{2m} + U(x,t)\n$$</span></p>\n<p>哈密顿量算符化，称为<strong>哈密顿算符</strong></p>\n<p><span class=\"math display\">$$\n\\hat{H} = \\frac{\\hat p_x^2}{2m} +\nU(x,t)=\\frac{-\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} + U(x,t)\n$$</span></p>\n<p><strong>薛定谔方程</strong>：对于保守系统，其能量算符作用在波函数上，等于哈密顿算符作用在波函数上</p>\n<p><span class=\"math display\">$$\n\\boxed{\\hat{E} \\Psi (x,t) = \\hat{H} \\Psi (x,t)}\n$$</span></p>\n<p>将其展开</p>\n<p><span class=\"math display\">$$\n\\boxed{i\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} =\n\\left(\\frac{-\\hbar^2}{2m}\\frac{\\partial ^2}{\\partial x^2} +\nU(x,t)\\right) \\Psi (x,t)}\n$$</span></p>\n<p>推广到三维势场</p>\n<p><span class=\"math display\">$$\n\\boxed{i\\hbar \\frac{\\partial \\Psi (\\boldsymbol{r},t)}{\\partial t} =\n\\left(-\\frac{\\hbar^2}{2m}\\nabla^2 + U(\\boldsymbol{r},t)\\right) \\Psi\n(\\boldsymbol{r},t)}\n$$</span></p>\n<h4 id=\"定态薛定谔方程\">定态薛定谔方程</h4>\n<p>若微观粒子在稳定的势场中，则其势能函数 <span\nclass=\"math inline\"><em>U</em></span>\n与时间无关，称这类问题为定态问题</p>\n<p><span class=\"math display\">$$\n\\hat{H} = -\\frac{\\hbar^2}{2m}\\nabla^2 + U(\\boldsymbol{r})\n$$</span></p>\n<p><span class=\"math display\">$$\n\\\ni\\hbar \\frac{\\partial}{\\partial t}\\Psi (\\boldsymbol{r},t) = \\hat{H} \\Psi\n(\\boldsymbol{r},t)\n$$</span></p>\n<p>此时哈密顿算符与时间无关，薛定谔方程可以用分离变量法求解，波函数\n<span class=\"math inline\"><em>Ψ</em></span>\n分解为空间函数和时间函数的乘积</p>\n<p>设 <span\nclass=\"math inline\"><em>Ψ</em>(<strong>r</strong>, <em>t</em>) = <em>Φ</em>(<strong>r</strong>)<em>T</em>(<em>t</em>)</span></p>\n<p><span class=\"math display\">$$\ni\\hbar \\frac{\\mathrm{d} T(t)}{\\mathrm{d} t}\\Phi(\\boldsymbol{r}) =\n\\left[\\hat{H} \\Phi(\\boldsymbol{r})\\right] T(t)\n$$</span></p>\n<p><span class=\"math display\">$$\ni\\hbar \\frac{1}{T(t)}\\mathrm{d} t =\n\\frac{1}{\\Phi(\\boldsymbol{r})}\\hat{H} \\Phi(\\boldsymbol{r}) = const = E\n$$</span></p>\n<p>其中 <span class=\"math inline\"><em>E</em></span> 为本征值，<span\nclass=\"math inline\"><em>Φ</em></span> 为本征函数 得到分别只含有变量\n<span class=\"math inline\"><em>t</em></span> 和 <span\nclass=\"math inline\"><strong>r</strong></span> 的两个方程</p>\n<p><span class=\"math display\">$$\n\\left\\{\n\\begin{aligned}\n  &amp;i \\hbar \\frac{\\mathrm{d} T(t)}{\\mathrm{d} t} =\nET(t)  &amp;&amp;\\text{(1)}\\\\\n  &amp;\\hat{H} \\Phi(\\boldsymbol{r}) =\nE\\Phi(\\boldsymbol{r})  &amp;&amp;\\text{(2)}\n\\end{aligned}\n\\right.\n$$</span></p>\n<p>方程(1)的解为</p>\n<p><span class=\"math display\">$$\nT(t) = e^{-\\frac{i}{\\hbar}Et}\n$$</span></p>\n<p>方程(2)是关于变量 <span class=\"math inline\"><em>x</em></span>、<span\nclass=\"math inline\"><em>y</em></span>、<span\nclass=\"math inline\"><em>z</em></span>\n的微分方程，称为<strong>定态薛定谔方程</strong>，又称为哈密顿算符的本征方程</p>\n<p><span class=\"math display\">$$\n\\boxed{\\left[-\\frac{\\hbar^2}{2m}\\nabla^2 + U(x,y,z)\\right] \\Phi(x,y,z) =\nE\\Phi(x,y,z)}\n$$</span></p>\n<p>其解与外力场 <span class=\"math inline\"><em>U</em></span>\n和边界条件有关 波函数是两者的乘积</p>\n<p><span class=\"math display\">$$\n\\boxed{\\Psi (\\boldsymbol{r},t) =\n\\Phi(\\boldsymbol{r})e^{-i\\frac{1}{\\hbar}Et}}\n$$</span></p>\n<ul>\n<li>粒子在空间中出现的几率密度与时间无关——<strong>定态</strong></li>\n</ul>\n<p><span class=\"math display\">$$\n\\vert\\Psi (\\boldsymbol{r},t)\\vert^2 =\\vert\\Phi(\\boldsymbol{r})\ne^{-i\\frac{1}{\\hbar}Et}\\vert^2 = \\vert\\Phi(\\boldsymbol{r})\\vert^2\n$$</span></p>\n<h4 id=\"薛定谔方程的应用\">薛定谔方程的应用</h4>\n<h5 id=\"一维无限深方势阱\">一维无限深方势阱</h5>\n<p>金属中的电子由于金属表面势能（能垒）的束缚而被限制在一个有限的空间范围内运动\n如果金属表面的能垒很高，可以将金属表面看成一个刚性的盒子。若只考虑一维运动，则其势能函数为</p>\n<p><span class=\"math display\">$$\nU(x) =\n\\left\\{\n  \\begin{aligned}\n    &amp;0 \\quad (0 \\leq x \\leq L)\\\\\n    &amp;\\infty \\quad (x &lt; 0 \\text{ or } x &gt; L)\n  \\end{aligned}\n\\right.\n$$</span></p>\n<p>称为<strong>一维无限深方势阱</strong></p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504111721435.png\"\nalt=\"无限深方势阱\" />\n<figcaption aria-hidden=\"true\">无限深方势阱</figcaption>\n</figure>\n<ul>\n<li>势阱内</li>\n</ul>\n<p><span class=\"math display\">$$\n-\\frac{\\hbar^2}{2m}\\frac{\\mathrm{d}^2}{\\mathrm{d} x^2} \\Phi_i(x) =\nE\\Phi_i(x)\n$$</span></p>\n<p>令 <span class=\"math inline\">$k\n=\\sqrt{\\frac{2mE}{\\hbar^2}}$</span>，得</p>\n<p><span class=\"math display\">$$\n\\frac{\\mathrm{d}^2\\Phi_i}{\\mathrm{d} x^2} + k^2\\Phi_i = 0\n$$</span></p>\n<p>其解为</p>\n<p><span\nclass=\"math display\"><em>Φ</em><sub><em>i</em></sub>(<em>x</em>) = <em>C</em>sin (<em>k</em><em>x</em> + <em>δ</em>)</span></p>\n<p>其中 <span class=\"math inline\"><em>C</em></span> 和 <span\nclass=\"math inline\"><em>δ</em></span> 为常数，由波函数的自然条件确定</p>\n<ul>\n<li>势阱外</li>\n</ul>\n<p><span class=\"math display\">$$\n-\\frac{\\hbar^2}{2m}(\\frac{\\mathrm{d}^2}{\\mathrm{d}x^2}+\\infty)\\Phi_e(x)\n= E\\Phi_e(x)\n$$</span></p>\n<p>其解为</p>\n<p><span\nclass=\"math display\"><em>Φ</em><sub><em>e</em></sub>(<em>x</em>) = 0</span></p>\n<ul>\n<li>波函数在肼壁上连续的条件为</li>\n</ul>\n<p><span class=\"math display\">$$\n\\left\\{\n  \\begin{aligned}\n    &amp;\\Phi_i(0) = \\Phi_e(0) \\\\\n    &amp;\\Phi_i(L) = \\Phi_e(L) \\\\\n  \\end{aligned}\n\\right.\n$$</span></p>\n<p>由边界条件可得</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\Phi_i(0)= 0 &amp;&amp; \\text{(1)}\\\\\n  \\Phi_i(L) = 0 &amp;&amp; \\text{(2)}\n\\end{cases}\n$$</span></p>\n<p>由 <span class=\"math inline\">(1)</span> 可得 <span\nclass=\"math inline\"><em>δ</em> = 0</span>、</p>\n<p>由 <span class=\"math inline\">(2)</span> 可得 <span\nclass=\"math inline\"><em>k</em><em>L</em> = <em>n</em><em>π</em></span>，其中\n<span class=\"math inline\"><em>n</em> ∈ ℕ<sup>*</sup></span>，即 <span\nclass=\"math inline\">$k = \\frac{n\\pi}{L}$</span></p>\n<p><span class=\"math display\">$$\n\\Phi(x) =\\sqrt{\\frac{2}{L}}\\sin\\left(\\frac{n\\pi}{L}x\\right)\n$$</span></p>\n<ul>\n<li><strong>粒子的能量:</strong> <span class=\"math inline\">$E =\n\\frac{\\hbar^2k^2}{2m} = \\frac{n^2\\pi^2\\hbar^2}{2mL^2}$</span>，<span\nclass=\"math inline\"><em>n</em></span> 为能量量子数\n<ul>\n<li>能量取分立值（能级），这是<strong>能量量子化</strong>的表现</li>\n</ul></li>\n</ul>\n<p><span class=\"math display\">$$\n\\Delta E = E_{n+1} - E_n =\n\\frac{\\hbar^2}{2m}\\left(\\left(\\frac{(n+1)\\pi}{L}\\right)^2 -\n\\left(\\frac{n\\pi}{L}\\right)^2\\right) = (2n+1)\\frac{\\hbar^2\\pi^2}{2mL^2}\n$$</span></p>\n<ul>\n<li>当 <span class=\"math inline\"><em>a</em>↑</span> 时 <span\nclass=\"math inline\"><em>Δ</em><em>E</em>↓</span>，并且当 <span\nclass=\"math inline\"><em>n</em> → ∞</span> 时， <span\nclass=\"math inline\"><em>Δ</em><em>E</em> → 0</span>，即能级间隔趋于零，能级连续，形成连续谱</li>\n<li>最低能量（零点能）<span\nclass=\"math inline\">$E_1=\\frac{\\pi^2\\hbar^2}{amL^2}&gt;0$</span>，具有波动性</li>\n<li>在势阱中形成驻波</li>\n</ul>\n<p><span class=\"math display\">$$\n\\Phi(x) =C\\sin\\left(\\frac{n\\pi}{L}x\\right)\n$$</span></p>\n<p>由归一化条件</p>\n<p><span class=\"math display\">$$\n\\int_{-\\infty}^{+\\infty} \\vert \\Phi(x) \\vert^2\\,\\mathrm{d}x =\n\\int_{0}^{L} C^2\\sin^2\\left(\\frac{n\\pi}{L}x\\right)\\,\\mathrm{d}x = C^2\n\\cdot \\frac{L}{2} = 1\n$$</span></p>\n<p>解得</p>\n<p><span class=\"math display\">$$\nC = \\sqrt{\\frac{2}{L}}\n$$</span></p>\n<p>故定态波函数为</p>\n<p><span class=\"math display\">$$\n\\Phi(x) =\n\\left\\{\n  \\begin{aligned}\n    &amp;\\sqrt{\\frac{2}{L}}\\sin\\left(\\frac{n\\pi}{L}x\\right) &amp;&amp;\n(0 \\leq x \\leq L)\\\\\n    &amp;0 &amp;&amp; (x &lt; 0 \\text{ or } x &gt; L)\n  \\end{aligned}\n\\right.\n$$</span></p>\n<h6\nid=\"一维无线深方势阱中粒子的波函数和概率密度\">一维无线深方势阱中粒子的波函数和概率密度</h6>\n<p><span class=\"math display\">$$\n\\Phi (x,t) = \\sqrt{\\frac{2}{L}} \\sin\\left(\\frac{n\\pi}{L}x\\right), \\quad\n(0 \\leq x \\leq L)\n$$</span></p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504131458204.png\"\nalt=\"波函数和概率密度\" />\n<figcaption aria-hidden=\"true\">波函数和概率密度</figcaption>\n</figure>\n<p>可以看出</p>\n<ul>\n<li>势阱中的粒子波函数为驻波</li>\n<li>基态 <span class=\"math inline\"><em>n</em> = 1</span> 除了 <span\nclass=\"math inline\"><em>x</em> = 0</span> 和 <span\nclass=\"math inline\"><em>x</em> = <em>L</em></span>\n处为节点外，其余无节点</li>\n<li>第 <span class=\"math inline\"><em>n</em></span> 量子态有 <span\nclass=\"math inline\"><em>n</em> − 1</span> 个 node</li>\n</ul>\n<h6\nid=\"一维无限深势阱中粒子的波函数是正交归一的\">一维无限深势阱中粒子的波函数是正交归一的</h6>\n<p>设不同能级的波函数为 <span\nclass=\"math inline\"><em>Φ</em><sub><em>n</em></sub>(<em>x</em>)</span>\n和 <span\nclass=\"math inline\"><em>Φ</em><sub><em>m</em></sub>(<em>x</em>)</span></p>\n<ul>\n<li>正交性</li>\n</ul>\n<p><span class=\"math display\">$$\n\\int_{-\\infty}^{+\\infty} \\Phi_n(x) \\Phi_m(x)\\,\\mathrm{d}x = \\int\n_{-\\infty }^{+\\infty }\\sqrt{\\frac{2}{L}}\\sin\\frac{m\\pi }{L} x\\cdot\n\\sqrt{\\frac{2}{L}}\\sin\\frac{n\\pi }{L}\\,\\mathrm{d} x=\\frac{1}{L}\\int\n_{0}^{L}\\left(\\cos\\frac{m-n}{L} -\\cos\\frac{m+n}{L}\\right)\\,\\mathrm{d}\nx=0\n$$</span></p>\n<ul>\n<li>归一性</li>\n</ul>\n<p><span class=\"math display\">$$\n\\int_{-\\infty}^{+\\infty} \\Phi_n(x) \\Phi_n(x)\\,\\mathrm{d}x = \\int\n_{-\\infty }^{+\\infty }\\sqrt{\\frac{2}{L}}\\sin\\frac{n\\pi }{L} x\\cdot\n\\sqrt{\\frac{2}{L}}\\sin\\frac{n\\pi }{L}\\,\\mathrm{d} x=\\frac{1}{L}\\int\n_{0}^{L}\\left(\\cos 0 -\\cos\\frac{2n\\pi }{L}\\right)\\,\\mathrm{d} x=1\n$$</span></p>\n<h5 id=\"波尔对应原理\">波尔对应原理</h5>\n<ul>\n<li>在大量子数极限下，量子规律必须转化为经典规律，这也被称为<strong>量子物理的对应原理</strong></li>\n</ul>\n<p>比如</p>\n<ul>\n<li>本征能量</li>\n</ul>\n<p><span class=\"math display\">$$\nE = E_n = \\frac{\\hbar^2 \\pi^2 n^2}{2mL^2} = n^2 \\frac{h^2}{8mL^2}\n$$</span></p>\n<ul>\n<li>相邻能级的间隔为</li>\n</ul>\n<p><span class=\"math display\">$$\n\\Delta E_n = (2n+1)\\frac{h^2}{8mL^2}\n$$</span></p>\n<ul>\n<li>相对能级间隔</li>\n</ul>\n<p><span class=\"math display\">$$\n\\frac{\\Delta E_n}{E_n} = \\frac{2n+1}{n^2}\n$$</span></p>\n<ul>\n<li>当 <span class=\"math inline\"><em>n</em> → ∞</span> 时， <span\nclass=\"math inline\"><em>Δ</em><em>E</em><sub><em>n</em></sub> → 0</span>\n，即能级间隔趋于零，能级连续，形成连续谱</li>\n</ul>\n<p>粒子在势阱中的概率分布为</p>\n<p><span class=\"math display\">$$\n\\rho(x) = \\vert \\Phi(x) \\vert^2 =\n\\left\\{\n  \\begin{aligned}\n    &amp;\\frac{2}{L}\\sin^2(\\frac{n\\pi}{L}x) &amp;&amp; (0 \\leq x \\leq\nL)\\\\\n    &amp;0 &amp;&amp; (x &lt; 0 \\text{ or } x &gt; L)\n  \\end{aligned}\n\\right.\n$$</span></p>\n<h5 id=\"德布罗意的驻波思想\">德布罗意的驻波思想</h5>\n<ul>\n<li>一个频率为 <span class=\"math inline\"><em>ν</em></span> 、波长 <span\nclass=\"math inline\"><em>λ</em></span> 沿 <span\nclass=\"math inline\"><em>x</em></span>\n方向传播的单色平面波的表达式为</li>\n</ul>\n<p><span class=\"math display\">$$\n\\Psi(x,t) = \\Psi_0 e^{-i \\frac{2\\pi}{h}(Et -Px)}\n$$</span></p>\n<ul>\n<li>全波函数为</li>\n</ul>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n\\Psi ( x,t) =\\Phi ( x) e^{-\\frac{i}{\\hbar } Et} &amp;=\\sqrt{\\frac{2}{L}}\ne^{-i\\frac{Et}{\\hbar }}\\sin\\frac{n\\pi }{L} x\\\\\n&amp;=\\frac{1}{2i}\\sqrt{\\frac{2}{L}} e^{-i\\frac{Et}{\\hbar }}\\left(\ne^{i\\frac{n\\pi }{L} x} -e^{-i\\frac{n\\pi }{L} x}\\right)\\\\\n&amp;=\\frac{1}{2i}\\sqrt{\\frac{2}{L}} e^{-i\\frac{Et}{\\hbar }}\\left(\ne^{i\\frac{p_{n}}{\\hbar }} -e^{-i\\frac{p_{n}}{\\hbar } x}\\right)\n\\end{aligned}\n$$</span></p>\n<p>可以将波函数视为频率相同、波长相同、传播方向相反的两单色平面波的叠加</p>\n<p>则由德布罗意的物质波理论，一个动量为 <span\nclass=\"math inline\"><em>p</em></span>、质量为 <span\nclass=\"math inline\"><em>m</em></span>、能量为 <span\nclass=\"math inline\"><em>E</em></span> 的自由粒子，沿着 <span\nclass=\"math inline\"><em>x</em></span> 轴运动的波函数为</p>\n<p><span class=\"math display\">$$\n\\Psi ( x,t) =\\Psi _{0} e^{-\\frac{i}{\\hbar }( Et-px)}\n$$</span></p>\n<p>波函数也为频率相同、波长相同、传播方向相反的两单色平面波的叠加形成驻波</p>\n<ul>\n<li>势阱中粒子的动量和波长\n<ul>\n<li>动量：<span class=\"math inline\">$p_n =\\sqrt{2mE_n} =\n\\pm\\frac{n\\hbar}{2L} = \\pm n \\frac{ h}{2L}$</span></li>\n<li>波长：<span class=\"math inline\">$\\lambda_n =\n\\frac{\\hbar}{p_n}=\\frac{2L}{n}$</span>\n说明势阱中粒子的每一个能量本征态正好对应德布罗意波的一个特征波长的驻波</li>\n</ul></li>\n<li>符合德布罗意的驻波理论</li>\n</ul>\n<h5 id=\"一维方势垒和隧穿效应\">一维方势垒和隧穿效应</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504181642705.png\"\nalt=\"Tunel effect\" />\n<figcaption aria-hidden=\"true\">Tunel effect</figcaption>\n</figure>\n<p>设</p>\n<p><span class=\"math display\">$$\nV(x)=\n\\begin{cases}\n    0, &amp; x &lt; x_1 \\quad \\text{or} \\quad x &gt; x_2 \\\\\n    V_0, &amp; x_1 &lt; x &lt; x_2\n\\end{cases}\n$$</span></p>\n<p>称为方势垒</p>\n<p>现有一能量为 <span class=\"math inline\"><em>E</em></span>\n的粒子从左向右入射</p>\n<p>在经典力学中，若 <span\nclass=\"math inline\"><em>E</em> &lt; <em>V</em><sub>0</sub></span>，则粒子无法穿过势垒，<span\nclass=\"math inline\"><em>E</em> &gt; <em>V</em><sub>0</sub></span>\n时，粒子能够完全穿过势垒</p>\n<p>但是在量子力学中，粒子是一种物质波，情况完全不一样，需要通过求解薛定谔方程来确定</p>\n<p><span class=\"math display\">$$\n\\frac{d^2\\psi(x)}{dx^2}=\\frac{2m}{\\hbar^2}(V_0-E)\\psi(x)\n$$</span></p>\n<p>在这里我们设 <span\nclass=\"math inline\"><em>V</em><sub>0</sub> &gt; <em>E</em></span>，令\n<span class=\"math inline\">$k=\\sqrt{\\frac{2mE}{\\hbar^2}}$</span> 和 <span\nclass=\"math inline\">$k' = \\sqrt{\\frac{2m(V_0-E)}{\\hbar^2}}$</span></p>\n<p>则薛定谔方程可化为</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\frac{d^2\\psi_1(x)}{dx^2} = -k^2\\psi_1(x), &amp; x &lt; x_1 \\\\\n  \\frac{d^2\\psi_2(x)}{dx^2} = k'^2\\psi_2(x), &amp; x_1 &lt; x &lt; x_2\n\\\\\n  \\frac{d^2\\psi_3(x)}{dx^2} = -k^2\\psi_3(x), &amp; x &gt; x_2\n\\end{cases}\n$$</span></p>\n<p>解得</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\psi_1 = A e^{ikx} + A' e^{-ikx}, &amp; x &lt; x_1 \\\\\n  \\psi_2 = B e^{k'x} + B' e^{-k'x}, &amp; x_1 &lt; x &lt; x_2 \\\\\n  \\psi_3 = C e^{ikx} , &amp; x &gt; x_2\n\\end{cases}\n$$</span></p>\n<p>由连续性（在这里我们令 <span\nclass=\"math inline\"><em>x</em><sub>1</sub> = 0</span>，<span\nclass=\"math inline\"><em>x</em><sub>2</sub> = <em>a</em></span>）</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\psi_1(0) = \\psi_2(0) \\rightarrow A + A' = B + B' \\\\\n  \\psi_1'(0) = \\psi_2'(0) \\rightarrow ik(A - A') = k' (B - B') \\\\\n  \\psi_2(a) = \\psi_3(a) \\rightarrow B e^{k'a} + B' e^{-k'a} = C e^{ika}\n\\\\\n  \\psi_2'(a) = \\psi_3'(a) \\rightarrow k' B e^{k'a} - k' B' e^{-k'a} =\nikC e^{ika}\n\\end{cases}\n$$</span></p>\n<p>求解并经过计算得到</p>\n<ul>\n<li><strong>反射系数：</strong> <span class=\"math inline\">$\\displaystyle\nR =\\frac{\\vert A'\\vert^2}{\\vert A\\vert^2}\n=\\frac{(k^2+k'^2)^2\\sinh^2(k'a)}{\\left(k^2+k'^2\\right)\\sinh^2(k'a) +\n4k^2k'^2}$</span></li>\n<li><strong>透射系数：</strong> <span class=\"math inline\">$\\displaystyle\nT =\\frac{\\vert C\\vert^2}{\\vert A\\vert^2}\n=\\frac{4k^2k'^2}{\\left(k^2+k'^2\\right)\\sinh^2(k'a) +\n4k^2k'^2}$</span></li>\n</ul>\n<p>显然有 <span class=\"math inline\">$\\boxed{T+R=1}$</span></p>\n<h2 id=\"定态问题\">定态问题</h2>\n<h2 id=\"量子力学的基本假设\">量子力学的基本假设</h2>\n<h3 id=\"波函数假设\">波函数假设</h3>\n<p>微观粒子的状态可以被一个波函数完全描述，从这个波函数可以得到体系的所有性质</p>\n<p>波函数一般满足连续性、有限性和单值性三个条件</p>\n<ol type=\"1\">\n<li>物质波可以用一个随时间、空间变化的波函数 <span\nclass=\"math inline\"><em>Ψ</em>(<strong>r</strong>, <em>t</em>)</span>\n来描述</li>\n<li>自由粒子的波函数是单色平面波 <span class=\"math inline\">$\\Psi(x,t) =\n\\Psi_0 e^{-i\\frac{2\\pi}{h}(Et - Px)} = \\Psi_0 e^{-i\\frac{1}{\\hbar}(Et -\nPx)}$</span></li>\n<li>波恩：德布罗意波是描述粒子在空间概率分布的概率波 波函数的模的平方\n<span\nclass=\"math inline\">|<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup></span>\n表示 <span class=\"math inline\"><em>t</em></span> 时刻，在坐标 <span\nclass=\"math inline\"><strong>r</strong></span> 处粒子出现的概率密度</li>\n<li>波函数满足<strong>单值、有限、连续</strong>的条件，称为<strong>波函数的标准条件</strong></li>\n<li><strong>归一化条件：</strong> 在整个空间中发现粒子的概率为 <span\nclass=\"math inline\">1</span>，即 <span\nclass=\"math inline\">∫<sub><em>Ω</em></sub>|<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup> d<em>V</em> = 1</span>，其中\n<span class=\"math inline\"><em>Ω</em></span> 为全空间</li>\n</ol>\n<h3 id=\"力学算符假设\">力学算符假设</h3>\n<p>量子力学中的力学量用线性厄米（Hermite）算符表示。如果经典力学中有相关的力学量，则在量子力学中也有相应表示这个力学量的算符</p>\n<p>算符能将波函数变换为另一个波函数</p>\n<ul>\n<li>动量算符 <span\nclass=\"math inline\"><em>p̂</em> = −<em>i</em>ℏ∇</span></li>\n<li>位置算符 <span class=\"math inline\">$\\hat{\\boldsymbol{r}} =\n\\boldsymbol{r}$</span></li>\n<li>能量算符 <span class=\"math inline\">$\\hat{H} = \\frac{\\hat{p}^2}{2m} +\nU(\\boldsymbol{r}) = -\\frac{\\hbar ^2}{2m}\\nabla ^2 +\nU(\\boldsymbol{r})$</span></li>\n<li>角动量算符 <span class=\"math inline\">$\\hat{\\boldsymbol{L}}\n=\\hat{\\boldsymbol{r}} \\times \\hat{\\boldsymbol{p}}\n=\\left\\vert\\begin{smallmatrix}\\boldsymbol{i} &amp; \\boldsymbol{j} &amp;\n\\boldsymbol{k} \\newline x &amp; y &amp; z \\newline p_x &amp; p_y &amp;\np_z \\end{smallmatrix}\\right\\vert$</span>\n<ul>\n<li><span\nclass=\"math inline\"><em>L̂</em><sub><em>x</em></sub> = <em>y</em><em>p̂</em><sub><em>z</em></sub> − <em>z</em><em>p̂</em><sub><em>y</em></sub></span></li>\n<li><span\nclass=\"math inline\"><em>L̂</em><sub><em>y</em></sub> = <em>z</em><em>p̂</em><sub><em>x</em></sub> − <em>x</em><em>p̂</em><sub><em>z</em></sub></span></li>\n<li><span\nclass=\"math inline\"><em>L̂</em><sub><em>z</em></sub> = <em>x</em><em>p̂</em><sub><em>y</em></sub> − <em>y</em><em>p̂</em><sub><em>x</em></sub></span></li>\n</ul></li>\n</ul>\n<h4 id=\"厄米hermite算符\">厄米（Hermite）算符</h4>\n<p><span class=\"math inline\"><em>Â</em></span>\n是厄米算符的充分必要条件是</p>\n<p><span\nclass=\"math display\">∫<em>Ψ</em><sup>*</sup><em>Â</em><em>φ</em> d<em>V</em> = ∫<em>Ψ</em>(<em>Â</em><em>Ψ</em><sup>*</sup>) d<em>V</em></span></p>\n<p>其中 <span class=\"math inline\"><em>Ψ</em></span> 和 <span\nclass=\"math inline\"><em>φ</em></span> 是在无穷远处趋向 <span\nclass=\"math inline\">0</span> 的任意函数</p>\n<ul>\n<li>如果 <span class=\"math inline\"><em>Â</em></span> 和 <span\nclass=\"math inline\"><em>B̂</em></span> 都是厄米算符，则 <span\nclass=\"math inline\"><em>Â</em><em>B̂</em> + <em>B̂</em><em>Â</em></span>\n也是厄米算符</li>\n</ul>\n<p><strong>证明：</strong></p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n&amp;\\int _{-\\infty }^{+\\infty }\\Psi ^{*}\\left(\\hat{A}\\hat{B} +\n\\hat{B}\\hat{A}\\right)\\varphi\\,\\mathrm{d}x \\\\\n= &amp;\\int _{-\\infty }^{+\\infty }\\Psi\n^{*}\\hat{A}(\\hat{B}\\varphi)\\,\\mathrm{d}x + \\int _{-\\infty }^{+\\infty\n}\\Psi ^{*}\\hat{B}(\\hat{A}\\varphi)\\,\\mathrm{d}x\\\\\n= &amp;\\int _{-\\infty }^{+\\infty }(\\hat{A}\\Psi)\n^{*}(\\hat{B}\\varphi)\\,\\mathrm{d}x + \\int _{-\\infty }^{+\\infty\n}(\\hat{B}\\Psi) ^{*}(\\hat{A}\\varphi)\\,\\mathrm{d}x\\\\\n= &amp;\\int\n_{-\\infty}^{+\\infty}\\left[\\varphi\\left(\\hat{B}\\hat{A}\\Psi\\right)^*+\\varphi\\left(\\hat{A}\\hat{B}\\Psi\\right)^*\\right]\\\\\n= &amp;\\int\n_{-\\infty}^{+\\infty}\\varphi\\left[\\left(\\hat{A}\\hat{B}+\\hat{B}\\hat{A}\\right)\n\\Psi\\right]^*\\,\\mathrm{d}x\n\\end{aligned}\n$$</span></p>\n<ul>\n<li>如果 <span class=\"math inline\"><em>Â</em></span> 和 <span\nclass=\"math inline\"><em>B̂</em></span> 都是厄米算符，则 <span\nclass=\"math inline\"><em>i</em>(<em>Â</em><em>B̂</em> − <em>B̂</em><em>Â</em>)</span>\n也是厄米算符</li>\n</ul>\n<h5 id=\"厄米算符的性质\">厄米算符的性质</h5>\n<ol type=\"1\">\n<li>对于系统的任何量子态，其厄米算符的平均值 <span\nclass=\"math inline\"><em>F̄</em> = ∫<sub>−∞</sub><sup>+∞</sup><em>Ψ</em><sup>*</sup><em>F̂</em><em>Ψ</em> d<em>V</em></span>\n是实数</li>\n<li><strong>厄米算符的本征值是实数</strong>，所以量子力学中的任何力学算符都是厄米算符</li>\n<li><strong>厄米算符属于不同本征值的本征函数彼此正交</strong>\n<ul>\n<li><strong>厄米算符的本征函数是正交统一的完全集</strong></li>\n<li>任何物理上合理的波函数都可以用这个正交统一的完全集展开</li>\n</ul></li>\n</ol>\n<p><strong>证明：</strong></p>\n<ul>\n<li>平均值为实数</li>\n</ul>\n<p><span\nclass=\"math display\"><em>F̄</em> = ∫<sub>−∞</sub><sup>+∞</sup><em>Ψ</em><sup>*</sup><em>F̂</em><em>Ψ</em> d<em>V</em> = ∫<sub>−∞</sub><sup>+∞</sup>(<em>F̂</em><em>Ψ</em>)<sup>*</sup><em>Ψ</em> d<em>V</em> = (∫<sub>−∞</sub><sup>+∞</sup><em>Ψ</em><sup>*</sup><em>F̂</em><em>Ψ</em> d<em>V</em>)<sup>*</sup> = <em>F̄</em><sup>*</sup></span></p>\n<p>故 <span class=\"math inline\"><em>F̄</em></span> 是实数</p>\n<ul>\n<li><p>本征值是实数</p>\n<p>由厄米算符的定义</p></li>\n</ul>\n<p><span\nclass=\"math display\">∫<sub>−∞</sub><sup>+∞</sup><em>Ψ</em><sup>*</sup><em>F̂</em><em>Ψ</em><sub><em>n</em></sub> d<em>V</em> = ∫<sub>−∞</sub><sup>+∞</sup>(<em>F̂</em><em>Ψ</em>)<sup>*</sup><em>Ψ</em> d<em>V</em></span></p>\n<p>设 <span\nclass=\"math inline\"><em>F̂</em><em>Ψ</em> = <em>F</em><em>Ψ</em></span>，则</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n    \\int _{-\\infty} ^{+\\infty} \\Psi ^*F\\Psi\\mathrm{d}\\,V &amp;= \\int\n_{-\\infty}^{+\\infty} \\left(F\\Psi\\right)^* \\Psi\\,\\mathrm{d}V\\\\\n    \\Rightarrow F\\int _{-\\infty} ^{+\\infty} \\Psi ^*\\Psi\\mathrm{d}\\,V\n&amp;= F^*\\int _{-\\infty}^{+\\infty} \\Psi^* \\Psi\\,\\mathrm{d}V\n\\end{aligned}\n$$</span></p>\n<p>则 <span\nclass=\"math inline\"><em>F</em> = <em>F</em><sup>*</sup></span>，故本征值为实数</p>\n<ul>\n<li><p>属于不同本征值的本征函数正交</p>\n<p>由厄米算符的定义</p></li>\n</ul>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  \\int \\Psi _{m}^{*}\\hat{F} \\Psi _{n} \\, \\mathrm{d}V&amp;=\\int (\\hat{F}\n\\Psi _{m})^{*} \\Psi _{n} \\, \\mathrm{d} V\\\\\nF_{n}\\int \\Psi m^{*} \\Psi _{n}\\,\\mathrm{d} V&amp;=F_{m}^{*}\\int \\Psi\n_{m}^{*} \\Psi _{n} \\, \\mathrm{d} V\\\\\n( F_{n} -F_{m})\\int \\Psi _{m}^{*} \\Psi _{n} \\,\\mathrm{d} V&amp;=0\n\\end{aligned}\n$$</span></p>\n<p><span class=\"math inline\"><em>m</em> ≠ <em>n</em></span>，则 <span\nclass=\"math inline\">∫<em>Ψ</em><sub><em>m</em></sub><sup><em>n</em></sup><em>Ψ</em><sub><em>n</em></sub> d<em>V</em> = 1</span>，则\n<span\nclass=\"math inline\"><em>F</em><sub><em>n</em></sub> = <em>F</em><sub><em>m</em></sub></span></p>\n<p>这里有 <span class=\"math inline\">$\\displaystyle \\int \\Psi _m^*\\Psi _n\n\\, \\mathrm{d}V = \\delta _{nm} =\\begin{cases} 0 &amp;,n\\neq m\\\\ 1\n&amp;,n=m\\end{cases}$</span></p>\n<ul>\n<li><p>波函数可以用正交统一的完全集展开 <span\nclass=\"math inline\"><em>Ψ</em> = ∑<sub><em>n</em></sub><em>c</em><sub><em>n</em></sub><em>Ψ</em><sub><em>n</em></sub></span></p>\n<p>使用数学归纳法，假设当 <span class=\"math inline\"><em>n</em></span>\n时成立</p></li>\n</ul>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  &amp; \\Psi &amp;&amp;= \\sum _{n} c_n\\Psi _n \\\\\n  &amp; \\Psi _m^*\\Psi &amp;&amp;= \\sum _{n} c_n\\Psi _m^*\\Psi _n\\\\\n  &amp; \\int\\Psi _m^*\\Psi \\,\\mathrm{d}V &amp;&amp;= \\sum _{n} c_n\\int\n\\Psi _m^*\\Psi _n \\,\\mathrm{d}V \\\\\n  &amp;                                   &amp;&amp;= \\sum _n c_n \\delta\n_{mn}\\\\\n  &amp;                                  &amp;&amp;= c_m\\\\\n\\end{aligned}\n$$</span></p>\n<p>可以得到 <span\nclass=\"math inline\"><em>c</em><sub><em>m</em></sub> = ∫<em>Ψ</em><sub><em>m</em></sub><sup>*</sup><em>Ψ</em> d<em>V</em></span>\n，当 <span class=\"math inline\"><em>m</em></span> 时成立</p>\n<h3 id=\"测量假设\">测量假设</h3>\n<p>当一个量子系统处于量子态 <span class=\"math inline\"><em>Ψ</em></span>\n时，对力学量 <span class=\"math inline\"><em>F̂</em></span>\n的测量结果一定是该力学算符的本征值之一，结果为 <span\nclass=\"math inline\"><em>F</em><sub><em>n</em></sub></span> 的概率为\n<span\nclass=\"math inline\">|<em>c</em><sub><em>n</em></sub>|<sup>2</sup> = |∫<em>ϕ</em><sub><em>n</em></sub><sup>*</sup><em>Ψ</em> d<em>V</em>|<sup>2</sup></span></p>\n<p>这里 <span\nclass=\"math inline\"><em>F̂</em><em>φ</em><sub><em>n</em></sub> = <em>F</em><sub><em>n</em></sub><em>φ</em><sub><em>n</em></sub></span>\n是力学量 <span class=\"math inline\"><em>F̂</em></span>\n的本征方程，测量完成后，该量子系统坍缩至 <span\nclass=\"math inline\"><em>φ</em><sub><em>n</em></sub></span></p>\n<p><strong>结论</strong></p>\n<ul>\n<li>根据测量假设，当一个量子系统处在量子态 <span\nclass=\"math inline\"><em>Ψ</em></span> 时，对力学量 <span\nclass=\"math inline\"><em>F̂</em></span> 的测量结果的统计平均值为</li>\n</ul>\n<p><span class=\"math display\">$$\n\\bar{F} = \\sum _n F_n \\left\\vert c_n \\right\\vert ^2 = \\sum _n F_n\n\\left\\vert \\int\\phi_n^*\\Psi\\,\\mathrm{d}V\\right\\vert ^2 =\\boxed{\\int\n\\Psi^* \\hat{F} \\Psi\\,\\mathrm{d}V}\n$$</span></p>\n<p><strong>证明：</strong></p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n   &amp;\\int \\Psi ^* \\hat{F} \\Psi \\mathrm{d}V\\\\\n   =&amp;\\int \\left(\\sum_m c_m\\Psi_m\\right)^*\\hat{F}\\left(\\sum_n\nc_n\\Psi_n\\right)\\mathrm{d}V\\\\\n   =&amp;\\int \\left(\\sum_m c_m\\Psi_m\\right)^*\\left(\\sum_n c_n\n\\hat{F}\\Psi_n\\right)\\mathrm{d}V\\\\\n   =&amp;\\int \\left(\\sum_m c_m\\Psi_m\\right)^*\\left(\\sum_n c_n\nF_n\\Psi_n\\right)\\mathrm{d}V\\\\\n   =&amp;\\sum_{mn}c_m c_n F_n \\int\n\\left(\\Psi_m^*\\Psi_n\\right)\\mathrm{d}V\\\\\n   =&amp;\\sum_{mn}c_m c_n F_n \\delta _{mn}\\\\\n   =&amp;\\sum_n\\left\\vert c_n \\right\\vert ^2 F_n\n\\end{aligned}\n$$</span></p>\n<ul>\n<li>测量假设推论：当一个量子系统处于量子态 <span\nclass=\"math inline\"><em>Ψ</em></span> 时，且满足 <span\nclass=\"math inline\">∑<sub><em>n</em></sub>|<em>c</em><sub><em>n</em></sub>|<sup>2</sup> = 1</span>\n时，对力学量的测量结果一定是该力学算符的本征值之一，测量结果为 <span\nclass=\"math inline\"><em>F</em><sub><em>n</em></sub></span> 的概率为\n<span\nclass=\"math inline\">|<em>c</em><sub><em>n</em></sub>|<sup>2</sup></span>，测量完成之后，该量子系统探索至\n<span class=\"math inline\"><em>ϕ</em><sub><em>n</em></sub></span></li>\n</ul>\n<h4 id=\"动量本征方程\">动量本征方程</h4>\n<p><span\nclass=\"math display\">−<em>i</em>ℏ∇<em>Φ</em><sub><strong>r</strong></sub>(<strong>r</strong>) = <em>p̂</em><em>Φ</em><sub><strong>r</strong></sub>(<strong>r</strong>) = <em>p</em><em>Φ</em><sub><strong>r</strong></sub>(<strong>r</strong>)</span></p>\n<p>其在三个坐标轴上的分量为</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{r}}}{\\partial x} = p_x\\Phi\n_{\\boldsymbol{r}}\\\\\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{r}}}{\\partial y} = p_y\\Phi\n_{\\boldsymbol{r}}\\\\\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{r}}}{\\partial z} = p_z\\Phi\n_{\\boldsymbol{r}}\n\\end{cases}\n$$</span></p>\n<p>其解为</p>\n<p><span class=\"math display\">$$\n\\Phi _{\\boldsymbol{p}}(\\boldsymbol{r}) =\n\\frac{1}{(2\\pi\\hbar)^\\frac{3}{2}}e^{\\frac{i}{\\hbar}\\boldsymbol{p}\\cdot\n\\boldsymbol{r}}\n$$</span></p>\n<p>测量结果为 <span class=\"math inline\"><em>p</em></span>\n的概率密度为</p>\n<p><span class=\"math display\">$$\n\\vert c_p \\vert^2 = \\left\\vert \\int\n\\Phi_p^*\\Psi\\,\\mathrm{d}v\\right\\vert^2 = \\left\\vert \\int\n\\frac{1}{(2\\pi\\hbar)^\\frac{3}{2}}e^{-\\frac{i}{\\hbar}\\boldsymbol{p}\\cdot\n\\boldsymbol{r}}\\Psi\\,\\mathrm{d}v\\right\\vert^2\n$$</span></p>\n<p>统计平均值为</p>\n<p><span\nclass=\"math display\"><em>p̄</em> = ∑<sub><em>n</em></sub><em>p</em><sub><em>i</em></sub>|<em>c</em><sub><em>p</em><sub><em>i</em></sub></sub>|<sup>2</sup></span></p>\n<h4 id=\"动能本征方程\">动能本征方程</h4>\n<p><span\nclass=\"math display\">−<em>i</em>ℏ∇<em>Φ</em><sub><strong>p</strong></sub>(<strong>r</strong>) = <em>p̂</em><em>Φ</em><sub><strong>p</strong></sub>(<strong>r</strong>)</span></p>\n<p>其在三个坐标轴的分量为</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{p}}}{\\partial x} = p_x\\Phi\n_{\\boldsymbol{p}}\\\\\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{p}}}{\\partial y} = p_y\\Phi\n_{\\boldsymbol{p}}\\\\\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{p}}}{\\partial z} = p_z\\Phi\n_{\\boldsymbol{p}}\n\\end{cases}\n$$</span></p>\n<p>记动能算符为 <span class=\"math inline\"><em>T̂</em></span></p>\n<p><span class=\"math display\">$$\n\\hat{T}\\Phi _{\\boldsymbol{p}}(\\boldsymbol{r}) =\n-\\frac{\\hbar^2}{2m}\\nabla ^2\\Phi _{\\boldsymbol{p}}(\\boldsymbol{r})=\n\\frac{\\hat{p}^2}{2m}\\Phi _{\\boldsymbol{p}}(\\boldsymbol{r})\n$$</span></p>\n<p>所以<strong>动量的本征函数等于动能的本征函数</strong></p>\n<p>同样当一个量子系统处于量子态 <span\nclass=\"math inline\"><em>Ψ</em></span> 时，测量动能为 <span\nclass=\"math inline\">$\\frac{p^2}{2m}$</span> 的概率为</p>\n<p><span class=\"math display\">$$\n\\vert c_{\\frac{p^2}{2m}} \\vert^2 = \\left\\vert \\int\n\\Phi_{\\frac{p^2}{2m}}^*\\Psi\\,\\mathrm{d}v\\right\\vert^2 = \\left\\vert \\int\n\\frac{1}{(2\\pi\\hbar)^\\frac{3}{2}}e^{-\\frac{i}{\\hbar}\\boldsymbol{p}\\cdot\n\\boldsymbol{r}}\\Psi\\,\\mathrm{d}v\\right\\vert^2\n$$</span></p>\n<p>统计平均值为</p>\n<p><span class=\"math display\">$$\n\\bar{\\frac{p^2}{2m}} = \\sum_{n} \\frac{p_i^2}{2m}\\vert\nc_{\\frac{p_i^2}{2m}} \\vert ^2\n$$</span></p>\n<h3 id=\"态叠加原理\">态叠加原理</h3>\n<p>如果 <span\nclass=\"math inline\"><em>Ψ</em><sub>1</sub>, <em>Ψ</em><sub>2</sub>…</span>\n是体系的一系列可能的状，则 <span class=\"math inline\">$\\displaystyle\\Psi\n= \\sum _i ^n c_n\\Psi_n$</span> 也是体系的一个可能的状态。对于处于 <span\nclass=\"math inline\"><em>Ψ</em></span> 态的体系，该体系分别部分地处在\n<span\nclass=\"math inline\"><em>Ψ</em><sub>1</sub>, <em>Ψ</em><sub>2</sub>…<em>Ψ</em><sub><em>n</em></sub>…</span>\n态中</p>\n<h3 id=\"薛定谔方程-1\">薛定谔方程</h3>\n<p>波函数随时间演化满足<strong>薛定谔方程</strong></p>\n<p><span class=\"math display\">$$\n\\boxed{i\\hbar \\frac{\\partial \\Psi (\\boldsymbol{r},t)}{\\partial t} =\n\\hat{H} \\Psi (\\boldsymbol{r},t)}\n$$</span></p>\n<h4 id=\"定态问题-1\">定态问题</h4>\n<p>若粒子处于稳定的势场中，则势能函数 <span\nclass=\"math inline\"><em>U</em></span>\n与时间无关，称这类问题为定态问题</p>\n<p><span class=\"math display\">$$\n\\Psi(\\boldsymbol{r} , t) = \\Phi(\\boldsymbol{r})e^{-i\\frac{1}{\\hbar}Et}\n$$</span></p>\n<p><span class=\"math display\">$$\n\\left[ -\\frac{\\hbar^2}{2m}\\nabla^2   + U(\\boldsymbol{r})\\right]\n\\Phi(\\boldsymbol{r}) = E\\Phi(\\boldsymbol{r})\n$$</span></p>\n<p>也称为哈密顿算符的本征方程</p>\n<h3 id=\"同类粒子的不可分辨性原理\">同类粒子的不可分辨性原理</h3>\n<p>在量子力学中，内禀属行完全相同的粒子是<strong>不可分辨</strong>的，对任意这两个粒子进行交换，不会改变系统的状态</p>\n<p>经典力学中，能够得到粒子的运动方程和轨道方程 <span\nclass=\"math inline\"><em>r⃗</em> = <em>r⃗</em>(<em>t</em>)</span>，然而在量子力学中，只能得到粒子在空间中分布的概率密度\n<span\nclass=\"math inline\"><em>ρ</em> = |<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup></span>，而不能得到粒子在空间中的轨道方程，因此得不到粒子的轨道方程</p>\n<p>对于内禀性相同的粒子，因为没有轨道方程，所以无法分辨，对于任意的两个这样的粒子进行交换，不会改变系统的状态，即粒子在空间中出现的概率密度不会改变</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  &amp;&amp;\\left\\vert\\Psi(1,\\ldots , i , \\ldots , j \\ldots\nn)\\right\\vert &amp;= \\left\\vert\\Psi(1,\\ldots , j , \\ldots , i \\ldots\nn)\\right\\vert\\\\\n  \\Rightarrow&amp;&amp;\\Psi(1,\\ldots , i , \\ldots , j \\ldots n) &amp;=\ne^{i\\theta}\\Psi(1,\\ldots , j , \\ldots , i \\ldots n)\n\\end{aligned}\n$$</span></p>\n<p>实验表明，所有粒子可以分为两类</p>\n<ol type=\"1\">\n<li><strong>玻色子：</strong> <span\nclass=\"math inline\"><em>θ</em> = 0</span>，交换粒子后波函数不变</li>\n<li><strong>费米子：</strong> <span\nclass=\"math inline\"><em>θ</em> = <em>π</em></span>，交换粒子后波函数反对称</li>\n</ol>\n<h3 id=\"算符之间的对易关系\">算符之间的对易关系</h3>\n<p>两个算符 <span class=\"math inline\"><em>Â</em></span> 和 <span\nclass=\"math inline\"><em>B̂</em></span> 的对易子记为 <span\nclass=\"math inline\">[<em>Â</em>, <em>B̂</em>] = <em>Â</em><em>B̂</em> − <em>B̂</em><em>Â</em></span></p>\n<h4\nid=\"动量算符和坐标算符之间的对易关系\">动量算符和坐标算符之间的对易关系</h4>\n<p><span\nclass=\"math display\">[<em>x</em>, <em>p̂</em><sub><em>x</em></sub>] = −<em>i</em>ℏ</span></p>\n<p><strong>证明：</strong></p>\n<p>将 <span\nclass=\"math inline\">[<em>x</em>, <em>p̂</em><sub><em>x</em></sub>] = <em>x</em><em>p̂</em><sub><em>X</em></sub> − <em>p̂</em><sub><em>x</em></sub><em>x</em></span>\n作用于任意波函数 <span class=\"math inline\"><em>Ψ</em></span> 上</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  \\left[x,\\hat{p}_{x}\\right]\\Psi &amp;= \\left(x\\hat{p}_{x} - \\hat{p}_x\nx\\right)\\Psi\\\\\n  &amp;=-i\\hbar\\left(x\\frac{\\partial}{\\partial x} -\n\\frac{\\partial}{\\partial x}x\\right)\\Psi\\\\\n  &amp;=-i\\hbar\\left[x\\frac{\\partial \\Psi}{\\partial\nx}-\\frac{\\partial}{\\partial x}\\left(x\\Psi\\right)\\right]\\\\\n  &amp;=i\\hbar\\Psi\n\\end{aligned}\n$$</span></p>\n<p>故 <span\nclass=\"math inline\">[<em>x</em>, <em>p̂</em><sub><em>x</em></sub>] = −<em>i</em>ℏ</span></p>\n<h3 id=\"共同本征函数\">共同本征函数</h3>\n<h4 id=\"两个算符对易\">两个算符对易</h4>\n<p>如果两个算符 <span class=\"math inline\"><em>Â</em></span> 和 <span\nclass=\"math inline\"><em>B̂</em></span> 满足对易子为 <span\nclass=\"math inline\">0</span> ，即 <span\nclass=\"math inline\">[<em>Â</em>, <em>B̂</em>] = <em>Â</em><em>B̂</em> − <em>B̂</em><em>Â</em> = 0</span>，则称这两个算符<strong>对易</strong></p>\n<h4 id=\"对易的一个定理\">对易的一个定理</h4>\n<p>若两个力学量算符有一组共同完备的本征函数系，则二算符对易</p>\n<p><strong>证明：</strong></p>\n<p>假设</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\hat{F}\\varphi _n = F_n \\varphi _n\\\\\n  \\hat{G}\\varphi _n = G_n \\varphi _n\n\\end{cases}\n$$</span></p>\n<p><span class=\"math inline\"><em>φ</em></span> 组成完备系，则任意量子态\n<span class=\"math inline\"><em>Φ</em>(<em>x</em>)</span> 可以按其展开为\n<span\nclass=\"math inline\"><em>Φ</em>(<em>x</em>) = ∑<sub><em>n</em></sub><em>c</em><sub><em>i</em></sub><em>φ</em><sub><em>i</em></sub>(<em>x</em>)</span></p>\n<p>则</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  \\left(\\hat{F}\\hat{G}-\\hat{G}\\hat{F}\\right)\\Psi(x)\n  &amp;= \\left(\\hat{F}\\hat{G}-\\hat{G}\\hat{F}\\right)\\sum _n c_n \\varphi\n_n (x)\\\\\n  &amp;= \\sum _n c_n \\left(\\hat{F}\\hat{G}-\\hat{G}\\hat{F}\\right)\\varphi\n_n (x)\\\\\n  &amp;= \\sum _n c_n \\left(F_nG_n - G_nF_n\\right)\\varphi _n (x)\\\\\n  &amp; = 0\n\\end{aligned}\n$$</span></p>\n<p>由于 <span class=\"math inline\"><em>Ψ</em>(<em>x</em>)</span>\n是任意的函数，则 <span\nclass=\"math inline\"><em>F̂</em><em>Ĝ</em> = <em>Ĝ</em><em>F̂</em></span></p>\n<ul>\n<li><strong>其逆定理：</strong>\n若两个力学算符对易，则这两个算符有组成完备系的共同本征函数</li>\n</ul>\n<p><strong>证明：</strong></p>\n<p>已知 <span\nclass=\"math inline\"><em>F̂</em><em>Ĝ</em> = <em>Ĝ</em><em>F̂</em></span>，<span\nclass=\"math inline\"><em>F̂</em><em>ϕ</em><sub><em>n</em></sub> = <em>F</em><em>ϕ</em><sub><em>n</em></sub></span></p>\n<p><span\nclass=\"math display\"><em>F̂</em><em>Ĝ</em><em>φ</em><sub><em>n</em></sub> = <em>Ĝ</em><em>F̂</em><em>φ</em><sub><em>n</em></sub> = <em>F</em><em>Ĝ</em><em>φ</em><sub><em>n</em></sub></span></p>\n<p>即</p>\n<p><span\nclass=\"math display\"><em>F̂</em>(<em>Ĝ</em><em>φ</em><sub><em>n</em></sub>) = <em>F</em>(<em>Ĝ</em><em>φ</em><sub><em>n</em></sub>)</span></p>\n<p>说明 <span\nclass=\"math inline\"><em>Ĝ</em><em>φ</em><sub><em>n</em></sub></span>\n也是 <span class=\"math inline\"><em>F̂</em></span> 的本征函数，本征值为\n<span class=\"math inline\"><em>F</em></span> 故 <span\nclass=\"math inline\"><em>Ĝ</em><em>φ</em><sub><em>n</em></sub></span> 和\n<span class=\"math inline\"><em>φ</em><sub><em>n</em></sub></span>\n表示统一个量子态，<span\nclass=\"math inline\"><em>Ĝ</em><em>φ</em><sub><em>n</em></sub> = <em>G</em><em>φ</em></span></p>\n<h3 id=\"力学量完全集合\">力学量完全集合</h3>\n<ul>\n<li><strong>定义：</strong>能够完全确定状态的一组两两对易的力学量算符的最小（数目）集称为<strong>力学量完全集</strong></li>\n<li>力学量完全集中的力学量数目一般与体系自由度数相同</li>\n<li>由力学量的完全集所确定的本征函数系构成该体系态空间的一组完备的本征函数，即体系中的任何状态均可用它展开</li>\n</ul>\n<h3 id=\"角动量算符之间的对易关系\">角动量算符之间的对易关系</h3>\n<h4 id=\"角动量算符\">角动量算符</h4>\n<ul>\n<li><span\nclass=\"math inline\">[<em>L̂</em><sub><em>x</em></sub>, <em>L̂</em><sub><em>y</em></sub>] = <em>i</em>ℏ<em>L̂</em><sub><em>z</em></sub></span></li>\n<li><span\nclass=\"math inline\">[<em>L̂</em><sub><em>y</em></sub>, <em>L̂</em><sub><em>z</em></sub>] = <em>i</em>ℏ<em>L̂</em><sub><em>x</em></sub></span></li>\n<li><span\nclass=\"math inline\">[<em>L̂</em><sub><em>z</em></sub>, <em>L̂</em><sub><em>x</em></sub>] = <em>i</em>ℏ<em>L̂</em><sub><em>y</em></sub></span></li>\n</ul>\n<h4 id=\"角动量平方算符\">角动量平方算符</h4>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n\\hat{L} ^2 =\\hat{L} \\cdot \\hat{L} &amp;= \\hat{L}_x^2 + \\hat{L}_y^2 +\n\\hat{L}_z^2\\\\\n  &amp;= -\\hbar ^2 \\left[\n\\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial}{\\partial\\theta}\\right)+\\frac{1}{\\sin\\theta^2}\\frac{\\partial^2}{\\partial\n\\varphi^2}\\right]\n\\end{aligned}\n$$</span></p>\n<p><span\nclass=\"math display\">[<em>L̂</em><sup>2</sup>, <em>L̂</em><sub><em>x</em></sub>] = [<em>L̂</em><sup>2</sup>, <em>L̂</em><sub><em>y</em></sub>] = [<em>L̂</em><sup>2</sup>, <em>L̂</em><sub><em>z</em></sub>] = 0</span></p>\n<h5 id=\"角动量算符的本征方程\">角动量算符的本征方程</h5>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  &amp;&amp;-\\hbar ^2 \\left[\n\\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial}{\\partial\\theta}\\right)+\\frac{1}{\\sin^2\\theta}\\frac{\\partial^2}{\\partial\n\\varphi^2}\\right]Y &amp;= \\mu \\hbar ^2 Y\\\\\n  \\Rightarrow\n&amp;&amp;\\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial\nY}{\\partial\\theta}\\right)+\\frac{1}{\\sin^2\\theta}\\frac{\\partial^2}{\\partial\n\\varphi^2}Y +\\mu Y &amp;= 0\n\\end{aligned}\n$$</span></p>\n<p>令 <span\nclass=\"math inline\"><em>Y</em>(<em>θ</em>, <em>φ</em>) = <em>Θ</em>(<em>θ</em>)<em>f</em>(<em>φ</em>)</span>，得到</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  &amp;\\frac{sin\\theta}{\\Theta}\\frac{\\partial}{\\partial\n\\theta}\\left(\\sin\\theta\\frac{\\partial\\Theta}{\\partial \\theta }\\right) +\n\\mu\\sin^2\\theta = -\\frac{1}{f}\\frac{\\partial ^2 f}{\\partial\\varphi ^2} =\nconst = \\lambda\\\\\n  \\Rightarrow &amp;\n  \\begin{cases}\n    \\frac{1}{\\sin\\theta}\\frac{\\mathrm\nd}{\\mathrm{d}\\theta}\\left(\\sin\\theta\\frac{\\mathrm{d}\\Theta}{\\mathrm{d}\\theta}\\right)\n+\\left(\\mu -\\frac{\\lambda}{\\sin^2\\theta}\\right)\\Theta = 0\\\\\n    \\frac{\\mathrm{d}^2 f}{\\mathrm{d}\\varphi ^2} +\\lambda f = 0\n  \\end{cases}\n\\end{aligned}\n$$</span></p>\n<p>先处理关于 <span class=\"math inline\"><em>φ</em></span> 的方程</p>\n<p>令 <span\nclass=\"math inline\"><em>λ</em> = <em>m</em><sub><em>l</em></sub><sup>2</sup>, <em>m</em><sub><em>l</em></sub> = 0, ±1, ±2, …</span>，则</p>\n<p><span\nclass=\"math display\"><em>f</em>(<em>φ</em>) = <em>A</em>cos (<em>m</em><sub><em>l</em></sub><em>φ</em>) + <em>B</em>sin (<em>m</em><sub><em>l</em></sub><em>φ</em>)</span></p>\n<p>再处理关于 <span class=\"math inline\"><em>θ</em></span> 的方程</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  &amp;\\frac{1}{\\sin\\theta}\\frac{\\mathrm\nd}{\\mathrm{d}\\theta}\\left(\\sin\\theta\\frac{\\mathrm{d}\\Theta}{\\mathrm{d}\\theta}\\right)\n+\\left(\\mu -\\frac{\\lambda}{\\sin^2\\theta}\\right)\\Theta = 0\\\\\n  \\Rightarrow &amp; \\frac{1}{\\sin\\theta}\\frac{\\mathrm\nd}{\\mathrm{d}\\theta}\\left(\\sin\\theta\\frac{\\mathrm{d}\\Theta}{\\mathrm{d}\\theta}\\right)\n+\\left(\\mu -\\frac{m_l^2}{\\sin^2\\theta}\\right)\\Theta = 0\\\\\n\\end{aligned}\n$$</span></p>\n<p>令 <span\nclass=\"math inline\"><em>x</em> = cos <em>θ</em>, <em>y</em>(<em>x</em>) = <em>Θ</em>(<em>θ</em>)</span>，则</p>\n<p><span class=\"math display\">$$\n\\frac{1}{1-x^2}\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}\n-2x\\frac{\\mathrm{d}y}{\\mathrm{d}x}+ \\left(\\mu\n-\\frac{m_l^2}{1-x^2}\\right)y = 0 \\quad\\left(\\text{连带勒让德方程}\\right)\n$$</span></p>\n<ul>\n<li><strong>本征值：</strong><span\nclass=\"math inline\"><em>μ</em> = <em>l</em>(<em>l</em> + 1)</span>，<span\nclass=\"math inline\"><em>l</em> = 0, 1, 2, …</span></li>\n<li><span\nclass=\"math inline\"><em>Θ</em>(<em>θ</em>) = <em>P</em><sub><em>l</em></sub><sup><em>m</em></sup>(<em>θ</em>)</span></li>\n</ul>\n<p>则角动量平方算符的本征方程变为</p>\n<p><span class=\"math display\">$$\n\\hat{L}^2 Y_{l,m_l} = -\\hbar ^2\n\\left[\\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial}{\\partial\\theta}\\right)+\\frac{1}{\\sin^2\\theta}\\frac{\\partial^2}{\\partial\n\\varphi^2}\\right]Y_{l,m_l} = l(l+1)\\hbar ^2 Y_{l,m_l}\n$$</span></p>\n<p>其解为</p>\n<p><span class=\"math display\">$$\nY_{L,m_l}(\\theta , \\varphi) = (-1)^{m_l}\\sqrt{\\frac{(2l+1)(l-\\vert\nm_l\\vert)!}{4\\pi (l+\\vert\nm_l\\vert)!}}P_l^{m_l}(\\cos\\theta)e^{im_l\\varphi}\n$$</span></p>\n<p>其中 <span class=\"math inline\"><em>l</em> = 0, 1, 2, …</span> ，<span\nclass=\"math inline\"><em>m</em><sub><em>l</em></sub> = −<em>l</em>, −<em>l</em> + 1, …, <em>l</em></span>\n该函数同时也为角动量算符 <span\nclass=\"math inline\"><em>L̂</em><sub><em>z</em></sub></span>\n的本征函数</p>\n<h5 id=\"统计平均值\">统计平均值</h5>\n<p>当一个量子系统处于量子态 <span class=\"math inline\"><em>Ψ</em></span>\n时，且满足 <span class=\"math inline\">$\\displaystyle \\Psi\\left(\\theta ,\n\\varphi\\right) = \\sum_{l}\\sum_{m_l=-1}^l c_{l,m_l}Y_{l,m_l}\\left(\\theta\n, \\varphi\\right)$</span> ，<span class=\"math inline\">$\\sum_{l}\\sum_{m_l\n= -1}^l =\\left\\vert c_{l,l_m}\\right\\vert^2 = 1$</span> 时，对测量结果为\n<span class=\"math inline\"><em>l</em>(<em>l</em> + 1)ℏ<sup>2</sup></span>\n的概率为 <span\nclass=\"math inline\">|<em>c</em><sub><em>l</em>, <em>m</em><sub><em>l</em></sub></sub>|<sup>2</sup></span>，测量完成之后，该量子系统坍缩至\n<span\nclass=\"math inline\"><em>Y</em><sub><em>l</em>, <em>m</em><sub><em>l</em></sub></sub></span></p>\n<p>统计平均值为</p>\n<p><span class=\"math display\">$$\n\\bar{L}^2 = \\sum_{l}l(l+1)\\hbar ^2 \\sum_{m_l=-l}^{l} \\left\\vert\nc_{l,m_l}\\right\\vert^2\n$$</span></p>\n<p>对角动量 <span class=\"math inline\"><em>z</em></span>\n分量进行测量的结果一定是该力学量算符的本征值之一，测量结果为 <span\nclass=\"math inline\"><em>m</em><sub><em>l</em></sub>ℏ</span> 的概率为\n<span\nclass=\"math inline\">|<em>c</em><sub><em>l</em>, <em>m</em><sub><em>l</em></sub></sub>|<sup>2</sup></span>\n，测量完成之后，该量子系统坍缩至 <span\nclass=\"math inline\"><em>Y</em><sub><em>l</em>, <em>m</em><sub><em>l</em></sub></sub></span></p>\n<p>统计平均值为</p>\n<p><span class=\"math display\">$$\n\\bar{L}_z = \\sum_{l}  \\sum_{m_l=-l}^{l} m_l\\hbar\\left\\vert\nc_{l,m_l}\\right\\vert^2\n$$</span></p>\n<p>这里角动量平方算符和角动量算符的本征方程分别为</p>\n<p><span\nclass=\"math display\"><em>L̂</em><sup>2</sup><em>Y</em><sub><em>l</em>, <em>m</em><sub><em>l</em></sub></sub> = <em>l</em>(<em>l</em> + 1)ℏ<sup>2</sup><em>Y</em><sub><em>l</em>, <em>m</em><sub><em>l</em></sub></sub></span></p>\n<p><span\nclass=\"math display\"><em>L̂</em><sub><em>z</em></sub><em>Y</em><sub><em>l</em>, <em>m</em><sub><em>l</em></sub></sub> = <em>m</em><sub><em>l</em></sub>ℏ<em>Y</em><sub><em>l</em>, <em>m</em><sub><em>l</em></sub></sub></span></p>\n<h2 id=\"算符与电子自旋\">算符与电子自旋</h2>\n<h3\nid=\"未归一化的量子态下的算符平均值\">未归一化的量子态下的算符平均值</h3>\n<p><span class=\"math display\">$$\n\\bar{A} = \\frac{\\iiint\n\\Psi^*(x,y,z)\\hat{A}\\Psi(x,y,z)\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z}{\\iiint\n\\Psi^*(x,y,z)\\Psi(x,y,z)\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z}\n$$</span></p>\n<h3 id=\"线性算符\">线性算符</h3>\n<p>线性算符 <span class=\"math inline\"><em>F̂</em></span> 满足</p>\n<p><span\nclass=\"math display\"><em>F̂</em>(<em>a</em><em>Ψ</em><sub>1</sub> + <em>b</em><em>Ψ</em><sub>2</sub>) = <em>a</em><em>F̂</em><em>Ψ</em><sub>1</sub> + <em>b</em><em>F̂</em><em>Ψ</em><sub>2</sub></span></p>\n<p>位置算符 <span class=\"math inline\"><em>x̂</em> = <em>x</em></span>\n和动量算符 <span class=\"math inline\">$\\hat{p_x} =\n-i\\hbar\\frac{\\partial}{\\partial x}$</span> 均为线性算符</p>\n<p>由于态叠加原理，哈密顿算符 <span\nclass=\"math inline\"><em>Ĥ</em></span>\n也是线性算符，薛定谔方程是线性微分方程，则若 <span\nclass=\"math inline\"><em>Ψ</em><sub>1</sub></span> 和 <span\nclass=\"math inline\"><em>Ψ</em><sub>2</sub></span> 是薛定谔方程的解，则\n<span\nclass=\"math inline\"><em>c</em><sub>1</sub><em>Ψ</em><sub>1</sub> + <em>c</em><sub>2</sub><em>Ψ</em><sub>2</sub></span>\n也是薛定谔方程的解</p>\n<p>对于定态薛定谔方程也满足这个条件</p>\n<p>态叠加原理要求算符是线性的厄米算符</p>\n<h3 id=\"厄米算符\">厄米算符</h3>\n<h4 id=\"厄米算符的本征值是实数\">厄米算符的本征值是实数</h4>\n<h4 id=\"厄米算符的平均值是实数\">厄米算符的平均值是实数</h4>\n<h4 id=\"厄米算符本征值具有正交性\">厄米算符本征值具有正交性</h4>\n<p>当两个函数 <span\nclass=\"math inline\"><em>Ψ</em><sub><em>q</em></sub></span> 和 <span\nclass=\"math inline\"><em>Ψ</em><sub>2</sub></span> 满足下列关系</p>\n<p><span\nclass=\"math display\">∫<em>Ψ</em><sub>1</sub><sup>*</sup><em>Ψ</em><sub>2</sub> d<em>x</em> ≡ ∫⟨<em>Ψ</em><sub>1</sub>|<em>Ψ</em><sub>2</sub>⟩ = 0</span></p>\n<p>则我们称这两个函数相互正交，<span\nclass=\"math inline\">⟨<em>Ψ</em><sub>1</sub>|<em>Ψ</em><sub>2</sub>⟩</span>\n称为内积</p>\n<p>厄米算符两个不同本征值的本征函数总是正交的</p>\n<p><strong>证明：</strong></p>\n<p>（待补充 o_O）</p>\n<p>将这些正交的本征函数归一化，<span\nclass=\"math inline\">∫<em>Ψ</em><sub>1</sub><sup>*</sup><em>Ψ</em><sub>2</sub> d<em>x</em> = 1</span>，所以<strong>厄米算符</strong>有一组正交化的本征函数</p>\n<p><span class=\"math display\">$$\n\\int \\Psi_k^*\\Psi_l\\,\\mathrm{d}x =\\delta_{kl} =\n\\begin{cases}\n  0 &amp;,k\\neq l\\\\\n  1 &amp;,k=l\n\\end{cases}\n$$</span></p>\n<p>所以厄米算符的分立谱的所有本征函数都是正交归一化的</p>\n<h3 id=\"动量算符的厄米性\">动量算符的厄米性</h3>\n<p><strong>证明：</strong></p>\n<p>（待补充）</p>\n<h3 id=\"算符运算初步\">算符运算初步</h3>\n<h4 id=\"算符之和\">算符之和</h4>\n<p><span\nclass=\"math display\"><em>Â</em> + <em>B̂</em> = <em>Ĉ</em></span></p>\n<p><span\nclass=\"math display\"><em>Ĉ</em><em>Ψ</em> = (<em>Â</em> + <em>B̂</em>)<em>Ψ</em> = <em>Â</em><em>Ψ</em> + <em>B̂</em><em>Ψ</em></span></p>\n<h4 id=\"算符之积\">算符之积</h4>\n<p><span\nclass=\"math display\"><em>Â</em><em>B̂</em> = <em>Ĉ</em></span></p>\n<p><span\nclass=\"math display\"><em>Ĉ</em><em>Ψ</em> = <em>Â</em>(<em>B̂</em><em>Ψ</em>)</span></p>\n<p>一般情况下，算符之积<strong>不满足</strong>交换律，即</p>\n<p><span\nclass=\"math display\"><em>Â</em><em>B̂</em> ≠ <em>B̂</em><em>Â</em></span></p>\n<h4 id=\"算符的对易性\">算符的对易性</h4>\n<p>如果 <span\nclass=\"math inline\"><em>Â</em><em>B̂</em> = <em>B̂</em><em>Â</em></span>，则称\n<span class=\"math inline\"><em>Â</em></span> 和 <span\nclass=\"math inline\"><em>B̂</em></span> 是<strong>对易的</strong></p>\n<p>记为 <span\nclass=\"math inline\">[<em>Â</em>, <em>B̂</em>] ≡ <em>Â</em><em>B̂</em> − <em>B̂</em><em>Â</em> = 0</span>，称\n<span class=\"math inline\">[<em>Â</em>, <em>B̂</em>]</span> 为 <span\nclass=\"math inline\"><em>Â</em></span> 和 <span\nclass=\"math inline\"><em>B̂</em></span> 的<strong>对易子</strong></p>\n<h3 id=\"电子自旋\">电子自旋</h3>\n<h4 id=\"电子自旋角动量及其空间量子化\">电子自旋角动量及其空间量子化</h4>\n<h5 id=\"斯特恩-盖拉赫实验\">斯特恩-盖拉赫实验</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192235176.png\"\nalt=\"Stern-Garlach experiment\" />\n<figcaption aria-hidden=\"true\">Stern-Garlach experiment</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192240318.png\"\nalt=\"磁力线\" />\n<figcaption aria-hidden=\"true\">磁力线</figcaption>\n</figure>\n<p>磁铁的特殊形状使得磁极之间的磁力线不是均匀的，从而产生非匀强磁场</p>\n<p>在非匀强磁场之中，银原子和磁场的相互作用能为</p>\n<p><span\nclass=\"math display\"><em>W</em> = −<strong>M</strong> ⋅ <strong>B</strong></span></p>\n<p>对 <span class=\"math inline\"><em>z</em></span> 方向求微分</p>\n<p><span class=\"math display\">$$\nF_z = -\\frac{\\partial W}{\\partial z} = M_z \\frac{\\partial B}{\\partial z}\n$$</span></p>\n<p>实验结果为</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192317946.png\"\nalt=\"result\" />\n<figcaption aria-hidden=\"true\">result</figcaption>\n</figure>\n<p>加入磁场之后，银原子分裂为两束。银原子的角动量数 <span\nclass=\"math inline\"><em>l</em> = 0</span>，且最外层为 <span\nclass=\"math inline\"><em>s</em></span>\n电子，无轨道角动量，说明会银原子有自由度，且有两个取值</p>\n<h6 id=\"斯特恩-盖拉赫实验的意义\">斯特恩-盖拉赫实验的意义</h6>\n<ol type=\"1\">\n<li>证明了角动量空间量子化的存在\n<ul>\n<li>原子沉积层不是连续的一片，而是分开的线，说明了角动量空间量子化的存在</li>\n</ul></li>\n<li>发现了新的矛盾\n<ul>\n<li><span\nclass=\"math inline\"><em>l</em> = 0</span>，应当有一条沉积线，但是实验结果却又两条沉积线，这说明原来对原子中的电子运动的描述是不完全的</li>\n</ul></li>\n<li>提供了原子的“态分离”技术</li>\n</ol>\n<h6 id=\"理论解释\">理论解释</h6>\n<p>1925\n年乌伦贝克和古兹米特根据斯特恩-盖拉赫实验的结果，<strong>提出了电子不是指点，具有固有的自旋角动量\n<span class=\"math inline\"><strong>S</strong></span> 和相应的自旋磁矩\n<span\nclass=\"math inline\"><strong>μ</strong><sub><strong>s</strong></sub></span></strong>\n的观点</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192340149.png\"\nalt=\"电子自旋角动量和磁矩\" />\n<figcaption aria-hidden=\"true\">电子自旋角动量和磁矩</figcaption>\n</figure>\n<p>由于电子带负电，其自旋磁矩和根据右手螺旋定律得到的方向相反</p>\n<p>相对于外磁场方向，<span class=\"math inline\"><strong>B</strong></span>\n有朝上和朝下两种取向</p>\n<p>但是若将电子视为 <span\nclass=\"math inline\"><em>r</em> = 10<sup>−16</sup><em>m</em></span>\n的小球，按照 <span class=\"math inline\"><strong>S</strong> ∼ ℏ</span>\n估计得到的电子表面速度 <span\nclass=\"math inline\"> &gt; <em>c</em></span></p>\n<p>电子在任意一个方向测量其自旋角动量的结果都是 <span\nclass=\"math inline\">±ℏ</span></p>\n<h5 id=\"泡利不相容原理\">泡利不相容原理</h5>\n<ol type=\"1\">\n<li>费米子和玻色子\n<ol type=\"1\">\n<li><strong>费米子：</strong> 自旋量子数为半奇数的粒子</li>\n<li><strong>玻色子：</strong> 自旋量子数为整数的粒子</li>\n</ol></li>\n<li>泡利不相容原理\n<ul>\n<li>不能有两个电子具有相同的 <span\nclass=\"math inline\"><em>n</em>, <em>m</em>, <em>l</em>, <em>m</em><sub><em>l</em></sub>, <em>m</em><sub><em>s</em></sub></span></li>\n</ul></li>\n<li>玻色凝聚\n<ul>\n<li>玻色子不受泡利不相容原理的限制，一个单粒子态可容纳多个玻色子</li>\n</ul></li>\n</ol>\n<h5 id=\"电子的自旋算符和自旋波函数\">电子的自旋算符和自旋波函数</h5>\n<h6 id=\"自旋算符\">自旋算符</h6>\n<p>自旋角动量是纯量子概念，但也是一个力学量</p>\n<p>自旋角动量与电子的坐标和动量无关，是电子内部状态的表征，是描述电子状态的第四个自由度</p>\n<p>自旋算符记为 <span class=\"math inline\"><em>Ŝ</em></span></p>\n<ul>\n<li><span\nclass=\"math inline\">$\\hat{\\boldsymbol{S}}\\times\\hat{\\boldsymbol{S}}\n=i\\hbar\\hat{\\boldsymbol{S}}$</span></li>\n<li><span\nclass=\"math inline\">$[\\hat{\\boldsymbol{S}_x},\\hat{\\boldsymbol{S}}_y] =\ni\\hbar \\hat{\\boldsymbol{S}}_z$</span></li>\n<li><span\nclass=\"math inline\">$[\\hat{\\boldsymbol{S}}_y,\\hat{\\boldsymbol{S}}_z] =\ni\\hbar \\hat{\\boldsymbol{S}}_x$</span></li>\n<li><span\nclass=\"math inline\">$[\\hat{\\boldsymbol{S}}_z,\\hat{\\boldsymbol{S}}_x] =\ni\\hbar \\hat{\\boldsymbol{S}}_y$</span></li>\n</ul>\n<p>由于<strong>自旋角动量</strong>在空间任意方向上的投影都只能取 <span\nclass=\"math inline\">$\\pm\\frac{\\hbar}{2}$</span>，则 <span\nclass=\"math inline\">$\\hat{\\boldsymbol{S}}_x$</span>，<span\nclass=\"math inline\">$\\hat{\\boldsymbol{S}}_y$</span> 和 <span\nclass=\"math inline\">$\\hat{\\boldsymbol{S}}_z$</span> 的本征值都是 <span\nclass=\"math inline\">$\\pm\\frac{\\hbar}{2}$</span>，其平方为 <span\nclass=\"math inline\">$\\frac{\\hbar}{2}^2$</span></p>\n<h6 id=\"含自旋的状态波函数\">含自旋的状态波函数</h6>\n<p>电子的含自旋的波函数为</p>\n<p><span\nclass=\"math display\"><em>Ψ</em> = <em>Ψ</em>(<em>x</em>, <em>y</em>, <em>z</em>, <em>S</em><sub><em>z</em></sub>, <em>t</em>)</span></p>\n<p>由于 <span class=\"math inline\"><em>S</em><sub><em>z</em></sub></span>\n只有两个取值 <span\nclass=\"math inline\">$\\pm\\frac{\\hbar}{2}$</span>，所以可以写为两个分量</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\psi_1=\\psi(x,y,z,\\frac{\\hbar}{2},t)\\\\\n  \\psi_2=\\psi(x,y,z,-\\frac{\\hbar}{2},t)\n\\end{cases}\n$$</span></p>\n<p>写作列矩阵</p>\n<p><span class=\"math display\">$$\n\\Psi = \\begin{pmatrix}\n  \\psi_1(\\boldsymbol{r},t)\\\\\n  \\psi_2(\\boldsymbol{r},t)\n\\end{pmatrix}\n$$</span></p>\n<p>这里的正负号是规定好的</p>\n<p>若已知电子处于 <span class=\"math inline\">$S_z =\n\\frac{\\hbar}{2}$</span> 或 <span class=\"math inline\">$S_z =\n-\\frac{\\hbar}{2}$</span> 的状态，则其波函数分别可以写为：</p>\n<p><span class=\"math display\">$$\n\\Psi = \\begin{pmatrix}\n  \\psi_1(\\boldsymbol{r},t)\\\\\n  0\n\\end{pmatrix}\n\\qquad\n\\Psi = \\begin{pmatrix}\n  0\\\\\n  \\psi_2(\\boldsymbol{r},t)\n\\end{pmatrix}\n$$</span></p>\n<h6 id=\"自旋算符的矩阵表示pauli-矩阵\">自旋算符的矩阵表示，Pauli\n矩阵</h6>\n<p><strong><span\nclass=\"math inline\"><em>Ŝ</em><sub><em>z</em></sub></span>\n的矩阵形式</strong></p>\n<p><span class=\"math display\">$$\n\\hat{S}_z = \\frac{\\hbar}{2}\n\\begin{pmatrix}\n  1 &amp; 0\\\\\n  0 &amp; -1\n\\end{pmatrix}\n$$</span></p>\n<p><strong>Pauli 算符</strong></p>\n<p>对于 <span class=\"math inline\"><em>Ŝ</em><sub><em>z</em></sub></span>\n的矩阵形式，我们定义 Pauli 算符，使得</p>\n<p><span class=\"math display\">$$\n\\hat{S}_z = \\frac{\\hbar}{2}\\hat{\\sigma}\n$$</span></p>\n<p>从自旋算符与 Pauli 矩阵之间的关系，可以得到自旋算符的矩阵表示</p>\n<p><span class=\"math display\">$$\n\\hat{S}_x = \\frac{\\hbar}{2}\\begin{pmatrix}\n  0 &amp; 1\\\\\n  1 &amp; 0\n\\end{pmatrix}\n\\quad\n\\hat{S}_y = \\frac{\\hbar}{2}\\begin{pmatrix}\n  0 &amp; -i\\\\\n  i &amp; 0\n\\end{pmatrix}\n\\quad\n\\hat{S}_z = \\frac{\\hbar}{2}\\begin{pmatrix}\n  1 &amp; 0\\\\\n  0 &amp; -1\n\\end{pmatrix}\n$$</span></p>\n<h6 id=\"自旋波函数\">自旋波函数</h6>\n<p>波函数 <span class=\"math inline\">$\\Psi =\n\\begin{pmatrix}\\psi_1\\newline \\psi_2\\end{pmatrix}$</span>\n中，一般情况下，<span\nclass=\"math inline\"><em>Ψ</em><sub>1</sub> ≠ <em>Ψ</em><sub>2</sub></span>，两者对\n<span class=\"math inline\">(<em>x</em>, <em>y</em>, <em>z</em>)</span>\n的依赖是不相同的，因为自旋对轨道运动有一定的影响，但是当影响足够小时，可以忽略，此时认为\n<span class=\"math inline\"><em>Ψ</em><sub>1</sub></span> 和 <span\nclass=\"math inline\"><em>Ψ</em><sub>2</sub></span> 的函数形式相同，<span\nclass=\"math inline\"><em>Ψ</em></span> 可以写作如下的形式</p>\n<p><span\nclass=\"math display\"><em>Ψ</em>(<strong>r</strong>, <em>S</em><sub><em>z</em></sub>, <em>t</em>) = <em>ψ</em>(<strong>r</strong>, <em>t</em>)<em>χ</em>(<em>S</em><sub><em>z</em></sub>)</span></p>\n<p>其中 <span\nclass=\"math inline\"><em>χ</em>(<em>S</em><sub><em>z</em></sub>)</span>\n是 <span class=\"math inline\"><em>Ŝ</em><sub><em>z</em></sub></span>\n的本征函数，称为自旋波函数</p>\n<p><span class=\"math display\">$$\n\\chi_{\\frac{1}{2}}(S_z) = \\begin{pmatrix}\n  1\\\\\n  0\n\\end{pmatrix}\n\\quad\n\\chi_{-\\frac{1}{2}}(S_z) = \\begin{pmatrix}\n  0\\\\\n  1\n\\end{pmatrix}\n$$</span></p>\n<p>这两个自旋波函数相互正交</p>\n<h3 id=\"无限深势阱\">无限深势阱</h3>\n<h3 id=\"谐振子\">谐振子</h3>\n<h4 id=\"势能\">势能</h4>\n<p>若先择线性谐振子平衡位置为坐标原点和势能零点，则一维线性谐振子得到势能可以表示为</p>\n<p><span class=\"math display\">$$\nU(x) = \\frac{1}{2}kx^2 = \\frac{1}{2}m\\omega^2x^2\n$$</span></p>\n<h5 id=\"谐振子的定态薛定谔方程\">谐振子的定态薛定谔方程</h5>\n<p>一维谐振子的哈密顿量为</p>\n<p><span class=\"math display\">$$\n\\hat{H} = -\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} +\n\\frac{1}{2}m\\omega^2x^2\n$$</span></p>\n<p>满足的定态薛定谔方程为</p>\n<p><span class=\"math display\">$$\n\\left[-\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} +\n\\frac{1}{2}m\\omega^2x^2\\right]\\Phi(x) = E\\Phi(x)\n$$</span></p>\n<p>一维谐振子的能量是量子化的</p>\n","excerpt":"","more":"<h2 id=\"基本常数\">基本常数</h2>\n<table>\n<colgroup>\n<col style=\"width: 16%\" />\n<col style=\"width: 15%\" />\n<col style=\"width: 29%\" />\n<col style=\"width: 38%\" />\n</colgroup>\n<thead>\n<tr>\n<th>名称</th>\n<th>符号</th>\n<th>数值</th>\n<th>单位</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>斯特番常数</td>\n<td><span class=\"math inline\"><em>σ</em></span></td>\n<td><span class=\"math inline\">5.67 × 10<sup>−8</sup></span></td>\n<td><span\nclass=\"math inline\"><em>W</em> ⋅ <em>m</em><sup>−2</sup> ⋅ <em>K</em><sup>−4</sup></span></td>\n</tr>\n<tr>\n<td>维恩常数</td>\n<td><span class=\"math inline\"><em>b</em></span></td>\n<td><span class=\"math inline\">2.898 × 10<sup>−3</sup></span></td>\n<td><span class=\"math inline\"><em>m</em> ⋅ <em>K</em></span></td>\n</tr>\n<tr>\n<td>玻尔兹曼常数</td>\n<td><span class=\"math inline\"><em>k</em></span></td>\n<td><span class=\"math inline\">1.38 × 10<sup>−23</sup></span></td>\n<td><span\nclass=\"math inline\"><em>J</em> ⋅ <em>K</em><sup>−1</sup></span></td>\n</tr>\n<tr>\n<td>普朗克常数</td>\n<td><span class=\"math inline\"><em>h</em></span></td>\n<td><span class=\"math inline\">6.63 × 10<sup>−34</sup></span></td>\n<td><span class=\"math inline\"><em>J</em> ⋅ <em>s</em></span></td>\n</tr>\n<tr>\n<td>康普顿波长</td>\n<td><span\nclass=\"math inline\"><em>λ</em><sub><em>c</em></sub></span></td>\n<td><span class=\"math inline\">0.02426</span></td>\n<td><span class=\"math inline\">Å</span></td>\n</tr>\n<tr>\n<td>里德伯常数</td>\n<td><span class=\"math inline\"><em>R</em></span></td>\n<td><span class=\"math inline\">1.097 × 10<sup>7</sup></span></td>\n<td><span class=\"math inline\"><em>m</em><sup>−1</sup></span></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"算符\">算符</h2>\n<table>\n<colgroup>\n<col style=\"width: 13%\" />\n<col style=\"width: 86%\" />\n</colgroup>\n<thead>\n<tr>\n<th>名称</th>\n<th>表达式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>能量算符</td>\n<td><span class=\"math inline\">$\\hat{E} = i\\hbar\\frac{\\partial}{\\partial\nt}$</span></td>\n</tr>\n<tr>\n<td>动量算符</td>\n<td><span class=\"math inline\"><em>p̂</em> = −<em>i</em>ℏ∇</span></td>\n</tr>\n<tr>\n<td>哈密顿算符</td>\n<td><span class=\"math inline\">$\\hat{H} = -\\frac{\\hbar^2}{2m}\\nabla ^2 +\nU(\\boldsymbol{r},t)$</span></td>\n</tr>\n<tr>\n<td>角动量算符</td>\n<td><span\nclass=\"math inline\"><em>L̂</em> = <em>r̂</em> × <em>p̂</em></span></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"量子物理基础\">量子物理基础</h2>\n<h3 id=\"黑体辐射\">黑体辐射</h3>\n<h4 id=\"热辐射的基本概念\">热辐射的基本概念</h4>\n<ul>\n<li>所有物在有限体温度下都会发射电磁波，这种与温度有关的辐射称为热辐射\n(heat radiation).</li>\n<li>热辐射是连续谱.</li>\n<li>基本性质：温度越高，发射的能量越大，电磁波的短波成分能量越大.</li>\n<li>平衡热辐射：热辐射是热平衡状态下的辐射.</li>\n</ul>\n<h5 id=\"热辐射基本参数\">热辐射基本参数</h5>\n<p><strong>单色辐出度 <span\nclass=\"math inline\"><em>M</em><sub><em>λ</em></sub>(<em>W</em>/<em>m</em><sup>3</sup>)</span></strong></p>\n<p>物体单位表面在单位时间内发出的波长在 <span\nclass=\"math inline\"><em>λ</em></span>\n附近单位波长间隔内的电磁波的能量，用于描述物体辐射能量的能力</p>\n<p><span class=\"math display\">$$\nM_{\\lambda}(T)=\\frac{\\mathrm{d}E_{\\lambda}}{\\mathrm{d}\\lambda}\n$$</span></p>\n<p><strong>辐出度 <span\nclass=\"math inline\"><em>M</em>(<em>T</em>)(<em>W</em>/<em>m</em><sup>2</sup>)</span></strong></p>\n<p>物体从单位面积上发射的所有波长的辐射总功率</p>\n<p><span\nclass=\"math display\"><em>M</em>(<em>t</em>) = ∫<sub>0</sub><sup>+∞</sup><em>M</em><sub><em>λ</em></sub>(<em>T</em>) d<em>λ</em></span></p>\n<p><strong>吸收比 <span\nclass=\"math inline\"><em>α</em>(<em>T</em>)</span> 和反射比 <span\nclass=\"math inline\"><em>r</em>(<em>T</em>)</span></strong></p>\n<ul>\n<li><strong>吸收比</strong>：辐射从外界入射到物体表面时，吸收的能量和入射的能量之比，是吸收能力的量度.</li>\n</ul>\n<p><span class=\"math display\">$$\n\\alpha(T)=\\frac{E^\\text{吸收}}{E^\\text{入射}}\n$$</span></p>\n<ul>\n<li><strong>反射比</strong>：辐射从外界入射到物体表面时，反射的能量和入射的能量之比，是反射能力的量度.</li>\n</ul>\n<p><span class=\"math display\">$$\nr(T)=\\frac{E^\\text{反射}}{E^\\text{入射}}\n$$</span></p>\n<p>**单色吸收比 <span\nclass=\"math inline\"><em>α</em>(<em>λ</em>, <em>T</em>)</span>\n和单色反射比 <span\nclass=\"math inline\"><em>r</em>(<em>λ</em>, <em>T</em>) * *</span></p>\n<ul>\n<li><strong>单色吸收比</strong>：当辐射从外界入射到物体表面时，吸收的波长从\n<span class=\"math inline\"><em>λ</em></span> 到 <span\nclass=\"math inline\"><em>λ</em> + d<em>λ</em></span> 波长间隔内的能量\n<span\nclass=\"math inline\"><em>E</em><sub><em>λ</em></sub><sup>吸收</sup>d<em>λ</em></span>\n和入射的能量 <span\nclass=\"math inline\"><em>E</em><sub><em>λ</em></sub><sup>入射</sup>d<em>λ</em></span>\n之比.</li>\n</ul>\n<p><span class=\"math display\">$$\n\\alpha(\\lambda,T)=\\frac{E_\\lambda^\\text{吸收}}{E_\\lambda^\\text{入射}}\n$$</span></p>\n<ul>\n<li><strong>单色反射比</strong>：当辐射从外界入射到物体表面时，反射的波长从\n<span class=\"math inline\"><em>λ</em></span> 到 <span\nclass=\"math inline\"><em>λ</em> + d<em>λ</em></span> 波长间隔内的能量\n<span\nclass=\"math inline\"><em>E</em><sub><em>λ</em></sub><sup>反射</sup>d<em>λ</em></span>\n和入射的能量 <span\nclass=\"math inline\"><em>E</em><sub><em>λ</em></sub><sup>入射</sup>d<em>λ</em></span>\n之比.</li>\n</ul>\n<p><span class=\"math display\">$$\nr(\\lambda,T)=\\frac{E_\\lambda^\\text{反射}}{E_\\lambda^\\text{入射}}\n$$</span></p>\n<p>对于不透明物体，有 <span\nclass=\"math inline\"><em>α</em>(<em>λ</em>, <em>T</em>) + <em>r</em>(<em>λ</em>, <em>T</em>) = 1</span>.</p>\n<h5 id=\"基尔霍夫定律\">基尔霍夫定律</h5>\n<p>一个好的发射体一定是个好的吸收体（黑白盘子实验） <img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/%E9%BB%91%E7%99%BD%E7%9B%98%E5%AE%9E%E9%AA%8C.png\"\nalt=\"黑白盘实验\" /></p>\n<p>温度一定时物体在某波长处的单色辐出度与单色吸收比的比值与物体及物体表面的性质无关，即</p>\n<p><span class=\"math display\">$$\n\\frac{M_1(\\lambda,T)}{\\alpha_1(\\lambda,T)} =\n\\frac{M_2(\\lambda,T)}{\\alpha_2(\\lambda,T)}=\\ldots=M_0(\\lambda,T).\n$$</span></p>\n<p>其中 <span\nclass=\"math inline\"><em>M</em><sub>0</sub>(<em>λ</em>, <em>T</em>)</span>\n是一个只与波长和温度有关，与物体材料、表面状态无关的函数，称为黑体辐射强度，是黑体的单色辐出度.</p>\n<h5 id=\"黑体\">黑体</h5>\n<p>能完全吸收各种波长电磁波而无反射的物体是黑体\n黑体是理想模型，可以建立只有小孔的空腔，小孔是黑体，空腔内的辐射是黑体辐射</p>\n<h6 id=\"黑体辐射的基本规律\">黑体辐射的基本规律</h6>\n<p>温度一定时，黑体辐射的强度与波长有关，存在一定的波长 <span\nclass=\"math inline\"><em>λ</em><sub>max</sub></span>\n使得辐射强度最大，称为黑体辐射的主波长. <img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/%E9%BB%91%E4%BD%93%E8%BE%90%E5%B0%84%E5%9B%BE.png\"\nalt=\"黑体辐射图\" /></p>\n<ul>\n<li><strong>斯特番-玻尔兹曼定律(J. Stefan, L. Boltzmann)</strong>\n实验证明，黑体的总辐出度 <span\nclass=\"math inline\"><em>M</em><sub>0</sub>(<em>T</em>)</span> 与温度\n<span class=\"math inline\"><em>T</em></span> 的四次方成正比</li>\n</ul>\n<p><span\nclass=\"math display\"><em>M</em><sub>0</sub>(<em>T</em>) = <em>σ</em><em>T</em><sup>4</sup></span></p>\n<p>其中 <span\nclass=\"math inline\"><em>σ</em> = 5.67 × 10<sup>−8</sup><em>W</em> ⋅ <em>m</em><sup>−2</sup> ⋅ <em>K</em><sup>−4</sup></span>，称为斯特番常数.\n1879 年斯特番实验总结得到，1884 年玻尔兹曼理论证明.\n表明热辐射对温度的敏感性 <span\nclass=\"math inline\"> ∝ <em>T</em><sup>4</sup></span>.</p>\n<ul>\n<li>维恩位移定律(W. Wien) 黑体辐射中单色辐出值的极值波长 <span\nclass=\"math inline\"><em>λ</em><sub><em>m</em></sub></span> 与黑体温度\n<span class=\"math inline\"><em>T</em></span> 之积为常数</li>\n</ul>\n<p><span\nclass=\"math display\"><em>λ</em><sub><em>m</em></sub><em>T</em> = <em>b</em></span></p>\n<p>其中 <span\nclass=\"math inline\"><em>b</em> = 2.898 × 10<sup>−3</sup><em>m</em> ⋅ <em>K</em></span>\n，为 Wien 常数.</p>\n<h5\nid=\"普朗克的能量子假说和黑体辐射公式\">普朗克的能量子假说和黑体辐射公式</h5>\n<h6 id=\"维恩公式\">维恩公式</h6>\n<p><span\nclass=\"math display\"><em>M</em><sub>0</sub>(<em>ν</em>, <em>T</em>) = <em>α</em><em>ν</em><sup>3</sup><em>e</em><sup>−<em>β</em>/<em>T</em></sup></span></p>\n<ul>\n<li>在高频段与实验符合得很好，但是在低频段明显偏离实验曲线</li>\n</ul>\n<h6 id=\"瑞利-金斯公式\">瑞利-金斯公式</h6>\n<p><span class=\"math display\">$$\nM_0(\\nu,T)=\\frac{2\\pi \\nu^2}{c^2}kT\n$$</span></p>\n<ul>\n<li>其中 <span\nclass=\"math inline\"><em>k</em> = 1.38 × 10<sup>−23</sup><em>J</em> ⋅ <em>K</em><sup>−1</sup></span>\n，为玻尔兹曼常数.</li>\n<li>低频段与实验符合得很好，但是在高频段明显偏离实验曲线.</li>\n<li>且当 <span class=\"math inline\"><em>ν</em> → ∞</span> 时，<span\nclass=\"math inline\"><em>M</em><sub>0</sub>(<em>ν</em>, <em>T</em>) → ∞</span>，称为紫外灾难.</li>\n</ul>\n<h6 id=\"普朗克公式\">普朗克公式</h6>\n<p>普朗克以适用于高频段的维恩公式和适用于低频段的瑞利-金斯公式为基础，提出了<strong>普朗克黑体辐射公式</strong>，是一个半经验公式.</p>\n<p><span class=\"math display\">$$\nM_0(\\nu,T)=\\frac{2\\pi\\nu^2}{c^2}\\frac{h\\nu}{e^{\\frac{h\\nu}{kT}}-1}\n$$</span></p>\n<ul>\n<li><p>其中 <span\nclass=\"math inline\"><em>h</em> = 6.63 × 10<sup>−34</sup><em>J</em> ⋅ <em>s</em></span>\n为普朗克常量.</p></li>\n<li><p>普朗克公式在整个频段都符合实验结果.</p></li>\n<li><p>普朗克认为：空腔内壁的分子、原子的振动可以看成是许多带电的简谐振子，这些简谐振子可以辐射和吸收能量，并与空腔内的辐射达到平衡。从空腔小孔辐射出的电磁波，就是由这些空腔内壁的简谐振子辐射出的。他假定对于频率为\n<span class=\"math inline\"><em>ν</em></span>\n的振子，振子能量不是连续的，而是分立的，它的取值是某一最小能量 <span\nclass=\"math inline\"><em>h</em></span>\n的整数倍，即<strong>当振子吸收或放出能量时，以 <span\nclass=\"math inline\"><em>h</em><em>ν</em></span>\n为单位.</strong></p></li>\n<li><p>我们计 <span\nclass=\"math inline\"><em>ε</em> = <em>h</em><em>ν</em></span>\n，称为<strong>能量子（quanta of enmergy）</strong></p></li>\n<li><p>由普朗克公式可以推出其他热辐射公式</p>\n<p><span class=\"math display\">$$\nM_0(\\nu,T)=\\frac{2\\pi\\nu^2}{c^2}\\frac{h\\nu}{e^{\\frac{h\\nu}{kT}}-1}\\ \\\n\\left\\{\n  \\begin{aligned}\n  &amp;\\text{积分} \\rightarrow M=\\sigma T^4, \\ \\\n\\text{斯特番-玻尔兹曼定律}\\\\\n  &amp;\\text{求导} \\rightarrow \\lambda_mT=b. \\ \\ \\text{维恩位移定律}\\\\\n  &amp;\\text{低频极限} \\rightarrow M_0(\\nu,T)=\\frac{2\\pi\\nu^2}{c^2}kT, \\\n\\ \\text{瑞利-金斯公式}\\\\\n  &amp;\\text{高频极限} \\rightarrow M_0(\\nu,T)=\\alpha\\nu^3e^{-\\beta/T}, \\\n\\ \\text{维恩公式}\n  \\end{aligned}\n\\right.\n$$</span></p></li>\n</ul>\n<h3 id=\"光电效应photoelectric-effect\">光电效应（Photoelectric\neffect）</h3>\n<h4 id=\"实验模型\">实验模型</h4>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250228160736.png\"\nalt=\"实验装置\" />\n<figcaption aria-hidden=\"true\">实验装置</figcaption>\n</figure>\n<p>当光照在金属表面，电子从金属中脱出的现象，称为光电效应</p>\n<h4 id=\"基本参数\">基本参数</h4>\n<h4 id=\"饱和电流\">饱和电流</h4>\n<p>实验表明，当入射光强度不变，加速电势差 <span\nclass=\"math inline\"><em>U</em></span> 越大，光电流 <span\nclass=\"math inline\"><em>I</em></span>\n也越大，当电势差增大到一定值时，光电流达到饱和值，此时的光电流称为<strong>饱和电流</strong>。若改变入射光强，<strong>饱和电流的大小与入射光强成正比</strong>，说明从阴极逸出的电子数全部飞到阳极，单位时间从金属表面逸出的电子数与入射光强成正比.</p>\n<h4 id=\"遏制电压差\">遏制电压差</h4>\n<p>改变阴极与阳极之间的电压，当电压增大到一定值时，光电流减小到零，此时的电压差称为<strong>遏制电压差</strong>。遏制电压差的大小与入射光的频率有关，与光强无关.\n光电子从表面逸出的最大初速度 <span\nclass=\"math inline\"><em>v</em><sub><em>m</em></sub></span> 满足：</p>\n<p><span class=\"math display\">$$\n\\frac{1}{2} m v_m^2 = eU_0\n$$</span></p>\n<h4 id=\"爱因斯坦的光量子论\">爱因斯坦的光量子论</h4>\n<p>电子辐射由以光速 <span class=\"math inline\"><em>c</em></span>\n运动的局限于空间某小范围的光量子（光子），即光子流组成 光子的能量为\n<span class=\"math inline\"><em>ε</em> = <em>h</em><em>ν</em></span>\n，动量为 <span class=\"math inline\">$p = \\frac{h}{\\lambda}$</span></p>\n<ul>\n<li>光电效应的基本方程</li>\n</ul>\n<p><span class=\"math display\">$$\nh \\nu=\\frac{1}{2} m v_{\\mathrm{m}}^{2}+A\n$$</span></p>\n<p>其中 <span\nclass=\"math inline\">$\\frac{1}{2}mv_{\\mathrm{m}}^{2}$</span>\n是光电子的最大初动能.</p>\n<p><strong>解释：</strong>\n光照射金属时，电子吸收光子，能量增加，一部分用于克服金属脱出功，一部分增加电子的初动能</p>\n<h4 id=\"光的波粒二象性\">光的波粒二象性</h4>\n<ul>\n<li>一些情况下，光的波动性表现得很明显，如干涉、衍射、偏振等现象.</li>\n<li>一些情况下，光的粒子性表现得很明显，如光电效应、康普顿散射等现象.</li>\n</ul>\n<p>这被称为光的波粒二象性</p>\n<ul>\n<li>光不是牛顿经典粒子，也不是康普顿的经典波</li>\n</ul>\n<p>基本关系式</p>\n<p><span class=\"math display\">$$\n\\left\\{\n  \\begin{aligned}\n    &amp;\\varepsilon = h\\nu \\quad \\text{粒子性}\\\\\n    &amp;p = \\frac{\\varepsilon}{c}=\\frac{h}{\\lambda} \\quad \\text{波动性}\n  \\end{aligned}\n\\right.\n$$</span></p>\n<h3 id=\"康普顿散射\">康普顿散射</h3>\n<p>在散射的 X\n射线中，存在与入射光波长相等的波，也存在波长比入射光波长大的波，这种现象称为<strong>康普顿散射</strong>\n.</p>\n<h4 id=\"特点\">特点</h4>\n<p><span\nclass=\"math display\"><em>Δ</em><em>λ</em> = <em>λ</em><sup>′</sup> − <em>λ</em> = <em>λ</em><sub><em>c</em></sub>(1 − cos <em>θ</em>)</span></p>\n<p>其中</p>\n<ul>\n<li><span class=\"math inline\">$\\lambda_c =\\frac{h}{m_{0}c}= 0.02426\n\\text{Å}$</span> 被称为康普顿波长. 当光子的波长等于 <span\nclass=\"math inline\"><em>λ</em><sub><em>c</em></sub></span>\n时，其能量等于电子的能量 <span\nclass=\"math inline\"><em>m</em><sub><em>c</em></sub><em>c</em><sup>2</sup> = 1.511MeV</span>\n.</li>\n<li><span class=\"math inline\"><em>θ</em></span> 为散射角.</li>\n</ul>\n<ol type=\"1\">\n<li>波长改变量随散射角 <span class=\"math inline\"><em>θ</em></span>\n的增大而增大</li>\n<li>新成分的相对强度随散射角 <span class=\"math inline\"><em>θ</em></span>\n的增大而增大</li>\n<li>同一个散射角下，所有散射物质的波长差相等</li>\n<li>随着原子序数的增加，原波长成分的相对强度增大，即对对于轻元素康普顿散射更为明显.</li>\n</ol>\n<p>其中 3、4 是由吴有训发现的</p>\n<h4 id=\"推导\">推导</h4>\n<p>使用动量守恒和能量守恒进行推导（X\n射线光子与静止的自由电子的碰撞）</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250302131054.png\"\nalt=\"康普顿散射推导\" />\n<figcaption aria-hidden=\"true\">康普顿散射推导</figcaption>\n</figure>\n<p>由能量守恒：</p>\n<p><span\nclass=\"math display\"><em>h</em><em>ν</em> + <em>m</em><sub><em>e</em></sub><em>c</em><sup>2</sup> = <em>h</em><em>ν</em><sup>′</sup> + <em>m</em><em>c</em><sup>2</sup></span></p>\n<p>其中 <span\nclass=\"math inline\">$m=\\frac{m_{e}}{\\sqrt{1-\\frac{v^2}{c^2}}}$</span></p>\n<p>由 <span class=\"math inline\"><em>x</em></span> 方向上的动量守恒</p>\n<p><span class=\"math display\">$$\n\\begin{equation}\n  \\frac{h\\nu _0}{c} = \\frac{h\\nu}{c} \\cos{\\theta} + mv\\cos{\\varphi}\n\\end{equation}\n$$</span></p>\n<p>由 <span class=\"math inline\"><em>y</em></span> 方向上的动量守恒</p>\n<p><span class=\"math display\">$$\n\\begin{equation}\n  0 = \\frac{h\\nu}{c} \\sin{\\theta} - mv\\sin{\\varphi}\n\\end{equation}\n$$</span></p>\n<p>解方程组即可得到康普顿散射的公式</p>\n<p><span class=\"math display\">$$\n\\Delta \\lambda = \\lambda _{0} -\\lambda =\\frac{h}{m_{e}c}\n(1-\\cos{\\theta})\n$$</span></p>\n<h3 id=\"波尔氢原子理论\">波尔氢原子理论</h3>\n<h4 id=\"原子模型的发展\">原子模型的发展</h4>\n<ol type=\"1\">\n<li>汤姆逊的面包夹葡萄干模型</li>\n<li>卢瑟福的 <span class=\"math inline\"><em>α</em></span>\n粒子散射实验和原子的核结构模型</li>\n</ol>\n<h4 id=\"氢原子光谱\">氢原子光谱</h4>\n<h5 id=\"公式\">公式</h5>\n<h6 id=\"里德伯公式\">里德伯公式</h6>\n<p><span class=\"math display\">$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{m^{2}}-\\frac{1}{n^{2}}\\right)\n\\quad(m=1,2,3,\\cdots;n=m+1,m+2,m+3,\\cdots)\n$$</span></p>\n<p>其中：</p>\n<ul>\n<li><span class=\"math inline\">$\\widetilde{\\nu} =\n\\frac{1}{\\lambda}$</span> 为波长的倒数，即波数</li>\n<li><span\nclass=\"math inline\"><em>R</em> = 1.097 × 10<sup>7</sup><em>m</em><sup>−1</sup></span>\n为里德伯常数</li>\n</ul>\n<h6 id=\"赖曼系-m1-紫外区\">赖曼系（ <span\nclass=\"math inline\"><em>m</em> = 1</span> ，紫外区）</h6>\n<p><span class=\"math display\">$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{1^{2}}-\\frac{1}{n^{2}}\\right)\n\\quad(n=2,3,4,\\cdots)\n$$</span></p>\n<h6 id=\"巴尔末系-m2\">巴尔末系（ <span\nclass=\"math inline\"><em>m</em> = 2</span> ）</h6>\n<p><span class=\"math display\">$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{2^{2}}-\\frac{1}{n^{2}}\\right)\n\\quad(n=3,4,5,\\cdots)\n$$</span></p>\n<h6 id=\"帕邢系-m3-红外区\">帕邢系（ <span\nclass=\"math inline\"><em>m</em> = 3</span> ，红外区）</h6>\n<p><span class=\"math display\">$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{3^{2}}-\\frac{1}{n^{2}}\\right)\n\\quad(n=4,5,6,\\cdots)\n$$</span></p>\n<h6 id=\"布拉开系-m4-近红外区\">布拉开系 （ <span\nclass=\"math inline\"><em>m</em> = 4</span> ，近红外区）</h6>\n<p><span class=\"math display\">$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{4^{2}}-\\frac{1}{n^{2}}\\right)\n\\quad(n=5,6,7,\\cdots)\n$$</span></p>\n<h6 id=\"普丰德系-m5-远红外区\">普丰德系（ <span\nclass=\"math inline\"><em>m</em> = 5</span> ，远红外区）</h6>\n<p><span class=\"math display\">$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{5^{2}}-\\frac{1}{n^{2}}\\right)\n\\quad(n=6,7,8,\\cdots)\n$$</span></p>\n<h6 id=\"汉弗莱系-m6-远红外区\">汉弗莱系 （ <span\nclass=\"math inline\"><em>m</em> = 6</span> ，远红外区）</h6>\n<p><span class=\"math display\">$$\n\\widetilde{\\nu}=R\\left(\\frac{1}{6^{2}}-\\frac{1}{n^{2}}\\right)\n\\quad(n=7,8,9,\\cdots)\n$$</span></p>\n<h5 id=\"波尔的氢原子模型\">波尔的氢原子模型</h5>\n<h5 id=\"波尔假设\">波尔假设</h5>\n<ol type=\"1\">\n<li><p>原子中的电子只能在一些分离的轨道上运行，在每一个轨道上运动的电子处于不稳定的能量状态（定态\n<span\nclass=\"math inline\"><em>E</em><em>W</em><sub><em>n</em></sub></span>\n），不向外辐射能量</p></li>\n<li><p><strong>频率条件：</strong>\n当电子从一个定态跃迁另一个定态时，发射或吸收一个光子，\n$h_{nm}=E_n-E_m$</p></li>\n<li><p><strong>结论：</strong></p>\n<p><span class=\"math display\">$$\n\\nu=\\frac{E_{n}-E_{m}}{h}=\\frac{m e^{4}}{8 \\varepsilon _{0}^{2}\nh^{3}}\\left(\\frac{1}{m^{2}}-\\frac{1}{n^{2}}\\right)\n$$</span></p></li>\n</ol>\n<h5 id=\"波尔角动量量子化条件\">波尔角动量量子化条件</h5>\n<p><span class=\"math display\">$$\nL=n \\frac{h}{2 \\pi}=n \\hbar,n=1,2,3,\\cdots\n$$</span></p>\n<p>其中， <span class=\"math inline\"><em>n</em></span> 为量子数， <span\nclass=\"math inline\">$\\hbar=\\frac{h}{2\\pi}$</span> 为约化普朗克常数.\n<strong>定量计算：</strong> 由电子的向心力和轨道角动量的量子化得到</p>\n<p><span class=\"math display\">$$\n\\left\\{\n  \\begin{aligned}\n    &amp;m\\frac{v^{2}}{r}=\\frac{1}{4\\pi \\varepsilon _{0}}\\cdot\n\\frac{e^2}{r^2}\\\\\n    &amp;L=mvr=n\\hbar\n  \\end{aligned}\n\\right.\n$$</span></p>\n<p>解得：</p>\n<p><span class=\"math display\">$$\n\\left\\{\n  \\begin{aligned}\n    &amp;r_n=n^2\\frac{4\\pi \\varepsilon _{0} \\hbar^{2}}{m e^{2}}=n^2r_1\\\\\n    &amp;v_n=\\frac{e^{2}}{4\\pi \\varepsilon _{0} n \\hbar}=\\alpha\n\\frac{c}{n}\n  \\end{aligned}\n\\right.\n$$</span></p>\n<p>其中 <span class=\"math inline\">$r_1 = \\frac{4\\pi \\varepsilon _{0}\n\\hbar^{2}}{m e^{2}} = 0.529\\text{Å}$</span> 为氢原子中电子的最小轨道</p>\n<p><strong>轨道能量：</strong></p>\n<p><span class=\"math display\">$$\nE_n =\\frac{1}{2}mv_n^2 + (-\\frac{1}{4\\pi \\varepsilon _0}\\cdot\n\\frac{e^2}{r_n^2}) =\n-\\frac{me^4}{8\\varepsilon_0^2h^2n^2}=-\\frac{1}{n^2}E_1\n$$</span></p>\n<p>其中 <span\nclass=\"math inline\"><em>E</em><sub>1</sub> = 13.6<em>e</em><em>V</em></span>\n为氢原子基态能量</p>\n<h5 id=\"波尔的对应原理\">波尔的对应原理</h5>\n<p>当 <span class=\"math inline\"><em>n</em> → +∞</span> 时，<span\nclass=\"math inline\"><em>r</em><sub><em>n</em></sub> → 0</span> ，<span\nclass=\"math inline\"><em>E</em><sub><em>n</em></sub> → 0</span> ，<span\nclass=\"math inline\">$\\displaystyle \\Delta E = E_n - E_{n+1} =\n\\frac{me^4}{4 \\varepsilon _0h^2n^3}\\rightarrow 0$</span>\n，即能级间距趋于零，能级连续，形成连续谱.</p>\n<h2 id=\"量子动力学入门\">量子动力学入门</h2>\n<p>量子力学的两条路线</p>\n<ol type=\"1\">\n<li>波动力学 普朗克、爱因斯坦、德布罗意、薛定谔</li>\n<li>矩阵力学 普朗克、波尔、海森堡</li>\n</ol>\n<ul>\n<li>最后由玻恩给出统计解释</li>\n<li>波动力学和矩阵力学完全等价</li>\n</ul>\n<h3 id=\"物质波\">物质波</h3>\n<h4 id=\"德布罗意假说\">德布罗意假说</h4>\n<p>德布罗意假设：实物具有波粒二象性</p>\n<table>\n<thead>\n<tr>\n<th>量</th>\n<th>粒子性</th>\n<th>波动性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"math inline\"><em>E</em></span></td>\n<td><span\nclass=\"math inline\"><em>m</em><em>c</em><sup>2</sup></span></td>\n<td><span class=\"math inline\"><em>h</em><em>ν</em></span></td>\n</tr>\n<tr>\n<td><span class=\"math inline\"><em>p</em></span></td>\n<td><span class=\"math inline\"><em>m</em><em>v</em></span></td>\n<td><span class=\"math inline\">$\\frac{h}{\\lambda}$</span></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"德布罗意原子稳定性驻波思想\">德布罗意原子稳定性驻波思想</h4>\n<p>原子中的电子在原子核库仑场中运动表现得波动性具有驻波得特征，驻波的稳定性使得电子不会坠落到原子核内</p>\n<h5 id=\"能量的量子化\">能量的量子化</h5>\n<ul>\n<li><span class=\"math inline\">$\\lambda = \\frac{2L}{n}$</span></li>\n<li><span class=\"math inline\">$p=\\frac{h}{2L}n$</span></li>\n<li><span class=\"math inline\">$E = \\frac{p^2}{2m} =\n\\frac{h^2}{8mL^2}n^2$</span></li>\n</ul>\n<h5\nid=\"物质波的概念对波尔轨道角动量量子化条件的解释\">物质波的概念对波尔轨道角动量量子化条件的解释</h5>\n<p>德布罗意认为电子在经典的圆轨道上运动，形成一个环形驻波</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250308170617.png\"\nalt=\"电子驻波\" />\n<figcaption aria-hidden=\"true\">电子驻波</figcaption>\n</figure>\n<p>电子绕行原子一周，圆周长应等于波长的整数倍</p>\n<p><span\nclass=\"math display\">2<em>π</em><em>r</em> = <em>n</em><em>λ</em></span></p>\n<p><span class=\"math display\">$$\nL = rmv = \\frac{n\\lambda}{2\\pi} \\cdot \\frac{h}{\\lambda} = n\\hbar\n$$</span></p>\n<h4 id=\"物质波的实验验证\">物质波的实验验证</h4>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250308171040.png\"\nalt=\"物质波的实验验证\" />\n<figcaption aria-hidden=\"true\">物质波的实验验证</figcaption>\n</figure>\n<h5 id=\"布拉格公式\">布拉格公式</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503151817449.png\"\nalt=\"布拉格公式推导\" />\n<figcaption aria-hidden=\"true\">布拉格公式推导</figcaption>\n</figure>\n<p><span\nclass=\"math display\"><em>δ</em> = 2<em>d</em>sin <em>θ</em> = <em>n</em><em>λ</em>  (<em>n</em> = 1, 2, 3, ⋯)</span></p>\n<h4 id=\"微观粒子波动性的应用\">微观粒子波动性的应用</h4>\n<ul>\n<li>显微镜使用电子波提大大提高了分辨率</li>\n</ul>\n<h3 id=\"波函数的统计解释\">波函数的统计解释</h3>\n<h4 id=\"对电子是什么的两种经典观点\">对电子是什么的两种经典观点</h4>\n<ol type=\"1\">\n<li>电子是波包\n<ul>\n<li>由两种不同频率的波合成一个波包</li>\n<li>这种观点夸大了波动性，忽略了粒子性\n<ol type=\"1\">\n<li>不同频率波在媒质中传播速度不同，波包会逐步扩展而消失，但是实际粒子并没有消失\n说明波包是电子的某种实际结果</li>\n<li>在媒质界面上一部分反射，一部分折射，但实际例子或整个反射，或整个折射</li>\n</ol></li>\n</ul></li>\n<li>经典粒子\n<ul>\n<li>粒子是基本的，波动性源于粒子与粒子的相互作用，或者粒子与狭缝周围原子的相互作用。</li>\n<li>这种观点夸大了粒子性，抹杀了波动性\n<ol type=\"1\">\n<li>电子的双缝衍射实验表明电子具有波动性</li>\n<li>电子的波动性并不是很多电子在空间聚集在一起时的相互作用的结果，而是单个电子就具有波动性，是电子自己和自己的干涉</li>\n</ol></li>\n</ul></li>\n</ol>\n<h4 id=\"对波函数的统计解释\">对波函数的统计解释</h4>\n<p>1926 年，玻恩提出了对波函数 <span\nclass=\"math inline\"><em>Ψ</em>(<strong>r</strong>, <em>t</em>)</span>\n的统计解释，将实物粒子的波动性和粒子性有机地结合在一起。</p>\n<h5 id=\"对亮度的解释\">对亮度的解释</h5>\n<ol type=\"1\">\n<li>波的观点 亮度是该点德布罗意波强度的大小</li>\n<li>粒子的观点\n亮度与该点附近出现的感光点的数目成正比，即与该点附近电子的数目成正比，即与该点附近电子的概率成正比</li>\n</ol>\n<h5 id=\"玻恩对波函数的统计解释\">玻恩对波函数的统计解释</h5>\n<p>波函数 <span class=\"math inline\"><em>Ψ</em></span>\n是描述粒子在空间概率分布的<strong>概率振幅</strong>，其模的平方 <span\nclass=\"math inline\">|<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup> = <em>Ψ</em>(<strong>r</strong>, <em>t</em>)<sup>*</sup><em>Ψ</em>(<strong>r</strong>, <em>t</em>)</span>\n表示 <span class=\"math inline\"><em>t</em></span> 时刻，在坐标 <span\nclass=\"math inline\"><strong>r</strong></span>\n附近单位体积中发现一个粒子的概率，被称为<strong>概率密度</strong></p>\n<ul>\n<li>目前对波函数最好的解释是概率波</li>\n<li><span class=\"math inline\"><em>t</em></span> 时刻，一个粒子处于 <span\nclass=\"math inline\"><em>x</em> → <em>x</em> + d<em>x</em></span> ，<span\nclass=\"math inline\"><em>y</em> → <em>y</em> + d<em>y</em></span> ，<span\nclass=\"math inline\"><em>z</em> → <em>z</em> + d<em>z</em></span>\n的概率为 <span\nclass=\"math inline\">|<em>Ψ</em>(<em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>)|<sup>2</sup>d<em>x</em>d<em>y</em>d<em>z</em></span>，记\n<span\nclass=\"math inline\"><em>ρ</em>(<em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>) = |<em>Ψ</em>(<em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>)|<sup>2</sup></span>\n为概率密度.</li>\n<li>在空间 <span class=\"math inline\"><em>Ω</em></span>\n中发现粒子的概率为 <span\nclass=\"math inline\">∫<sub><em>Ω</em></sub><em>ρ</em>(<em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>) d<em>x</em>d<em>y</em>d<em>z</em></span></li>\n</ul>\n<h4 id=\"波函数满足的条件\">波函数满足的条件</h4>\n<ol type=\"1\">\n<li>单值性\n<ul>\n<li>在空间的任何地方，概率密度只能有一个，所以一般波函数在任何地方都是单值的；</li>\n</ul></li>\n<li>有限性\n<ul>\n<li>粒子必然在空间的某处出现，概率综合为 1，所以在空间的任何有限体积元\n<span class=\"math inline\">d<em>V</em></span> 中，概率密度 <span\nclass=\"math inline\"><em>ρ</em>(<em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>)</span>\n有限；</li>\n<li><strong>归一化条件</strong>：<span\nclass=\"math inline\">∫<sub><em>Ω</em></sub>|<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup> d<em>V</em> = 1</span>\n，其中 <span class=\"math inline\"><em>Ω</em></span> 为全空间；</li>\n<li>归一化条件并不能排除在某些孤立奇点上 <span\nclass=\"math inline\">|<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup> → ∞</span></li>\n</ul></li>\n<li>连续性\n<ul>\n<li>波函数一阶导数连续（即使在势能函数有限大小间断点处）</li>\n</ul></li>\n</ol>\n<h3 id=\"不确定度关系\">不确定度关系</h3>\n<h4 id=\"形式-1位置-动量不确定关系\">形式 1（位置-动量不确定关系）</h4>\n<p>当粒子处在 <span class=\"math inline\"><em>x</em></span>\n方向的一个有限范围 <span class=\"math inline\"><em>Δ</em><em>x</em></span>\n内时，其动量 <span\nclass=\"math inline\"><em>p</em><sub><em>x</em></sub></span>\n的有一个不完全确定的数值范围 <span\nclass=\"math inline\"><em>Δ</em><em>p</em><sub><em>x</em></sub></span>\n，两者的乘积满足：</p>\n<p><span class=\"math display\">$$\n\\Delta x \\Delta p \\geq \\frac{\\hbar}{2}\n$$</span></p>\n<p>若记 <span class=\"math inline\">$k=\\frac{2\\pi}{\\lambda}$</span>\n，则</p>\n<p><span class=\"math display\">$$\n\\Delta x \\Delta k \\geq \\frac{1}{2}\n$$</span></p>\n<ul>\n<li><strong>含义</strong>：微观粒子的位置和动量不能同时准确地测定</li>\n<li>规律\n<ol type=\"1\">\n<li>当 <span class=\"math inline\"><em>Δ</em><em>x</em></span> 越小，<span\nclass=\"math inline\"><em>Δ</em><em>p</em></span> 越大</li>\n<li>当 <span class=\"math inline\"><em>Δ</em><em>p</em></span> 越小，<span\nclass=\"math inline\"><em>Δ</em><em>x</em></span> 越大</li>\n</ol></li>\n</ul>\n<p>电子的单缝衍射为例</p>\n<ul>\n<li>进入单缝之前的 <span class=\"math inline\"><em>Δ</em><em>x</em></span>\n趋向无穷大</li>\n</ul>\n<h4 id=\"形式-2\">形式 2</h4>\n<p>若粒子在能量状态 <span class=\"math inline\"><em>E</em></span>\n附近停留时间 <span class=\"math inline\"><em>Δ</em><em>t</em></span>\n，则其能量 <span class=\"math inline\"><em>E</em></span>\n有一个不完全确定的数值范围 <span\nclass=\"math inline\"><em>Δ</em><em>E</em></span> ，两者的乘积满足：</p>\n<p><span class=\"math display\">$$\n\\Delta t \\Delta E \\geq \\frac{\\hbar}{2}\n$$</span></p>\n<p>只有当粒子的停留时间为无穷大（定态）时，其能量才是确定的（<span\nclass=\"math inline\"><em>Δ</em><em>E</em> = 0</span> ）</p>\n<h4 id=\"电子单缝衍射的结论\">电子单缝衍射的结论</h4>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281611015.png\"\nalt=\"电子单缝衍射实验示意图\" />\n<figcaption aria-hidden=\"true\">电子单缝衍射实验示意图</figcaption>\n</figure>\n<ul>\n<li>电子通过单缝之后，动量在 <span class=\"math inline\"><em>x</em></span>\n方向上的分量 <span\nclass=\"math inline\"><em>P</em><sub><em>x</em></sub></span> 的大小为</li>\n</ul>\n<p><span\nclass=\"math display\">−<em>p</em> ⋅ sin <em>θ</em><sub>1</sub> ≤ <em>p</em><sub><em>x</em></sub> = <em>p</em> ⋅ sin <em>θ</em> ≤ <em>p</em> ⋅ sin <em>θ</em><sub>1</sub></span></p>\n<ul>\n<li>电子通过单缝后，动量在 <span class=\"math inline\"><em>x</em></span>\n方向分量的不确定量为</li>\n</ul>\n<p><span class=\"math display\">$$\n\\Delta p_x = 2p \\cdot \\sin{\\theta_1} =\\frac{2p\\lambda}{\\Delta x}\n$$</span></p>\n<p>带入德布罗意关系 <span\nclass=\"math inline\"><em>p</em><em>λ</em> = <em>h</em></span>，得到</p>\n<p><span\nclass=\"math display\"><em>Δ</em><em>x</em> ⋅ <em>Δ</em><em>p</em><sub><em>x</em></sub> = 2<em>h</em></span></p>\n<p>这里的讨论只反映不确定度关系的实质，并不表示准确的量值关系</p>\n<h2 id=\"量子力学\">量子力学</h2>\n<h3 id=\"薛定谔方程\">薛定谔方程</h3>\n<ul>\n<li>建立的是描写波函数随时间变化的方程，它必须是波函数应满足的含有对时间微商的微分方程</li>\n<li>是一个假设，无法被推导出来</li>\n</ul>\n<h4 id=\"满足的条件\">满足的条件</h4>\n<ol type=\"1\">\n<li>方程是线性的 如果 <span\nclass=\"math inline\"><em>Ψ</em><sub>1</sub></span> 和 <span\nclass=\"math inline\"><em>Ψ</em><sub>2</sub></span> 是薛定谔方程的解，则\n<span\nclass=\"math inline\"><em>a</em><em>Ψ</em><sub>1</sub> + <em>b</em><em>Ψ</em><sub>2</sub></span>\n也是薛定谔方程的解 这是由态叠加原理决定的</li>\n<li>方程的系数不应当包含状态参量，如动量、能量等\n否则这个方程只能被粒子的部分状态满足</li>\n</ol>\n<h4 id=\"自由粒子的薛定谔方程\">自由粒子的薛定谔方程</h4>\n<p>动量为 <span class=\"math inline\"><em>p</em></span> 、质量为 <span\nclass=\"math inline\"><em>m</em></span> 、能量为 <span\nclass=\"math inline\"><em>E</em></span> 的粒子在 <span\nclass=\"math inline\"><em>x</em></span> 方向上自由运动的薛定谔方程为</p>\n<p><span class=\"math display\">$$\n\\Psi \\left(x,t\\right) =\\Psi _0 e^{-\\frac{i}{\\hbar}\\left(Et-px\\right)}\n$$</span></p>\n<p><strong>对时间求偏导</strong></p>\n<p><span class=\"math display\">$$\n\\frac{\\partial \\Psi (x,t)}{\\partial t} = -\\frac{i}{\\hbar}E\\Psi (x,t)\n$$</span></p>\n<p>左右两边同乘 <span class=\"math inline\"><em>i</em>ℏ</span></p>\n<p><span class=\"math display\">$$\ni\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} = E\\Psi (x,t)\n$$</span></p>\n<p>我们记算符 <span class=\"math inline\"><em>Ê</em></span> 为能量算符</p>\n<p><span class=\"math display\">$$\n\\boxed{\\hat{E} \\equiv i\\hbar \\frac{\\partial}{\\partial t}}\n$$</span></p>\n<p>则</p>\n<p><span\nclass=\"math display\"><em>Ê</em><em>Ψ</em>(<em>x</em>, <em>t</em>) = <em>E</em><em>Ψ</em>(<em>x</em>, <em>t</em>)</span></p>\n<p><strong>对 <span class=\"math inline\"><em>x</em></span>\n求偏导</strong></p>\n<p><span class=\"math display\">$$\n\\frac{\\partial \\Psi (x,t)}{\\partial x} = \\frac{i}{\\hbar}p_x\\Psi (x,t)\n$$</span></p>\n<p>左右两边同乘 <span class=\"math inline\">−<em>i</em>ℏ</span></p>\n<p><span class=\"math display\">$$\n-i\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial x} = p_x\\Psi (x,t)\n$$</span></p>\n<p>我们记算符 <span class=\"math inline\">$\\hat{p_x}$</span>\n为动量算符</p>\n<p><span class=\"math display\">$$\n\\boxed{\\hat{p_x} \\equiv -i\\hbar \\frac{\\partial}{\\partial x}}\n$$</span></p>\n<p>则</p>\n<p><span class=\"math display\">$$\n\\hat{p_x} \\Psi (x,t) = p_x\\Psi (x,t)\n$$</span></p>\n<p><strong>对 <span class=\"math inline\"><em>x</em></span>\n做二次偏导</strong></p>\n<p><span class=\"math display\">$$\n\\frac{\\partial^2 \\Psi (x,t)}{\\partial x^2} = -\\frac{p_x^2}{\\hbar^2}\\Psi\n(x,t)\n$$</span></p>\n<p><strong>综合考虑</strong></p>\n<p><span class=\"math display\">$$\n\\left\\{\n  \\begin{aligned}\n    &amp;i\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} = E\\Psi (x,t)\\\\\n    &amp;\\frac{\\partial ^2 \\Psi (x,t)}{\\partial x^2} =\n-\\frac{p_x^2}{\\hbar^2}\\Psi (x,t)\n    \\end{aligned}\n\\right.\n$$</span></p>\n<p>由 <span class=\"math inline\">$E = \\frac{p_x^2}{2m}$</span>，有</p>\n<p><span class=\"math display\">$$\ni\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} = E\\Psi (x,t) =\n-\\frac{p_x^2}{2m}\\Psi (x,t)=-\\frac{\\hbar^2}{2m}\\frac{\\partial^2 \\Psi\n(x,t)}{\\partial x^2}\n$$</span></p>\n<p><strong>即</strong></p>\n<p><span class=\"math display\">$$\n\\boxed{i\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} =\n-\\frac{\\hbar^2}{2m}\\frac{\\partial^2 \\Psi (x,t)}{\\partial x^2}}\n$$</span></p>\n<p>这就是自由粒子的薛定谔方程</p>\n<h4 id=\"薛定谔方程的一般形式\">薛定谔方程的一般形式</h4>\n<p>将自由粒子运动算符推广到非自由粒子运动，粒子所处的势场为 <span\nclass=\"math inline\"><em>U</em>(<em>x</em>, <em>t</em>)</span>\n对于保守系统，其能量等于<strong>哈密顿量</strong></p>\n<p><span class=\"math display\">$$\nE = H = \\frac{p^2}{2m} + U(x,t)\n$$</span></p>\n<p>哈密顿量算符化，称为<strong>哈密顿算符</strong></p>\n<p><span class=\"math display\">$$\n\\hat{H} = \\frac{\\hat p_x^2}{2m} +\nU(x,t)=\\frac{-\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} + U(x,t)\n$$</span></p>\n<p><strong>薛定谔方程</strong>：对于保守系统，其能量算符作用在波函数上，等于哈密顿算符作用在波函数上</p>\n<p><span class=\"math display\">$$\n\\boxed{\\hat{E} \\Psi (x,t) = \\hat{H} \\Psi (x,t)}\n$$</span></p>\n<p>将其展开</p>\n<p><span class=\"math display\">$$\n\\boxed{i\\hbar \\frac{\\partial \\Psi (x,t)}{\\partial t} =\n\\left(\\frac{-\\hbar^2}{2m}\\frac{\\partial ^2}{\\partial x^2} +\nU(x,t)\\right) \\Psi (x,t)}\n$$</span></p>\n<p>推广到三维势场</p>\n<p><span class=\"math display\">$$\n\\boxed{i\\hbar \\frac{\\partial \\Psi (\\boldsymbol{r},t)}{\\partial t} =\n\\left(-\\frac{\\hbar^2}{2m}\\nabla^2 + U(\\boldsymbol{r},t)\\right) \\Psi\n(\\boldsymbol{r},t)}\n$$</span></p>\n<h4 id=\"定态薛定谔方程\">定态薛定谔方程</h4>\n<p>若微观粒子在稳定的势场中，则其势能函数 <span\nclass=\"math inline\"><em>U</em></span>\n与时间无关，称这类问题为定态问题</p>\n<p><span class=\"math display\">$$\n\\hat{H} = -\\frac{\\hbar^2}{2m}\\nabla^2 + U(\\boldsymbol{r})\n$$</span></p>\n<p><span class=\"math display\">$$\n\\\ni\\hbar \\frac{\\partial}{\\partial t}\\Psi (\\boldsymbol{r},t) = \\hat{H} \\Psi\n(\\boldsymbol{r},t)\n$$</span></p>\n<p>此时哈密顿算符与时间无关，薛定谔方程可以用分离变量法求解，波函数\n<span class=\"math inline\"><em>Ψ</em></span>\n分解为空间函数和时间函数的乘积</p>\n<p>设 <span\nclass=\"math inline\"><em>Ψ</em>(<strong>r</strong>, <em>t</em>) = <em>Φ</em>(<strong>r</strong>)<em>T</em>(<em>t</em>)</span></p>\n<p><span class=\"math display\">$$\ni\\hbar \\frac{\\mathrm{d} T(t)}{\\mathrm{d} t}\\Phi(\\boldsymbol{r}) =\n\\left[\\hat{H} \\Phi(\\boldsymbol{r})\\right] T(t)\n$$</span></p>\n<p><span class=\"math display\">$$\ni\\hbar \\frac{1}{T(t)}\\mathrm{d} t =\n\\frac{1}{\\Phi(\\boldsymbol{r})}\\hat{H} \\Phi(\\boldsymbol{r}) = const = E\n$$</span></p>\n<p>其中 <span class=\"math inline\"><em>E</em></span> 为本征值，<span\nclass=\"math inline\"><em>Φ</em></span> 为本征函数 得到分别只含有变量\n<span class=\"math inline\"><em>t</em></span> 和 <span\nclass=\"math inline\"><strong>r</strong></span> 的两个方程</p>\n<p><span class=\"math display\">$$\n\\left\\{\n\\begin{aligned}\n  &amp;i \\hbar \\frac{\\mathrm{d} T(t)}{\\mathrm{d} t} =\nET(t)  &amp;&amp;\\text{(1)}\\\\\n  &amp;\\hat{H} \\Phi(\\boldsymbol{r}) =\nE\\Phi(\\boldsymbol{r})  &amp;&amp;\\text{(2)}\n\\end{aligned}\n\\right.\n$$</span></p>\n<p>方程(1)的解为</p>\n<p><span class=\"math display\">$$\nT(t) = e^{-\\frac{i}{\\hbar}Et}\n$$</span></p>\n<p>方程(2)是关于变量 <span class=\"math inline\"><em>x</em></span>、<span\nclass=\"math inline\"><em>y</em></span>、<span\nclass=\"math inline\"><em>z</em></span>\n的微分方程，称为<strong>定态薛定谔方程</strong>，又称为哈密顿算符的本征方程</p>\n<p><span class=\"math display\">$$\n\\boxed{\\left[-\\frac{\\hbar^2}{2m}\\nabla^2 + U(x,y,z)\\right] \\Phi(x,y,z) =\nE\\Phi(x,y,z)}\n$$</span></p>\n<p>其解与外力场 <span class=\"math inline\"><em>U</em></span>\n和边界条件有关 波函数是两者的乘积</p>\n<p><span class=\"math display\">$$\n\\boxed{\\Psi (\\boldsymbol{r},t) =\n\\Phi(\\boldsymbol{r})e^{-i\\frac{1}{\\hbar}Et}}\n$$</span></p>\n<ul>\n<li>粒子在空间中出现的几率密度与时间无关——<strong>定态</strong></li>\n</ul>\n<p><span class=\"math display\">$$\n\\vert\\Psi (\\boldsymbol{r},t)\\vert^2 =\\vert\\Phi(\\boldsymbol{r})\ne^{-i\\frac{1}{\\hbar}Et}\\vert^2 = \\vert\\Phi(\\boldsymbol{r})\\vert^2\n$$</span></p>\n<h4 id=\"薛定谔方程的应用\">薛定谔方程的应用</h4>\n<h5 id=\"一维无限深方势阱\">一维无限深方势阱</h5>\n<p>金属中的电子由于金属表面势能（能垒）的束缚而被限制在一个有限的空间范围内运动\n如果金属表面的能垒很高，可以将金属表面看成一个刚性的盒子。若只考虑一维运动，则其势能函数为</p>\n<p><span class=\"math display\">$$\nU(x) =\n\\left\\{\n  \\begin{aligned}\n    &amp;0 \\quad (0 \\leq x \\leq L)\\\\\n    &amp;\\infty \\quad (x &lt; 0 \\text{ or } x &gt; L)\n  \\end{aligned}\n\\right.\n$$</span></p>\n<p>称为<strong>一维无限深方势阱</strong></p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504111721435.png\"\nalt=\"无限深方势阱\" />\n<figcaption aria-hidden=\"true\">无限深方势阱</figcaption>\n</figure>\n<ul>\n<li>势阱内</li>\n</ul>\n<p><span class=\"math display\">$$\n-\\frac{\\hbar^2}{2m}\\frac{\\mathrm{d}^2}{\\mathrm{d} x^2} \\Phi_i(x) =\nE\\Phi_i(x)\n$$</span></p>\n<p>令 <span class=\"math inline\">$k\n=\\sqrt{\\frac{2mE}{\\hbar^2}}$</span>，得</p>\n<p><span class=\"math display\">$$\n\\frac{\\mathrm{d}^2\\Phi_i}{\\mathrm{d} x^2} + k^2\\Phi_i = 0\n$$</span></p>\n<p>其解为</p>\n<p><span\nclass=\"math display\"><em>Φ</em><sub><em>i</em></sub>(<em>x</em>) = <em>C</em>sin (<em>k</em><em>x</em> + <em>δ</em>)</span></p>\n<p>其中 <span class=\"math inline\"><em>C</em></span> 和 <span\nclass=\"math inline\"><em>δ</em></span> 为常数，由波函数的自然条件确定</p>\n<ul>\n<li>势阱外</li>\n</ul>\n<p><span class=\"math display\">$$\n-\\frac{\\hbar^2}{2m}(\\frac{\\mathrm{d}^2}{\\mathrm{d}x^2}+\\infty)\\Phi_e(x)\n= E\\Phi_e(x)\n$$</span></p>\n<p>其解为</p>\n<p><span\nclass=\"math display\"><em>Φ</em><sub><em>e</em></sub>(<em>x</em>) = 0</span></p>\n<ul>\n<li>波函数在肼壁上连续的条件为</li>\n</ul>\n<p><span class=\"math display\">$$\n\\left\\{\n  \\begin{aligned}\n    &amp;\\Phi_i(0) = \\Phi_e(0) \\\\\n    &amp;\\Phi_i(L) = \\Phi_e(L) \\\\\n  \\end{aligned}\n\\right.\n$$</span></p>\n<p>由边界条件可得</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\Phi_i(0)= 0 &amp;&amp; \\text{(1)}\\\\\n  \\Phi_i(L) = 0 &amp;&amp; \\text{(2)}\n\\end{cases}\n$$</span></p>\n<p>由 <span class=\"math inline\">(1)</span> 可得 <span\nclass=\"math inline\"><em>δ</em> = 0</span>、</p>\n<p>由 <span class=\"math inline\">(2)</span> 可得 <span\nclass=\"math inline\"><em>k</em><em>L</em> = <em>n</em><em>π</em></span>，其中\n<span class=\"math inline\"><em>n</em> ∈ ℕ<sup>*</sup></span>，即 <span\nclass=\"math inline\">$k = \\frac{n\\pi}{L}$</span></p>\n<p><span class=\"math display\">$$\n\\Phi(x) =\\sqrt{\\frac{2}{L}}\\sin\\left(\\frac{n\\pi}{L}x\\right)\n$$</span></p>\n<ul>\n<li><strong>粒子的能量:</strong> <span class=\"math inline\">$E =\n\\frac{\\hbar^2k^2}{2m} = \\frac{n^2\\pi^2\\hbar^2}{2mL^2}$</span>，<span\nclass=\"math inline\"><em>n</em></span> 为能量量子数\n<ul>\n<li>能量取分立值（能级），这是<strong>能量量子化</strong>的表现</li>\n</ul></li>\n</ul>\n<p><span class=\"math display\">$$\n\\Delta E = E_{n+1} - E_n =\n\\frac{\\hbar^2}{2m}\\left(\\left(\\frac{(n+1)\\pi}{L}\\right)^2 -\n\\left(\\frac{n\\pi}{L}\\right)^2\\right) = (2n+1)\\frac{\\hbar^2\\pi^2}{2mL^2}\n$$</span></p>\n<ul>\n<li>当 <span class=\"math inline\"><em>a</em>↑</span> 时 <span\nclass=\"math inline\"><em>Δ</em><em>E</em>↓</span>，并且当 <span\nclass=\"math inline\"><em>n</em> → ∞</span> 时， <span\nclass=\"math inline\"><em>Δ</em><em>E</em> → 0</span>，即能级间隔趋于零，能级连续，形成连续谱</li>\n<li>最低能量（零点能）<span\nclass=\"math inline\">$E_1=\\frac{\\pi^2\\hbar^2}{amL^2}&gt;0$</span>，具有波动性</li>\n<li>在势阱中形成驻波</li>\n</ul>\n<p><span class=\"math display\">$$\n\\Phi(x) =C\\sin\\left(\\frac{n\\pi}{L}x\\right)\n$$</span></p>\n<p>由归一化条件</p>\n<p><span class=\"math display\">$$\n\\int_{-\\infty}^{+\\infty} \\vert \\Phi(x) \\vert^2\\,\\mathrm{d}x =\n\\int_{0}^{L} C^2\\sin^2\\left(\\frac{n\\pi}{L}x\\right)\\,\\mathrm{d}x = C^2\n\\cdot \\frac{L}{2} = 1\n$$</span></p>\n<p>解得</p>\n<p><span class=\"math display\">$$\nC = \\sqrt{\\frac{2}{L}}\n$$</span></p>\n<p>故定态波函数为</p>\n<p><span class=\"math display\">$$\n\\Phi(x) =\n\\left\\{\n  \\begin{aligned}\n    &amp;\\sqrt{\\frac{2}{L}}\\sin\\left(\\frac{n\\pi}{L}x\\right) &amp;&amp;\n(0 \\leq x \\leq L)\\\\\n    &amp;0 &amp;&amp; (x &lt; 0 \\text{ or } x &gt; L)\n  \\end{aligned}\n\\right.\n$$</span></p>\n<h6\nid=\"一维无线深方势阱中粒子的波函数和概率密度\">一维无线深方势阱中粒子的波函数和概率密度</h6>\n<p><span class=\"math display\">$$\n\\Phi (x,t) = \\sqrt{\\frac{2}{L}} \\sin\\left(\\frac{n\\pi}{L}x\\right), \\quad\n(0 \\leq x \\leq L)\n$$</span></p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504131458204.png\"\nalt=\"波函数和概率密度\" />\n<figcaption aria-hidden=\"true\">波函数和概率密度</figcaption>\n</figure>\n<p>可以看出</p>\n<ul>\n<li>势阱中的粒子波函数为驻波</li>\n<li>基态 <span class=\"math inline\"><em>n</em> = 1</span> 除了 <span\nclass=\"math inline\"><em>x</em> = 0</span> 和 <span\nclass=\"math inline\"><em>x</em> = <em>L</em></span>\n处为节点外，其余无节点</li>\n<li>第 <span class=\"math inline\"><em>n</em></span> 量子态有 <span\nclass=\"math inline\"><em>n</em> − 1</span> 个 node</li>\n</ul>\n<h6\nid=\"一维无限深势阱中粒子的波函数是正交归一的\">一维无限深势阱中粒子的波函数是正交归一的</h6>\n<p>设不同能级的波函数为 <span\nclass=\"math inline\"><em>Φ</em><sub><em>n</em></sub>(<em>x</em>)</span>\n和 <span\nclass=\"math inline\"><em>Φ</em><sub><em>m</em></sub>(<em>x</em>)</span></p>\n<ul>\n<li>正交性</li>\n</ul>\n<p><span class=\"math display\">$$\n\\int_{-\\infty}^{+\\infty} \\Phi_n(x) \\Phi_m(x)\\,\\mathrm{d}x = \\int\n_{-\\infty }^{+\\infty }\\sqrt{\\frac{2}{L}}\\sin\\frac{m\\pi }{L} x\\cdot\n\\sqrt{\\frac{2}{L}}\\sin\\frac{n\\pi }{L}\\,\\mathrm{d} x=\\frac{1}{L}\\int\n_{0}^{L}\\left(\\cos\\frac{m-n}{L} -\\cos\\frac{m+n}{L}\\right)\\,\\mathrm{d}\nx=0\n$$</span></p>\n<ul>\n<li>归一性</li>\n</ul>\n<p><span class=\"math display\">$$\n\\int_{-\\infty}^{+\\infty} \\Phi_n(x) \\Phi_n(x)\\,\\mathrm{d}x = \\int\n_{-\\infty }^{+\\infty }\\sqrt{\\frac{2}{L}}\\sin\\frac{n\\pi }{L} x\\cdot\n\\sqrt{\\frac{2}{L}}\\sin\\frac{n\\pi }{L}\\,\\mathrm{d} x=\\frac{1}{L}\\int\n_{0}^{L}\\left(\\cos 0 -\\cos\\frac{2n\\pi }{L}\\right)\\,\\mathrm{d} x=1\n$$</span></p>\n<h5 id=\"波尔对应原理\">波尔对应原理</h5>\n<ul>\n<li>在大量子数极限下，量子规律必须转化为经典规律，这也被称为<strong>量子物理的对应原理</strong></li>\n</ul>\n<p>比如</p>\n<ul>\n<li>本征能量</li>\n</ul>\n<p><span class=\"math display\">$$\nE = E_n = \\frac{\\hbar^2 \\pi^2 n^2}{2mL^2} = n^2 \\frac{h^2}{8mL^2}\n$$</span></p>\n<ul>\n<li>相邻能级的间隔为</li>\n</ul>\n<p><span class=\"math display\">$$\n\\Delta E_n = (2n+1)\\frac{h^2}{8mL^2}\n$$</span></p>\n<ul>\n<li>相对能级间隔</li>\n</ul>\n<p><span class=\"math display\">$$\n\\frac{\\Delta E_n}{E_n} = \\frac{2n+1}{n^2}\n$$</span></p>\n<ul>\n<li>当 <span class=\"math inline\"><em>n</em> → ∞</span> 时， <span\nclass=\"math inline\"><em>Δ</em><em>E</em><sub><em>n</em></sub> → 0</span>\n，即能级间隔趋于零，能级连续，形成连续谱</li>\n</ul>\n<p>粒子在势阱中的概率分布为</p>\n<p><span class=\"math display\">$$\n\\rho(x) = \\vert \\Phi(x) \\vert^2 =\n\\left\\{\n  \\begin{aligned}\n    &amp;\\frac{2}{L}\\sin^2(\\frac{n\\pi}{L}x) &amp;&amp; (0 \\leq x \\leq\nL)\\\\\n    &amp;0 &amp;&amp; (x &lt; 0 \\text{ or } x &gt; L)\n  \\end{aligned}\n\\right.\n$$</span></p>\n<h5 id=\"德布罗意的驻波思想\">德布罗意的驻波思想</h5>\n<ul>\n<li>一个频率为 <span class=\"math inline\"><em>ν</em></span> 、波长 <span\nclass=\"math inline\"><em>λ</em></span> 沿 <span\nclass=\"math inline\"><em>x</em></span>\n方向传播的单色平面波的表达式为</li>\n</ul>\n<p><span class=\"math display\">$$\n\\Psi(x,t) = \\Psi_0 e^{-i \\frac{2\\pi}{h}(Et -Px)}\n$$</span></p>\n<ul>\n<li>全波函数为</li>\n</ul>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n\\Psi ( x,t) =\\Phi ( x) e^{-\\frac{i}{\\hbar } Et} &amp;=\\sqrt{\\frac{2}{L}}\ne^{-i\\frac{Et}{\\hbar }}\\sin\\frac{n\\pi }{L} x\\\\\n&amp;=\\frac{1}{2i}\\sqrt{\\frac{2}{L}} e^{-i\\frac{Et}{\\hbar }}\\left(\ne^{i\\frac{n\\pi }{L} x} -e^{-i\\frac{n\\pi }{L} x}\\right)\\\\\n&amp;=\\frac{1}{2i}\\sqrt{\\frac{2}{L}} e^{-i\\frac{Et}{\\hbar }}\\left(\ne^{i\\frac{p_{n}}{\\hbar }} -e^{-i\\frac{p_{n}}{\\hbar } x}\\right)\n\\end{aligned}\n$$</span></p>\n<p>可以将波函数视为频率相同、波长相同、传播方向相反的两单色平面波的叠加</p>\n<p>则由德布罗意的物质波理论，一个动量为 <span\nclass=\"math inline\"><em>p</em></span>、质量为 <span\nclass=\"math inline\"><em>m</em></span>、能量为 <span\nclass=\"math inline\"><em>E</em></span> 的自由粒子，沿着 <span\nclass=\"math inline\"><em>x</em></span> 轴运动的波函数为</p>\n<p><span class=\"math display\">$$\n\\Psi ( x,t) =\\Psi _{0} e^{-\\frac{i}{\\hbar }( Et-px)}\n$$</span></p>\n<p>波函数也为频率相同、波长相同、传播方向相反的两单色平面波的叠加形成驻波</p>\n<ul>\n<li>势阱中粒子的动量和波长\n<ul>\n<li>动量：<span class=\"math inline\">$p_n =\\sqrt{2mE_n} =\n\\pm\\frac{n\\hbar}{2L} = \\pm n \\frac{ h}{2L}$</span></li>\n<li>波长：<span class=\"math inline\">$\\lambda_n =\n\\frac{\\hbar}{p_n}=\\frac{2L}{n}$</span>\n说明势阱中粒子的每一个能量本征态正好对应德布罗意波的一个特征波长的驻波</li>\n</ul></li>\n<li>符合德布罗意的驻波理论</li>\n</ul>\n<h5 id=\"一维方势垒和隧穿效应\">一维方势垒和隧穿效应</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504181642705.png\"\nalt=\"Tunel effect\" />\n<figcaption aria-hidden=\"true\">Tunel effect</figcaption>\n</figure>\n<p>设</p>\n<p><span class=\"math display\">$$\nV(x)=\n\\begin{cases}\n    0, &amp; x &lt; x_1 \\quad \\text{or} \\quad x &gt; x_2 \\\\\n    V_0, &amp; x_1 &lt; x &lt; x_2\n\\end{cases}\n$$</span></p>\n<p>称为方势垒</p>\n<p>现有一能量为 <span class=\"math inline\"><em>E</em></span>\n的粒子从左向右入射</p>\n<p>在经典力学中，若 <span\nclass=\"math inline\"><em>E</em> &lt; <em>V</em><sub>0</sub></span>，则粒子无法穿过势垒，<span\nclass=\"math inline\"><em>E</em> &gt; <em>V</em><sub>0</sub></span>\n时，粒子能够完全穿过势垒</p>\n<p>但是在量子力学中，粒子是一种物质波，情况完全不一样，需要通过求解薛定谔方程来确定</p>\n<p><span class=\"math display\">$$\n\\frac{d^2\\psi(x)}{dx^2}=\\frac{2m}{\\hbar^2}(V_0-E)\\psi(x)\n$$</span></p>\n<p>在这里我们设 <span\nclass=\"math inline\"><em>V</em><sub>0</sub> &gt; <em>E</em></span>，令\n<span class=\"math inline\">$k=\\sqrt{\\frac{2mE}{\\hbar^2}}$</span> 和 <span\nclass=\"math inline\">$k' = \\sqrt{\\frac{2m(V_0-E)}{\\hbar^2}}$</span></p>\n<p>则薛定谔方程可化为</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\frac{d^2\\psi_1(x)}{dx^2} = -k^2\\psi_1(x), &amp; x &lt; x_1 \\\\\n  \\frac{d^2\\psi_2(x)}{dx^2} = k'^2\\psi_2(x), &amp; x_1 &lt; x &lt; x_2\n\\\\\n  \\frac{d^2\\psi_3(x)}{dx^2} = -k^2\\psi_3(x), &amp; x &gt; x_2\n\\end{cases}\n$$</span></p>\n<p>解得</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\psi_1 = A e^{ikx} + A' e^{-ikx}, &amp; x &lt; x_1 \\\\\n  \\psi_2 = B e^{k'x} + B' e^{-k'x}, &amp; x_1 &lt; x &lt; x_2 \\\\\n  \\psi_3 = C e^{ikx} , &amp; x &gt; x_2\n\\end{cases}\n$$</span></p>\n<p>由连续性（在这里我们令 <span\nclass=\"math inline\"><em>x</em><sub>1</sub> = 0</span>，<span\nclass=\"math inline\"><em>x</em><sub>2</sub> = <em>a</em></span>）</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\psi_1(0) = \\psi_2(0) \\rightarrow A + A' = B + B' \\\\\n  \\psi_1'(0) = \\psi_2'(0) \\rightarrow ik(A - A') = k' (B - B') \\\\\n  \\psi_2(a) = \\psi_3(a) \\rightarrow B e^{k'a} + B' e^{-k'a} = C e^{ika}\n\\\\\n  \\psi_2'(a) = \\psi_3'(a) \\rightarrow k' B e^{k'a} - k' B' e^{-k'a} =\nikC e^{ika}\n\\end{cases}\n$$</span></p>\n<p>求解并经过计算得到</p>\n<ul>\n<li><strong>反射系数：</strong> <span class=\"math inline\">$\\displaystyle\nR =\\frac{\\vert A'\\vert^2}{\\vert A\\vert^2}\n=\\frac{(k^2+k'^2)^2\\sinh^2(k'a)}{\\left(k^2+k'^2\\right)\\sinh^2(k'a) +\n4k^2k'^2}$</span></li>\n<li><strong>透射系数：</strong> <span class=\"math inline\">$\\displaystyle\nT =\\frac{\\vert C\\vert^2}{\\vert A\\vert^2}\n=\\frac{4k^2k'^2}{\\left(k^2+k'^2\\right)\\sinh^2(k'a) +\n4k^2k'^2}$</span></li>\n</ul>\n<p>显然有 <span class=\"math inline\">$\\boxed{T+R=1}$</span></p>\n<h2 id=\"定态问题\">定态问题</h2>\n<h2 id=\"量子力学的基本假设\">量子力学的基本假设</h2>\n<h3 id=\"波函数假设\">波函数假设</h3>\n<p>微观粒子的状态可以被一个波函数完全描述，从这个波函数可以得到体系的所有性质</p>\n<p>波函数一般满足连续性、有限性和单值性三个条件</p>\n<ol type=\"1\">\n<li>物质波可以用一个随时间、空间变化的波函数 <span\nclass=\"math inline\"><em>Ψ</em>(<strong>r</strong>, <em>t</em>)</span>\n来描述</li>\n<li>自由粒子的波函数是单色平面波 <span class=\"math inline\">$\\Psi(x,t) =\n\\Psi_0 e^{-i\\frac{2\\pi}{h}(Et - Px)} = \\Psi_0 e^{-i\\frac{1}{\\hbar}(Et -\nPx)}$</span></li>\n<li>波恩：德布罗意波是描述粒子在空间概率分布的概率波 波函数的模的平方\n<span\nclass=\"math inline\">|<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup></span>\n表示 <span class=\"math inline\"><em>t</em></span> 时刻，在坐标 <span\nclass=\"math inline\"><strong>r</strong></span> 处粒子出现的概率密度</li>\n<li>波函数满足<strong>单值、有限、连续</strong>的条件，称为<strong>波函数的标准条件</strong></li>\n<li><strong>归一化条件：</strong> 在整个空间中发现粒子的概率为 <span\nclass=\"math inline\">1</span>，即 <span\nclass=\"math inline\">∫<sub><em>Ω</em></sub>|<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup> d<em>V</em> = 1</span>，其中\n<span class=\"math inline\"><em>Ω</em></span> 为全空间</li>\n</ol>\n<h3 id=\"力学算符假设\">力学算符假设</h3>\n<p>量子力学中的力学量用线性厄米（Hermite）算符表示。如果经典力学中有相关的力学量，则在量子力学中也有相应表示这个力学量的算符</p>\n<p>算符能将波函数变换为另一个波函数</p>\n<ul>\n<li>动量算符 <span\nclass=\"math inline\"><em>p̂</em> = −<em>i</em>ℏ∇</span></li>\n<li>位置算符 <span class=\"math inline\">$\\hat{\\boldsymbol{r}} =\n\\boldsymbol{r}$</span></li>\n<li>能量算符 <span class=\"math inline\">$\\hat{H} = \\frac{\\hat{p}^2}{2m} +\nU(\\boldsymbol{r}) = -\\frac{\\hbar ^2}{2m}\\nabla ^2 +\nU(\\boldsymbol{r})$</span></li>\n<li>角动量算符 <span class=\"math inline\">$\\hat{\\boldsymbol{L}}\n=\\hat{\\boldsymbol{r}} \\times \\hat{\\boldsymbol{p}}\n=\\left\\vert\\begin{smallmatrix}\\boldsymbol{i} &amp; \\boldsymbol{j} &amp;\n\\boldsymbol{k} \\newline x &amp; y &amp; z \\newline p_x &amp; p_y &amp;\np_z \\end{smallmatrix}\\right\\vert$</span>\n<ul>\n<li><span\nclass=\"math inline\"><em>L̂</em><sub><em>x</em></sub> = <em>y</em><em>p̂</em><sub><em>z</em></sub> − <em>z</em><em>p̂</em><sub><em>y</em></sub></span></li>\n<li><span\nclass=\"math inline\"><em>L̂</em><sub><em>y</em></sub> = <em>z</em><em>p̂</em><sub><em>x</em></sub> − <em>x</em><em>p̂</em><sub><em>z</em></sub></span></li>\n<li><span\nclass=\"math inline\"><em>L̂</em><sub><em>z</em></sub> = <em>x</em><em>p̂</em><sub><em>y</em></sub> − <em>y</em><em>p̂</em><sub><em>x</em></sub></span></li>\n</ul></li>\n</ul>\n<h4 id=\"厄米hermite算符\">厄米（Hermite）算符</h4>\n<p><span class=\"math inline\"><em>Â</em></span>\n是厄米算符的充分必要条件是</p>\n<p><span\nclass=\"math display\">∫<em>Ψ</em><sup>*</sup><em>Â</em><em>φ</em> d<em>V</em> = ∫<em>Ψ</em>(<em>Â</em><em>Ψ</em><sup>*</sup>) d<em>V</em></span></p>\n<p>其中 <span class=\"math inline\"><em>Ψ</em></span> 和 <span\nclass=\"math inline\"><em>φ</em></span> 是在无穷远处趋向 <span\nclass=\"math inline\">0</span> 的任意函数</p>\n<ul>\n<li>如果 <span class=\"math inline\"><em>Â</em></span> 和 <span\nclass=\"math inline\"><em>B̂</em></span> 都是厄米算符，则 <span\nclass=\"math inline\"><em>Â</em><em>B̂</em> + <em>B̂</em><em>Â</em></span>\n也是厄米算符</li>\n</ul>\n<p><strong>证明：</strong></p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n&amp;\\int _{-\\infty }^{+\\infty }\\Psi ^{*}\\left(\\hat{A}\\hat{B} +\n\\hat{B}\\hat{A}\\right)\\varphi\\,\\mathrm{d}x \\\\\n= &amp;\\int _{-\\infty }^{+\\infty }\\Psi\n^{*}\\hat{A}(\\hat{B}\\varphi)\\,\\mathrm{d}x + \\int _{-\\infty }^{+\\infty\n}\\Psi ^{*}\\hat{B}(\\hat{A}\\varphi)\\,\\mathrm{d}x\\\\\n= &amp;\\int _{-\\infty }^{+\\infty }(\\hat{A}\\Psi)\n^{*}(\\hat{B}\\varphi)\\,\\mathrm{d}x + \\int _{-\\infty }^{+\\infty\n}(\\hat{B}\\Psi) ^{*}(\\hat{A}\\varphi)\\,\\mathrm{d}x\\\\\n= &amp;\\int\n_{-\\infty}^{+\\infty}\\left[\\varphi\\left(\\hat{B}\\hat{A}\\Psi\\right)^*+\\varphi\\left(\\hat{A}\\hat{B}\\Psi\\right)^*\\right]\\\\\n= &amp;\\int\n_{-\\infty}^{+\\infty}\\varphi\\left[\\left(\\hat{A}\\hat{B}+\\hat{B}\\hat{A}\\right)\n\\Psi\\right]^*\\,\\mathrm{d}x\n\\end{aligned}\n$$</span></p>\n<ul>\n<li>如果 <span class=\"math inline\"><em>Â</em></span> 和 <span\nclass=\"math inline\"><em>B̂</em></span> 都是厄米算符，则 <span\nclass=\"math inline\"><em>i</em>(<em>Â</em><em>B̂</em> − <em>B̂</em><em>Â</em>)</span>\n也是厄米算符</li>\n</ul>\n<h5 id=\"厄米算符的性质\">厄米算符的性质</h5>\n<ol type=\"1\">\n<li>对于系统的任何量子态，其厄米算符的平均值 <span\nclass=\"math inline\"><em>F̄</em> = ∫<sub>−∞</sub><sup>+∞</sup><em>Ψ</em><sup>*</sup><em>F̂</em><em>Ψ</em> d<em>V</em></span>\n是实数</li>\n<li><strong>厄米算符的本征值是实数</strong>，所以量子力学中的任何力学算符都是厄米算符</li>\n<li><strong>厄米算符属于不同本征值的本征函数彼此正交</strong>\n<ul>\n<li><strong>厄米算符的本征函数是正交统一的完全集</strong></li>\n<li>任何物理上合理的波函数都可以用这个正交统一的完全集展开</li>\n</ul></li>\n</ol>\n<p><strong>证明：</strong></p>\n<ul>\n<li>平均值为实数</li>\n</ul>\n<p><span\nclass=\"math display\"><em>F̄</em> = ∫<sub>−∞</sub><sup>+∞</sup><em>Ψ</em><sup>*</sup><em>F̂</em><em>Ψ</em> d<em>V</em> = ∫<sub>−∞</sub><sup>+∞</sup>(<em>F̂</em><em>Ψ</em>)<sup>*</sup><em>Ψ</em> d<em>V</em> = (∫<sub>−∞</sub><sup>+∞</sup><em>Ψ</em><sup>*</sup><em>F̂</em><em>Ψ</em> d<em>V</em>)<sup>*</sup> = <em>F̄</em><sup>*</sup></span></p>\n<p>故 <span class=\"math inline\"><em>F̄</em></span> 是实数</p>\n<ul>\n<li><p>本征值是实数</p>\n<p>由厄米算符的定义</p></li>\n</ul>\n<p><span\nclass=\"math display\">∫<sub>−∞</sub><sup>+∞</sup><em>Ψ</em><sup>*</sup><em>F̂</em><em>Ψ</em><sub><em>n</em></sub> d<em>V</em> = ∫<sub>−∞</sub><sup>+∞</sup>(<em>F̂</em><em>Ψ</em>)<sup>*</sup><em>Ψ</em> d<em>V</em></span></p>\n<p>设 <span\nclass=\"math inline\"><em>F̂</em><em>Ψ</em> = <em>F</em><em>Ψ</em></span>，则</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n    \\int _{-\\infty} ^{+\\infty} \\Psi ^*F\\Psi\\mathrm{d}\\,V &amp;= \\int\n_{-\\infty}^{+\\infty} \\left(F\\Psi\\right)^* \\Psi\\,\\mathrm{d}V\\\\\n    \\Rightarrow F\\int _{-\\infty} ^{+\\infty} \\Psi ^*\\Psi\\mathrm{d}\\,V\n&amp;= F^*\\int _{-\\infty}^{+\\infty} \\Psi^* \\Psi\\,\\mathrm{d}V\n\\end{aligned}\n$$</span></p>\n<p>则 <span\nclass=\"math inline\"><em>F</em> = <em>F</em><sup>*</sup></span>，故本征值为实数</p>\n<ul>\n<li><p>属于不同本征值的本征函数正交</p>\n<p>由厄米算符的定义</p></li>\n</ul>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  \\int \\Psi _{m}^{*}\\hat{F} \\Psi _{n} \\, \\mathrm{d}V&amp;=\\int (\\hat{F}\n\\Psi _{m})^{*} \\Psi _{n} \\, \\mathrm{d} V\\\\\nF_{n}\\int \\Psi m^{*} \\Psi _{n}\\,\\mathrm{d} V&amp;=F_{m}^{*}\\int \\Psi\n_{m}^{*} \\Psi _{n} \\, \\mathrm{d} V\\\\\n( F_{n} -F_{m})\\int \\Psi _{m}^{*} \\Psi _{n} \\,\\mathrm{d} V&amp;=0\n\\end{aligned}\n$$</span></p>\n<p><span class=\"math inline\"><em>m</em> ≠ <em>n</em></span>，则 <span\nclass=\"math inline\">∫<em>Ψ</em><sub><em>m</em></sub><sup><em>n</em></sup><em>Ψ</em><sub><em>n</em></sub> d<em>V</em> = 1</span>，则\n<span\nclass=\"math inline\"><em>F</em><sub><em>n</em></sub> = <em>F</em><sub><em>m</em></sub></span></p>\n<p>这里有 <span class=\"math inline\">$\\displaystyle \\int \\Psi _m^*\\Psi _n\n\\, \\mathrm{d}V = \\delta _{nm} =\\begin{cases} 0 &amp;,n\\neq m\\\\ 1\n&amp;,n=m\\end{cases}$</span></p>\n<ul>\n<li><p>波函数可以用正交统一的完全集展开 <span\nclass=\"math inline\"><em>Ψ</em> = ∑<sub><em>n</em></sub><em>c</em><sub><em>n</em></sub><em>Ψ</em><sub><em>n</em></sub></span></p>\n<p>使用数学归纳法，假设当 <span class=\"math inline\"><em>n</em></span>\n时成立</p></li>\n</ul>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  &amp; \\Psi &amp;&amp;= \\sum _{n} c_n\\Psi _n \\\\\n  &amp; \\Psi _m^*\\Psi &amp;&amp;= \\sum _{n} c_n\\Psi _m^*\\Psi _n\\\\\n  &amp; \\int\\Psi _m^*\\Psi \\,\\mathrm{d}V &amp;&amp;= \\sum _{n} c_n\\int\n\\Psi _m^*\\Psi _n \\,\\mathrm{d}V \\\\\n  &amp;                                   &amp;&amp;= \\sum _n c_n \\delta\n_{mn}\\\\\n  &amp;                                  &amp;&amp;= c_m\\\\\n\\end{aligned}\n$$</span></p>\n<p>可以得到 <span\nclass=\"math inline\"><em>c</em><sub><em>m</em></sub> = ∫<em>Ψ</em><sub><em>m</em></sub><sup>*</sup><em>Ψ</em> d<em>V</em></span>\n，当 <span class=\"math inline\"><em>m</em></span> 时成立</p>\n<h3 id=\"测量假设\">测量假设</h3>\n<p>当一个量子系统处于量子态 <span class=\"math inline\"><em>Ψ</em></span>\n时，对力学量 <span class=\"math inline\"><em>F̂</em></span>\n的测量结果一定是该力学算符的本征值之一，结果为 <span\nclass=\"math inline\"><em>F</em><sub><em>n</em></sub></span> 的概率为\n<span\nclass=\"math inline\">|<em>c</em><sub><em>n</em></sub>|<sup>2</sup> = |∫<em>ϕ</em><sub><em>n</em></sub><sup>*</sup><em>Ψ</em> d<em>V</em>|<sup>2</sup></span></p>\n<p>这里 <span\nclass=\"math inline\"><em>F̂</em><em>φ</em><sub><em>n</em></sub> = <em>F</em><sub><em>n</em></sub><em>φ</em><sub><em>n</em></sub></span>\n是力学量 <span class=\"math inline\"><em>F̂</em></span>\n的本征方程，测量完成后，该量子系统坍缩至 <span\nclass=\"math inline\"><em>φ</em><sub><em>n</em></sub></span></p>\n<p><strong>结论</strong></p>\n<ul>\n<li>根据测量假设，当一个量子系统处在量子态 <span\nclass=\"math inline\"><em>Ψ</em></span> 时，对力学量 <span\nclass=\"math inline\"><em>F̂</em></span> 的测量结果的统计平均值为</li>\n</ul>\n<p><span class=\"math display\">$$\n\\bar{F} = \\sum _n F_n \\left\\vert c_n \\right\\vert ^2 = \\sum _n F_n\n\\left\\vert \\int\\phi_n^*\\Psi\\,\\mathrm{d}V\\right\\vert ^2 =\\boxed{\\int\n\\Psi^* \\hat{F} \\Psi\\,\\mathrm{d}V}\n$$</span></p>\n<p><strong>证明：</strong></p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n   &amp;\\int \\Psi ^* \\hat{F} \\Psi \\mathrm{d}V\\\\\n   =&amp;\\int \\left(\\sum_m c_m\\Psi_m\\right)^*\\hat{F}\\left(\\sum_n\nc_n\\Psi_n\\right)\\mathrm{d}V\\\\\n   =&amp;\\int \\left(\\sum_m c_m\\Psi_m\\right)^*\\left(\\sum_n c_n\n\\hat{F}\\Psi_n\\right)\\mathrm{d}V\\\\\n   =&amp;\\int \\left(\\sum_m c_m\\Psi_m\\right)^*\\left(\\sum_n c_n\nF_n\\Psi_n\\right)\\mathrm{d}V\\\\\n   =&amp;\\sum_{mn}c_m c_n F_n \\int\n\\left(\\Psi_m^*\\Psi_n\\right)\\mathrm{d}V\\\\\n   =&amp;\\sum_{mn}c_m c_n F_n \\delta _{mn}\\\\\n   =&amp;\\sum_n\\left\\vert c_n \\right\\vert ^2 F_n\n\\end{aligned}\n$$</span></p>\n<ul>\n<li>测量假设推论：当一个量子系统处于量子态 <span\nclass=\"math inline\"><em>Ψ</em></span> 时，且满足 <span\nclass=\"math inline\">∑<sub><em>n</em></sub>|<em>c</em><sub><em>n</em></sub>|<sup>2</sup> = 1</span>\n时，对力学量的测量结果一定是该力学算符的本征值之一，测量结果为 <span\nclass=\"math inline\"><em>F</em><sub><em>n</em></sub></span> 的概率为\n<span\nclass=\"math inline\">|<em>c</em><sub><em>n</em></sub>|<sup>2</sup></span>，测量完成之后，该量子系统探索至\n<span class=\"math inline\"><em>ϕ</em><sub><em>n</em></sub></span></li>\n</ul>\n<h4 id=\"动量本征方程\">动量本征方程</h4>\n<p><span\nclass=\"math display\">−<em>i</em>ℏ∇<em>Φ</em><sub><strong>r</strong></sub>(<strong>r</strong>) = <em>p̂</em><em>Φ</em><sub><strong>r</strong></sub>(<strong>r</strong>) = <em>p</em><em>Φ</em><sub><strong>r</strong></sub>(<strong>r</strong>)</span></p>\n<p>其在三个坐标轴上的分量为</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{r}}}{\\partial x} = p_x\\Phi\n_{\\boldsymbol{r}}\\\\\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{r}}}{\\partial y} = p_y\\Phi\n_{\\boldsymbol{r}}\\\\\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{r}}}{\\partial z} = p_z\\Phi\n_{\\boldsymbol{r}}\n\\end{cases}\n$$</span></p>\n<p>其解为</p>\n<p><span class=\"math display\">$$\n\\Phi _{\\boldsymbol{p}}(\\boldsymbol{r}) =\n\\frac{1}{(2\\pi\\hbar)^\\frac{3}{2}}e^{\\frac{i}{\\hbar}\\boldsymbol{p}\\cdot\n\\boldsymbol{r}}\n$$</span></p>\n<p>测量结果为 <span class=\"math inline\"><em>p</em></span>\n的概率密度为</p>\n<p><span class=\"math display\">$$\n\\vert c_p \\vert^2 = \\left\\vert \\int\n\\Phi_p^*\\Psi\\,\\mathrm{d}v\\right\\vert^2 = \\left\\vert \\int\n\\frac{1}{(2\\pi\\hbar)^\\frac{3}{2}}e^{-\\frac{i}{\\hbar}\\boldsymbol{p}\\cdot\n\\boldsymbol{r}}\\Psi\\,\\mathrm{d}v\\right\\vert^2\n$$</span></p>\n<p>统计平均值为</p>\n<p><span\nclass=\"math display\"><em>p̄</em> = ∑<sub><em>n</em></sub><em>p</em><sub><em>i</em></sub>|<em>c</em><sub><em>p</em><sub><em>i</em></sub></sub>|<sup>2</sup></span></p>\n<h4 id=\"动能本征方程\">动能本征方程</h4>\n<p><span\nclass=\"math display\">−<em>i</em>ℏ∇<em>Φ</em><sub><strong>p</strong></sub>(<strong>r</strong>) = <em>p̂</em><em>Φ</em><sub><strong>p</strong></sub>(<strong>r</strong>)</span></p>\n<p>其在三个坐标轴的分量为</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{p}}}{\\partial x} = p_x\\Phi\n_{\\boldsymbol{p}}\\\\\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{p}}}{\\partial y} = p_y\\Phi\n_{\\boldsymbol{p}}\\\\\n  -i\\hbar \\frac{\\partial \\Phi _{\\boldsymbol{p}}}{\\partial z} = p_z\\Phi\n_{\\boldsymbol{p}}\n\\end{cases}\n$$</span></p>\n<p>记动能算符为 <span class=\"math inline\"><em>T̂</em></span></p>\n<p><span class=\"math display\">$$\n\\hat{T}\\Phi _{\\boldsymbol{p}}(\\boldsymbol{r}) =\n-\\frac{\\hbar^2}{2m}\\nabla ^2\\Phi _{\\boldsymbol{p}}(\\boldsymbol{r})=\n\\frac{\\hat{p}^2}{2m}\\Phi _{\\boldsymbol{p}}(\\boldsymbol{r})\n$$</span></p>\n<p>所以<strong>动量的本征函数等于动能的本征函数</strong></p>\n<p>同样当一个量子系统处于量子态 <span\nclass=\"math inline\"><em>Ψ</em></span> 时，测量动能为 <span\nclass=\"math inline\">$\\frac{p^2}{2m}$</span> 的概率为</p>\n<p><span class=\"math display\">$$\n\\vert c_{\\frac{p^2}{2m}} \\vert^2 = \\left\\vert \\int\n\\Phi_{\\frac{p^2}{2m}}^*\\Psi\\,\\mathrm{d}v\\right\\vert^2 = \\left\\vert \\int\n\\frac{1}{(2\\pi\\hbar)^\\frac{3}{2}}e^{-\\frac{i}{\\hbar}\\boldsymbol{p}\\cdot\n\\boldsymbol{r}}\\Psi\\,\\mathrm{d}v\\right\\vert^2\n$$</span></p>\n<p>统计平均值为</p>\n<p><span class=\"math display\">$$\n\\bar{\\frac{p^2}{2m}} = \\sum_{n} \\frac{p_i^2}{2m}\\vert\nc_{\\frac{p_i^2}{2m}} \\vert ^2\n$$</span></p>\n<h3 id=\"态叠加原理\">态叠加原理</h3>\n<p>如果 <span\nclass=\"math inline\"><em>Ψ</em><sub>1</sub>, <em>Ψ</em><sub>2</sub>…</span>\n是体系的一系列可能的状，则 <span class=\"math inline\">$\\displaystyle\\Psi\n= \\sum _i ^n c_n\\Psi_n$</span> 也是体系的一个可能的状态。对于处于 <span\nclass=\"math inline\"><em>Ψ</em></span> 态的体系，该体系分别部分地处在\n<span\nclass=\"math inline\"><em>Ψ</em><sub>1</sub>, <em>Ψ</em><sub>2</sub>…<em>Ψ</em><sub><em>n</em></sub>…</span>\n态中</p>\n<h3 id=\"薛定谔方程-1\">薛定谔方程</h3>\n<p>波函数随时间演化满足<strong>薛定谔方程</strong></p>\n<p><span class=\"math display\">$$\n\\boxed{i\\hbar \\frac{\\partial \\Psi (\\boldsymbol{r},t)}{\\partial t} =\n\\hat{H} \\Psi (\\boldsymbol{r},t)}\n$$</span></p>\n<h4 id=\"定态问题-1\">定态问题</h4>\n<p>若粒子处于稳定的势场中，则势能函数 <span\nclass=\"math inline\"><em>U</em></span>\n与时间无关，称这类问题为定态问题</p>\n<p><span class=\"math display\">$$\n\\Psi(\\boldsymbol{r} , t) = \\Phi(\\boldsymbol{r})e^{-i\\frac{1}{\\hbar}Et}\n$$</span></p>\n<p><span class=\"math display\">$$\n\\left[ -\\frac{\\hbar^2}{2m}\\nabla^2   + U(\\boldsymbol{r})\\right]\n\\Phi(\\boldsymbol{r}) = E\\Phi(\\boldsymbol{r})\n$$</span></p>\n<p>也称为哈密顿算符的本征方程</p>\n<h3 id=\"同类粒子的不可分辨性原理\">同类粒子的不可分辨性原理</h3>\n<p>在量子力学中，内禀属行完全相同的粒子是<strong>不可分辨</strong>的，对任意这两个粒子进行交换，不会改变系统的状态</p>\n<p>经典力学中，能够得到粒子的运动方程和轨道方程 <span\nclass=\"math inline\"><em>r⃗</em> = <em>r⃗</em>(<em>t</em>)</span>，然而在量子力学中，只能得到粒子在空间中分布的概率密度\n<span\nclass=\"math inline\"><em>ρ</em> = |<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup></span>，而不能得到粒子在空间中的轨道方程，因此得不到粒子的轨道方程</p>\n<p>对于内禀性相同的粒子，因为没有轨道方程，所以无法分辨，对于任意的两个这样的粒子进行交换，不会改变系统的状态，即粒子在空间中出现的概率密度不会改变</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  &amp;&amp;\\left\\vert\\Psi(1,\\ldots , i , \\ldots , j \\ldots\nn)\\right\\vert &amp;= \\left\\vert\\Psi(1,\\ldots , j , \\ldots , i \\ldots\nn)\\right\\vert\\\\\n  \\Rightarrow&amp;&amp;\\Psi(1,\\ldots , i , \\ldots , j \\ldots n) &amp;=\ne^{i\\theta}\\Psi(1,\\ldots , j , \\ldots , i \\ldots n)\n\\end{aligned}\n$$</span></p>\n<p>实验表明，所有粒子可以分为两类</p>\n<ol type=\"1\">\n<li><strong>玻色子：</strong> <span\nclass=\"math inline\"><em>θ</em> = 0</span>，交换粒子后波函数不变</li>\n<li><strong>费米子：</strong> <span\nclass=\"math inline\"><em>θ</em> = <em>π</em></span>，交换粒子后波函数反对称</li>\n</ol>\n<h3 id=\"算符之间的对易关系\">算符之间的对易关系</h3>\n<p>两个算符 <span class=\"math inline\"><em>Â</em></span> 和 <span\nclass=\"math inline\"><em>B̂</em></span> 的对易子记为 <span\nclass=\"math inline\">[<em>Â</em>, <em>B̂</em>] = <em>Â</em><em>B̂</em> − <em>B̂</em><em>Â</em></span></p>\n<h4\nid=\"动量算符和坐标算符之间的对易关系\">动量算符和坐标算符之间的对易关系</h4>\n<p><span\nclass=\"math display\">[<em>x</em>, <em>p̂</em><sub><em>x</em></sub>] = −<em>i</em>ℏ</span></p>\n<p><strong>证明：</strong></p>\n<p>将 <span\nclass=\"math inline\">[<em>x</em>, <em>p̂</em><sub><em>x</em></sub>] = <em>x</em><em>p̂</em><sub><em>X</em></sub> − <em>p̂</em><sub><em>x</em></sub><em>x</em></span>\n作用于任意波函数 <span class=\"math inline\"><em>Ψ</em></span> 上</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  \\left[x,\\hat{p}_{x}\\right]\\Psi &amp;= \\left(x\\hat{p}_{x} - \\hat{p}_x\nx\\right)\\Psi\\\\\n  &amp;=-i\\hbar\\left(x\\frac{\\partial}{\\partial x} -\n\\frac{\\partial}{\\partial x}x\\right)\\Psi\\\\\n  &amp;=-i\\hbar\\left[x\\frac{\\partial \\Psi}{\\partial\nx}-\\frac{\\partial}{\\partial x}\\left(x\\Psi\\right)\\right]\\\\\n  &amp;=i\\hbar\\Psi\n\\end{aligned}\n$$</span></p>\n<p>故 <span\nclass=\"math inline\">[<em>x</em>, <em>p̂</em><sub><em>x</em></sub>] = −<em>i</em>ℏ</span></p>\n<h3 id=\"共同本征函数\">共同本征函数</h3>\n<h4 id=\"两个算符对易\">两个算符对易</h4>\n<p>如果两个算符 <span class=\"math inline\"><em>Â</em></span> 和 <span\nclass=\"math inline\"><em>B̂</em></span> 满足对易子为 <span\nclass=\"math inline\">0</span> ，即 <span\nclass=\"math inline\">[<em>Â</em>, <em>B̂</em>] = <em>Â</em><em>B̂</em> − <em>B̂</em><em>Â</em> = 0</span>，则称这两个算符<strong>对易</strong></p>\n<h4 id=\"对易的一个定理\">对易的一个定理</h4>\n<p>若两个力学量算符有一组共同完备的本征函数系，则二算符对易</p>\n<p><strong>证明：</strong></p>\n<p>假设</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\hat{F}\\varphi _n = F_n \\varphi _n\\\\\n  \\hat{G}\\varphi _n = G_n \\varphi _n\n\\end{cases}\n$$</span></p>\n<p><span class=\"math inline\"><em>φ</em></span> 组成完备系，则任意量子态\n<span class=\"math inline\"><em>Φ</em>(<em>x</em>)</span> 可以按其展开为\n<span\nclass=\"math inline\"><em>Φ</em>(<em>x</em>) = ∑<sub><em>n</em></sub><em>c</em><sub><em>i</em></sub><em>φ</em><sub><em>i</em></sub>(<em>x</em>)</span></p>\n<p>则</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  \\left(\\hat{F}\\hat{G}-\\hat{G}\\hat{F}\\right)\\Psi(x)\n  &amp;= \\left(\\hat{F}\\hat{G}-\\hat{G}\\hat{F}\\right)\\sum _n c_n \\varphi\n_n (x)\\\\\n  &amp;= \\sum _n c_n \\left(\\hat{F}\\hat{G}-\\hat{G}\\hat{F}\\right)\\varphi\n_n (x)\\\\\n  &amp;= \\sum _n c_n \\left(F_nG_n - G_nF_n\\right)\\varphi _n (x)\\\\\n  &amp; = 0\n\\end{aligned}\n$$</span></p>\n<p>由于 <span class=\"math inline\"><em>Ψ</em>(<em>x</em>)</span>\n是任意的函数，则 <span\nclass=\"math inline\"><em>F̂</em><em>Ĝ</em> = <em>Ĝ</em><em>F̂</em></span></p>\n<ul>\n<li><strong>其逆定理：</strong>\n若两个力学算符对易，则这两个算符有组成完备系的共同本征函数</li>\n</ul>\n<p><strong>证明：</strong></p>\n<p>已知 <span\nclass=\"math inline\"><em>F̂</em><em>Ĝ</em> = <em>Ĝ</em><em>F̂</em></span>，<span\nclass=\"math inline\"><em>F̂</em><em>ϕ</em><sub><em>n</em></sub> = <em>F</em><em>ϕ</em><sub><em>n</em></sub></span></p>\n<p><span\nclass=\"math display\"><em>F̂</em><em>Ĝ</em><em>φ</em><sub><em>n</em></sub> = <em>Ĝ</em><em>F̂</em><em>φ</em><sub><em>n</em></sub> = <em>F</em><em>Ĝ</em><em>φ</em><sub><em>n</em></sub></span></p>\n<p>即</p>\n<p><span\nclass=\"math display\"><em>F̂</em>(<em>Ĝ</em><em>φ</em><sub><em>n</em></sub>) = <em>F</em>(<em>Ĝ</em><em>φ</em><sub><em>n</em></sub>)</span></p>\n<p>说明 <span\nclass=\"math inline\"><em>Ĝ</em><em>φ</em><sub><em>n</em></sub></span>\n也是 <span class=\"math inline\"><em>F̂</em></span> 的本征函数，本征值为\n<span class=\"math inline\"><em>F</em></span> 故 <span\nclass=\"math inline\"><em>Ĝ</em><em>φ</em><sub><em>n</em></sub></span> 和\n<span class=\"math inline\"><em>φ</em><sub><em>n</em></sub></span>\n表示统一个量子态，<span\nclass=\"math inline\"><em>Ĝ</em><em>φ</em><sub><em>n</em></sub> = <em>G</em><em>φ</em></span></p>\n<h3 id=\"力学量完全集合\">力学量完全集合</h3>\n<ul>\n<li><strong>定义：</strong>能够完全确定状态的一组两两对易的力学量算符的最小（数目）集称为<strong>力学量完全集</strong></li>\n<li>力学量完全集中的力学量数目一般与体系自由度数相同</li>\n<li>由力学量的完全集所确定的本征函数系构成该体系态空间的一组完备的本征函数，即体系中的任何状态均可用它展开</li>\n</ul>\n<h3 id=\"角动量算符之间的对易关系\">角动量算符之间的对易关系</h3>\n<h4 id=\"角动量算符\">角动量算符</h4>\n<ul>\n<li><span\nclass=\"math inline\">[<em>L̂</em><sub><em>x</em></sub>, <em>L̂</em><sub><em>y</em></sub>] = <em>i</em>ℏ<em>L̂</em><sub><em>z</em></sub></span></li>\n<li><span\nclass=\"math inline\">[<em>L̂</em><sub><em>y</em></sub>, <em>L̂</em><sub><em>z</em></sub>] = <em>i</em>ℏ<em>L̂</em><sub><em>x</em></sub></span></li>\n<li><span\nclass=\"math inline\">[<em>L̂</em><sub><em>z</em></sub>, <em>L̂</em><sub><em>x</em></sub>] = <em>i</em>ℏ<em>L̂</em><sub><em>y</em></sub></span></li>\n</ul>\n<h4 id=\"角动量平方算符\">角动量平方算符</h4>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n\\hat{L} ^2 =\\hat{L} \\cdot \\hat{L} &amp;= \\hat{L}_x^2 + \\hat{L}_y^2 +\n\\hat{L}_z^2\\\\\n  &amp;= -\\hbar ^2 \\left[\n\\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial}{\\partial\\theta}\\right)+\\frac{1}{\\sin\\theta^2}\\frac{\\partial^2}{\\partial\n\\varphi^2}\\right]\n\\end{aligned}\n$$</span></p>\n<p><span\nclass=\"math display\">[<em>L̂</em><sup>2</sup>, <em>L̂</em><sub><em>x</em></sub>] = [<em>L̂</em><sup>2</sup>, <em>L̂</em><sub><em>y</em></sub>] = [<em>L̂</em><sup>2</sup>, <em>L̂</em><sub><em>z</em></sub>] = 0</span></p>\n<h5 id=\"角动量算符的本征方程\">角动量算符的本征方程</h5>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  &amp;&amp;-\\hbar ^2 \\left[\n\\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial}{\\partial\\theta}\\right)+\\frac{1}{\\sin^2\\theta}\\frac{\\partial^2}{\\partial\n\\varphi^2}\\right]Y &amp;= \\mu \\hbar ^2 Y\\\\\n  \\Rightarrow\n&amp;&amp;\\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial\nY}{\\partial\\theta}\\right)+\\frac{1}{\\sin^2\\theta}\\frac{\\partial^2}{\\partial\n\\varphi^2}Y +\\mu Y &amp;= 0\n\\end{aligned}\n$$</span></p>\n<p>令 <span\nclass=\"math inline\"><em>Y</em>(<em>θ</em>, <em>φ</em>) = <em>Θ</em>(<em>θ</em>)<em>f</em>(<em>φ</em>)</span>，得到</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  &amp;\\frac{sin\\theta}{\\Theta}\\frac{\\partial}{\\partial\n\\theta}\\left(\\sin\\theta\\frac{\\partial\\Theta}{\\partial \\theta }\\right) +\n\\mu\\sin^2\\theta = -\\frac{1}{f}\\frac{\\partial ^2 f}{\\partial\\varphi ^2} =\nconst = \\lambda\\\\\n  \\Rightarrow &amp;\n  \\begin{cases}\n    \\frac{1}{\\sin\\theta}\\frac{\\mathrm\nd}{\\mathrm{d}\\theta}\\left(\\sin\\theta\\frac{\\mathrm{d}\\Theta}{\\mathrm{d}\\theta}\\right)\n+\\left(\\mu -\\frac{\\lambda}{\\sin^2\\theta}\\right)\\Theta = 0\\\\\n    \\frac{\\mathrm{d}^2 f}{\\mathrm{d}\\varphi ^2} +\\lambda f = 0\n  \\end{cases}\n\\end{aligned}\n$$</span></p>\n<p>先处理关于 <span class=\"math inline\"><em>φ</em></span> 的方程</p>\n<p>令 <span\nclass=\"math inline\"><em>λ</em> = <em>m</em><sub><em>l</em></sub><sup>2</sup>, <em>m</em><sub><em>l</em></sub> = 0, ±1, ±2, …</span>，则</p>\n<p><span\nclass=\"math display\"><em>f</em>(<em>φ</em>) = <em>A</em>cos (<em>m</em><sub><em>l</em></sub><em>φ</em>) + <em>B</em>sin (<em>m</em><sub><em>l</em></sub><em>φ</em>)</span></p>\n<p>再处理关于 <span class=\"math inline\"><em>θ</em></span> 的方程</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  &amp;\\frac{1}{\\sin\\theta}\\frac{\\mathrm\nd}{\\mathrm{d}\\theta}\\left(\\sin\\theta\\frac{\\mathrm{d}\\Theta}{\\mathrm{d}\\theta}\\right)\n+\\left(\\mu -\\frac{\\lambda}{\\sin^2\\theta}\\right)\\Theta = 0\\\\\n  \\Rightarrow &amp; \\frac{1}{\\sin\\theta}\\frac{\\mathrm\nd}{\\mathrm{d}\\theta}\\left(\\sin\\theta\\frac{\\mathrm{d}\\Theta}{\\mathrm{d}\\theta}\\right)\n+\\left(\\mu -\\frac{m_l^2}{\\sin^2\\theta}\\right)\\Theta = 0\\\\\n\\end{aligned}\n$$</span></p>\n<p>令 <span\nclass=\"math inline\"><em>x</em> = cos <em>θ</em>, <em>y</em>(<em>x</em>) = <em>Θ</em>(<em>θ</em>)</span>，则</p>\n<p><span class=\"math display\">$$\n\\frac{1}{1-x^2}\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}\n-2x\\frac{\\mathrm{d}y}{\\mathrm{d}x}+ \\left(\\mu\n-\\frac{m_l^2}{1-x^2}\\right)y = 0 \\quad\\left(\\text{连带勒让德方程}\\right)\n$$</span></p>\n<ul>\n<li><strong>本征值：</strong><span\nclass=\"math inline\"><em>μ</em> = <em>l</em>(<em>l</em> + 1)</span>，<span\nclass=\"math inline\"><em>l</em> = 0, 1, 2, …</span></li>\n<li><span\nclass=\"math inline\"><em>Θ</em>(<em>θ</em>) = <em>P</em><sub><em>l</em></sub><sup><em>m</em></sup>(<em>θ</em>)</span></li>\n</ul>\n<p>则角动量平方算符的本征方程变为</p>\n<p><span class=\"math display\">$$\n\\hat{L}^2 Y_{l,m_l} = -\\hbar ^2\n\\left[\\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial}{\\partial\\theta}\\right)+\\frac{1}{\\sin^2\\theta}\\frac{\\partial^2}{\\partial\n\\varphi^2}\\right]Y_{l,m_l} = l(l+1)\\hbar ^2 Y_{l,m_l}\n$$</span></p>\n<p>其解为</p>\n<p><span class=\"math display\">$$\nY_{L,m_l}(\\theta , \\varphi) = (-1)^{m_l}\\sqrt{\\frac{(2l+1)(l-\\vert\nm_l\\vert)!}{4\\pi (l+\\vert\nm_l\\vert)!}}P_l^{m_l}(\\cos\\theta)e^{im_l\\varphi}\n$$</span></p>\n<p>其中 <span class=\"math inline\"><em>l</em> = 0, 1, 2, …</span> ，<span\nclass=\"math inline\"><em>m</em><sub><em>l</em></sub> = −<em>l</em>, −<em>l</em> + 1, …, <em>l</em></span>\n该函数同时也为角动量算符 <span\nclass=\"math inline\"><em>L̂</em><sub><em>z</em></sub></span>\n的本征函数</p>\n<h5 id=\"统计平均值\">统计平均值</h5>\n<p>当一个量子系统处于量子态 <span class=\"math inline\"><em>Ψ</em></span>\n时，且满足 <span class=\"math inline\">$\\displaystyle \\Psi\\left(\\theta ,\n\\varphi\\right) = \\sum_{l}\\sum_{m_l=-1}^l c_{l,m_l}Y_{l,m_l}\\left(\\theta\n, \\varphi\\right)$</span> ，<span class=\"math inline\">$\\sum_{l}\\sum_{m_l\n= -1}^l =\\left\\vert c_{l,l_m}\\right\\vert^2 = 1$</span> 时，对测量结果为\n<span class=\"math inline\"><em>l</em>(<em>l</em> + 1)ℏ<sup>2</sup></span>\n的概率为 <span\nclass=\"math inline\">|<em>c</em><sub><em>l</em>, <em>m</em><sub><em>l</em></sub></sub>|<sup>2</sup></span>，测量完成之后，该量子系统坍缩至\n<span\nclass=\"math inline\"><em>Y</em><sub><em>l</em>, <em>m</em><sub><em>l</em></sub></sub></span></p>\n<p>统计平均值为</p>\n<p><span class=\"math display\">$$\n\\bar{L}^2 = \\sum_{l}l(l+1)\\hbar ^2 \\sum_{m_l=-l}^{l} \\left\\vert\nc_{l,m_l}\\right\\vert^2\n$$</span></p>\n<p>对角动量 <span class=\"math inline\"><em>z</em></span>\n分量进行测量的结果一定是该力学量算符的本征值之一，测量结果为 <span\nclass=\"math inline\"><em>m</em><sub><em>l</em></sub>ℏ</span> 的概率为\n<span\nclass=\"math inline\">|<em>c</em><sub><em>l</em>, <em>m</em><sub><em>l</em></sub></sub>|<sup>2</sup></span>\n，测量完成之后，该量子系统坍缩至 <span\nclass=\"math inline\"><em>Y</em><sub><em>l</em>, <em>m</em><sub><em>l</em></sub></sub></span></p>\n<p>统计平均值为</p>\n<p><span class=\"math display\">$$\n\\bar{L}_z = \\sum_{l}  \\sum_{m_l=-l}^{l} m_l\\hbar\\left\\vert\nc_{l,m_l}\\right\\vert^2\n$$</span></p>\n<p>这里角动量平方算符和角动量算符的本征方程分别为</p>\n<p><span\nclass=\"math display\"><em>L̂</em><sup>2</sup><em>Y</em><sub><em>l</em>, <em>m</em><sub><em>l</em></sub></sub> = <em>l</em>(<em>l</em> + 1)ℏ<sup>2</sup><em>Y</em><sub><em>l</em>, <em>m</em><sub><em>l</em></sub></sub></span></p>\n<p><span\nclass=\"math display\"><em>L̂</em><sub><em>z</em></sub><em>Y</em><sub><em>l</em>, <em>m</em><sub><em>l</em></sub></sub> = <em>m</em><sub><em>l</em></sub>ℏ<em>Y</em><sub><em>l</em>, <em>m</em><sub><em>l</em></sub></sub></span></p>\n<h2 id=\"算符与电子自旋\">算符与电子自旋</h2>\n<h3\nid=\"未归一化的量子态下的算符平均值\">未归一化的量子态下的算符平均值</h3>\n<p><span class=\"math display\">$$\n\\bar{A} = \\frac{\\iiint\n\\Psi^*(x,y,z)\\hat{A}\\Psi(x,y,z)\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z}{\\iiint\n\\Psi^*(x,y,z)\\Psi(x,y,z)\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z}\n$$</span></p>\n<h3 id=\"线性算符\">线性算符</h3>\n<p>线性算符 <span class=\"math inline\"><em>F̂</em></span> 满足</p>\n<p><span\nclass=\"math display\"><em>F̂</em>(<em>a</em><em>Ψ</em><sub>1</sub> + <em>b</em><em>Ψ</em><sub>2</sub>) = <em>a</em><em>F̂</em><em>Ψ</em><sub>1</sub> + <em>b</em><em>F̂</em><em>Ψ</em><sub>2</sub></span></p>\n<p>位置算符 <span class=\"math inline\"><em>x̂</em> = <em>x</em></span>\n和动量算符 <span class=\"math inline\">$\\hat{p_x} =\n-i\\hbar\\frac{\\partial}{\\partial x}$</span> 均为线性算符</p>\n<p>由于态叠加原理，哈密顿算符 <span\nclass=\"math inline\"><em>Ĥ</em></span>\n也是线性算符，薛定谔方程是线性微分方程，则若 <span\nclass=\"math inline\"><em>Ψ</em><sub>1</sub></span> 和 <span\nclass=\"math inline\"><em>Ψ</em><sub>2</sub></span> 是薛定谔方程的解，则\n<span\nclass=\"math inline\"><em>c</em><sub>1</sub><em>Ψ</em><sub>1</sub> + <em>c</em><sub>2</sub><em>Ψ</em><sub>2</sub></span>\n也是薛定谔方程的解</p>\n<p>对于定态薛定谔方程也满足这个条件</p>\n<p>态叠加原理要求算符是线性的厄米算符</p>\n<h3 id=\"厄米算符\">厄米算符</h3>\n<h4 id=\"厄米算符的本征值是实数\">厄米算符的本征值是实数</h4>\n<h4 id=\"厄米算符的平均值是实数\">厄米算符的平均值是实数</h4>\n<h4 id=\"厄米算符本征值具有正交性\">厄米算符本征值具有正交性</h4>\n<p>当两个函数 <span\nclass=\"math inline\"><em>Ψ</em><sub><em>q</em></sub></span> 和 <span\nclass=\"math inline\"><em>Ψ</em><sub>2</sub></span> 满足下列关系</p>\n<p><span\nclass=\"math display\">∫<em>Ψ</em><sub>1</sub><sup>*</sup><em>Ψ</em><sub>2</sub> d<em>x</em> ≡ ∫⟨<em>Ψ</em><sub>1</sub>|<em>Ψ</em><sub>2</sub>⟩ = 0</span></p>\n<p>则我们称这两个函数相互正交，<span\nclass=\"math inline\">⟨<em>Ψ</em><sub>1</sub>|<em>Ψ</em><sub>2</sub>⟩</span>\n称为内积</p>\n<p>厄米算符两个不同本征值的本征函数总是正交的</p>\n<p><strong>证明：</strong></p>\n<p>（待补充 o_O）</p>\n<p>将这些正交的本征函数归一化，<span\nclass=\"math inline\">∫<em>Ψ</em><sub>1</sub><sup>*</sup><em>Ψ</em><sub>2</sub> d<em>x</em> = 1</span>，所以<strong>厄米算符</strong>有一组正交化的本征函数</p>\n<p><span class=\"math display\">$$\n\\int \\Psi_k^*\\Psi_l\\,\\mathrm{d}x =\\delta_{kl} =\n\\begin{cases}\n  0 &amp;,k\\neq l\\\\\n  1 &amp;,k=l\n\\end{cases}\n$$</span></p>\n<p>所以厄米算符的分立谱的所有本征函数都是正交归一化的</p>\n<h3 id=\"动量算符的厄米性\">动量算符的厄米性</h3>\n<p><strong>证明：</strong></p>\n<p>（待补充）</p>\n<h3 id=\"算符运算初步\">算符运算初步</h3>\n<h4 id=\"算符之和\">算符之和</h4>\n<p><span\nclass=\"math display\"><em>Â</em> + <em>B̂</em> = <em>Ĉ</em></span></p>\n<p><span\nclass=\"math display\"><em>Ĉ</em><em>Ψ</em> = (<em>Â</em> + <em>B̂</em>)<em>Ψ</em> = <em>Â</em><em>Ψ</em> + <em>B̂</em><em>Ψ</em></span></p>\n<h4 id=\"算符之积\">算符之积</h4>\n<p><span\nclass=\"math display\"><em>Â</em><em>B̂</em> = <em>Ĉ</em></span></p>\n<p><span\nclass=\"math display\"><em>Ĉ</em><em>Ψ</em> = <em>Â</em>(<em>B̂</em><em>Ψ</em>)</span></p>\n<p>一般情况下，算符之积<strong>不满足</strong>交换律，即</p>\n<p><span\nclass=\"math display\"><em>Â</em><em>B̂</em> ≠ <em>B̂</em><em>Â</em></span></p>\n<h4 id=\"算符的对易性\">算符的对易性</h4>\n<p>如果 <span\nclass=\"math inline\"><em>Â</em><em>B̂</em> = <em>B̂</em><em>Â</em></span>，则称\n<span class=\"math inline\"><em>Â</em></span> 和 <span\nclass=\"math inline\"><em>B̂</em></span> 是<strong>对易的</strong></p>\n<p>记为 <span\nclass=\"math inline\">[<em>Â</em>, <em>B̂</em>] ≡ <em>Â</em><em>B̂</em> − <em>B̂</em><em>Â</em> = 0</span>，称\n<span class=\"math inline\">[<em>Â</em>, <em>B̂</em>]</span> 为 <span\nclass=\"math inline\"><em>Â</em></span> 和 <span\nclass=\"math inline\"><em>B̂</em></span> 的<strong>对易子</strong></p>\n<h3 id=\"电子自旋\">电子自旋</h3>\n<h4 id=\"电子自旋角动量及其空间量子化\">电子自旋角动量及其空间量子化</h4>\n<h5 id=\"斯特恩-盖拉赫实验\">斯特恩-盖拉赫实验</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192235176.png\"\nalt=\"Stern-Garlach experiment\" />\n<figcaption aria-hidden=\"true\">Stern-Garlach experiment</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192240318.png\"\nalt=\"磁力线\" />\n<figcaption aria-hidden=\"true\">磁力线</figcaption>\n</figure>\n<p>磁铁的特殊形状使得磁极之间的磁力线不是均匀的，从而产生非匀强磁场</p>\n<p>在非匀强磁场之中，银原子和磁场的相互作用能为</p>\n<p><span\nclass=\"math display\"><em>W</em> = −<strong>M</strong> ⋅ <strong>B</strong></span></p>\n<p>对 <span class=\"math inline\"><em>z</em></span> 方向求微分</p>\n<p><span class=\"math display\">$$\nF_z = -\\frac{\\partial W}{\\partial z} = M_z \\frac{\\partial B}{\\partial z}\n$$</span></p>\n<p>实验结果为</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192317946.png\"\nalt=\"result\" />\n<figcaption aria-hidden=\"true\">result</figcaption>\n</figure>\n<p>加入磁场之后，银原子分裂为两束。银原子的角动量数 <span\nclass=\"math inline\"><em>l</em> = 0</span>，且最外层为 <span\nclass=\"math inline\"><em>s</em></span>\n电子，无轨道角动量，说明会银原子有自由度，且有两个取值</p>\n<h6 id=\"斯特恩-盖拉赫实验的意义\">斯特恩-盖拉赫实验的意义</h6>\n<ol type=\"1\">\n<li>证明了角动量空间量子化的存在\n<ul>\n<li>原子沉积层不是连续的一片，而是分开的线，说明了角动量空间量子化的存在</li>\n</ul></li>\n<li>发现了新的矛盾\n<ul>\n<li><span\nclass=\"math inline\"><em>l</em> = 0</span>，应当有一条沉积线，但是实验结果却又两条沉积线，这说明原来对原子中的电子运动的描述是不完全的</li>\n</ul></li>\n<li>提供了原子的“态分离”技术</li>\n</ol>\n<h6 id=\"理论解释\">理论解释</h6>\n<p>1925\n年乌伦贝克和古兹米特根据斯特恩-盖拉赫实验的结果，<strong>提出了电子不是指点，具有固有的自旋角动量\n<span class=\"math inline\"><strong>S</strong></span> 和相应的自旋磁矩\n<span\nclass=\"math inline\"><strong>μ</strong><sub><strong>s</strong></sub></span></strong>\n的观点</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192340149.png\"\nalt=\"电子自旋角动量和磁矩\" />\n<figcaption aria-hidden=\"true\">电子自旋角动量和磁矩</figcaption>\n</figure>\n<p>由于电子带负电，其自旋磁矩和根据右手螺旋定律得到的方向相反</p>\n<p>相对于外磁场方向，<span class=\"math inline\"><strong>B</strong></span>\n有朝上和朝下两种取向</p>\n<p>但是若将电子视为 <span\nclass=\"math inline\"><em>r</em> = 10<sup>−16</sup><em>m</em></span>\n的小球，按照 <span class=\"math inline\"><strong>S</strong> ∼ ℏ</span>\n估计得到的电子表面速度 <span\nclass=\"math inline\"> &gt; <em>c</em></span></p>\n<p>电子在任意一个方向测量其自旋角动量的结果都是 <span\nclass=\"math inline\">±ℏ</span></p>\n<h5 id=\"泡利不相容原理\">泡利不相容原理</h5>\n<ol type=\"1\">\n<li>费米子和玻色子\n<ol type=\"1\">\n<li><strong>费米子：</strong> 自旋量子数为半奇数的粒子</li>\n<li><strong>玻色子：</strong> 自旋量子数为整数的粒子</li>\n</ol></li>\n<li>泡利不相容原理\n<ul>\n<li>不能有两个电子具有相同的 <span\nclass=\"math inline\"><em>n</em>, <em>m</em>, <em>l</em>, <em>m</em><sub><em>l</em></sub>, <em>m</em><sub><em>s</em></sub></span></li>\n</ul></li>\n<li>玻色凝聚\n<ul>\n<li>玻色子不受泡利不相容原理的限制，一个单粒子态可容纳多个玻色子</li>\n</ul></li>\n</ol>\n<h5 id=\"电子的自旋算符和自旋波函数\">电子的自旋算符和自旋波函数</h5>\n<h6 id=\"自旋算符\">自旋算符</h6>\n<p>自旋角动量是纯量子概念，但也是一个力学量</p>\n<p>自旋角动量与电子的坐标和动量无关，是电子内部状态的表征，是描述电子状态的第四个自由度</p>\n<p>自旋算符记为 <span class=\"math inline\"><em>Ŝ</em></span></p>\n<ul>\n<li><span\nclass=\"math inline\">$\\hat{\\boldsymbol{S}}\\times\\hat{\\boldsymbol{S}}\n=i\\hbar\\hat{\\boldsymbol{S}}$</span></li>\n<li><span\nclass=\"math inline\">$[\\hat{\\boldsymbol{S}_x},\\hat{\\boldsymbol{S}}_y] =\ni\\hbar \\hat{\\boldsymbol{S}}_z$</span></li>\n<li><span\nclass=\"math inline\">$[\\hat{\\boldsymbol{S}}_y,\\hat{\\boldsymbol{S}}_z] =\ni\\hbar \\hat{\\boldsymbol{S}}_x$</span></li>\n<li><span\nclass=\"math inline\">$[\\hat{\\boldsymbol{S}}_z,\\hat{\\boldsymbol{S}}_x] =\ni\\hbar \\hat{\\boldsymbol{S}}_y$</span></li>\n</ul>\n<p>由于<strong>自旋角动量</strong>在空间任意方向上的投影都只能取 <span\nclass=\"math inline\">$\\pm\\frac{\\hbar}{2}$</span>，则 <span\nclass=\"math inline\">$\\hat{\\boldsymbol{S}}_x$</span>，<span\nclass=\"math inline\">$\\hat{\\boldsymbol{S}}_y$</span> 和 <span\nclass=\"math inline\">$\\hat{\\boldsymbol{S}}_z$</span> 的本征值都是 <span\nclass=\"math inline\">$\\pm\\frac{\\hbar}{2}$</span>，其平方为 <span\nclass=\"math inline\">$\\frac{\\hbar}{2}^2$</span></p>\n<h6 id=\"含自旋的状态波函数\">含自旋的状态波函数</h6>\n<p>电子的含自旋的波函数为</p>\n<p><span\nclass=\"math display\"><em>Ψ</em> = <em>Ψ</em>(<em>x</em>, <em>y</em>, <em>z</em>, <em>S</em><sub><em>z</em></sub>, <em>t</em>)</span></p>\n<p>由于 <span class=\"math inline\"><em>S</em><sub><em>z</em></sub></span>\n只有两个取值 <span\nclass=\"math inline\">$\\pm\\frac{\\hbar}{2}$</span>，所以可以写为两个分量</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\psi_1=\\psi(x,y,z,\\frac{\\hbar}{2},t)\\\\\n  \\psi_2=\\psi(x,y,z,-\\frac{\\hbar}{2},t)\n\\end{cases}\n$$</span></p>\n<p>写作列矩阵</p>\n<p><span class=\"math display\">$$\n\\Psi = \\begin{pmatrix}\n  \\psi_1(\\boldsymbol{r},t)\\\\\n  \\psi_2(\\boldsymbol{r},t)\n\\end{pmatrix}\n$$</span></p>\n<p>这里的正负号是规定好的</p>\n<p>若已知电子处于 <span class=\"math inline\">$S_z =\n\\frac{\\hbar}{2}$</span> 或 <span class=\"math inline\">$S_z =\n-\\frac{\\hbar}{2}$</span> 的状态，则其波函数分别可以写为：</p>\n<p><span class=\"math display\">$$\n\\Psi = \\begin{pmatrix}\n  \\psi_1(\\boldsymbol{r},t)\\\\\n  0\n\\end{pmatrix}\n\\qquad\n\\Psi = \\begin{pmatrix}\n  0\\\\\n  \\psi_2(\\boldsymbol{r},t)\n\\end{pmatrix}\n$$</span></p>\n<h6 id=\"自旋算符的矩阵表示pauli-矩阵\">自旋算符的矩阵表示，Pauli\n矩阵</h6>\n<p><strong><span\nclass=\"math inline\"><em>Ŝ</em><sub><em>z</em></sub></span>\n的矩阵形式</strong></p>\n<p><span class=\"math display\">$$\n\\hat{S}_z = \\frac{\\hbar}{2}\n\\begin{pmatrix}\n  1 &amp; 0\\\\\n  0 &amp; -1\n\\end{pmatrix}\n$$</span></p>\n<p><strong>Pauli 算符</strong></p>\n<p>对于 <span class=\"math inline\"><em>Ŝ</em><sub><em>z</em></sub></span>\n的矩阵形式，我们定义 Pauli 算符，使得</p>\n<p><span class=\"math display\">$$\n\\hat{S}_z = \\frac{\\hbar}{2}\\hat{\\sigma}\n$$</span></p>\n<p>从自旋算符与 Pauli 矩阵之间的关系，可以得到自旋算符的矩阵表示</p>\n<p><span class=\"math display\">$$\n\\hat{S}_x = \\frac{\\hbar}{2}\\begin{pmatrix}\n  0 &amp; 1\\\\\n  1 &amp; 0\n\\end{pmatrix}\n\\quad\n\\hat{S}_y = \\frac{\\hbar}{2}\\begin{pmatrix}\n  0 &amp; -i\\\\\n  i &amp; 0\n\\end{pmatrix}\n\\quad\n\\hat{S}_z = \\frac{\\hbar}{2}\\begin{pmatrix}\n  1 &amp; 0\\\\\n  0 &amp; -1\n\\end{pmatrix}\n$$</span></p>\n<h6 id=\"自旋波函数\">自旋波函数</h6>\n<p>波函数 <span class=\"math inline\">$\\Psi =\n\\begin{pmatrix}\\psi_1\\newline \\psi_2\\end{pmatrix}$</span>\n中，一般情况下，<span\nclass=\"math inline\"><em>Ψ</em><sub>1</sub> ≠ <em>Ψ</em><sub>2</sub></span>，两者对\n<span class=\"math inline\">(<em>x</em>, <em>y</em>, <em>z</em>)</span>\n的依赖是不相同的，因为自旋对轨道运动有一定的影响，但是当影响足够小时，可以忽略，此时认为\n<span class=\"math inline\"><em>Ψ</em><sub>1</sub></span> 和 <span\nclass=\"math inline\"><em>Ψ</em><sub>2</sub></span> 的函数形式相同，<span\nclass=\"math inline\"><em>Ψ</em></span> 可以写作如下的形式</p>\n<p><span\nclass=\"math display\"><em>Ψ</em>(<strong>r</strong>, <em>S</em><sub><em>z</em></sub>, <em>t</em>) = <em>ψ</em>(<strong>r</strong>, <em>t</em>)<em>χ</em>(<em>S</em><sub><em>z</em></sub>)</span></p>\n<p>其中 <span\nclass=\"math inline\"><em>χ</em>(<em>S</em><sub><em>z</em></sub>)</span>\n是 <span class=\"math inline\"><em>Ŝ</em><sub><em>z</em></sub></span>\n的本征函数，称为自旋波函数</p>\n<p><span class=\"math display\">$$\n\\chi_{\\frac{1}{2}}(S_z) = \\begin{pmatrix}\n  1\\\\\n  0\n\\end{pmatrix}\n\\quad\n\\chi_{-\\frac{1}{2}}(S_z) = \\begin{pmatrix}\n  0\\\\\n  1\n\\end{pmatrix}\n$$</span></p>\n<p>这两个自旋波函数相互正交</p>\n<h3 id=\"无限深势阱\">无限深势阱</h3>\n<h3 id=\"谐振子\">谐振子</h3>\n<h4 id=\"势能\">势能</h4>\n<p>若先择线性谐振子平衡位置为坐标原点和势能零点，则一维线性谐振子得到势能可以表示为</p>\n<p><span class=\"math display\">$$\nU(x) = \\frac{1}{2}kx^2 = \\frac{1}{2}m\\omega^2x^2\n$$</span></p>\n<h5 id=\"谐振子的定态薛定谔方程\">谐振子的定态薛定谔方程</h5>\n<p>一维谐振子的哈密顿量为</p>\n<p><span class=\"math display\">$$\n\\hat{H} = -\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} +\n\\frac{1}{2}m\\omega^2x^2\n$$</span></p>\n<p>满足的定态薛定谔方程为</p>\n<p><span class=\"math display\">$$\n\\left[-\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} +\n\\frac{1}{2}m\\omega^2x^2\\right]\\Phi(x) = E\\Phi(x)\n$$</span></p>\n<p>一维谐振子的能量是量子化的</p>\n"},{"title":"数理方法笔记","math":true,"_content":"\n## 几类偏微分方程的导出和定解问题\n\n### 弦振动、热传导、调和方程的导出，定解问题\n\n#### 弦振动方程\n\n一条弦固定在区间 $[0,L]$ 上，密度为 $\\rho$，在平衡处附近做微小的振动，记 $u(t,x)$ 为弦在时刻 $t$ 处于位置 $x$ 的位移，满足以下的微分方程\n\n$$\n\\begin{equation}\nu_{tt} -a^2u_{xx}=F(t,x), \\quad 0 < x < L, \\quad t > 0\n\\end{equation}\n$$\n\n其中 $a$ 为待定的弦的波速\n\n在弦振动方程中，若 $F\\equiv 0$，则称为其次方程，否则为非齐次方程\n\n##### 弦振动方程的证明\n\n任取一段弦 $[x,x+\\Delta x]$，这段弦的长度为\n\n$$\n\\Delta s = \\int_x^{x+\\Delta x}\\sqrt{1+\\left(\\frac{\\partial u}{\\partial x}\\right)^2}\\,\\mathrm{d}x.\n$$\n\n其中 $\\left\\vert\\frac{\\partial u}{\\partial x}\\right\\vert\\ll 1$，则 $\\Delta s \\approx \\Delta x$，则其弹力与时间无关，设为 $T(x)$\n\n我们分别在水平方向和竖直方向上对这段弦进行受力分析\n\n1. 水平方向上速度为 $0$，则其受力平衡\n\n   $$\n   T(x+\\Delta x)\\cos\\beta - T(x)\\cos\\alpha = 0\n   $$\n\n   其中 $\\alpha$ 和 $\\beta$ 分别为 $x$ 和 $x+\\Delta x$ 处的切线与水平线的夹角，由于假设弦在平衡位置附近做微小振动，则 $\\cos\\alpha \\approx 1$， $\\cos\\beta \\approx 1$，则可以得到弹力为恒定的，计为 $T$\n\n2. 在竖直方向( $u^-$ )上进行受力分析\n\n   $$\n   \\rho\\Delta s \\frac{\\partial^2u}{\\partial x^2}=T(\\sin\\beta - \\sin\\alpha) + F(t,x)\\Delta s\n   $$\n\n   其中 $\\displaystyle\\lim_{\\theta\\to 0}\\sin\\theta = \\lim_{\\theta\\to 0}\\tan\\theta$，再将 $\\Delta s = \\Delta x$ 代入上式，得到\n\n   $$\n   \\rho\\Delta x \\frac{\\partial^2u}{\\partial t^2}=T(\\frac{\\partial u}{\\partial x}(x+\\Delta x) - \\frac{\\partial u}{\\partial x}(x)) + F(t,x)\\Delta x\n   $$\n\n   再令 $\\Delta x \\to 0$，得到\n\n   $$\n   \\rho \\frac{\\partial^2u}{\\partial t^2} = T\\frac{\\partial^2u}{\\partial x^2} + F(t,x)\n   $$\n\n   我们令 $a^2 = \\frac{T}{\\rho},F(t,x)=\\frac{f(t,x)}{\\rho}$，则得到 $\\boxed{弦振动方程}$\n\n   $$\n   u_{tt} -a^2u_{xx}=F(t,x), \\quad 0 < x < L, \\quad t > 0\n   $$\n\n##### 弦振动方程的定解问题\n\n###### 初值条件\n\n当一条弦足够长并且需要研究远离两端的点的振动情况时，可以假设弦无限长\n\n$$\n\\left\\{\n    \\begin{aligned}\n        &u_{tt}-a^2u_{xx}=F(t,x),\\\\\n        &u(0,x)=\\varphi(x),\\\\\n        &u_t(0,x)=\\psi(x).\n    \\end{aligned}\n\\right.\n$$\n\n这三个条件分别表示了方程本身、初始位移和初始速度\n\n这个问题被称为弦振动方程的 **初值问题**或者 **Cauchy 问题**\n\n###### 边界条件\n\n当我们要考虑的弦在一个有限的区间 $I=[0,L]$ 上的振动情况时，需要给出边界条件，即弦在端点处的条件\n\n我们以一个端点 $x=a$ 为例，常见的边界条件有以下三种\n\n1. Dirichlet 边界条件：\n\n   $$\n   u(t,a)=\\varphi(t),\\forall t> 0\n   $$\n\n2. Neumann 边界条件：\n\n   $$\n   u_x(t,a)=\\mu(t),\\forall t> 0\n   $$\n\n   这表示了端点处的力。特别的，当 $\\mu(t)= 0$ 时，表示端点处没有力的作用，称为自由条件\n\n3. Robin 边界条件：\n\n   $$\n   \\begin{aligned}\n    &T\\frac{\\partial u}{\\partial x}(t,a)-ku(t,a)=0\\\\\n    \\Rightarrow &\\left(\\frac{\\partial u}{\\partial x}-\\sigma u\\right)|_{x=a}=0\n   \\end{aligned}\n   $$\n\n   其中 $\\sigma = \\frac{k}{T}$ 表示弦的一端与一线性弹簧连接\n\n   若弹簧为非线性的，则有\n\n   $$\n   \\left(\\frac{\\partial u}{\\partial x}-\\sigma (u)\\right)|_{x=a}=0\n   $$\n\n#### 热传导方程\n\n温度分布与时间的关系为热传导方程，同样的物质的浓度分布与时间的关系也满足热传导方程。\n\n物体的温度为 $u(t,x)$，则热传导方程为：\n\n$$\nu_t-a^2\\Delta u=\\tilde{f}\n$$\n\n其中 $\\displaystyle\\Delta=\\nabla^2=\\sum\\frac{\\partial^2}{\\partial {x_i}^2}$ 为 Laplace 算子\n\n##### 热传导方程的证明\n\n三维空间 $\\mathbb{R}^3$ 中的物体 $\\Omega$，设其温度分布函数为 $u(t,x_1,x_2,x_3)$，比热容均匀为 $c$\n\n我们取 $\\Omega$ 上的一个子区域 $D$，分析其在时间 $t_1$ 到 $t_2$ 之间的热量变化\n\n$D$ 上温度变化需要的热量为\n\n$$\nQ=\\int_D c\\rho(u(t_2,x_1,x_2,x_3)-u(t_1,x_1,x_2,x_3))\\,\\mathrm{d}V\n$$\n\n$Q$ 的来源有两个\n\n1. $D$ 的边界 $\\partial D$ 处流入的热量 $Q_1$\n2. $D$ 内部的热源提供的热量 $Q_2$\n\n热量的传导满足 Fourier 实验定律：对给定 $\\Omega$ 内的任意一个界面，从界面的一侧传导到另一侧的热量与温度沿该界面的法向的导数大小、界面的面积、传导的时间段成正比\n\n$$\n\\mathrm{d}Q=-k\\frac{\\partial u}{\\partial \\vec{n}}\\mathrm{d}s\\mathrm{d}t.\n$$\n\n则 $D$ 的边界 $\\partial D$ 处流入的热量 $Q_1$ 为\n\n$$\nQ_1=\\int_{t_1}^{t_2}\\int_{\\partial D}k\\frac{\\partial u}{\\partial \\vec{n}}\\,\\mathrm{d}S\\mathrm{d}t\n$$\n\n物体内部热源产热量 $Q_2$ 为\n\n$$\nQ_2=\\int_{t_1}^{t_2}\\int_D f(t,x_1,x_2,x_3)\\,\\mathrm{d}V\\mathrm{d}ts\n$$\n\n其中 $f(t,x_1,x_2,x_3)$ 为单位体积在单位时间内产生的热量\n\n在 $t_1$ 到 $t_2$ 之间，热量守恒定律告诉我们\n\n$$\nQ=Q_1+Q_2\n$$\n\n即\n\n$$\n\\int_D c\\rho(u(t_2,x_1,x_2,x_3)-u(t_1,x_1,x_2,x_3))\\,\\mathrm{d}V=\\int_{t_1}^{t_2}\\int_{\\partial D}k\\frac{\\partial u}{\\partial \\vec{n}}\\,\\mathrm{d}S\\mathrm{d}t+\\int_{t_1}^{t_2}\\int_D f(t,x_1,x_2,x_3)\\,\\mathrm{d}V\\mathrm{d}t\n$$\n\n变换得到\n\n$$\n\\int_{t_1}^{t_2}\\int_D c\\rho\\frac{\\partial u}{\\partial t}\\,\\mathrm{d}V\\mathrm{d}t=\\int_{t_1}^{t_2}\\int_{D}\\operatorname{div}(k\\cdot\\nabla u)\\,\\mathrm{d}V\\mathrm{d}t+\\int_{t_1}^{t_2}\\int_D f(t,x_1,x_2,x_3)\\,\\mathrm{d}V\\mathrm{d}t\n$$\n\n即\n\n$$\nc\\rho\\frac{\\partial u}{\\partial t}=k\\nabla^2 u+f(t,x_1,x_2,x_3)\n$$\n\n令 $a^2=\\frac{k}{c\\rho},\\tilde{f}=\\frac{f}{c\\rho}$，并用 Laplace 算子代替 $\\nabla^2$ 则得到热传导方程\n\n$$\nu_t-a^2\\Delta u=\\tilde{f}\n$$\n\n##### 热传导方程的定解问题\n\n###### 初值条件\n\n只需要给出初始的温度分布\n\n$$\nu(0,x_1,x_2,x_3)=\\varphi(x_1,x_2,x_3)\n$$\n\n###### 边界条件\n\n为了由热传导方程及其初值条件得到温度分布函数，还需要给定在边界 $\\partial\\Omega$ 上的边界条件\n\n1. Dirichlet 边界条件：\n\n   $$\n   u(t,x_1,x_2,x_3)|_{\\partial\\Omega}=\\varphi(t,x_1,x_2,x_3),\\forall t>0,x\\in\\partial\\Omega,\n   $$\n\n   这表明了边界上的温度变化情况\n\n2. Neumann 边界条件：\n\n   $$\n   \\frac{\\partial u}{\\partial \\vec{n}}(t,x_1,x_2,x_3)|_{\\partial\\Omega}=\\mu(t,x_1,x_2,x_3),\\forall t>0,x\\in\\partial\\Omega,\n   $$\n\n   这表明了边界上热量的传递情况\n\n   特别的，当 $\\mu(t,x_1,x_2,x_3)\\equiv 0$ 时，表示边界上没有热量传递，称为绝热条件\n\n3. Robin 边界条件：当物体处在一个温度为 $u_0$ 的介质中，物体与介质的热传导符合 Newton 交换律，物体 $\\Omega$ 在边界与介质交换的热流量与物体表面的温度 $u$ 与介质在物面的温度 $u_0$ 之差成正比，也与物面面积及交换的时间成正比，从物体表面流出的热量是\n\n   $$\n   \\mathrm{d}Q=-k_1(u-u_0)\\mathrm{d}s\\mathrm{d}t.\n   $$\n\n   在边界上流入的热量必须等于流出的热量，则\n\n   $$\n   -k\\frac{\\partial u}{\\partial \\vec{n}}=k_1(u-u_0)\n   $$\n\n   整理得到\n\n   $$\n   \\left(\\frac{\\partial u}{\\partial \\vec{n}}+\\sigma u\\right)\\vert_{\\partial \\Omega}=\\varphi(t,x_1,x_2,x_3)\n   $$\n\n#### 调和方程\n\n调和方程常用于描述保守力场中的势函数\n\n$$\n\\Delta u = \\phi\n$$\n\n当 $\\phi \\equiv 0$ 时，称为 Laplace 方程，否则称为 Poisson 方程\n\n##### 调和方程的证明\n\n###### Laplace 方程\n\n在空间 $\\mathbb{R}^3$ 中，有一物体 $D$，其密度为 $\\rho(x,y,z)$，在 $D$ 外有一点 $P(x,y,z)$ 有一单位质量的物体\n\n物体中质心在 $(\\varepsilon,\\eta,\\zeta)$ 的一微元对 $P$ 处物体的引力为\n\n$$\n\\mathrm{d}\\vec{F}=k\\int_D\\frac{\\rho}{r^2}\\,\\mathrm{d}\\varepsilon\\mathrm{d}\\eta\\mathrm{d}\\zeta\n$$\n\n但是不推导这个好像对最终结果没有什么影响，不管了\n\n引力势能为\n\n$$\nu(x,y,z)=int_D\\frac{\\rho}{r}\\,\\mathrm{d}\\varepsilon\\mathrm{d}\\eta\\mathrm{d}\\zeta\n$$\n\n则\n\n$$\n\\Delta u = \\Delta\\left(\\int_D\\frac{\\rho}{r}\\,\\mathrm{d}\\varepsilon\\mathrm{d}\\eta\\mathrm{d}\\zeta\\right) = \\int_D\\rho\\Delta\\left(\\frac{1}{r}\\right)\\,\\mathrm{d}\\varepsilon\\mathrm{d}\\eta\\mathrm{d}\\zeta= 0\n$$\n\n###### Poisson 方程\n\n我们考虑\n","source":"_posts/数理方法笔记.md","raw":"---\ntitle: 数理方法笔记\nmath: true\n---\n\n## 几类偏微分方程的导出和定解问题\n\n### 弦振动、热传导、调和方程的导出，定解问题\n\n#### 弦振动方程\n\n一条弦固定在区间 $[0,L]$ 上，密度为 $\\rho$，在平衡处附近做微小的振动，记 $u(t,x)$ 为弦在时刻 $t$ 处于位置 $x$ 的位移，满足以下的微分方程\n\n$$\n\\begin{equation}\nu_{tt} -a^2u_{xx}=F(t,x), \\quad 0 < x < L, \\quad t > 0\n\\end{equation}\n$$\n\n其中 $a$ 为待定的弦的波速\n\n在弦振动方程中，若 $F\\equiv 0$，则称为其次方程，否则为非齐次方程\n\n##### 弦振动方程的证明\n\n任取一段弦 $[x,x+\\Delta x]$，这段弦的长度为\n\n$$\n\\Delta s = \\int_x^{x+\\Delta x}\\sqrt{1+\\left(\\frac{\\partial u}{\\partial x}\\right)^2}\\,\\mathrm{d}x.\n$$\n\n其中 $\\left\\vert\\frac{\\partial u}{\\partial x}\\right\\vert\\ll 1$，则 $\\Delta s \\approx \\Delta x$，则其弹力与时间无关，设为 $T(x)$\n\n我们分别在水平方向和竖直方向上对这段弦进行受力分析\n\n1. 水平方向上速度为 $0$，则其受力平衡\n\n   $$\n   T(x+\\Delta x)\\cos\\beta - T(x)\\cos\\alpha = 0\n   $$\n\n   其中 $\\alpha$ 和 $\\beta$ 分别为 $x$ 和 $x+\\Delta x$ 处的切线与水平线的夹角，由于假设弦在平衡位置附近做微小振动，则 $\\cos\\alpha \\approx 1$， $\\cos\\beta \\approx 1$，则可以得到弹力为恒定的，计为 $T$\n\n2. 在竖直方向( $u^-$ )上进行受力分析\n\n   $$\n   \\rho\\Delta s \\frac{\\partial^2u}{\\partial x^2}=T(\\sin\\beta - \\sin\\alpha) + F(t,x)\\Delta s\n   $$\n\n   其中 $\\displaystyle\\lim_{\\theta\\to 0}\\sin\\theta = \\lim_{\\theta\\to 0}\\tan\\theta$，再将 $\\Delta s = \\Delta x$ 代入上式，得到\n\n   $$\n   \\rho\\Delta x \\frac{\\partial^2u}{\\partial t^2}=T(\\frac{\\partial u}{\\partial x}(x+\\Delta x) - \\frac{\\partial u}{\\partial x}(x)) + F(t,x)\\Delta x\n   $$\n\n   再令 $\\Delta x \\to 0$，得到\n\n   $$\n   \\rho \\frac{\\partial^2u}{\\partial t^2} = T\\frac{\\partial^2u}{\\partial x^2} + F(t,x)\n   $$\n\n   我们令 $a^2 = \\frac{T}{\\rho},F(t,x)=\\frac{f(t,x)}{\\rho}$，则得到 $\\boxed{弦振动方程}$\n\n   $$\n   u_{tt} -a^2u_{xx}=F(t,x), \\quad 0 < x < L, \\quad t > 0\n   $$\n\n##### 弦振动方程的定解问题\n\n###### 初值条件\n\n当一条弦足够长并且需要研究远离两端的点的振动情况时，可以假设弦无限长\n\n$$\n\\left\\{\n    \\begin{aligned}\n        &u_{tt}-a^2u_{xx}=F(t,x),\\\\\n        &u(0,x)=\\varphi(x),\\\\\n        &u_t(0,x)=\\psi(x).\n    \\end{aligned}\n\\right.\n$$\n\n这三个条件分别表示了方程本身、初始位移和初始速度\n\n这个问题被称为弦振动方程的 **初值问题**或者 **Cauchy 问题**\n\n###### 边界条件\n\n当我们要考虑的弦在一个有限的区间 $I=[0,L]$ 上的振动情况时，需要给出边界条件，即弦在端点处的条件\n\n我们以一个端点 $x=a$ 为例，常见的边界条件有以下三种\n\n1. Dirichlet 边界条件：\n\n   $$\n   u(t,a)=\\varphi(t),\\forall t> 0\n   $$\n\n2. Neumann 边界条件：\n\n   $$\n   u_x(t,a)=\\mu(t),\\forall t> 0\n   $$\n\n   这表示了端点处的力。特别的，当 $\\mu(t)= 0$ 时，表示端点处没有力的作用，称为自由条件\n\n3. Robin 边界条件：\n\n   $$\n   \\begin{aligned}\n    &T\\frac{\\partial u}{\\partial x}(t,a)-ku(t,a)=0\\\\\n    \\Rightarrow &\\left(\\frac{\\partial u}{\\partial x}-\\sigma u\\right)|_{x=a}=0\n   \\end{aligned}\n   $$\n\n   其中 $\\sigma = \\frac{k}{T}$ 表示弦的一端与一线性弹簧连接\n\n   若弹簧为非线性的，则有\n\n   $$\n   \\left(\\frac{\\partial u}{\\partial x}-\\sigma (u)\\right)|_{x=a}=0\n   $$\n\n#### 热传导方程\n\n温度分布与时间的关系为热传导方程，同样的物质的浓度分布与时间的关系也满足热传导方程。\n\n物体的温度为 $u(t,x)$，则热传导方程为：\n\n$$\nu_t-a^2\\Delta u=\\tilde{f}\n$$\n\n其中 $\\displaystyle\\Delta=\\nabla^2=\\sum\\frac{\\partial^2}{\\partial {x_i}^2}$ 为 Laplace 算子\n\n##### 热传导方程的证明\n\n三维空间 $\\mathbb{R}^3$ 中的物体 $\\Omega$，设其温度分布函数为 $u(t,x_1,x_2,x_3)$，比热容均匀为 $c$\n\n我们取 $\\Omega$ 上的一个子区域 $D$，分析其在时间 $t_1$ 到 $t_2$ 之间的热量变化\n\n$D$ 上温度变化需要的热量为\n\n$$\nQ=\\int_D c\\rho(u(t_2,x_1,x_2,x_3)-u(t_1,x_1,x_2,x_3))\\,\\mathrm{d}V\n$$\n\n$Q$ 的来源有两个\n\n1. $D$ 的边界 $\\partial D$ 处流入的热量 $Q_1$\n2. $D$ 内部的热源提供的热量 $Q_2$\n\n热量的传导满足 Fourier 实验定律：对给定 $\\Omega$ 内的任意一个界面，从界面的一侧传导到另一侧的热量与温度沿该界面的法向的导数大小、界面的面积、传导的时间段成正比\n\n$$\n\\mathrm{d}Q=-k\\frac{\\partial u}{\\partial \\vec{n}}\\mathrm{d}s\\mathrm{d}t.\n$$\n\n则 $D$ 的边界 $\\partial D$ 处流入的热量 $Q_1$ 为\n\n$$\nQ_1=\\int_{t_1}^{t_2}\\int_{\\partial D}k\\frac{\\partial u}{\\partial \\vec{n}}\\,\\mathrm{d}S\\mathrm{d}t\n$$\n\n物体内部热源产热量 $Q_2$ 为\n\n$$\nQ_2=\\int_{t_1}^{t_2}\\int_D f(t,x_1,x_2,x_3)\\,\\mathrm{d}V\\mathrm{d}ts\n$$\n\n其中 $f(t,x_1,x_2,x_3)$ 为单位体积在单位时间内产生的热量\n\n在 $t_1$ 到 $t_2$ 之间，热量守恒定律告诉我们\n\n$$\nQ=Q_1+Q_2\n$$\n\n即\n\n$$\n\\int_D c\\rho(u(t_2,x_1,x_2,x_3)-u(t_1,x_1,x_2,x_3))\\,\\mathrm{d}V=\\int_{t_1}^{t_2}\\int_{\\partial D}k\\frac{\\partial u}{\\partial \\vec{n}}\\,\\mathrm{d}S\\mathrm{d}t+\\int_{t_1}^{t_2}\\int_D f(t,x_1,x_2,x_3)\\,\\mathrm{d}V\\mathrm{d}t\n$$\n\n变换得到\n\n$$\n\\int_{t_1}^{t_2}\\int_D c\\rho\\frac{\\partial u}{\\partial t}\\,\\mathrm{d}V\\mathrm{d}t=\\int_{t_1}^{t_2}\\int_{D}\\operatorname{div}(k\\cdot\\nabla u)\\,\\mathrm{d}V\\mathrm{d}t+\\int_{t_1}^{t_2}\\int_D f(t,x_1,x_2,x_3)\\,\\mathrm{d}V\\mathrm{d}t\n$$\n\n即\n\n$$\nc\\rho\\frac{\\partial u}{\\partial t}=k\\nabla^2 u+f(t,x_1,x_2,x_3)\n$$\n\n令 $a^2=\\frac{k}{c\\rho},\\tilde{f}=\\frac{f}{c\\rho}$，并用 Laplace 算子代替 $\\nabla^2$ 则得到热传导方程\n\n$$\nu_t-a^2\\Delta u=\\tilde{f}\n$$\n\n##### 热传导方程的定解问题\n\n###### 初值条件\n\n只需要给出初始的温度分布\n\n$$\nu(0,x_1,x_2,x_3)=\\varphi(x_1,x_2,x_3)\n$$\n\n###### 边界条件\n\n为了由热传导方程及其初值条件得到温度分布函数，还需要给定在边界 $\\partial\\Omega$ 上的边界条件\n\n1. Dirichlet 边界条件：\n\n   $$\n   u(t,x_1,x_2,x_3)|_{\\partial\\Omega}=\\varphi(t,x_1,x_2,x_3),\\forall t>0,x\\in\\partial\\Omega,\n   $$\n\n   这表明了边界上的温度变化情况\n\n2. Neumann 边界条件：\n\n   $$\n   \\frac{\\partial u}{\\partial \\vec{n}}(t,x_1,x_2,x_3)|_{\\partial\\Omega}=\\mu(t,x_1,x_2,x_3),\\forall t>0,x\\in\\partial\\Omega,\n   $$\n\n   这表明了边界上热量的传递情况\n\n   特别的，当 $\\mu(t,x_1,x_2,x_3)\\equiv 0$ 时，表示边界上没有热量传递，称为绝热条件\n\n3. Robin 边界条件：当物体处在一个温度为 $u_0$ 的介质中，物体与介质的热传导符合 Newton 交换律，物体 $\\Omega$ 在边界与介质交换的热流量与物体表面的温度 $u$ 与介质在物面的温度 $u_0$ 之差成正比，也与物面面积及交换的时间成正比，从物体表面流出的热量是\n\n   $$\n   \\mathrm{d}Q=-k_1(u-u_0)\\mathrm{d}s\\mathrm{d}t.\n   $$\n\n   在边界上流入的热量必须等于流出的热量，则\n\n   $$\n   -k\\frac{\\partial u}{\\partial \\vec{n}}=k_1(u-u_0)\n   $$\n\n   整理得到\n\n   $$\n   \\left(\\frac{\\partial u}{\\partial \\vec{n}}+\\sigma u\\right)\\vert_{\\partial \\Omega}=\\varphi(t,x_1,x_2,x_3)\n   $$\n\n#### 调和方程\n\n调和方程常用于描述保守力场中的势函数\n\n$$\n\\Delta u = \\phi\n$$\n\n当 $\\phi \\equiv 0$ 时，称为 Laplace 方程，否则称为 Poisson 方程\n\n##### 调和方程的证明\n\n###### Laplace 方程\n\n在空间 $\\mathbb{R}^3$ 中，有一物体 $D$，其密度为 $\\rho(x,y,z)$，在 $D$ 外有一点 $P(x,y,z)$ 有一单位质量的物体\n\n物体中质心在 $(\\varepsilon,\\eta,\\zeta)$ 的一微元对 $P$ 处物体的引力为\n\n$$\n\\mathrm{d}\\vec{F}=k\\int_D\\frac{\\rho}{r^2}\\,\\mathrm{d}\\varepsilon\\mathrm{d}\\eta\\mathrm{d}\\zeta\n$$\n\n但是不推导这个好像对最终结果没有什么影响，不管了\n\n引力势能为\n\n$$\nu(x,y,z)=int_D\\frac{\\rho}{r}\\,\\mathrm{d}\\varepsilon\\mathrm{d}\\eta\\mathrm{d}\\zeta\n$$\n\n则\n\n$$\n\\Delta u = \\Delta\\left(\\int_D\\frac{\\rho}{r}\\,\\mathrm{d}\\varepsilon\\mathrm{d}\\eta\\mathrm{d}\\zeta\\right) = \\int_D\\rho\\Delta\\left(\\frac{1}{r}\\right)\\,\\mathrm{d}\\varepsilon\\mathrm{d}\\eta\\mathrm{d}\\zeta= 0\n$$\n\n###### Poisson 方程\n\n我们考虑\n","slug":"数理方法笔记","published":1,"date":"2025-09-11T11:36:20.596Z","updated":"2025-09-11T16:16:10.821Z","comments":1,"layout":"post","photos":[],"_id":"cmffo52nu000b6xzde2k60xpj","content":"<h2\nid=\"几类偏微分方程的导出和定解问题\">几类偏微分方程的导出和定解问题</h2>\n<h3\nid=\"弦振动热传导调和方程的导出定解问题\">弦振动、热传导、调和方程的导出，定解问题</h3>\n<h4 id=\"弦振动方程\">弦振动方程</h4>\n<p>一条弦固定在区间 <span class=\"math inline\">[0, <em>L</em>]</span>\n上，密度为 <span\nclass=\"math inline\"><em>ρ</em></span>，在平衡处附近做微小的振动，记\n<span class=\"math inline\"><em>u</em>(<em>t</em>, <em>x</em>)</span>\n为弦在时刻 <span class=\"math inline\"><em>t</em></span> 处于位置 <span\nclass=\"math inline\"><em>x</em></span> 的位移，满足以下的微分方程</p>\n<p><span\nclass=\"math display\"><em>u</em><sub><em>t</em><em>t</em></sub> − <em>a</em><sup>2</sup><em>u</em><sub><em>x</em><em>x</em></sub> = <em>F</em>(<em>t</em>, <em>x</em>),  0 &lt; <em>x</em> &lt; <em>L</em>,  <em>t</em> &gt; 0</span></p>\n<p>其中 <span class=\"math inline\"><em>a</em></span> 为待定的弦的波速</p>\n<p>在弦振动方程中，若 <span\nclass=\"math inline\"><em>F</em> ≡ 0</span>，则称为其次方程，否则为非齐次方程</p>\n<h5 id=\"弦振动方程的证明\">弦振动方程的证明</h5>\n<p>任取一段弦 <span\nclass=\"math inline\">[<em>x</em>, <em>x</em> + <em>Δ</em><em>x</em>]</span>，这段弦的长度为</p>\n<p><span class=\"math display\">$$\n\\Delta s = \\int_x^{x+\\Delta x}\\sqrt{1+\\left(\\frac{\\partial u}{\\partial\nx}\\right)^2}\\,\\mathrm{d}x.\n$$</span></p>\n<p>其中 <span class=\"math inline\">$\\left\\vert\\frac{\\partial u}{\\partial\nx}\\right\\vert\\ll 1$</span>，则 <span\nclass=\"math inline\"><em>Δ</em><em>s</em> ≈ <em>Δ</em><em>x</em></span>，则其弹力与时间无关，设为\n<span class=\"math inline\"><em>T</em>(<em>x</em>)</span></p>\n<p>我们分别在水平方向和竖直方向上对这段弦进行受力分析</p>\n<ol type=\"1\">\n<li><p>水平方向上速度为 <span\nclass=\"math inline\">0</span>，则其受力平衡</p>\n<p><span\nclass=\"math display\"><em>T</em>(<em>x</em> + <em>Δ</em><em>x</em>)cos <em>β</em> − <em>T</em>(<em>x</em>)cos <em>α</em> = 0</span></p>\n<p>其中 <span class=\"math inline\"><em>α</em></span> 和 <span\nclass=\"math inline\"><em>β</em></span> 分别为 <span\nclass=\"math inline\"><em>x</em></span> 和 <span\nclass=\"math inline\"><em>x</em> + <em>Δ</em><em>x</em></span>\n处的切线与水平线的夹角，由于假设弦在平衡位置附近做微小振动，则 <span\nclass=\"math inline\">cos <em>α</em> ≈ 1</span>， <span\nclass=\"math inline\">cos <em>β</em> ≈ 1</span>，则可以得到弹力为恒定的，计为\n<span class=\"math inline\"><em>T</em></span></p></li>\n<li><p>在竖直方向( <span\nclass=\"math inline\"><em>u</em><sup>−</sup></span> )上进行受力分析</p>\n<p><span class=\"math display\">$$\n\\rho\\Delta s \\frac{\\partial^2u}{\\partial x^2}=T(\\sin\\beta - \\sin\\alpha)\n+ F(t,x)\\Delta s\n$$</span></p>\n<p>其中 <span\nclass=\"math inline\">lim<sub><em>θ</em> → 0</sub>sin <em>θ</em> = lim<sub><em>θ</em> → 0</sub>tan <em>θ</em></span>，再将\n<span\nclass=\"math inline\"><em>Δ</em><em>s</em> = <em>Δ</em><em>x</em></span>\n代入上式，得到</p>\n<p><span class=\"math display\">$$\n\\rho\\Delta x \\frac{\\partial^2u}{\\partial t^2}=T(\\frac{\\partial\nu}{\\partial x}(x+\\Delta x) - \\frac{\\partial u}{\\partial x}(x)) +\nF(t,x)\\Delta x\n$$</span></p>\n<p>再令 <span\nclass=\"math inline\"><em>Δ</em><em>x</em> → 0</span>，得到</p>\n<p><span class=\"math display\">$$\n\\rho \\frac{\\partial^2u}{\\partial t^2} = T\\frac{\\partial^2u}{\\partial\nx^2} + F(t,x)\n$$</span></p>\n<p>我们令 <span class=\"math inline\">$a^2 =\n\\frac{T}{\\rho},F(t,x)=\\frac{f(t,x)}{\\rho}$</span>，则得到 <span\nclass=\"math inline\">$\\boxed{弦振动方程}$</span></p>\n<p><span\nclass=\"math display\"><em>u</em><sub><em>t</em><em>t</em></sub> − <em>a</em><sup>2</sup><em>u</em><sub><em>x</em><em>x</em></sub> = <em>F</em>(<em>t</em>, <em>x</em>),  0 &lt; <em>x</em> &lt; <em>L</em>,  <em>t</em> &gt; 0</span></p></li>\n</ol>\n<h5 id=\"弦振动方程的定解问题\">弦振动方程的定解问题</h5>\n<h6 id=\"初值条件\">初值条件</h6>\n<p>当一条弦足够长并且需要研究远离两端的点的振动情况时，可以假设弦无限长</p>\n<p><span class=\"math display\">$$\n\\left\\{\n    \\begin{aligned}\n        &amp;u_{tt}-a^2u_{xx}=F(t,x),\\\\\n        &amp;u(0,x)=\\varphi(x),\\\\\n        &amp;u_t(0,x)=\\psi(x).\n    \\end{aligned}\n\\right.\n$$</span></p>\n<p>这三个条件分别表示了方程本身、初始位移和初始速度</p>\n<p>这个问题被称为弦振动方程的 <strong>初值问题</strong>或者\n<strong>Cauchy 问题</strong></p>\n<h6 id=\"边界条件\">边界条件</h6>\n<p>当我们要考虑的弦在一个有限的区间 <span\nclass=\"math inline\"><em>I</em> = [0, <em>L</em>]</span>\n上的振动情况时，需要给出边界条件，即弦在端点处的条件</p>\n<p>我们以一个端点 <span\nclass=\"math inline\"><em>x</em> = <em>a</em></span>\n为例，常见的边界条件有以下三种</p>\n<ol type=\"1\">\n<li><p>Dirichlet 边界条件：</p>\n<p><span\nclass=\"math display\"><em>u</em>(<em>t</em>, <em>a</em>) = <em>φ</em>(<em>t</em>), ∀<em>t</em> &gt; 0</span></p></li>\n<li><p>Neumann 边界条件：</p>\n<p><span\nclass=\"math display\"><em>u</em><sub><em>x</em></sub>(<em>t</em>, <em>a</em>) = <em>μ</em>(<em>t</em>), ∀<em>t</em> &gt; 0</span></p>\n<p>这表示了端点处的力。特别的，当 <span\nclass=\"math inline\"><em>μ</em>(<em>t</em>) = 0</span>\n时，表示端点处没有力的作用，称为自由条件</p></li>\n<li><p>Robin 边界条件：</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n&amp;T\\frac{\\partial u}{\\partial x}(t,a)-ku(t,a)=0\\\\\n\\Rightarrow &amp;\\left(\\frac{\\partial u}{\\partial x}-\\sigma\nu\\right)|_{x=a}=0\n\\end{aligned}\n$$</span></p>\n<p>其中 <span class=\"math inline\">$\\sigma = \\frac{k}{T}$</span>\n表示弦的一端与一线性弹簧连接</p>\n<p>若弹簧为非线性的，则有</p>\n<p><span class=\"math display\">$$\n\\left(\\frac{\\partial u}{\\partial x}-\\sigma (u)\\right)|_{x=a}=0\n$$</span></p></li>\n</ol>\n<h4 id=\"热传导方程\">热传导方程</h4>\n<p>温度分布与时间的关系为热传导方程，同样的物质的浓度分布与时间的关系也满足热传导方程。</p>\n<p>物体的温度为 <span\nclass=\"math inline\"><em>u</em>(<em>t</em>, <em>x</em>)</span>，则热传导方程为：</p>\n<p><span\nclass=\"math display\"><em>u</em><sub><em>t</em></sub> − <em>a</em><sup>2</sup><em>Δ</em><em>u</em> = <em>f̃</em></span></p>\n<p>其中 <span\nclass=\"math inline\">$\\displaystyle\\Delta=\\nabla^2=\\sum\\frac{\\partial^2}{\\partial\n{x_i}^2}$</span> 为 Laplace 算子</p>\n<h5 id=\"热传导方程的证明\">热传导方程的证明</h5>\n<p>三维空间 <span class=\"math inline\">ℝ<sup>3</sup></span> 中的物体\n<span class=\"math inline\"><em>Ω</em></span>，设其温度分布函数为 <span\nclass=\"math inline\"><em>u</em>(<em>t</em>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>)</span>，比热容均匀为\n<span class=\"math inline\"><em>c</em></span></p>\n<p>我们取 <span class=\"math inline\"><em>Ω</em></span> 上的一个子区域\n<span class=\"math inline\"><em>D</em></span>，分析其在时间 <span\nclass=\"math inline\"><em>t</em><sub>1</sub></span> 到 <span\nclass=\"math inline\"><em>t</em><sub>2</sub></span> 之间的热量变化</p>\n<p><span class=\"math inline\"><em>D</em></span>\n上温度变化需要的热量为</p>\n<p><span\nclass=\"math display\"><em>Q</em> = ∫<sub><em>D</em></sub><em>c</em><em>ρ</em>(<em>u</em>(<em>t</em><sub>2</sub>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>) − <em>u</em>(<em>t</em><sub>1</sub>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>)) d<em>V</em></span></p>\n<p><span class=\"math inline\"><em>Q</em></span> 的来源有两个</p>\n<ol type=\"1\">\n<li><span class=\"math inline\"><em>D</em></span> 的边界 <span\nclass=\"math inline\">∂<em>D</em></span> 处流入的热量 <span\nclass=\"math inline\"><em>Q</em><sub>1</sub></span></li>\n<li><span class=\"math inline\"><em>D</em></span> 内部的热源提供的热量\n<span class=\"math inline\"><em>Q</em><sub>2</sub></span></li>\n</ol>\n<p>热量的传导满足 Fourier 实验定律：对给定 <span\nclass=\"math inline\"><em>Ω</em></span>\n内的任意一个界面，从界面的一侧传导到另一侧的热量与温度沿该界面的法向的导数大小、界面的面积、传导的时间段成正比</p>\n<p><span class=\"math display\">$$\n\\mathrm{d}Q=-k\\frac{\\partial u}{\\partial \\vec{n}}\\mathrm{d}s\\mathrm{d}t.\n$$</span></p>\n<p>则 <span class=\"math inline\"><em>D</em></span> 的边界 <span\nclass=\"math inline\">∂<em>D</em></span> 处流入的热量 <span\nclass=\"math inline\"><em>Q</em><sub>1</sub></span> 为</p>\n<p><span class=\"math display\">$$\nQ_1=\\int_{t_1}^{t_2}\\int_{\\partial D}k\\frac{\\partial u}{\\partial\n\\vec{n}}\\,\\mathrm{d}S\\mathrm{d}t\n$$</span></p>\n<p>物体内部热源产热量 <span\nclass=\"math inline\"><em>Q</em><sub>2</sub></span> 为</p>\n<p><span\nclass=\"math display\"><em>Q</em><sub>2</sub> = ∫<sub><em>t</em><sub>1</sub></sub><sup><em>t</em><sub>2</sub></sup>∫<sub><em>D</em></sub><em>f</em>(<em>t</em>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>) d<em>V</em>d<em>t</em><em>s</em></span></p>\n<p>其中 <span\nclass=\"math inline\"><em>f</em>(<em>t</em>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>)</span>\n为单位体积在单位时间内产生的热量</p>\n<p>在 <span class=\"math inline\"><em>t</em><sub>1</sub></span> 到 <span\nclass=\"math inline\"><em>t</em><sub>2</sub></span>\n之间，热量守恒定律告诉我们</p>\n<p><span\nclass=\"math display\"><em>Q</em> = <em>Q</em><sub>1</sub> + <em>Q</em><sub>2</sub></span></p>\n<p>即</p>\n<p><span class=\"math display\">$$\n\\int_D\nc\\rho(u(t_2,x_1,x_2,x_3)-u(t_1,x_1,x_2,x_3))\\,\\mathrm{d}V=\\int_{t_1}^{t_2}\\int_{\\partial\nD}k\\frac{\\partial u}{\\partial\n\\vec{n}}\\,\\mathrm{d}S\\mathrm{d}t+\\int_{t_1}^{t_2}\\int_D\nf(t,x_1,x_2,x_3)\\,\\mathrm{d}V\\mathrm{d}t\n$$</span></p>\n<p>变换得到</p>\n<p><span class=\"math display\">$$\n\\int_{t_1}^{t_2}\\int_D c\\rho\\frac{\\partial u}{\\partial\nt}\\,\\mathrm{d}V\\mathrm{d}t=\\int_{t_1}^{t_2}\\int_{D}\\operatorname{div}(k\\cdot\\nabla\nu)\\,\\mathrm{d}V\\mathrm{d}t+\\int_{t_1}^{t_2}\\int_D\nf(t,x_1,x_2,x_3)\\,\\mathrm{d}V\\mathrm{d}t\n$$</span></p>\n<p>即</p>\n<p><span class=\"math display\">$$\nc\\rho\\frac{\\partial u}{\\partial t}=k\\nabla^2 u+f(t,x_1,x_2,x_3)\n$$</span></p>\n<p>令 <span\nclass=\"math inline\">$a^2=\\frac{k}{c\\rho},\\tilde{f}=\\frac{f}{c\\rho}$</span>，并用\nLaplace 算子代替 <span class=\"math inline\">∇<sup>2</sup></span>\n则得到热传导方程</p>\n<p><span\nclass=\"math display\"><em>u</em><sub><em>t</em></sub> − <em>a</em><sup>2</sup><em>Δ</em><em>u</em> = <em>f̃</em></span></p>\n<h5 id=\"热传导方程的定解问题\">热传导方程的定解问题</h5>\n<h6 id=\"初值条件-1\">初值条件</h6>\n<p>只需要给出初始的温度分布</p>\n<p><span\nclass=\"math display\"><em>u</em>(0, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>) = <em>φ</em>(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>)</span></p>\n<h6 id=\"边界条件-1\">边界条件</h6>\n<p>为了由热传导方程及其初值条件得到温度分布函数，还需要给定在边界 <span\nclass=\"math inline\">∂<em>Ω</em></span> 上的边界条件</p>\n<ol type=\"1\">\n<li><p>Dirichlet 边界条件：</p>\n<p><span\nclass=\"math display\"><em>u</em>(<em>t</em>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>)|<sub>∂<em>Ω</em></sub> = <em>φ</em>(<em>t</em>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>), ∀<em>t</em> &gt; 0, <em>x</em> ∈ ∂<em>Ω</em>,</span></p>\n<p>这表明了边界上的温度变化情况</p></li>\n<li><p>Neumann 边界条件：</p>\n<p><span class=\"math display\">$$\n\\frac{\\partial u}{\\partial\n\\vec{n}}(t,x_1,x_2,x_3)|_{\\partial\\Omega}=\\mu(t,x_1,x_2,x_3),\\forall\nt&gt;0,x\\in\\partial\\Omega,\n$$</span></p>\n<p>这表明了边界上热量的传递情况</p>\n<p>特别的，当 <span\nclass=\"math inline\"><em>μ</em>(<em>t</em>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>) ≡ 0</span>\n时，表示边界上没有热量传递，称为绝热条件</p></li>\n<li><p>Robin 边界条件：当物体处在一个温度为 <span\nclass=\"math inline\"><em>u</em><sub>0</sub></span>\n的介质中，物体与介质的热传导符合 Newton 交换律，物体 <span\nclass=\"math inline\"><em>Ω</em></span>\n在边界与介质交换的热流量与物体表面的温度 <span\nclass=\"math inline\"><em>u</em></span> 与介质在物面的温度 <span\nclass=\"math inline\"><em>u</em><sub>0</sub></span>\n之差成正比，也与物面面积及交换的时间成正比，从物体表面流出的热量是</p>\n<p><span\nclass=\"math display\">d<em>Q</em> = −<em>k</em><sub>1</sub>(<em>u</em> − <em>u</em><sub>0</sub>)d<em>s</em>d<em>t</em>.</span></p>\n<p>在边界上流入的热量必须等于流出的热量，则</p>\n<p><span class=\"math display\">$$\n-k\\frac{\\partial u}{\\partial \\vec{n}}=k_1(u-u_0)\n$$</span></p>\n<p>整理得到</p>\n<p><span class=\"math display\">$$\n\\left(\\frac{\\partial u}{\\partial \\vec{n}}+\\sigma u\\right)\\vert_{\\partial\n\\Omega}=\\varphi(t,x_1,x_2,x_3)\n$$</span></p></li>\n</ol>\n<h4 id=\"调和方程\">调和方程</h4>\n<p>调和方程常用于描述保守力场中的势函数</p>\n<p><span\nclass=\"math display\"><em>Δ</em><em>u</em> = <em>ϕ</em></span></p>\n<p>当 <span class=\"math inline\"><em>ϕ</em> ≡ 0</span> 时，称为 Laplace\n方程，否则称为 Poisson 方程</p>\n<h5 id=\"调和方程的证明\">调和方程的证明</h5>\n<h6 id=\"laplace-方程\">Laplace 方程</h6>\n<p>在空间 <span class=\"math inline\">ℝ<sup>3</sup></span> 中，有一物体\n<span class=\"math inline\"><em>D</em></span>，其密度为 <span\nclass=\"math inline\"><em>ρ</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>，在\n<span class=\"math inline\"><em>D</em></span> 外有一点 <span\nclass=\"math inline\"><em>P</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>\n有一单位质量的物体</p>\n<p>物体中质心在 <span\nclass=\"math inline\">(<em>ε</em>, <em>η</em>, <em>ζ</em>)</span>\n的一微元对 <span class=\"math inline\"><em>P</em></span>\n处物体的引力为</p>\n<p><span class=\"math display\">$$\n\\mathrm{d}\\vec{F}=k\\int_D\\frac{\\rho}{r^2}\\,\\mathrm{d}\\varepsilon\\mathrm{d}\\eta\\mathrm{d}\\zeta\n$$</span></p>\n<p>但是不推导这个好像对最终结果没有什么影响，不管了</p>\n<p>引力势能为</p>\n<p><span class=\"math display\">$$\nu(x,y,z)=int_D\\frac{\\rho}{r}\\,\\mathrm{d}\\varepsilon\\mathrm{d}\\eta\\mathrm{d}\\zeta\n$$</span></p>\n<p>则</p>\n<p><span class=\"math display\">$$\n\\Delta u =\n\\Delta\\left(\\int_D\\frac{\\rho}{r}\\,\\mathrm{d}\\varepsilon\\mathrm{d}\\eta\\mathrm{d}\\zeta\\right)\n=\n\\int_D\\rho\\Delta\\left(\\frac{1}{r}\\right)\\,\\mathrm{d}\\varepsilon\\mathrm{d}\\eta\\mathrm{d}\\zeta=\n0\n$$</span></p>\n<h6 id=\"poisson-方程\">Poisson 方程</h6>\n<p>我们考虑</p>\n","excerpt":"","more":"<h2\nid=\"几类偏微分方程的导出和定解问题\">几类偏微分方程的导出和定解问题</h2>\n<h3\nid=\"弦振动热传导调和方程的导出定解问题\">弦振动、热传导、调和方程的导出，定解问题</h3>\n<h4 id=\"弦振动方程\">弦振动方程</h4>\n<p>一条弦固定在区间 <span class=\"math inline\">[0, <em>L</em>]</span>\n上，密度为 <span\nclass=\"math inline\"><em>ρ</em></span>，在平衡处附近做微小的振动，记\n<span class=\"math inline\"><em>u</em>(<em>t</em>, <em>x</em>)</span>\n为弦在时刻 <span class=\"math inline\"><em>t</em></span> 处于位置 <span\nclass=\"math inline\"><em>x</em></span> 的位移，满足以下的微分方程</p>\n<p><span\nclass=\"math display\"><em>u</em><sub><em>t</em><em>t</em></sub> − <em>a</em><sup>2</sup><em>u</em><sub><em>x</em><em>x</em></sub> = <em>F</em>(<em>t</em>, <em>x</em>),  0 &lt; <em>x</em> &lt; <em>L</em>,  <em>t</em> &gt; 0</span></p>\n<p>其中 <span class=\"math inline\"><em>a</em></span> 为待定的弦的波速</p>\n<p>在弦振动方程中，若 <span\nclass=\"math inline\"><em>F</em> ≡ 0</span>，则称为其次方程，否则为非齐次方程</p>\n<h5 id=\"弦振动方程的证明\">弦振动方程的证明</h5>\n<p>任取一段弦 <span\nclass=\"math inline\">[<em>x</em>, <em>x</em> + <em>Δ</em><em>x</em>]</span>，这段弦的长度为</p>\n<p><span class=\"math display\">$$\n\\Delta s = \\int_x^{x+\\Delta x}\\sqrt{1+\\left(\\frac{\\partial u}{\\partial\nx}\\right)^2}\\,\\mathrm{d}x.\n$$</span></p>\n<p>其中 <span class=\"math inline\">$\\left\\vert\\frac{\\partial u}{\\partial\nx}\\right\\vert\\ll 1$</span>，则 <span\nclass=\"math inline\"><em>Δ</em><em>s</em> ≈ <em>Δ</em><em>x</em></span>，则其弹力与时间无关，设为\n<span class=\"math inline\"><em>T</em>(<em>x</em>)</span></p>\n<p>我们分别在水平方向和竖直方向上对这段弦进行受力分析</p>\n<ol type=\"1\">\n<li><p>水平方向上速度为 <span\nclass=\"math inline\">0</span>，则其受力平衡</p>\n<p><span\nclass=\"math display\"><em>T</em>(<em>x</em> + <em>Δ</em><em>x</em>)cos <em>β</em> − <em>T</em>(<em>x</em>)cos <em>α</em> = 0</span></p>\n<p>其中 <span class=\"math inline\"><em>α</em></span> 和 <span\nclass=\"math inline\"><em>β</em></span> 分别为 <span\nclass=\"math inline\"><em>x</em></span> 和 <span\nclass=\"math inline\"><em>x</em> + <em>Δ</em><em>x</em></span>\n处的切线与水平线的夹角，由于假设弦在平衡位置附近做微小振动，则 <span\nclass=\"math inline\">cos <em>α</em> ≈ 1</span>， <span\nclass=\"math inline\">cos <em>β</em> ≈ 1</span>，则可以得到弹力为恒定的，计为\n<span class=\"math inline\"><em>T</em></span></p></li>\n<li><p>在竖直方向( <span\nclass=\"math inline\"><em>u</em><sup>−</sup></span> )上进行受力分析</p>\n<p><span class=\"math display\">$$\n\\rho\\Delta s \\frac{\\partial^2u}{\\partial x^2}=T(\\sin\\beta - \\sin\\alpha)\n+ F(t,x)\\Delta s\n$$</span></p>\n<p>其中 <span\nclass=\"math inline\">lim<sub><em>θ</em> → 0</sub>sin <em>θ</em> = lim<sub><em>θ</em> → 0</sub>tan <em>θ</em></span>，再将\n<span\nclass=\"math inline\"><em>Δ</em><em>s</em> = <em>Δ</em><em>x</em></span>\n代入上式，得到</p>\n<p><span class=\"math display\">$$\n\\rho\\Delta x \\frac{\\partial^2u}{\\partial t^2}=T(\\frac{\\partial\nu}{\\partial x}(x+\\Delta x) - \\frac{\\partial u}{\\partial x}(x)) +\nF(t,x)\\Delta x\n$$</span></p>\n<p>再令 <span\nclass=\"math inline\"><em>Δ</em><em>x</em> → 0</span>，得到</p>\n<p><span class=\"math display\">$$\n\\rho \\frac{\\partial^2u}{\\partial t^2} = T\\frac{\\partial^2u}{\\partial\nx^2} + F(t,x)\n$$</span></p>\n<p>我们令 <span class=\"math inline\">$a^2 =\n\\frac{T}{\\rho},F(t,x)=\\frac{f(t,x)}{\\rho}$</span>，则得到 <span\nclass=\"math inline\">$\\boxed{弦振动方程}$</span></p>\n<p><span\nclass=\"math display\"><em>u</em><sub><em>t</em><em>t</em></sub> − <em>a</em><sup>2</sup><em>u</em><sub><em>x</em><em>x</em></sub> = <em>F</em>(<em>t</em>, <em>x</em>),  0 &lt; <em>x</em> &lt; <em>L</em>,  <em>t</em> &gt; 0</span></p></li>\n</ol>\n<h5 id=\"弦振动方程的定解问题\">弦振动方程的定解问题</h5>\n<h6 id=\"初值条件\">初值条件</h6>\n<p>当一条弦足够长并且需要研究远离两端的点的振动情况时，可以假设弦无限长</p>\n<p><span class=\"math display\">$$\n\\left\\{\n    \\begin{aligned}\n        &amp;u_{tt}-a^2u_{xx}=F(t,x),\\\\\n        &amp;u(0,x)=\\varphi(x),\\\\\n        &amp;u_t(0,x)=\\psi(x).\n    \\end{aligned}\n\\right.\n$$</span></p>\n<p>这三个条件分别表示了方程本身、初始位移和初始速度</p>\n<p>这个问题被称为弦振动方程的 <strong>初值问题</strong>或者\n<strong>Cauchy 问题</strong></p>\n<h6 id=\"边界条件\">边界条件</h6>\n<p>当我们要考虑的弦在一个有限的区间 <span\nclass=\"math inline\"><em>I</em> = [0, <em>L</em>]</span>\n上的振动情况时，需要给出边界条件，即弦在端点处的条件</p>\n<p>我们以一个端点 <span\nclass=\"math inline\"><em>x</em> = <em>a</em></span>\n为例，常见的边界条件有以下三种</p>\n<ol type=\"1\">\n<li><p>Dirichlet 边界条件：</p>\n<p><span\nclass=\"math display\"><em>u</em>(<em>t</em>, <em>a</em>) = <em>φ</em>(<em>t</em>), ∀<em>t</em> &gt; 0</span></p></li>\n<li><p>Neumann 边界条件：</p>\n<p><span\nclass=\"math display\"><em>u</em><sub><em>x</em></sub>(<em>t</em>, <em>a</em>) = <em>μ</em>(<em>t</em>), ∀<em>t</em> &gt; 0</span></p>\n<p>这表示了端点处的力。特别的，当 <span\nclass=\"math inline\"><em>μ</em>(<em>t</em>) = 0</span>\n时，表示端点处没有力的作用，称为自由条件</p></li>\n<li><p>Robin 边界条件：</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n&amp;T\\frac{\\partial u}{\\partial x}(t,a)-ku(t,a)=0\\\\\n\\Rightarrow &amp;\\left(\\frac{\\partial u}{\\partial x}-\\sigma\nu\\right)|_{x=a}=0\n\\end{aligned}\n$$</span></p>\n<p>其中 <span class=\"math inline\">$\\sigma = \\frac{k}{T}$</span>\n表示弦的一端与一线性弹簧连接</p>\n<p>若弹簧为非线性的，则有</p>\n<p><span class=\"math display\">$$\n\\left(\\frac{\\partial u}{\\partial x}-\\sigma (u)\\right)|_{x=a}=0\n$$</span></p></li>\n</ol>\n<h4 id=\"热传导方程\">热传导方程</h4>\n<p>温度分布与时间的关系为热传导方程，同样的物质的浓度分布与时间的关系也满足热传导方程。</p>\n<p>物体的温度为 <span\nclass=\"math inline\"><em>u</em>(<em>t</em>, <em>x</em>)</span>，则热传导方程为：</p>\n<p><span\nclass=\"math display\"><em>u</em><sub><em>t</em></sub> − <em>a</em><sup>2</sup><em>Δ</em><em>u</em> = <em>f̃</em></span></p>\n<p>其中 <span\nclass=\"math inline\">$\\displaystyle\\Delta=\\nabla^2=\\sum\\frac{\\partial^2}{\\partial\n{x_i}^2}$</span> 为 Laplace 算子</p>\n<h5 id=\"热传导方程的证明\">热传导方程的证明</h5>\n<p>三维空间 <span class=\"math inline\">ℝ<sup>3</sup></span> 中的物体\n<span class=\"math inline\"><em>Ω</em></span>，设其温度分布函数为 <span\nclass=\"math inline\"><em>u</em>(<em>t</em>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>)</span>，比热容均匀为\n<span class=\"math inline\"><em>c</em></span></p>\n<p>我们取 <span class=\"math inline\"><em>Ω</em></span> 上的一个子区域\n<span class=\"math inline\"><em>D</em></span>，分析其在时间 <span\nclass=\"math inline\"><em>t</em><sub>1</sub></span> 到 <span\nclass=\"math inline\"><em>t</em><sub>2</sub></span> 之间的热量变化</p>\n<p><span class=\"math inline\"><em>D</em></span>\n上温度变化需要的热量为</p>\n<p><span\nclass=\"math display\"><em>Q</em> = ∫<sub><em>D</em></sub><em>c</em><em>ρ</em>(<em>u</em>(<em>t</em><sub>2</sub>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>) − <em>u</em>(<em>t</em><sub>1</sub>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>)) d<em>V</em></span></p>\n<p><span class=\"math inline\"><em>Q</em></span> 的来源有两个</p>\n<ol type=\"1\">\n<li><span class=\"math inline\"><em>D</em></span> 的边界 <span\nclass=\"math inline\">∂<em>D</em></span> 处流入的热量 <span\nclass=\"math inline\"><em>Q</em><sub>1</sub></span></li>\n<li><span class=\"math inline\"><em>D</em></span> 内部的热源提供的热量\n<span class=\"math inline\"><em>Q</em><sub>2</sub></span></li>\n</ol>\n<p>热量的传导满足 Fourier 实验定律：对给定 <span\nclass=\"math inline\"><em>Ω</em></span>\n内的任意一个界面，从界面的一侧传导到另一侧的热量与温度沿该界面的法向的导数大小、界面的面积、传导的时间段成正比</p>\n<p><span class=\"math display\">$$\n\\mathrm{d}Q=-k\\frac{\\partial u}{\\partial \\vec{n}}\\mathrm{d}s\\mathrm{d}t.\n$$</span></p>\n<p>则 <span class=\"math inline\"><em>D</em></span> 的边界 <span\nclass=\"math inline\">∂<em>D</em></span> 处流入的热量 <span\nclass=\"math inline\"><em>Q</em><sub>1</sub></span> 为</p>\n<p><span class=\"math display\">$$\nQ_1=\\int_{t_1}^{t_2}\\int_{\\partial D}k\\frac{\\partial u}{\\partial\n\\vec{n}}\\,\\mathrm{d}S\\mathrm{d}t\n$$</span></p>\n<p>物体内部热源产热量 <span\nclass=\"math inline\"><em>Q</em><sub>2</sub></span> 为</p>\n<p><span\nclass=\"math display\"><em>Q</em><sub>2</sub> = ∫<sub><em>t</em><sub>1</sub></sub><sup><em>t</em><sub>2</sub></sup>∫<sub><em>D</em></sub><em>f</em>(<em>t</em>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>) d<em>V</em>d<em>t</em><em>s</em></span></p>\n<p>其中 <span\nclass=\"math inline\"><em>f</em>(<em>t</em>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>)</span>\n为单位体积在单位时间内产生的热量</p>\n<p>在 <span class=\"math inline\"><em>t</em><sub>1</sub></span> 到 <span\nclass=\"math inline\"><em>t</em><sub>2</sub></span>\n之间，热量守恒定律告诉我们</p>\n<p><span\nclass=\"math display\"><em>Q</em> = <em>Q</em><sub>1</sub> + <em>Q</em><sub>2</sub></span></p>\n<p>即</p>\n<p><span class=\"math display\">$$\n\\int_D\nc\\rho(u(t_2,x_1,x_2,x_3)-u(t_1,x_1,x_2,x_3))\\,\\mathrm{d}V=\\int_{t_1}^{t_2}\\int_{\\partial\nD}k\\frac{\\partial u}{\\partial\n\\vec{n}}\\,\\mathrm{d}S\\mathrm{d}t+\\int_{t_1}^{t_2}\\int_D\nf(t,x_1,x_2,x_3)\\,\\mathrm{d}V\\mathrm{d}t\n$$</span></p>\n<p>变换得到</p>\n<p><span class=\"math display\">$$\n\\int_{t_1}^{t_2}\\int_D c\\rho\\frac{\\partial u}{\\partial\nt}\\,\\mathrm{d}V\\mathrm{d}t=\\int_{t_1}^{t_2}\\int_{D}\\operatorname{div}(k\\cdot\\nabla\nu)\\,\\mathrm{d}V\\mathrm{d}t+\\int_{t_1}^{t_2}\\int_D\nf(t,x_1,x_2,x_3)\\,\\mathrm{d}V\\mathrm{d}t\n$$</span></p>\n<p>即</p>\n<p><span class=\"math display\">$$\nc\\rho\\frac{\\partial u}{\\partial t}=k\\nabla^2 u+f(t,x_1,x_2,x_3)\n$$</span></p>\n<p>令 <span\nclass=\"math inline\">$a^2=\\frac{k}{c\\rho},\\tilde{f}=\\frac{f}{c\\rho}$</span>，并用\nLaplace 算子代替 <span class=\"math inline\">∇<sup>2</sup></span>\n则得到热传导方程</p>\n<p><span\nclass=\"math display\"><em>u</em><sub><em>t</em></sub> − <em>a</em><sup>2</sup><em>Δ</em><em>u</em> = <em>f̃</em></span></p>\n<h5 id=\"热传导方程的定解问题\">热传导方程的定解问题</h5>\n<h6 id=\"初值条件-1\">初值条件</h6>\n<p>只需要给出初始的温度分布</p>\n<p><span\nclass=\"math display\"><em>u</em>(0, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>) = <em>φ</em>(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>)</span></p>\n<h6 id=\"边界条件-1\">边界条件</h6>\n<p>为了由热传导方程及其初值条件得到温度分布函数，还需要给定在边界 <span\nclass=\"math inline\">∂<em>Ω</em></span> 上的边界条件</p>\n<ol type=\"1\">\n<li><p>Dirichlet 边界条件：</p>\n<p><span\nclass=\"math display\"><em>u</em>(<em>t</em>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>)|<sub>∂<em>Ω</em></sub> = <em>φ</em>(<em>t</em>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>), ∀<em>t</em> &gt; 0, <em>x</em> ∈ ∂<em>Ω</em>,</span></p>\n<p>这表明了边界上的温度变化情况</p></li>\n<li><p>Neumann 边界条件：</p>\n<p><span class=\"math display\">$$\n\\frac{\\partial u}{\\partial\n\\vec{n}}(t,x_1,x_2,x_3)|_{\\partial\\Omega}=\\mu(t,x_1,x_2,x_3),\\forall\nt&gt;0,x\\in\\partial\\Omega,\n$$</span></p>\n<p>这表明了边界上热量的传递情况</p>\n<p>特别的，当 <span\nclass=\"math inline\"><em>μ</em>(<em>t</em>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>) ≡ 0</span>\n时，表示边界上没有热量传递，称为绝热条件</p></li>\n<li><p>Robin 边界条件：当物体处在一个温度为 <span\nclass=\"math inline\"><em>u</em><sub>0</sub></span>\n的介质中，物体与介质的热传导符合 Newton 交换律，物体 <span\nclass=\"math inline\"><em>Ω</em></span>\n在边界与介质交换的热流量与物体表面的温度 <span\nclass=\"math inline\"><em>u</em></span> 与介质在物面的温度 <span\nclass=\"math inline\"><em>u</em><sub>0</sub></span>\n之差成正比，也与物面面积及交换的时间成正比，从物体表面流出的热量是</p>\n<p><span\nclass=\"math display\">d<em>Q</em> = −<em>k</em><sub>1</sub>(<em>u</em> − <em>u</em><sub>0</sub>)d<em>s</em>d<em>t</em>.</span></p>\n<p>在边界上流入的热量必须等于流出的热量，则</p>\n<p><span class=\"math display\">$$\n-k\\frac{\\partial u}{\\partial \\vec{n}}=k_1(u-u_0)\n$$</span></p>\n<p>整理得到</p>\n<p><span class=\"math display\">$$\n\\left(\\frac{\\partial u}{\\partial \\vec{n}}+\\sigma u\\right)\\vert_{\\partial\n\\Omega}=\\varphi(t,x_1,x_2,x_3)\n$$</span></p></li>\n</ol>\n<h4 id=\"调和方程\">调和方程</h4>\n<p>调和方程常用于描述保守力场中的势函数</p>\n<p><span\nclass=\"math display\"><em>Δ</em><em>u</em> = <em>ϕ</em></span></p>\n<p>当 <span class=\"math inline\"><em>ϕ</em> ≡ 0</span> 时，称为 Laplace\n方程，否则称为 Poisson 方程</p>\n<h5 id=\"调和方程的证明\">调和方程的证明</h5>\n<h6 id=\"laplace-方程\">Laplace 方程</h6>\n<p>在空间 <span class=\"math inline\">ℝ<sup>3</sup></span> 中，有一物体\n<span class=\"math inline\"><em>D</em></span>，其密度为 <span\nclass=\"math inline\"><em>ρ</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>，在\n<span class=\"math inline\"><em>D</em></span> 外有一点 <span\nclass=\"math inline\"><em>P</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>\n有一单位质量的物体</p>\n<p>物体中质心在 <span\nclass=\"math inline\">(<em>ε</em>, <em>η</em>, <em>ζ</em>)</span>\n的一微元对 <span class=\"math inline\"><em>P</em></span>\n处物体的引力为</p>\n<p><span class=\"math display\">$$\n\\mathrm{d}\\vec{F}=k\\int_D\\frac{\\rho}{r^2}\\,\\mathrm{d}\\varepsilon\\mathrm{d}\\eta\\mathrm{d}\\zeta\n$$</span></p>\n<p>但是不推导这个好像对最终结果没有什么影响，不管了</p>\n<p>引力势能为</p>\n<p><span class=\"math display\">$$\nu(x,y,z)=int_D\\frac{\\rho}{r}\\,\\mathrm{d}\\varepsilon\\mathrm{d}\\eta\\mathrm{d}\\zeta\n$$</span></p>\n<p>则</p>\n<p><span class=\"math display\">$$\n\\Delta u =\n\\Delta\\left(\\int_D\\frac{\\rho}{r}\\,\\mathrm{d}\\varepsilon\\mathrm{d}\\eta\\mathrm{d}\\zeta\\right)\n=\n\\int_D\\rho\\Delta\\left(\\frac{1}{r}\\right)\\,\\mathrm{d}\\varepsilon\\mathrm{d}\\eta\\mathrm{d}\\zeta=\n0\n$$</span></p>\n<h6 id=\"poisson-方程\">Poisson 方程</h6>\n<p>我们考虑</p>\n"},{"title":"毛概","_content":"\n## 毛概是什么：马克思主义中国化时代化的历史进程和理论结果\n\n- 什么是马克思主义中国化时代化：\n  - 运用马克思主义的立场、观点和方法，观察时代、把握时代、引领时代，解决中国革命、建设、改革中的实际问题。\n  - 总结和提炼中国革命、建设、改革的实践经验并将其上升为理论，不断丰富和发展马克思主义的理论宝库，赋予马克思主义以新的时代内涵。\n  - 用中国人民喜闻乐见的民族语言来阐述马克思主义理论，使之成为具有中国特色，中国风格，中国气派的马克思主义\n- 1938 党的六届六中全会上，《论新阶段》的报告，标志着“马克思主义的中国化”这一命题的正式提出\n- 中共七大，刘少奇从理论上做出阐述\n- 内涵：马克思主义中国化时代化，就是立足*中国国情*和*时代特点*，坚持把马克思主义基本原理同中国*具体实际*相结合、同中华优秀*传统文化*相结合，深入研究和解决中国革命、建设、改革不同历史时期的实际问题，真正搞懂面临的时代课题，不断吸收新的时代内容，科学回答时代提出的重大理论和实践课题，创造新的理论成果。\n\n## 马克思主义中国化的理论成果\n\n- 毛泽东思想\n- 中国特色社会主义理论体系\n\n## 马克思主义中国化理论成果的精髓：实事求是\n\n## 理论\n\n### 新民主主义革命理论\n\n- 认清中国国情是解决中国革命问题的*基本前提*\n- 认清中国社会的性质，乃是认清一切革命问题的*基本的根据*\n\n#### 何以形成\n\n- 国情依据：近代中国是一个半殖民地半封建性质的社会\n  - 帝国主义列强进行政治，经济，文化的侵略，中国长期处于帝国主义国家的统治或半统治之下，没有完整的主权与国家的统一\n  - 前述侵略使得自给自足的封建经济基础解体，但封建制度的根基：地主阶级对农民的剥削仍然存在，而且同买办资本和高利贷资本的剥削结合在了一起。\n  - 主要矛盾：**帝国主义和中华民族的矛盾**（主要），封建主义和人民大众的矛盾\n  - 根本任务：推翻帝国主义，封建主义和官僚资本主义的统治，争取民族独立和人民解放\n- 时代背景\n  - 1917 年十月革命，建立了第一个无产阶级专政的政权\n  - 五四运动，中国无产阶级作为独立的政治力量成为革命的领导力量，马克思列宁主义逐步成为中国革命的指导思想，进入新民主主义革命阶段\n- 实践基础\n  - 旧民主主义革命的失败\n    - 旧式的农民战争\n    - 不触动封建根基的自强运动和改良主义\n    - 照搬西方资本主义的方案\n  - 包含对上述失败教训的深刻总结\n\n#### 基本内容\n\n- 提出\n  - 1939《中国革命和中国共产党》，第一次提出“新民主主义的革命”的概念\n  - 1948《在晋绥干部会议上的讲话》完整总结和概括了新民主主义革命总路线的内容\n- 总路线：**无产阶级领导的，人民大众的，反对帝国主义，封建主义和官僚资本主义的革命**\n  - 无产阶级的领导权是中国革命的中心问题，也是新民主主义革命理论的核心问题，也是新民主主义革命区别于旧民主主义革命的根本标志\n    - 与先进的生产方式相联系，没有私人占有的生产资料，富有组织纪律性\n    - 受“三座大山”的压迫\n    - 集中分布在少数大城市和大企业，利于组织团结\n    - 成员与农民间有天然的联系\n  - 革命的对象：分清敌友，是革命的*首要问题*\n    - 帝国主义（中国革命的首要对象）\n      - 近代中国贫困落后和一切灾难祸害的总根源\n      - 推翻帝国主义的压迫是中国走向独立和富强的前提\n    - 封建主义\n      - 帝国主义统治中国和封建军阀实行专制统治的社会基础，是中国经济现代化和政治民主化的主要障碍\n    - 官僚资本主义\n      - 对劳动人民 / 民族工商业的巧取豪夺，严重束缚了中国社会生产力的发展。\n  - 革命的任务\n    - 民族革命：对外推翻帝国主义的压迫\n    - 民主革命：对内推翻封建地主阶级和官僚资产阶级的压迫\n    - 相互区别，相互联系\n  - 革命的动力\n    - 无产阶级：中国革命*最基本的动力*，中国革命的领导力量\n    - 农民：中国革命的主力军，农民问题是中国革命的*基本问题*，**新民主主义革命实质上就是党领导下的农民革命，中国革命战争实质上就是党领导下的农民战争**\n    - 城市小资产阶级：无产阶级的可靠同盟者（广大知识分子，小商人，手工业者和自由职业者）\n    - 民族资产阶级：带有两面性的阶级，一方面受压迫，一方面政治经济上又有联系，表现出明显的动摇性\n- 纲领（总路线的展开）\n  - 政治纲领：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的，以工农联盟为基础的，_各革命阶级联合专政_（国体）的新民主主义的共和国。（不同于欧美，也不同于苏联）\n    - 革命的根本问题是政权问题\n    - 政体：民主集中制的人民代表大会制度\n  - 经济纲领：“两没收，一保护”\n    - 没收封建地主阶级的土地归农民所有（进行土地革命，耕者有其田，扫除封建的剥削关系，解放农村生产力）\n    - 没收官僚资本归新民主主义国家所有（建立具有社会主义性质的国营经济，使它居于领导地位，为建立新民主主义的国家政权实现向社会主义过渡奠定坚实的基础）\n    - 保护民族工商业（保护，推动民族资本主义经济的发展，使它在发展现代技术，发展社会生产力，满足人民生活需要方面发挥作用，但不能让它操纵国计民生）\n  - 文化纲领\n    - **“民族的”**：\n      - 内容上：反对帝国主义压迫，主张中华民族的尊严和独立\n      - 形式上：具有鲜明的民族风格，民族形式和民族特色\n    - **“科学的”**：\n      - 反对封建迷信，主张实事求是，客观真理，理论和实践的一致性\n      - 历史唯物主义的态度对待古今中外文化，发展民族新文化，提高民族自信\n    - **“大众的”**：\n      - 文化工作者要用革命文化教育和武装人民大众\n      - 以人民群众的实践作为创作的源泉\n      - 为人民大众服务\n- 道路：**农村包围城市，武装夺取政权**\n  - 成功原因\n    - 近代中国的社会性质，社会政治经济发展极端不平衡\n    - 广大农村深受反动统治阶级的多重压迫和剥削，革命愿望强烈\n    - 革命形势的变动\n    - 正式红军的存在\n    - 党的领导\n  - 土地革命：是中国革命的基本内容\n  - 农村革命根据地建设：是中国革命的战略阵地，进行武装斗争和土地革命的依托\n  - 武装斗争：中国革命的主要形式，是上述两者的有力保证\n- 基本经验：三大法宝：统一战线，武装斗争，党的建设\n  - 统一战线和武装斗争：针对敌人，是武器\n    - 统一战线：采取区别对待的方针，发展进步势力，争取中间势力，孤立顽固势力\n  - 党的建设：针对党自身，是掌握武器的人\n    - 思想建设放在首位\n    - 三大优良作风：理论联系实际，密切联系群众，批评与自我批评相结合\n\n#### 意义\n\n- 理论：极大地丰富了马克思主义的理论宝库，是马克思主义中国化时代化的重要理论成果，是对中国革命实际问题做出的分析和研究，是中国共产党集体智慧的结晶\n- 实践：在新民主主义革命理论的指导下，党团结带领人民完成了新民主主义革命，实现了民族独立和人民解放\n- 世界：极大改变了世界的政治格局，鼓舞了全世界人民争取解放，反对帝国主义斗争的信心，增强了世界人民争取和平的力量\n\n### 社会主义改造理论\n\n#### 过渡的依据\n\n- 新民主主义社会是一个过渡性的社会\n  - 中华人民共和国成立 $\\to$ 社会主义改造基本完成是我国从新民主主义到社会主义的过渡时期，性质是新民主主义社会\n  - 不是独立的社会形态，而是过渡性社会形态，由经济结构和社会主要矛盾决定\n  - 经济结构\n    - 社会主义性质的国营经济\n    - 半社会主义性质的合作社经济（个体 $\\to$ 国营）\n    - 农民和手工业者的个体经济\n    - 私人资本主义经济\n    - 国家资本主义经济（私人 $\\to$ 国营）\n  - 阶级构成\n    - 社会主义 $\\leftrightarrow$ 工人阶级\n    - 个体经济 $\\leftrightarrow$ 农民阶级和其他小资产阶级\n    - 资本主义经济 $\\leftrightarrow$ 民族资产阶级\n  - 主要矛盾\n    - 社会主义 $\\leftrightarrow$ 资本主义\n    - 工人阶级 $\\leftrightarrow$ 资产阶级\n- 理论依据\n  - 马克思 / 恩格斯：科学社会主义理论\n    - 无产阶级利用自己的政治统治一步一步夺取资产阶级的全部资本，把一切生产工具集中在国家也即成为统治阶级的无产阶级手里，并尽可能增加生产力的宗量\n  - 中国共产党人的理论：党的七届二中全会\n- 现实依据\n  - 经济：1949-1952，已经拥有了相对强大和迅速发展的社会主义国营经济，国家掌握了重要工矿企业，铁路，银行等国民经济的命脉，体现了国营经济相比其他成分的优越性。\n  - 政治：新中国是工人阶级领导的以工农联盟为基础的人民民主专政的国家，马克思主义在思想文化领域处于指导地位，中国共产党执政并得到人民群众的广泛拥护\n  - 国际形势：经过二战，资本主义国家也很不景气，尽管帝国主义国家对我国实施了军事上侵略威胁，经济上严密封锁，政治上孤立遏制等策略，但社会主义国家正充满向上发展的活力\n\n#### 如何过渡\n\n- 总路线与总任务（1953.6）\n  - 在一个相当长的时间内，逐步实现国家的社会主义工业化，并初步实现国家对农业、手工业和资本主义工商业的社会主义改造。\n  - 实质：把生产资料的资本主义私有制改变成生产资料的社会主义公有制\n- 核心内容：“一化三改”\n  - 社会主义工业化\n  - 对个体农业、手工业和资本主义工商业进行社会主义改造。\n    - 对农业的社会主义改造首先进行\n      - 积极领导，稳步前进的方针，循序渐进的步骤\n      - 互助组（社会主义萌芽） $\\to$ 初级农业生产合作社（半社会主义性质） $\\to$ 高级农业生产合作社（完全社会主义性质）\n        - 互助组：解决生产上的困难，自愿基础上建立，分为临时与常年\n        - 初级农业生产合作社：在互助组的基础上自愿组织，以土地入股，其他生产资料作价入社，实施统一经营，进行集体劳动，以按劳分配和土地入股分红相结合\n        - 高级农业生产合作社：由初级社发展而成，规模更大，生产资料归集体所有，取消了土地报酬，实行按劳分配\n    - 手工业的社会主义改造\n      - 积极领导，稳步前进\n      - 通过合作化道路，把个体手工业经济改造为社会主义的集体所有制\n        - 个体手工业经济：建立在生产资料私有制和个体劳动基础上\n      - 手工业供销小组（社会主义萌芽） $\\to$ 供销合作社（半社会主义性质） $\\to$ 生产合作社（社会主义性质）\n        - 手工业供销小组：独立手工业者 / 家庭手工业者由国营商业 / 供销合作社供给原料和包销产品 / 推销成品，通过加工订货方式组织起来\n        - 手工业供销合作社：随着供销业务的逐步扩大，手工业供销小组发展为合作社。\n        - 手工业生产合作社：社会主义性质的集体经济组织，生产资料归集体所有，在计划指导下，根据市场需要灵活安排，集中 / 分散生产，流动服务，独立核算，自负盈亏。\n      - 采取说服教育，典型示范和国家帮助的方法\n    - 资本主义工商业的社会主义改造\n      - 和平赎买：国家有偿将私营企业变为国营企业（让企业家在一定年限内从企业经营所得中获取一部分利润）\n      - 从低级到高级的过渡形式\n        - 具有社会主义因素的企业，实行初级形式的国家资本主义\n        - 半社会主义性质的企业，实行个别企业的公私合营\n        - 社会主义国营性质的企业，实现全行业的公私合营\n      - 采取“包下来”的政策，把资本主义工商业者改造为自食其力的社会主义劳动者\n- 历史经验\n  - 坚持社会主义工业化建设和社会主义改造同时并举\n  - 采取积极引导和逐步过渡的方式\n  - 用和平方法进行改造\n\n#### 意义\n\n- 社会主义基本经济制度确立的标志：1956 年底，三大改造完成\n- 社会主义基本制度确立的表现\n  - 经济：社会主义公有制成为经济基础\n    - 数千年的阶级剥削制度结束，社会主义制度确立\n  - 政治：1954 年《宪法》\n    - 根本政治制度：人民代表大会制度\n    - 基本政治制度：中国共产党领导的多党合作和政治协商制度\n    - 标志着中国从新民主主义国家转变为社会主义国家\n  - 社会关系\n    - 工人阶级成为国家的领导阶级\n    - 亿万农民和其他个体劳动者成为社会主义的集体劳动者\n- 重大意义\n  - 中国历史上最深刻最伟大的变革\n    - 广大农民真正成为国家的主人\n    - 奠定我国社会主义工业化的初步基础\n  - 为当代中国一切发展奠定了制度基础，社会生产力的发展，初步显示了社会主义的优越性\n  - 世界社会主义发展史上一个历史性的伟大胜利\n  - 丰富和发展社会主义理论\n- 经验\n  - 实现伟大复兴，必须建立符合我国实际的先进生产制度\n\n### 社会主义建设道路初步探索的理论成果\n\n#### 理论成果\n\n- 调动一切积极因素为社会主义事业服务（《论十大关系》探索中国特色社会主义建设道路的基本方针）\n  - 回答了如何建设和巩固社会主义的问题\n  - 有利于最大限度团结全国各族人民，为建设社会主义现代化国家而奋斗\n- 正确认识和处理社会主义社会矛盾的思想\n  - 此时无产阶级同资产阶级之间的矛盾已基本解决，但仍面临着其他的矛盾\n  - 社会主义社会的基本矛盾\n    - 生产力 $\\leftrightarrow$ 生产关系\n    - 经济基础 $\\leftrightarrow$ 上层建筑\n    - 与资本主义社会不同，两者的基本矛盾具有根本不同的性质与情况\n    - “又相适应，又相矛盾”\n    - 非对抗性的矛盾\n  - 社会主义社会的主要矛盾\n    - 人民对于经济文化迅速发展的需要\n    - 当前经济文化不能满足人民需要的状况\n    - 主要任务：集中力量发展社会生产力，实现国家工业化，逐步满足人民日益增长的物质和文化需要\n  - 两类不同性质的矛盾\n    - 敌我矛盾\n      - 对抗性矛盾，分清敌我\n      - 处理方法：专政\n    - 人民内部矛盾\n      - 非对抗性矛盾，分清是非\n      - 处理方法：民主\n      - 处理方针：\n        - 政治思想领域 $\\leftrightarrow$ “团结-批评-团结”\n        - 物质利益、分配 $\\leftrightarrow$ “统筹兼顾，适当安排”\n        - 人民群众和政府机关 $\\leftrightarrow$ 坚持民主集中制，克服政府机关的官僚主义，同时加强对群众的教育\n        - 科学文化领域 $\\leftrightarrow$ “百花齐放，百家争鸣”\n        - 共产党和民主党派 $\\leftrightarrow$ 在坚持社会主义道路和共产党领导的前提下“长期共存，互相监督”\n        - 民族矛盾 $\\leftrightarrow$ 民族平等，团结互助\n  - 意义：\n    - 团结全国各族文明发展我们的经济，文化，巩固新制度，建设新国家\n- 走中国工业化道路的思想\n  - 为什么要\n    - 实现工业化是中国近代以来历史发展的必然要求，也是民族独立和国家富强的必要条件\n    - 中华人民共和国的成立，为我国实现工业化提供了根本的政治前提\n  - 背景\n    - 国内：工业基础薄弱\n    - 国际：受苏联工业化模式影响，比例失调\n  - 总方针：\n    - 以农业为基础，以工业为主导\n    - 以农、轻、重为序发展国民经济\n  - “两条腿走路”工业化发展思路\n    - 重工业和轻工业同时并举\n    - 中央工业和地方工业同时并举\n    - 沿海工业和内地工业同时并举\n    - 大型企业和中小型企业同时并举\n  - “两步走”发展战略\n    - 目标：把中国建设成为一个具有现代农业，现代工业，现代国防，现代国防技术的强国\n    - 战略步骤\n      - 建成一个独立的比较完整的工业体系和国民经济体系\n      - 全面实现工业，农业，国防和科学技术现代化，使中国走在世界前列\n  - 要怎么做\n    - 正确的经济建设方针\n      - 党的八大：既反保守，又反冒进，坚持在综合平衡中稳步前进\n    - 调整和完善所有制结构\n    - 探索适合我国情况的经济体制和运行机制\n- 其他\n  - 四个现代化：现代化的工业，现代化的农业，现代化的交通运输业和现代化的国防\n\n#### 经验教训\n\n- 意义\n  - 巩固和发展了我国的社会主义制度\n  - 为开创中国特色社会主义提供了宝贵经验，理论准备和物质基础\n  - 丰富了科学社会主义的理论和实践\n- 经验教训，“六个必须”\n  - 把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路\n  - 正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力\n  - 从实际出发进行社会主义建设，建设规模和速度要和国力相适应，不能急于求成\n  - 发展社会主义民主，健全社会主义法治\n  - 坚持党的民主集中制和集体领导制度，加强执政党建设\n  - 坚持对外开放，借鉴和吸收人类文明成果建设社会主义\n\n## 历程\n\n### 毛泽东的思想历程 / 毛泽东思想的形成发展过程\n\n- 19 世纪末 20 世纪初，战争与革命成为时代的主题\n- 科学含义\n  - 马列主义在中国的运用和发展\n  - 被实践证明了的关于中国革命建设的正确理论原则和经验总结\n  - 中国共产党集体智慧的结晶\n- 中国革命战胜敌人的三大法宝：统一战线，武装斗争，党的建设\n- 主要内容与活的灵魂：==实事求是，群众路线，独立自主==\n  - 实事求是\n    - 从实际出发，把握客观规律\n    - 清醒认识和正确把握我国基本国情\n    - 推进实践基础上的理论创新\n  - 群众路线\n    - 将“人民群众是历史的创造者”（_本质_）的原理用在党的活动中\n    - 怎么做\n      - 坚持人民是推动历史发展的根本力量\n      - 坚持全心全意为人民服务的根本宗旨\n      - 保持党同人民群众的血肉联系\n  - 独立自主（针对“左”倾教条主义倾向提出的）\n    - 中华民族的优良传统\n    - 立党立国的重要原则\n    - 外交一以贯之的\n- 形成和发展\n  - 形成时期：\n    - 第一次国内革命战争\n      - 《中国社会各阶级的分析》/《湖南农民运动考察报告》\n      - 深刻分析中国社会各阶级在革命中的地位和作用\n      - 提出了新民主主义革命的基本思想\n    - 土地革命战争初期\n      - 《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》《反对本本主义》\n      - 农村包围城市，武装夺取政权，中国革命道路理论\n      - 毛泽东思想初步形成\n  - 成熟时期\n    - 土地革命战争后期，抗日战争时期\n      - 《实践论》《矛盾论》《<共产党人>发刊词》《中国革命和中国共产党》《新民主主义论》\n      - 实现了马克思主义与中国革命实际相结合的历史性飞跃\n      - 毛泽东思想趋于成熟\n    - 遵义会议，系统分析了党内左和右的思想根源\n    - 确立指导思想：1945 年 4-6 月召开的党的七大将毛泽东思想写入党章\n  - 继续发展\n    - 解放战争时期\n      - 《在中国共产党第七届中央委员会第二次全体会议上的报告》《论人民民主专政》\n      - 人民民主专政理论\n    - 新中国成立后\n      - 《论十大关系》《关于正确处理人民内部矛盾的问题》\n      - 社会主义改造理论、建设理论\n    - 毛泽东思想进一步丰富和发展\n- 历史地位\n  - 马克思主义中国化时代化的第一个重大理论成果\n  - 中国革命和建设的科学指南\n  - 中国共产党和中国人民宝贵的精神财富\n- 科学评价\n  - 完整准确理解和掌握毛泽东思想的科学体系\n  - 坚持辩证唯物主义和历史唯物主义的原则和方法\n  - 在实践中坚持和发展毛泽东思想\n- 辨析：毛泽东思想 $\\neq$ 毛泽东个人的思想\n  - 被实践证明了的正确的理论原则和经验总结\n  - 中国共产党集体智慧的结晶\n  - 主要是“毛泽东同志的思想”，其他领导人也对毛泽东思想的形成和发展做出了重要贡献\n\n### 邓小平理论\n\n- _中国特色社会主义理论体系的开篇之作_\n\n#### 邓小平理论的形成\n\n- 时代背景：和平与发展\n  - 和平：东西问题\n  - 发展：南北问题\n  - **发展是核心问题**\n- 历史依据：社会主义建设的经验教训\n  - 社会主义建设实践中的正确主张在改革开放后得到真正贯彻\n  - 社会主义建设经历的曲折和失误促使党和人民进行深刻反思\n- 现实依据：改革开放和现代化建设的实践\n- 形成过程\n  - “文革”结束后，邓小平强调实事求是是毛泽东思想的精髓，旗帜鲜明反对“两个凡是”的错误观点，支持领导开展真理标准问题的打讨论，推进各方面的拨乱反正\n  - 1978，党的十一届三中全会确定了解放思想，实事求是的思想路线，停止“以阶级斗争为纲”的错误，将全党工作的重点转移到社会主义现代化建设上来，做出改革开放的重大决策，实现了党的历史上具有深远意义的伟大转折。\n  - 1982，党的“十二大”提出“中国特色社会主义”，并成为党的全部理论和实践创新的主题\n  - 1984，《中共中央关于经济体制改革的决定》——社会主义经济是在公有制基础上的有计划的商品经济\n  - 1987，党的十三大，系统论述了我国社会主义初级阶段理论，明确概括和全面阐发了党“一个中心，两个基本点”的基本路线，对中国特色社会主义理论的主要内容做了系统概括，标志着邓小平理论轮廓的形成\n  - 1992，南方谈话，重申深化改革、加速发展的必要性和重要性，从理论上解答了当时困扰和束缚人们思想的一系列重大问题，邓小平理论走向成熟；党的十四大强调中国特色社会主义理论第一次比较系统地初步回答了中国这样的社会经济文化比较落后的国家如何建设社会主义，如何巩固和发展社会主义的一系列基本问题，继承和发展了马克思主义\n  - 1997，十五大正式提出“邓小平理论”这一概念，确立为党的指导思想并写入党章\n  - 1999，宪法修正案正式将邓小平理论载入宪法\n\n#### 理论问题\n\n- 首要、基本的理论问题：在中国这样一个经济文化比较落后的国家建设什么样的社会主义，怎样建设社会主义\n- 社会主义本质\n  - 解放生产力\n  - 发展生产力（社会主义的根本任务是发展生产力）\n  - 消灭剥削\n  - 消除两极分化\n  - 达到共同富裕\n- 包括了生产力和生产关系的问题\n\n#### 精髓\n\n- **解放思想，实事求是**\n\n#### 主要内容\n\n- 社会主义初级阶段（建设中国特色社会主义的总依据）理论\n  - 一切从社会主义初级阶段的实际出发，将社会主义初级阶段作为事关全局的基本国情加以把握\n  - 含义\n    - 我国社会已经是社会主义社会（社会性质）\n    - 我国的社会主义社会还处于初级阶段（发展程度）\n  - 社会主义初级阶段具有长期性\n  - 基本特征\n    - 以农业人口占多数的手工劳动为基础的农业国，逐步变为非农产业人口占多数的现代化的工业国的阶段\n    - 自然经济半自然经济占很大比重，变为商品经济高度发达的阶段\n    - 通过改革和探索建立和发展充满活力的社会主义经济、政治，文化体制的阶段\n    - 全民奋起，艰苦创业，实现中华民族伟大复兴的阶段\n- 党在社会主义初级阶段的基本路线\n  - **领导和团结全国各族人民**（_领导力量和依靠力量_），以**经济建设为中心（根本任务），坚持四项基本原则（社会主义道路，人民民主专政，党的领导，马列毛思想）解放和发展生产力的政治保证），坚持改革开放（发展动力与外部条件）**（_基本途径_），**自力更生，艰苦创业**（_实现目标的根本立足点_），为把我国建设成为**富强（经济），民主（政治），文明（思想）的社会主义现代化国家**（_奋斗目标_）而奋斗\n  - “一个中心（经济建设），两个基本点（四项基本原则（立国之本），改革开放（强国之路））”\n- 社会主义的根本任务是发展生产力，党和国家的工作重点是经济建设\n  - 发展生产力离不开科学技术\n  - 改革是动力，发展是目的，稳定是前提\n- 分“三步走”基本实现现代化![[Pasted image 20240612214124.png|300]]\n- 社会主义改革开放理论与市场经济理论\n  - 社会主义市场经济：在社会主义制度条件下，让市场在资源配置中起决定作用\n    - 所有制结构：公有制为主体，多种所有制经济共同发展\n    - 宏观调控：市场在国家宏观调控下对资源配置起到决定性作用\n    - 分配制度：按劳分配为主体，多种分配形式并存\n- “两手抓，两手都要硬”（物质文明和精神文明）（建设和法治）（改革开放和惩治腐败）\n- “一国两制”与祖国统一\n- 中国特色社会主义外交和国际战略\n  - 基本目标：维护我国的独立和主权，促进世界的和平与发展\n  - 冷静观察，稳住阵脚，沉着应付\n- 党的建设\n  - 重视马克思主义理论学习\n  - 加强组织建设\n  - 加强领导班子建设\n  - 打好党风建设\n  - 重视制度建设\n- “三个有利于”：\n  - 是否有利于发展社会主义社会的生产力\n  - 是否有利于增强社会主义国家的综合国力\n  - 是否有利于提高人民的生活水平\n\n#### 重要意义\n\n- 马克思列宁主义，毛泽东思想的继承和发展\n- 中国特色社会主义理论体系的开篇之作\n- 改革开放和社会主义现代化建设的科学指南\n\n### “三个代表”重要思想形成背景与具体内容\n\n#### 背景与形成过程\n\n- 社会历史条件\n  - 国际背景：发生并经历重大变化，基于冷战结束后国际局势的科学判断\n    - 国际共运遭受重大挫折\n    - 处于两种社会制度对立，斗争的最前沿\n  - 历史条件（国内背景）：党的历史方位和党员队伍发生了深刻变化，基于科学判断党的历史方位和总结历史经验\n    - 领导人民为夺取全国政权而奋斗 $\\to$ 领导人民掌握全国政权并长期执政\n    - 受到外部封锁和实行计划经济条件下领导国家建设 $\\to$ 对外开放和发展社会主义市场经济条件下领导国家建设\n    - 党员队伍进入整体性交接的关键时刻\n      - 提高党的领导水平和执政水平\n      - 提高拒腐防变和抵御风险的能力\n      - 要求党从新的实际出发，以改革的精神加强和改进党的建设，使党在世界形势深刻变化的历史进程中始终走在时代前列\n  - 实践基础：在建设中国特色社会主义伟大实践的基础上形成的\n- “三个代表”重要思想发展过程\n  - 酝酿\n    - 1989.6 / 8 提出大力加强党的建设，惩治腐败的要求，发布《关于加强党的建设的通知》\n    - 1991.7，中国共产党成立 70 周年大会上深刻论述了进一步加强党的建设的问题\n    - 1992.10，党的十四大系统论述了加强党的建设和改善党的领导的问题\n  - 形成\n    - 1994，十四届四中全会通过了《关于加强党的建设几个重大问题的决定》\n    - 1997，党的十五大，高度概括了新时期党的建设新的伟大工程的总目标\n    - 2000.2，在广东考察，首次对“三个代表”进行了比较全面的阐述\n    - 2000.6，在全国党校工作会议上指出，“三个代表”重要思想回答和解决的事“建设什么样的党，怎样建设党”的问题\n  - 深度发展\n    - 2000.10，就“改进党的作风”发表重要讲话\n    - 2001.7，庆祝中国共产党成立 80 周年大会上的讲话中全面阐述了“三个代表”重要思想的科学内涵和基本内容\n    - 2002.11，党的十六大确立为指导思想，写入党章\n\n#### 核心观点\n\n- 中国共产党始终代表中国先进生产力的发展要求\n- 中国共产党始终代表中国先进文化的前进方向\n- 中国共产党始终代表中国最广大人民的根本利益\n\n#### 主要内容\n\n- 发展是党执政兴国的第一要务\n- 建立社会主义市场经济体制\n  - 毫不动摇巩固发展公有制经济\n  - 毫不动摇鼓励、支持、引导非公有制经济\n  - 本质要求：发挥市场机制的作用和国家宏观调控\n- 全面建设小康社会\n  - 两个百年奋斗目标\n- 建设社会主义政治文明\n- 实施“引进来”和“走出去”的对外开放战略\n- 推进党的建设新的伟大工程\n\n#### 历史地位\n\n- 中国特色社会主义理论体系的丰富发展\n- 加强和改进党的建设，推进中国特色社会主义事业的强大理论武器\n\n### 科学发展观的形成过程与具体内容\n\n#### 形成条件\n\n- 国际背景：\n  - 深刻分析国际形势\n  - 顺应世界发展趋势\n  - 借鉴国外发展经验\n- 历史条件\n  - 深刻把握我国国情和新的阶段性特征\n- 实践基础\n  - 总结改革开放尤其是十六大以来实践经验的基础\n\n#### 形成过程\n\n- 逐步形成：抗击非典疫情和探索未完善社会主义市场经济体制\n  - 2003.7，总结非典经验：全面发展，协调发展，可持续发展\n  - 2003.10，科学发展观\n- 充实丰富：加强和改善宏观调控的时间\n  - 十四届六中全会，树立和落实科学发展观作为提高党的执政能力的重要内容\n  - 十一五规划的建议 / 纲要：以科学发展观统领经济社会发展全局\n- 走向成熟\n- 发展完善：十七大后，不断发展完善\n  - 2008.12，在中央经济工作会议上强调，科学发展观第一要义是发展\n  - 十七届五中全会强调，坚持发展是硬道理的本质要求，就是坚持科学发展\n  - 2012，确立为指导思想\n\n#### 内涵\n\n- 推动经济社会**发展**是科学发展观的*第一要义* （为什么）\n- **以人为本**是科学发展观的*核心立场* （为了谁和依靠谁）\n- **全面协调可持续**是科学发展观的*基本要求* （实现什么样的发展）\n- **统筹兼顾**是科学发展观的*根本方法* （怎么发展）\n\n#### 精神实质\n\n- 解放思想，实事求是，与时俱进，求真务实\n\n#### 内容\n\n- 转变经济发展方式\n  - 持续健康发展\n  - 创新驱动发展战略\n  - 经济结构战略性调整\n  - 促进区域协调发展战略\n  - 城乡发展一体化\n- 发展社会主义民主政治\n  - 社会主义核心价值体系\n  - 社会主义核心价值观\n- 推进社会主义文化强国建设\n- 构建社会主义和谐社会\n- 推进生态文明建设\n- 全面提高党的建设科学化水平\n\n#### 历史地位\n\n- 中国特色社会主义理论体系在新世纪新阶段的接续发展\n- 全面建设小康社会，加快推进社会主义现代化的根本指针\n","source":"_posts/毛概.md","raw":"---\ntitle: 毛概\n---\n\n## 毛概是什么：马克思主义中国化时代化的历史进程和理论结果\n\n- 什么是马克思主义中国化时代化：\n  - 运用马克思主义的立场、观点和方法，观察时代、把握时代、引领时代，解决中国革命、建设、改革中的实际问题。\n  - 总结和提炼中国革命、建设、改革的实践经验并将其上升为理论，不断丰富和发展马克思主义的理论宝库，赋予马克思主义以新的时代内涵。\n  - 用中国人民喜闻乐见的民族语言来阐述马克思主义理论，使之成为具有中国特色，中国风格，中国气派的马克思主义\n- 1938 党的六届六中全会上，《论新阶段》的报告，标志着“马克思主义的中国化”这一命题的正式提出\n- 中共七大，刘少奇从理论上做出阐述\n- 内涵：马克思主义中国化时代化，就是立足*中国国情*和*时代特点*，坚持把马克思主义基本原理同中国*具体实际*相结合、同中华优秀*传统文化*相结合，深入研究和解决中国革命、建设、改革不同历史时期的实际问题，真正搞懂面临的时代课题，不断吸收新的时代内容，科学回答时代提出的重大理论和实践课题，创造新的理论成果。\n\n## 马克思主义中国化的理论成果\n\n- 毛泽东思想\n- 中国特色社会主义理论体系\n\n## 马克思主义中国化理论成果的精髓：实事求是\n\n## 理论\n\n### 新民主主义革命理论\n\n- 认清中国国情是解决中国革命问题的*基本前提*\n- 认清中国社会的性质，乃是认清一切革命问题的*基本的根据*\n\n#### 何以形成\n\n- 国情依据：近代中国是一个半殖民地半封建性质的社会\n  - 帝国主义列强进行政治，经济，文化的侵略，中国长期处于帝国主义国家的统治或半统治之下，没有完整的主权与国家的统一\n  - 前述侵略使得自给自足的封建经济基础解体，但封建制度的根基：地主阶级对农民的剥削仍然存在，而且同买办资本和高利贷资本的剥削结合在了一起。\n  - 主要矛盾：**帝国主义和中华民族的矛盾**（主要），封建主义和人民大众的矛盾\n  - 根本任务：推翻帝国主义，封建主义和官僚资本主义的统治，争取民族独立和人民解放\n- 时代背景\n  - 1917 年十月革命，建立了第一个无产阶级专政的政权\n  - 五四运动，中国无产阶级作为独立的政治力量成为革命的领导力量，马克思列宁主义逐步成为中国革命的指导思想，进入新民主主义革命阶段\n- 实践基础\n  - 旧民主主义革命的失败\n    - 旧式的农民战争\n    - 不触动封建根基的自强运动和改良主义\n    - 照搬西方资本主义的方案\n  - 包含对上述失败教训的深刻总结\n\n#### 基本内容\n\n- 提出\n  - 1939《中国革命和中国共产党》，第一次提出“新民主主义的革命”的概念\n  - 1948《在晋绥干部会议上的讲话》完整总结和概括了新民主主义革命总路线的内容\n- 总路线：**无产阶级领导的，人民大众的，反对帝国主义，封建主义和官僚资本主义的革命**\n  - 无产阶级的领导权是中国革命的中心问题，也是新民主主义革命理论的核心问题，也是新民主主义革命区别于旧民主主义革命的根本标志\n    - 与先进的生产方式相联系，没有私人占有的生产资料，富有组织纪律性\n    - 受“三座大山”的压迫\n    - 集中分布在少数大城市和大企业，利于组织团结\n    - 成员与农民间有天然的联系\n  - 革命的对象：分清敌友，是革命的*首要问题*\n    - 帝国主义（中国革命的首要对象）\n      - 近代中国贫困落后和一切灾难祸害的总根源\n      - 推翻帝国主义的压迫是中国走向独立和富强的前提\n    - 封建主义\n      - 帝国主义统治中国和封建军阀实行专制统治的社会基础，是中国经济现代化和政治民主化的主要障碍\n    - 官僚资本主义\n      - 对劳动人民 / 民族工商业的巧取豪夺，严重束缚了中国社会生产力的发展。\n  - 革命的任务\n    - 民族革命：对外推翻帝国主义的压迫\n    - 民主革命：对内推翻封建地主阶级和官僚资产阶级的压迫\n    - 相互区别，相互联系\n  - 革命的动力\n    - 无产阶级：中国革命*最基本的动力*，中国革命的领导力量\n    - 农民：中国革命的主力军，农民问题是中国革命的*基本问题*，**新民主主义革命实质上就是党领导下的农民革命，中国革命战争实质上就是党领导下的农民战争**\n    - 城市小资产阶级：无产阶级的可靠同盟者（广大知识分子，小商人，手工业者和自由职业者）\n    - 民族资产阶级：带有两面性的阶级，一方面受压迫，一方面政治经济上又有联系，表现出明显的动摇性\n- 纲领（总路线的展开）\n  - 政治纲领：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的，以工农联盟为基础的，_各革命阶级联合专政_（国体）的新民主主义的共和国。（不同于欧美，也不同于苏联）\n    - 革命的根本问题是政权问题\n    - 政体：民主集中制的人民代表大会制度\n  - 经济纲领：“两没收，一保护”\n    - 没收封建地主阶级的土地归农民所有（进行土地革命，耕者有其田，扫除封建的剥削关系，解放农村生产力）\n    - 没收官僚资本归新民主主义国家所有（建立具有社会主义性质的国营经济，使它居于领导地位，为建立新民主主义的国家政权实现向社会主义过渡奠定坚实的基础）\n    - 保护民族工商业（保护，推动民族资本主义经济的发展，使它在发展现代技术，发展社会生产力，满足人民生活需要方面发挥作用，但不能让它操纵国计民生）\n  - 文化纲领\n    - **“民族的”**：\n      - 内容上：反对帝国主义压迫，主张中华民族的尊严和独立\n      - 形式上：具有鲜明的民族风格，民族形式和民族特色\n    - **“科学的”**：\n      - 反对封建迷信，主张实事求是，客观真理，理论和实践的一致性\n      - 历史唯物主义的态度对待古今中外文化，发展民族新文化，提高民族自信\n    - **“大众的”**：\n      - 文化工作者要用革命文化教育和武装人民大众\n      - 以人民群众的实践作为创作的源泉\n      - 为人民大众服务\n- 道路：**农村包围城市，武装夺取政权**\n  - 成功原因\n    - 近代中国的社会性质，社会政治经济发展极端不平衡\n    - 广大农村深受反动统治阶级的多重压迫和剥削，革命愿望强烈\n    - 革命形势的变动\n    - 正式红军的存在\n    - 党的领导\n  - 土地革命：是中国革命的基本内容\n  - 农村革命根据地建设：是中国革命的战略阵地，进行武装斗争和土地革命的依托\n  - 武装斗争：中国革命的主要形式，是上述两者的有力保证\n- 基本经验：三大法宝：统一战线，武装斗争，党的建设\n  - 统一战线和武装斗争：针对敌人，是武器\n    - 统一战线：采取区别对待的方针，发展进步势力，争取中间势力，孤立顽固势力\n  - 党的建设：针对党自身，是掌握武器的人\n    - 思想建设放在首位\n    - 三大优良作风：理论联系实际，密切联系群众，批评与自我批评相结合\n\n#### 意义\n\n- 理论：极大地丰富了马克思主义的理论宝库，是马克思主义中国化时代化的重要理论成果，是对中国革命实际问题做出的分析和研究，是中国共产党集体智慧的结晶\n- 实践：在新民主主义革命理论的指导下，党团结带领人民完成了新民主主义革命，实现了民族独立和人民解放\n- 世界：极大改变了世界的政治格局，鼓舞了全世界人民争取解放，反对帝国主义斗争的信心，增强了世界人民争取和平的力量\n\n### 社会主义改造理论\n\n#### 过渡的依据\n\n- 新民主主义社会是一个过渡性的社会\n  - 中华人民共和国成立 $\\to$ 社会主义改造基本完成是我国从新民主主义到社会主义的过渡时期，性质是新民主主义社会\n  - 不是独立的社会形态，而是过渡性社会形态，由经济结构和社会主要矛盾决定\n  - 经济结构\n    - 社会主义性质的国营经济\n    - 半社会主义性质的合作社经济（个体 $\\to$ 国营）\n    - 农民和手工业者的个体经济\n    - 私人资本主义经济\n    - 国家资本主义经济（私人 $\\to$ 国营）\n  - 阶级构成\n    - 社会主义 $\\leftrightarrow$ 工人阶级\n    - 个体经济 $\\leftrightarrow$ 农民阶级和其他小资产阶级\n    - 资本主义经济 $\\leftrightarrow$ 民族资产阶级\n  - 主要矛盾\n    - 社会主义 $\\leftrightarrow$ 资本主义\n    - 工人阶级 $\\leftrightarrow$ 资产阶级\n- 理论依据\n  - 马克思 / 恩格斯：科学社会主义理论\n    - 无产阶级利用自己的政治统治一步一步夺取资产阶级的全部资本，把一切生产工具集中在国家也即成为统治阶级的无产阶级手里，并尽可能增加生产力的宗量\n  - 中国共产党人的理论：党的七届二中全会\n- 现实依据\n  - 经济：1949-1952，已经拥有了相对强大和迅速发展的社会主义国营经济，国家掌握了重要工矿企业，铁路，银行等国民经济的命脉，体现了国营经济相比其他成分的优越性。\n  - 政治：新中国是工人阶级领导的以工农联盟为基础的人民民主专政的国家，马克思主义在思想文化领域处于指导地位，中国共产党执政并得到人民群众的广泛拥护\n  - 国际形势：经过二战，资本主义国家也很不景气，尽管帝国主义国家对我国实施了军事上侵略威胁，经济上严密封锁，政治上孤立遏制等策略，但社会主义国家正充满向上发展的活力\n\n#### 如何过渡\n\n- 总路线与总任务（1953.6）\n  - 在一个相当长的时间内，逐步实现国家的社会主义工业化，并初步实现国家对农业、手工业和资本主义工商业的社会主义改造。\n  - 实质：把生产资料的资本主义私有制改变成生产资料的社会主义公有制\n- 核心内容：“一化三改”\n  - 社会主义工业化\n  - 对个体农业、手工业和资本主义工商业进行社会主义改造。\n    - 对农业的社会主义改造首先进行\n      - 积极领导，稳步前进的方针，循序渐进的步骤\n      - 互助组（社会主义萌芽） $\\to$ 初级农业生产合作社（半社会主义性质） $\\to$ 高级农业生产合作社（完全社会主义性质）\n        - 互助组：解决生产上的困难，自愿基础上建立，分为临时与常年\n        - 初级农业生产合作社：在互助组的基础上自愿组织，以土地入股，其他生产资料作价入社，实施统一经营，进行集体劳动，以按劳分配和土地入股分红相结合\n        - 高级农业生产合作社：由初级社发展而成，规模更大，生产资料归集体所有，取消了土地报酬，实行按劳分配\n    - 手工业的社会主义改造\n      - 积极领导，稳步前进\n      - 通过合作化道路，把个体手工业经济改造为社会主义的集体所有制\n        - 个体手工业经济：建立在生产资料私有制和个体劳动基础上\n      - 手工业供销小组（社会主义萌芽） $\\to$ 供销合作社（半社会主义性质） $\\to$ 生产合作社（社会主义性质）\n        - 手工业供销小组：独立手工业者 / 家庭手工业者由国营商业 / 供销合作社供给原料和包销产品 / 推销成品，通过加工订货方式组织起来\n        - 手工业供销合作社：随着供销业务的逐步扩大，手工业供销小组发展为合作社。\n        - 手工业生产合作社：社会主义性质的集体经济组织，生产资料归集体所有，在计划指导下，根据市场需要灵活安排，集中 / 分散生产，流动服务，独立核算，自负盈亏。\n      - 采取说服教育，典型示范和国家帮助的方法\n    - 资本主义工商业的社会主义改造\n      - 和平赎买：国家有偿将私营企业变为国营企业（让企业家在一定年限内从企业经营所得中获取一部分利润）\n      - 从低级到高级的过渡形式\n        - 具有社会主义因素的企业，实行初级形式的国家资本主义\n        - 半社会主义性质的企业，实行个别企业的公私合营\n        - 社会主义国营性质的企业，实现全行业的公私合营\n      - 采取“包下来”的政策，把资本主义工商业者改造为自食其力的社会主义劳动者\n- 历史经验\n  - 坚持社会主义工业化建设和社会主义改造同时并举\n  - 采取积极引导和逐步过渡的方式\n  - 用和平方法进行改造\n\n#### 意义\n\n- 社会主义基本经济制度确立的标志：1956 年底，三大改造完成\n- 社会主义基本制度确立的表现\n  - 经济：社会主义公有制成为经济基础\n    - 数千年的阶级剥削制度结束，社会主义制度确立\n  - 政治：1954 年《宪法》\n    - 根本政治制度：人民代表大会制度\n    - 基本政治制度：中国共产党领导的多党合作和政治协商制度\n    - 标志着中国从新民主主义国家转变为社会主义国家\n  - 社会关系\n    - 工人阶级成为国家的领导阶级\n    - 亿万农民和其他个体劳动者成为社会主义的集体劳动者\n- 重大意义\n  - 中国历史上最深刻最伟大的变革\n    - 广大农民真正成为国家的主人\n    - 奠定我国社会主义工业化的初步基础\n  - 为当代中国一切发展奠定了制度基础，社会生产力的发展，初步显示了社会主义的优越性\n  - 世界社会主义发展史上一个历史性的伟大胜利\n  - 丰富和发展社会主义理论\n- 经验\n  - 实现伟大复兴，必须建立符合我国实际的先进生产制度\n\n### 社会主义建设道路初步探索的理论成果\n\n#### 理论成果\n\n- 调动一切积极因素为社会主义事业服务（《论十大关系》探索中国特色社会主义建设道路的基本方针）\n  - 回答了如何建设和巩固社会主义的问题\n  - 有利于最大限度团结全国各族人民，为建设社会主义现代化国家而奋斗\n- 正确认识和处理社会主义社会矛盾的思想\n  - 此时无产阶级同资产阶级之间的矛盾已基本解决，但仍面临着其他的矛盾\n  - 社会主义社会的基本矛盾\n    - 生产力 $\\leftrightarrow$ 生产关系\n    - 经济基础 $\\leftrightarrow$ 上层建筑\n    - 与资本主义社会不同，两者的基本矛盾具有根本不同的性质与情况\n    - “又相适应，又相矛盾”\n    - 非对抗性的矛盾\n  - 社会主义社会的主要矛盾\n    - 人民对于经济文化迅速发展的需要\n    - 当前经济文化不能满足人民需要的状况\n    - 主要任务：集中力量发展社会生产力，实现国家工业化，逐步满足人民日益增长的物质和文化需要\n  - 两类不同性质的矛盾\n    - 敌我矛盾\n      - 对抗性矛盾，分清敌我\n      - 处理方法：专政\n    - 人民内部矛盾\n      - 非对抗性矛盾，分清是非\n      - 处理方法：民主\n      - 处理方针：\n        - 政治思想领域 $\\leftrightarrow$ “团结-批评-团结”\n        - 物质利益、分配 $\\leftrightarrow$ “统筹兼顾，适当安排”\n        - 人民群众和政府机关 $\\leftrightarrow$ 坚持民主集中制，克服政府机关的官僚主义，同时加强对群众的教育\n        - 科学文化领域 $\\leftrightarrow$ “百花齐放，百家争鸣”\n        - 共产党和民主党派 $\\leftrightarrow$ 在坚持社会主义道路和共产党领导的前提下“长期共存，互相监督”\n        - 民族矛盾 $\\leftrightarrow$ 民族平等，团结互助\n  - 意义：\n    - 团结全国各族文明发展我们的经济，文化，巩固新制度，建设新国家\n- 走中国工业化道路的思想\n  - 为什么要\n    - 实现工业化是中国近代以来历史发展的必然要求，也是民族独立和国家富强的必要条件\n    - 中华人民共和国的成立，为我国实现工业化提供了根本的政治前提\n  - 背景\n    - 国内：工业基础薄弱\n    - 国际：受苏联工业化模式影响，比例失调\n  - 总方针：\n    - 以农业为基础，以工业为主导\n    - 以农、轻、重为序发展国民经济\n  - “两条腿走路”工业化发展思路\n    - 重工业和轻工业同时并举\n    - 中央工业和地方工业同时并举\n    - 沿海工业和内地工业同时并举\n    - 大型企业和中小型企业同时并举\n  - “两步走”发展战略\n    - 目标：把中国建设成为一个具有现代农业，现代工业，现代国防，现代国防技术的强国\n    - 战略步骤\n      - 建成一个独立的比较完整的工业体系和国民经济体系\n      - 全面实现工业，农业，国防和科学技术现代化，使中国走在世界前列\n  - 要怎么做\n    - 正确的经济建设方针\n      - 党的八大：既反保守，又反冒进，坚持在综合平衡中稳步前进\n    - 调整和完善所有制结构\n    - 探索适合我国情况的经济体制和运行机制\n- 其他\n  - 四个现代化：现代化的工业，现代化的农业，现代化的交通运输业和现代化的国防\n\n#### 经验教训\n\n- 意义\n  - 巩固和发展了我国的社会主义制度\n  - 为开创中国特色社会主义提供了宝贵经验，理论准备和物质基础\n  - 丰富了科学社会主义的理论和实践\n- 经验教训，“六个必须”\n  - 把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路\n  - 正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力\n  - 从实际出发进行社会主义建设，建设规模和速度要和国力相适应，不能急于求成\n  - 发展社会主义民主，健全社会主义法治\n  - 坚持党的民主集中制和集体领导制度，加强执政党建设\n  - 坚持对外开放，借鉴和吸收人类文明成果建设社会主义\n\n## 历程\n\n### 毛泽东的思想历程 / 毛泽东思想的形成发展过程\n\n- 19 世纪末 20 世纪初，战争与革命成为时代的主题\n- 科学含义\n  - 马列主义在中国的运用和发展\n  - 被实践证明了的关于中国革命建设的正确理论原则和经验总结\n  - 中国共产党集体智慧的结晶\n- 中国革命战胜敌人的三大法宝：统一战线，武装斗争，党的建设\n- 主要内容与活的灵魂：==实事求是，群众路线，独立自主==\n  - 实事求是\n    - 从实际出发，把握客观规律\n    - 清醒认识和正确把握我国基本国情\n    - 推进实践基础上的理论创新\n  - 群众路线\n    - 将“人民群众是历史的创造者”（_本质_）的原理用在党的活动中\n    - 怎么做\n      - 坚持人民是推动历史发展的根本力量\n      - 坚持全心全意为人民服务的根本宗旨\n      - 保持党同人民群众的血肉联系\n  - 独立自主（针对“左”倾教条主义倾向提出的）\n    - 中华民族的优良传统\n    - 立党立国的重要原则\n    - 外交一以贯之的\n- 形成和发展\n  - 形成时期：\n    - 第一次国内革命战争\n      - 《中国社会各阶级的分析》/《湖南农民运动考察报告》\n      - 深刻分析中国社会各阶级在革命中的地位和作用\n      - 提出了新民主主义革命的基本思想\n    - 土地革命战争初期\n      - 《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》《反对本本主义》\n      - 农村包围城市，武装夺取政权，中国革命道路理论\n      - 毛泽东思想初步形成\n  - 成熟时期\n    - 土地革命战争后期，抗日战争时期\n      - 《实践论》《矛盾论》《<共产党人>发刊词》《中国革命和中国共产党》《新民主主义论》\n      - 实现了马克思主义与中国革命实际相结合的历史性飞跃\n      - 毛泽东思想趋于成熟\n    - 遵义会议，系统分析了党内左和右的思想根源\n    - 确立指导思想：1945 年 4-6 月召开的党的七大将毛泽东思想写入党章\n  - 继续发展\n    - 解放战争时期\n      - 《在中国共产党第七届中央委员会第二次全体会议上的报告》《论人民民主专政》\n      - 人民民主专政理论\n    - 新中国成立后\n      - 《论十大关系》《关于正确处理人民内部矛盾的问题》\n      - 社会主义改造理论、建设理论\n    - 毛泽东思想进一步丰富和发展\n- 历史地位\n  - 马克思主义中国化时代化的第一个重大理论成果\n  - 中国革命和建设的科学指南\n  - 中国共产党和中国人民宝贵的精神财富\n- 科学评价\n  - 完整准确理解和掌握毛泽东思想的科学体系\n  - 坚持辩证唯物主义和历史唯物主义的原则和方法\n  - 在实践中坚持和发展毛泽东思想\n- 辨析：毛泽东思想 $\\neq$ 毛泽东个人的思想\n  - 被实践证明了的正确的理论原则和经验总结\n  - 中国共产党集体智慧的结晶\n  - 主要是“毛泽东同志的思想”，其他领导人也对毛泽东思想的形成和发展做出了重要贡献\n\n### 邓小平理论\n\n- _中国特色社会主义理论体系的开篇之作_\n\n#### 邓小平理论的形成\n\n- 时代背景：和平与发展\n  - 和平：东西问题\n  - 发展：南北问题\n  - **发展是核心问题**\n- 历史依据：社会主义建设的经验教训\n  - 社会主义建设实践中的正确主张在改革开放后得到真正贯彻\n  - 社会主义建设经历的曲折和失误促使党和人民进行深刻反思\n- 现实依据：改革开放和现代化建设的实践\n- 形成过程\n  - “文革”结束后，邓小平强调实事求是是毛泽东思想的精髓，旗帜鲜明反对“两个凡是”的错误观点，支持领导开展真理标准问题的打讨论，推进各方面的拨乱反正\n  - 1978，党的十一届三中全会确定了解放思想，实事求是的思想路线，停止“以阶级斗争为纲”的错误，将全党工作的重点转移到社会主义现代化建设上来，做出改革开放的重大决策，实现了党的历史上具有深远意义的伟大转折。\n  - 1982，党的“十二大”提出“中国特色社会主义”，并成为党的全部理论和实践创新的主题\n  - 1984，《中共中央关于经济体制改革的决定》——社会主义经济是在公有制基础上的有计划的商品经济\n  - 1987，党的十三大，系统论述了我国社会主义初级阶段理论，明确概括和全面阐发了党“一个中心，两个基本点”的基本路线，对中国特色社会主义理论的主要内容做了系统概括，标志着邓小平理论轮廓的形成\n  - 1992，南方谈话，重申深化改革、加速发展的必要性和重要性，从理论上解答了当时困扰和束缚人们思想的一系列重大问题，邓小平理论走向成熟；党的十四大强调中国特色社会主义理论第一次比较系统地初步回答了中国这样的社会经济文化比较落后的国家如何建设社会主义，如何巩固和发展社会主义的一系列基本问题，继承和发展了马克思主义\n  - 1997，十五大正式提出“邓小平理论”这一概念，确立为党的指导思想并写入党章\n  - 1999，宪法修正案正式将邓小平理论载入宪法\n\n#### 理论问题\n\n- 首要、基本的理论问题：在中国这样一个经济文化比较落后的国家建设什么样的社会主义，怎样建设社会主义\n- 社会主义本质\n  - 解放生产力\n  - 发展生产力（社会主义的根本任务是发展生产力）\n  - 消灭剥削\n  - 消除两极分化\n  - 达到共同富裕\n- 包括了生产力和生产关系的问题\n\n#### 精髓\n\n- **解放思想，实事求是**\n\n#### 主要内容\n\n- 社会主义初级阶段（建设中国特色社会主义的总依据）理论\n  - 一切从社会主义初级阶段的实际出发，将社会主义初级阶段作为事关全局的基本国情加以把握\n  - 含义\n    - 我国社会已经是社会主义社会（社会性质）\n    - 我国的社会主义社会还处于初级阶段（发展程度）\n  - 社会主义初级阶段具有长期性\n  - 基本特征\n    - 以农业人口占多数的手工劳动为基础的农业国，逐步变为非农产业人口占多数的现代化的工业国的阶段\n    - 自然经济半自然经济占很大比重，变为商品经济高度发达的阶段\n    - 通过改革和探索建立和发展充满活力的社会主义经济、政治，文化体制的阶段\n    - 全民奋起，艰苦创业，实现中华民族伟大复兴的阶段\n- 党在社会主义初级阶段的基本路线\n  - **领导和团结全国各族人民**（_领导力量和依靠力量_），以**经济建设为中心（根本任务），坚持四项基本原则（社会主义道路，人民民主专政，党的领导，马列毛思想）解放和发展生产力的政治保证），坚持改革开放（发展动力与外部条件）**（_基本途径_），**自力更生，艰苦创业**（_实现目标的根本立足点_），为把我国建设成为**富强（经济），民主（政治），文明（思想）的社会主义现代化国家**（_奋斗目标_）而奋斗\n  - “一个中心（经济建设），两个基本点（四项基本原则（立国之本），改革开放（强国之路））”\n- 社会主义的根本任务是发展生产力，党和国家的工作重点是经济建设\n  - 发展生产力离不开科学技术\n  - 改革是动力，发展是目的，稳定是前提\n- 分“三步走”基本实现现代化![[Pasted image 20240612214124.png|300]]\n- 社会主义改革开放理论与市场经济理论\n  - 社会主义市场经济：在社会主义制度条件下，让市场在资源配置中起决定作用\n    - 所有制结构：公有制为主体，多种所有制经济共同发展\n    - 宏观调控：市场在国家宏观调控下对资源配置起到决定性作用\n    - 分配制度：按劳分配为主体，多种分配形式并存\n- “两手抓，两手都要硬”（物质文明和精神文明）（建设和法治）（改革开放和惩治腐败）\n- “一国两制”与祖国统一\n- 中国特色社会主义外交和国际战略\n  - 基本目标：维护我国的独立和主权，促进世界的和平与发展\n  - 冷静观察，稳住阵脚，沉着应付\n- 党的建设\n  - 重视马克思主义理论学习\n  - 加强组织建设\n  - 加强领导班子建设\n  - 打好党风建设\n  - 重视制度建设\n- “三个有利于”：\n  - 是否有利于发展社会主义社会的生产力\n  - 是否有利于增强社会主义国家的综合国力\n  - 是否有利于提高人民的生活水平\n\n#### 重要意义\n\n- 马克思列宁主义，毛泽东思想的继承和发展\n- 中国特色社会主义理论体系的开篇之作\n- 改革开放和社会主义现代化建设的科学指南\n\n### “三个代表”重要思想形成背景与具体内容\n\n#### 背景与形成过程\n\n- 社会历史条件\n  - 国际背景：发生并经历重大变化，基于冷战结束后国际局势的科学判断\n    - 国际共运遭受重大挫折\n    - 处于两种社会制度对立，斗争的最前沿\n  - 历史条件（国内背景）：党的历史方位和党员队伍发生了深刻变化，基于科学判断党的历史方位和总结历史经验\n    - 领导人民为夺取全国政权而奋斗 $\\to$ 领导人民掌握全国政权并长期执政\n    - 受到外部封锁和实行计划经济条件下领导国家建设 $\\to$ 对外开放和发展社会主义市场经济条件下领导国家建设\n    - 党员队伍进入整体性交接的关键时刻\n      - 提高党的领导水平和执政水平\n      - 提高拒腐防变和抵御风险的能力\n      - 要求党从新的实际出发，以改革的精神加强和改进党的建设，使党在世界形势深刻变化的历史进程中始终走在时代前列\n  - 实践基础：在建设中国特色社会主义伟大实践的基础上形成的\n- “三个代表”重要思想发展过程\n  - 酝酿\n    - 1989.6 / 8 提出大力加强党的建设，惩治腐败的要求，发布《关于加强党的建设的通知》\n    - 1991.7，中国共产党成立 70 周年大会上深刻论述了进一步加强党的建设的问题\n    - 1992.10，党的十四大系统论述了加强党的建设和改善党的领导的问题\n  - 形成\n    - 1994，十四届四中全会通过了《关于加强党的建设几个重大问题的决定》\n    - 1997，党的十五大，高度概括了新时期党的建设新的伟大工程的总目标\n    - 2000.2，在广东考察，首次对“三个代表”进行了比较全面的阐述\n    - 2000.6，在全国党校工作会议上指出，“三个代表”重要思想回答和解决的事“建设什么样的党，怎样建设党”的问题\n  - 深度发展\n    - 2000.10，就“改进党的作风”发表重要讲话\n    - 2001.7，庆祝中国共产党成立 80 周年大会上的讲话中全面阐述了“三个代表”重要思想的科学内涵和基本内容\n    - 2002.11，党的十六大确立为指导思想，写入党章\n\n#### 核心观点\n\n- 中国共产党始终代表中国先进生产力的发展要求\n- 中国共产党始终代表中国先进文化的前进方向\n- 中国共产党始终代表中国最广大人民的根本利益\n\n#### 主要内容\n\n- 发展是党执政兴国的第一要务\n- 建立社会主义市场经济体制\n  - 毫不动摇巩固发展公有制经济\n  - 毫不动摇鼓励、支持、引导非公有制经济\n  - 本质要求：发挥市场机制的作用和国家宏观调控\n- 全面建设小康社会\n  - 两个百年奋斗目标\n- 建设社会主义政治文明\n- 实施“引进来”和“走出去”的对外开放战略\n- 推进党的建设新的伟大工程\n\n#### 历史地位\n\n- 中国特色社会主义理论体系的丰富发展\n- 加强和改进党的建设，推进中国特色社会主义事业的强大理论武器\n\n### 科学发展观的形成过程与具体内容\n\n#### 形成条件\n\n- 国际背景：\n  - 深刻分析国际形势\n  - 顺应世界发展趋势\n  - 借鉴国外发展经验\n- 历史条件\n  - 深刻把握我国国情和新的阶段性特征\n- 实践基础\n  - 总结改革开放尤其是十六大以来实践经验的基础\n\n#### 形成过程\n\n- 逐步形成：抗击非典疫情和探索未完善社会主义市场经济体制\n  - 2003.7，总结非典经验：全面发展，协调发展，可持续发展\n  - 2003.10，科学发展观\n- 充实丰富：加强和改善宏观调控的时间\n  - 十四届六中全会，树立和落实科学发展观作为提高党的执政能力的重要内容\n  - 十一五规划的建议 / 纲要：以科学发展观统领经济社会发展全局\n- 走向成熟\n- 发展完善：十七大后，不断发展完善\n  - 2008.12，在中央经济工作会议上强调，科学发展观第一要义是发展\n  - 十七届五中全会强调，坚持发展是硬道理的本质要求，就是坚持科学发展\n  - 2012，确立为指导思想\n\n#### 内涵\n\n- 推动经济社会**发展**是科学发展观的*第一要义* （为什么）\n- **以人为本**是科学发展观的*核心立场* （为了谁和依靠谁）\n- **全面协调可持续**是科学发展观的*基本要求* （实现什么样的发展）\n- **统筹兼顾**是科学发展观的*根本方法* （怎么发展）\n\n#### 精神实质\n\n- 解放思想，实事求是，与时俱进，求真务实\n\n#### 内容\n\n- 转变经济发展方式\n  - 持续健康发展\n  - 创新驱动发展战略\n  - 经济结构战略性调整\n  - 促进区域协调发展战略\n  - 城乡发展一体化\n- 发展社会主义民主政治\n  - 社会主义核心价值体系\n  - 社会主义核心价值观\n- 推进社会主义文化强国建设\n- 构建社会主义和谐社会\n- 推进生态文明建设\n- 全面提高党的建设科学化水平\n\n#### 历史地位\n\n- 中国特色社会主义理论体系在新世纪新阶段的接续发展\n- 全面建设小康社会，加快推进社会主义现代化的根本指针\n","slug":"毛概","published":1,"date":"2025-09-11T11:36:20.597Z","updated":"2025-09-11T11:36:20.597Z","comments":1,"layout":"post","photos":[],"_id":"cmffo52nu000c6xzdbgnhcr2e","content":"<h2\nid=\"毛概是什么马克思主义中国化时代化的历史进程和理论结果\">毛概是什么：马克思主义中国化时代化的历史进程和理论结果</h2>\n<ul>\n<li>什么是马克思主义中国化时代化：\n<ul>\n<li>运用马克思主义的立场、观点和方法，观察时代、把握时代、引领时代，解决中国革命、建设、改革中的实际问题。</li>\n<li>总结和提炼中国革命、建设、改革的实践经验并将其上升为理论，不断丰富和发展马克思主义的理论宝库，赋予马克思主义以新的时代内涵。</li>\n<li>用中国人民喜闻乐见的民族语言来阐述马克思主义理论，使之成为具有中国特色，中国风格，中国气派的马克思主义</li>\n</ul></li>\n<li>1938\n党的六届六中全会上，《论新阶段》的报告，标志着“马克思主义的中国化”这一命题的正式提出</li>\n<li>中共七大，刘少奇从理论上做出阐述</li>\n<li>内涵：马克思主义中国化时代化，就是立足<em>中国国情</em>和<em>时代特点</em>，坚持把马克思主义基本原理同中国<em>具体实际</em>相结合、同中华优秀<em>传统文化</em>相结合，深入研究和解决中国革命、建设、改革不同历史时期的实际问题，真正搞懂面临的时代课题，不断吸收新的时代内容，科学回答时代提出的重大理论和实践课题，创造新的理论成果。</li>\n</ul>\n<h2 id=\"马克思主义中国化的理论成果\">马克思主义中国化的理论成果</h2>\n<ul>\n<li>毛泽东思想</li>\n<li>中国特色社会主义理论体系</li>\n</ul>\n<h2\nid=\"马克思主义中国化理论成果的精髓实事求是\">马克思主义中国化理论成果的精髓：实事求是</h2>\n<h2 id=\"理论\">理论</h2>\n<h3 id=\"新民主主义革命理论\">新民主主义革命理论</h3>\n<ul>\n<li>认清中国国情是解决中国革命问题的<em>基本前提</em></li>\n<li>认清中国社会的性质，乃是认清一切革命问题的<em>基本的根据</em></li>\n</ul>\n<h4 id=\"何以形成\">何以形成</h4>\n<ul>\n<li>国情依据：近代中国是一个半殖民地半封建性质的社会\n<ul>\n<li>帝国主义列强进行政治，经济，文化的侵略，中国长期处于帝国主义国家的统治或半统治之下，没有完整的主权与国家的统一</li>\n<li>前述侵略使得自给自足的封建经济基础解体，但封建制度的根基：地主阶级对农民的剥削仍然存在，而且同买办资本和高利贷资本的剥削结合在了一起。</li>\n<li>主要矛盾：<strong>帝国主义和中华民族的矛盾</strong>（主要），封建主义和人民大众的矛盾</li>\n<li>根本任务：推翻帝国主义，封建主义和官僚资本主义的统治，争取民族独立和人民解放</li>\n</ul></li>\n<li>时代背景\n<ul>\n<li>1917 年十月革命，建立了第一个无产阶级专政的政权</li>\n<li>五四运动，中国无产阶级作为独立的政治力量成为革命的领导力量，马克思列宁主义逐步成为中国革命的指导思想，进入新民主主义革命阶段</li>\n</ul></li>\n<li>实践基础\n<ul>\n<li>旧民主主义革命的失败\n<ul>\n<li>旧式的农民战争</li>\n<li>不触动封建根基的自强运动和改良主义</li>\n<li>照搬西方资本主义的方案</li>\n</ul></li>\n<li>包含对上述失败教训的深刻总结</li>\n</ul></li>\n</ul>\n<h4 id=\"基本内容\">基本内容</h4>\n<ul>\n<li>提出\n<ul>\n<li>1939《中国革命和中国共产党》，第一次提出“新民主主义的革命”的概念</li>\n<li>1948《在晋绥干部会议上的讲话》完整总结和概括了新民主主义革命总路线的内容</li>\n</ul></li>\n<li>总路线：<strong>无产阶级领导的，人民大众的，反对帝国主义，封建主义和官僚资本主义的革命</strong>\n<ul>\n<li>无产阶级的领导权是中国革命的中心问题，也是新民主主义革命理论的核心问题，也是新民主主义革命区别于旧民主主义革命的根本标志\n<ul>\n<li>与先进的生产方式相联系，没有私人占有的生产资料，富有组织纪律性</li>\n<li>受“三座大山”的压迫</li>\n<li>集中分布在少数大城市和大企业，利于组织团结</li>\n<li>成员与农民间有天然的联系</li>\n</ul></li>\n<li>革命的对象：分清敌友，是革命的<em>首要问题</em>\n<ul>\n<li>帝国主义（中国革命的首要对象）\n<ul>\n<li>近代中国贫困落后和一切灾难祸害的总根源</li>\n<li>推翻帝国主义的压迫是中国走向独立和富强的前提</li>\n</ul></li>\n<li>封建主义\n<ul>\n<li>帝国主义统治中国和封建军阀实行专制统治的社会基础，是中国经济现代化和政治民主化的主要障碍</li>\n</ul></li>\n<li>官僚资本主义\n<ul>\n<li>对劳动人民 /\n民族工商业的巧取豪夺，严重束缚了中国社会生产力的发展。</li>\n</ul></li>\n</ul></li>\n<li>革命的任务\n<ul>\n<li>民族革命：对外推翻帝国主义的压迫</li>\n<li>民主革命：对内推翻封建地主阶级和官僚资产阶级的压迫</li>\n<li>相互区别，相互联系</li>\n</ul></li>\n<li>革命的动力\n<ul>\n<li>无产阶级：中国革命<em>最基本的动力</em>，中国革命的领导力量</li>\n<li>农民：中国革命的主力军，农民问题是中国革命的<em>基本问题</em>，<strong>新民主主义革命实质上就是党领导下的农民革命，中国革命战争实质上就是党领导下的农民战争</strong></li>\n<li>城市小资产阶级：无产阶级的可靠同盟者（广大知识分子，小商人，手工业者和自由职业者）</li>\n<li>民族资产阶级：带有两面性的阶级，一方面受压迫，一方面政治经济上又有联系，表现出明显的动摇性</li>\n</ul></li>\n</ul></li>\n<li>纲领（总路线的展开）\n<ul>\n<li>政治纲领：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的，以工农联盟为基础的，<em>各革命阶级联合专政</em>（国体）的新民主主义的共和国。（不同于欧美，也不同于苏联）\n<ul>\n<li>革命的根本问题是政权问题</li>\n<li>政体：民主集中制的人民代表大会制度</li>\n</ul></li>\n<li>经济纲领：“两没收，一保护”\n<ul>\n<li>没收封建地主阶级的土地归农民所有（进行土地革命，耕者有其田，扫除封建的剥削关系，解放农村生产力）</li>\n<li>没收官僚资本归新民主主义国家所有（建立具有社会主义性质的国营经济，使它居于领导地位，为建立新民主主义的国家政权实现向社会主义过渡奠定坚实的基础）</li>\n<li>保护民族工商业（保护，推动民族资本主义经济的发展，使它在发展现代技术，发展社会生产力，满足人民生活需要方面发挥作用，但不能让它操纵国计民生）</li>\n</ul></li>\n<li>文化纲领\n<ul>\n<li><strong>“民族的”</strong>：\n<ul>\n<li>内容上：反对帝国主义压迫，主张中华民族的尊严和独立</li>\n<li>形式上：具有鲜明的民族风格，民族形式和民族特色</li>\n</ul></li>\n<li><strong>“科学的”</strong>：\n<ul>\n<li>反对封建迷信，主张实事求是，客观真理，理论和实践的一致性</li>\n<li>历史唯物主义的态度对待古今中外文化，发展民族新文化，提高民族自信</li>\n</ul></li>\n<li><strong>“大众的”</strong>：\n<ul>\n<li>文化工作者要用革命文化教育和武装人民大众</li>\n<li>以人民群众的实践作为创作的源泉</li>\n<li>为人民大众服务</li>\n</ul></li>\n</ul></li>\n</ul></li>\n<li>道路：<strong>农村包围城市，武装夺取政权</strong>\n<ul>\n<li>成功原因\n<ul>\n<li>近代中国的社会性质，社会政治经济发展极端不平衡</li>\n<li>广大农村深受反动统治阶级的多重压迫和剥削，革命愿望强烈</li>\n<li>革命形势的变动</li>\n<li>正式红军的存在</li>\n<li>党的领导</li>\n</ul></li>\n<li>土地革命：是中国革命的基本内容</li>\n<li>农村革命根据地建设：是中国革命的战略阵地，进行武装斗争和土地革命的依托</li>\n<li>武装斗争：中国革命的主要形式，是上述两者的有力保证</li>\n</ul></li>\n<li>基本经验：三大法宝：统一战线，武装斗争，党的建设\n<ul>\n<li>统一战线和武装斗争：针对敌人，是武器\n<ul>\n<li>统一战线：采取区别对待的方针，发展进步势力，争取中间势力，孤立顽固势力</li>\n</ul></li>\n<li>党的建设：针对党自身，是掌握武器的人\n<ul>\n<li>思想建设放在首位</li>\n<li>三大优良作风：理论联系实际，密切联系群众，批评与自我批评相结合</li>\n</ul></li>\n</ul></li>\n</ul>\n<h4 id=\"意义\">意义</h4>\n<ul>\n<li>理论：极大地丰富了马克思主义的理论宝库，是马克思主义中国化时代化的重要理论成果，是对中国革命实际问题做出的分析和研究，是中国共产党集体智慧的结晶</li>\n<li>实践：在新民主主义革命理论的指导下，党团结带领人民完成了新民主主义革命，实现了民族独立和人民解放</li>\n<li>世界：极大改变了世界的政治格局，鼓舞了全世界人民争取解放，反对帝国主义斗争的信心，增强了世界人民争取和平的力量</li>\n</ul>\n<h3 id=\"社会主义改造理论\">社会主义改造理论</h3>\n<h4 id=\"过渡的依据\">过渡的依据</h4>\n<ul>\n<li>新民主主义社会是一个过渡性的社会\n<ul>\n<li>中华人民共和国成立 <span class=\"math inline\">→</span>\n社会主义改造基本完成是我国从新民主主义到社会主义的过渡时期，性质是新民主主义社会</li>\n<li>不是独立的社会形态，而是过渡性社会形态，由经济结构和社会主要矛盾决定</li>\n<li>经济结构\n<ul>\n<li>社会主义性质的国营经济</li>\n<li>半社会主义性质的合作社经济（个体 <span class=\"math inline\">→</span>\n国营）</li>\n<li>农民和手工业者的个体经济</li>\n<li>私人资本主义经济</li>\n<li>国家资本主义经济（私人 <span class=\"math inline\">→</span>\n国营）</li>\n</ul></li>\n<li>阶级构成\n<ul>\n<li>社会主义 <span class=\"math inline\">↔︎</span> 工人阶级</li>\n<li>个体经济 <span class=\"math inline\">↔︎</span>\n农民阶级和其他小资产阶级</li>\n<li>资本主义经济 <span class=\"math inline\">↔︎</span> 民族资产阶级</li>\n</ul></li>\n<li>主要矛盾\n<ul>\n<li>社会主义 <span class=\"math inline\">↔︎</span> 资本主义</li>\n<li>工人阶级 <span class=\"math inline\">↔︎</span> 资产阶级</li>\n</ul></li>\n</ul></li>\n<li>理论依据\n<ul>\n<li>马克思 / 恩格斯：科学社会主义理论\n<ul>\n<li>无产阶级利用自己的政治统治一步一步夺取资产阶级的全部资本，把一切生产工具集中在国家也即成为统治阶级的无产阶级手里，并尽可能增加生产力的宗量</li>\n</ul></li>\n<li>中国共产党人的理论：党的七届二中全会</li>\n</ul></li>\n<li>现实依据\n<ul>\n<li>经济：1949-1952，已经拥有了相对强大和迅速发展的社会主义国营经济，国家掌握了重要工矿企业，铁路，银行等国民经济的命脉，体现了国营经济相比其他成分的优越性。</li>\n<li>政治：新中国是工人阶级领导的以工农联盟为基础的人民民主专政的国家，马克思主义在思想文化领域处于指导地位，中国共产党执政并得到人民群众的广泛拥护</li>\n<li>国际形势：经过二战，资本主义国家也很不景气，尽管帝国主义国家对我国实施了军事上侵略威胁，经济上严密封锁，政治上孤立遏制等策略，但社会主义国家正充满向上发展的活力</li>\n</ul></li>\n</ul>\n<h4 id=\"如何过渡\">如何过渡</h4>\n<ul>\n<li>总路线与总任务（1953.6）\n<ul>\n<li>在一个相当长的时间内，逐步实现国家的社会主义工业化，并初步实现国家对农业、手工业和资本主义工商业的社会主义改造。</li>\n<li>实质：把生产资料的资本主义私有制改变成生产资料的社会主义公有制</li>\n</ul></li>\n<li>核心内容：“一化三改”\n<ul>\n<li>社会主义工业化</li>\n<li>对个体农业、手工业和资本主义工商业进行社会主义改造。\n<ul>\n<li>对农业的社会主义改造首先进行\n<ul>\n<li>积极领导，稳步前进的方针，循序渐进的步骤</li>\n<li>互助组（社会主义萌芽） <span class=\"math inline\">→</span>\n初级农业生产合作社（半社会主义性质） <span class=\"math inline\">→</span>\n高级农业生产合作社（完全社会主义性质）\n<ul>\n<li>互助组：解决生产上的困难，自愿基础上建立，分为临时与常年</li>\n<li>初级农业生产合作社：在互助组的基础上自愿组织，以土地入股，其他生产资料作价入社，实施统一经营，进行集体劳动，以按劳分配和土地入股分红相结合</li>\n<li>高级农业生产合作社：由初级社发展而成，规模更大，生产资料归集体所有，取消了土地报酬，实行按劳分配</li>\n</ul></li>\n</ul></li>\n<li>手工业的社会主义改造\n<ul>\n<li>积极领导，稳步前进</li>\n<li>通过合作化道路，把个体手工业经济改造为社会主义的集体所有制\n<ul>\n<li>个体手工业经济：建立在生产资料私有制和个体劳动基础上</li>\n</ul></li>\n<li>手工业供销小组（社会主义萌芽） <span class=\"math inline\">→</span>\n供销合作社（半社会主义性质） <span class=\"math inline\">→</span>\n生产合作社（社会主义性质）\n<ul>\n<li>手工业供销小组：独立手工业者 / 家庭手工业者由国营商业 /\n供销合作社供给原料和包销产品 / 推销成品，通过加工订货方式组织起来</li>\n<li>手工业供销合作社：随着供销业务的逐步扩大，手工业供销小组发展为合作社。</li>\n<li>手工业生产合作社：社会主义性质的集体经济组织，生产资料归集体所有，在计划指导下，根据市场需要灵活安排，集中\n/ 分散生产，流动服务，独立核算，自负盈亏。</li>\n</ul></li>\n<li>采取说服教育，典型示范和国家帮助的方法</li>\n</ul></li>\n<li>资本主义工商业的社会主义改造\n<ul>\n<li>和平赎买：国家有偿将私营企业变为国营企业（让企业家在一定年限内从企业经营所得中获取一部分利润）</li>\n<li>从低级到高级的过渡形式\n<ul>\n<li>具有社会主义因素的企业，实行初级形式的国家资本主义</li>\n<li>半社会主义性质的企业，实行个别企业的公私合营</li>\n<li>社会主义国营性质的企业，实现全行业的公私合营</li>\n</ul></li>\n<li>采取“包下来”的政策，把资本主义工商业者改造为自食其力的社会主义劳动者</li>\n</ul></li>\n</ul></li>\n</ul></li>\n<li>历史经验\n<ul>\n<li>坚持社会主义工业化建设和社会主义改造同时并举</li>\n<li>采取积极引导和逐步过渡的方式</li>\n<li>用和平方法进行改造</li>\n</ul></li>\n</ul>\n<h4 id=\"意义-1\">意义</h4>\n<ul>\n<li>社会主义基本经济制度确立的标志：1956 年底，三大改造完成</li>\n<li>社会主义基本制度确立的表现\n<ul>\n<li>经济：社会主义公有制成为经济基础\n<ul>\n<li>数千年的阶级剥削制度结束，社会主义制度确立</li>\n</ul></li>\n<li>政治：1954 年《宪法》\n<ul>\n<li>根本政治制度：人民代表大会制度</li>\n<li>基本政治制度：中国共产党领导的多党合作和政治协商制度</li>\n<li>标志着中国从新民主主义国家转变为社会主义国家</li>\n</ul></li>\n<li>社会关系\n<ul>\n<li>工人阶级成为国家的领导阶级</li>\n<li>亿万农民和其他个体劳动者成为社会主义的集体劳动者</li>\n</ul></li>\n</ul></li>\n<li>重大意义\n<ul>\n<li>中国历史上最深刻最伟大的变革\n<ul>\n<li>广大农民真正成为国家的主人</li>\n<li>奠定我国社会主义工业化的初步基础</li>\n</ul></li>\n<li>为当代中国一切发展奠定了制度基础，社会生产力的发展，初步显示了社会主义的优越性</li>\n<li>世界社会主义发展史上一个历史性的伟大胜利</li>\n<li>丰富和发展社会主义理论</li>\n</ul></li>\n<li>经验\n<ul>\n<li>实现伟大复兴，必须建立符合我国实际的先进生产制度</li>\n</ul></li>\n</ul>\n<h3\nid=\"社会主义建设道路初步探索的理论成果\">社会主义建设道路初步探索的理论成果</h3>\n<h4 id=\"理论成果\">理论成果</h4>\n<ul>\n<li>调动一切积极因素为社会主义事业服务（《论十大关系》探索中国特色社会主义建设道路的基本方针）\n<ul>\n<li>回答了如何建设和巩固社会主义的问题</li>\n<li>有利于最大限度团结全国各族人民，为建设社会主义现代化国家而奋斗</li>\n</ul></li>\n<li>正确认识和处理社会主义社会矛盾的思想\n<ul>\n<li>此时无产阶级同资产阶级之间的矛盾已基本解决，但仍面临着其他的矛盾</li>\n<li>社会主义社会的基本矛盾\n<ul>\n<li>生产力 <span class=\"math inline\">↔︎</span> 生产关系</li>\n<li>经济基础 <span class=\"math inline\">↔︎</span> 上层建筑</li>\n<li>与资本主义社会不同，两者的基本矛盾具有根本不同的性质与情况</li>\n<li>“又相适应，又相矛盾”</li>\n<li>非对抗性的矛盾</li>\n</ul></li>\n<li>社会主义社会的主要矛盾\n<ul>\n<li>人民对于经济文化迅速发展的需要</li>\n<li>当前经济文化不能满足人民需要的状况</li>\n<li>主要任务：集中力量发展社会生产力，实现国家工业化，逐步满足人民日益增长的物质和文化需要</li>\n</ul></li>\n<li>两类不同性质的矛盾\n<ul>\n<li>敌我矛盾\n<ul>\n<li>对抗性矛盾，分清敌我</li>\n<li>处理方法：专政</li>\n</ul></li>\n<li>人民内部矛盾\n<ul>\n<li>非对抗性矛盾，分清是非</li>\n<li>处理方法：民主</li>\n<li>处理方针：\n<ul>\n<li>政治思想领域 <span class=\"math inline\">↔︎</span>\n“团结-批评-团结”</li>\n<li>物质利益、分配 <span class=\"math inline\">↔︎</span>\n“统筹兼顾，适当安排”</li>\n<li>人民群众和政府机关 <span class=\"math inline\">↔︎</span>\n坚持民主集中制，克服政府机关的官僚主义，同时加强对群众的教育</li>\n<li>科学文化领域 <span class=\"math inline\">↔︎</span>\n“百花齐放，百家争鸣”</li>\n<li>共产党和民主党派 <span class=\"math inline\">↔︎</span>\n在坚持社会主义道路和共产党领导的前提下“长期共存，互相监督”</li>\n<li>民族矛盾 <span class=\"math inline\">↔︎</span> 民族平等，团结互助</li>\n</ul></li>\n</ul></li>\n</ul></li>\n<li>意义：\n<ul>\n<li>团结全国各族文明发展我们的经济，文化，巩固新制度，建设新国家</li>\n</ul></li>\n</ul></li>\n<li>走中国工业化道路的思想\n<ul>\n<li>为什么要\n<ul>\n<li>实现工业化是中国近代以来历史发展的必然要求，也是民族独立和国家富强的必要条件</li>\n<li>中华人民共和国的成立，为我国实现工业化提供了根本的政治前提</li>\n</ul></li>\n<li>背景\n<ul>\n<li>国内：工业基础薄弱</li>\n<li>国际：受苏联工业化模式影响，比例失调</li>\n</ul></li>\n<li>总方针：\n<ul>\n<li>以农业为基础，以工业为主导</li>\n<li>以农、轻、重为序发展国民经济</li>\n</ul></li>\n<li>“两条腿走路”工业化发展思路\n<ul>\n<li>重工业和轻工业同时并举</li>\n<li>中央工业和地方工业同时并举</li>\n<li>沿海工业和内地工业同时并举</li>\n<li>大型企业和中小型企业同时并举</li>\n</ul></li>\n<li>“两步走”发展战略\n<ul>\n<li>目标：把中国建设成为一个具有现代农业，现代工业，现代国防，现代国防技术的强国</li>\n<li>战略步骤\n<ul>\n<li>建成一个独立的比较完整的工业体系和国民经济体系</li>\n<li>全面实现工业，农业，国防和科学技术现代化，使中国走在世界前列</li>\n</ul></li>\n</ul></li>\n<li>要怎么做\n<ul>\n<li>正确的经济建设方针\n<ul>\n<li>党的八大：既反保守，又反冒进，坚持在综合平衡中稳步前进</li>\n</ul></li>\n<li>调整和完善所有制结构</li>\n<li>探索适合我国情况的经济体制和运行机制</li>\n</ul></li>\n</ul></li>\n<li>其他\n<ul>\n<li>四个现代化：现代化的工业，现代化的农业，现代化的交通运输业和现代化的国防</li>\n</ul></li>\n</ul>\n<h4 id=\"经验教训\">经验教训</h4>\n<ul>\n<li>意义\n<ul>\n<li>巩固和发展了我国的社会主义制度</li>\n<li>为开创中国特色社会主义提供了宝贵经验，理论准备和物质基础</li>\n<li>丰富了科学社会主义的理论和实践</li>\n</ul></li>\n<li>经验教训，“六个必须”\n<ul>\n<li>把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路</li>\n<li>正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力</li>\n<li>从实际出发进行社会主义建设，建设规模和速度要和国力相适应，不能急于求成</li>\n<li>发展社会主义民主，健全社会主义法治</li>\n<li>坚持党的民主集中制和集体领导制度，加强执政党建设</li>\n<li>坚持对外开放，借鉴和吸收人类文明成果建设社会主义</li>\n</ul></li>\n</ul>\n<h2 id=\"历程\">历程</h2>\n<h3 id=\"毛泽东的思想历程-毛泽东思想的形成发展过程\">毛泽东的思想历程 /\n毛泽东思想的形成发展过程</h3>\n<ul>\n<li>19 世纪末 20 世纪初，战争与革命成为时代的主题</li>\n<li>科学含义\n<ul>\n<li>马列主义在中国的运用和发展</li>\n<li>被实践证明了的关于中国革命建设的正确理论原则和经验总结</li>\n<li>中国共产党集体智慧的结晶</li>\n</ul></li>\n<li>中国革命战胜敌人的三大法宝：统一战线，武装斗争，党的建设</li>\n<li>主要内容与活的灵魂：==实事求是，群众路线，独立自主==\n<ul>\n<li>实事求是\n<ul>\n<li>从实际出发，把握客观规律</li>\n<li>清醒认识和正确把握我国基本国情</li>\n<li>推进实践基础上的理论创新</li>\n</ul></li>\n<li>群众路线\n<ul>\n<li>将“人民群众是历史的创造者”（<em>本质</em>）的原理用在党的活动中</li>\n<li>怎么做\n<ul>\n<li>坚持人民是推动历史发展的根本力量</li>\n<li>坚持全心全意为人民服务的根本宗旨</li>\n<li>保持党同人民群众的血肉联系</li>\n</ul></li>\n</ul></li>\n<li>独立自主（针对“左”倾教条主义倾向提出的）\n<ul>\n<li>中华民族的优良传统</li>\n<li>立党立国的重要原则</li>\n<li>外交一以贯之的</li>\n</ul></li>\n</ul></li>\n<li>形成和发展\n<ul>\n<li>形成时期：\n<ul>\n<li>第一次国内革命战争\n<ul>\n<li>《中国社会各阶级的分析》/《湖南农民运动考察报告》</li>\n<li>深刻分析中国社会各阶级在革命中的地位和作用</li>\n<li>提出了新民主主义革命的基本思想</li>\n</ul></li>\n<li>土地革命战争初期\n<ul>\n<li>《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》《反对本本主义》</li>\n<li>农村包围城市，武装夺取政权，中国革命道路理论</li>\n<li>毛泽东思想初步形成</li>\n</ul></li>\n</ul></li>\n<li>成熟时期\n<ul>\n<li>土地革命战争后期，抗日战争时期\n<ul>\n<li>《实践论》《矛盾论》《<共产党人>发刊词》《中国革命和中国共产党》《新民主主义论》</li>\n<li>实现了马克思主义与中国革命实际相结合的历史性飞跃</li>\n<li>毛泽东思想趋于成熟</li>\n</ul></li>\n<li>遵义会议，系统分析了党内左和右的思想根源</li>\n<li>确立指导思想：1945 年 4-6 月召开的党的七大将毛泽东思想写入党章</li>\n</ul></li>\n<li>继续发展\n<ul>\n<li>解放战争时期\n<ul>\n<li>《在中国共产党第七届中央委员会第二次全体会议上的报告》《论人民民主专政》</li>\n<li>人民民主专政理论</li>\n</ul></li>\n<li>新中国成立后\n<ul>\n<li>《论十大关系》《关于正确处理人民内部矛盾的问题》</li>\n<li>社会主义改造理论、建设理论</li>\n</ul></li>\n<li>毛泽东思想进一步丰富和发展</li>\n</ul></li>\n</ul></li>\n<li>历史地位\n<ul>\n<li>马克思主义中国化时代化的第一个重大理论成果</li>\n<li>中国革命和建设的科学指南</li>\n<li>中国共产党和中国人民宝贵的精神财富</li>\n</ul></li>\n<li>科学评价\n<ul>\n<li>完整准确理解和掌握毛泽东思想的科学体系</li>\n<li>坚持辩证唯物主义和历史唯物主义的原则和方法</li>\n<li>在实践中坚持和发展毛泽东思想</li>\n</ul></li>\n<li>辨析：毛泽东思想 <span class=\"math inline\">≠</span> 毛泽东个人的思想\n<ul>\n<li>被实践证明了的正确的理论原则和经验总结</li>\n<li>中国共产党集体智慧的结晶</li>\n<li>主要是“毛泽东同志的思想”，其他领导人也对毛泽东思想的形成和发展做出了重要贡献</li>\n</ul></li>\n</ul>\n<h3 id=\"邓小平理论\">邓小平理论</h3>\n<ul>\n<li><em>中国特色社会主义理论体系的开篇之作</em></li>\n</ul>\n<h4 id=\"邓小平理论的形成\">邓小平理论的形成</h4>\n<ul>\n<li>时代背景：和平与发展\n<ul>\n<li>和平：东西问题</li>\n<li>发展：南北问题</li>\n<li><strong>发展是核心问题</strong></li>\n</ul></li>\n<li>历史依据：社会主义建设的经验教训\n<ul>\n<li>社会主义建设实践中的正确主张在改革开放后得到真正贯彻</li>\n<li>社会主义建设经历的曲折和失误促使党和人民进行深刻反思</li>\n</ul></li>\n<li>现实依据：改革开放和现代化建设的实践</li>\n<li>形成过程\n<ul>\n<li>“文革”结束后，邓小平强调实事求是是毛泽东思想的精髓，旗帜鲜明反对“两个凡是”的错误观点，支持领导开展真理标准问题的打讨论，推进各方面的拨乱反正</li>\n<li>1978，党的十一届三中全会确定了解放思想，实事求是的思想路线，停止“以阶级斗争为纲”的错误，将全党工作的重点转移到社会主义现代化建设上来，做出改革开放的重大决策，实现了党的历史上具有深远意义的伟大转折。</li>\n<li>1982，党的“十二大”提出“中国特色社会主义”，并成为党的全部理论和实践创新的主题</li>\n<li>1984，《中共中央关于经济体制改革的决定》——社会主义经济是在公有制基础上的有计划的商品经济</li>\n<li>1987，党的十三大，系统论述了我国社会主义初级阶段理论，明确概括和全面阐发了党“一个中心，两个基本点”的基本路线，对中国特色社会主义理论的主要内容做了系统概括，标志着邓小平理论轮廓的形成</li>\n<li>1992，南方谈话，重申深化改革、加速发展的必要性和重要性，从理论上解答了当时困扰和束缚人们思想的一系列重大问题，邓小平理论走向成熟；党的十四大强调中国特色社会主义理论第一次比较系统地初步回答了中国这样的社会经济文化比较落后的国家如何建设社会主义，如何巩固和发展社会主义的一系列基本问题，继承和发展了马克思主义</li>\n<li>1997，十五大正式提出“邓小平理论”这一概念，确立为党的指导思想并写入党章</li>\n<li>1999，宪法修正案正式将邓小平理论载入宪法</li>\n</ul></li>\n</ul>\n<h4 id=\"理论问题\">理论问题</h4>\n<ul>\n<li>首要、基本的理论问题：在中国这样一个经济文化比较落后的国家建设什么样的社会主义，怎样建设社会主义</li>\n<li>社会主义本质\n<ul>\n<li>解放生产力</li>\n<li>发展生产力（社会主义的根本任务是发展生产力）</li>\n<li>消灭剥削</li>\n<li>消除两极分化</li>\n<li>达到共同富裕</li>\n</ul></li>\n<li>包括了生产力和生产关系的问题</li>\n</ul>\n<h4 id=\"精髓\">精髓</h4>\n<ul>\n<li><strong>解放思想，实事求是</strong></li>\n</ul>\n<h4 id=\"主要内容\">主要内容</h4>\n<ul>\n<li>社会主义初级阶段（建设中国特色社会主义的总依据）理论\n<ul>\n<li>一切从社会主义初级阶段的实际出发，将社会主义初级阶段作为事关全局的基本国情加以把握</li>\n<li>含义\n<ul>\n<li>我国社会已经是社会主义社会（社会性质）</li>\n<li>我国的社会主义社会还处于初级阶段（发展程度）</li>\n</ul></li>\n<li>社会主义初级阶段具有长期性</li>\n<li>基本特征\n<ul>\n<li>以农业人口占多数的手工劳动为基础的农业国，逐步变为非农产业人口占多数的现代化的工业国的阶段</li>\n<li>自然经济半自然经济占很大比重，变为商品经济高度发达的阶段</li>\n<li>通过改革和探索建立和发展充满活力的社会主义经济、政治，文化体制的阶段</li>\n<li>全民奋起，艰苦创业，实现中华民族伟大复兴的阶段</li>\n</ul></li>\n</ul></li>\n<li>党在社会主义初级阶段的基本路线\n<ul>\n<li><strong>领导和团结全国各族人民</strong>（<em>领导力量和依靠力量</em>），以<strong>经济建设为中心（根本任务），坚持四项基本原则（社会主义道路，人民民主专政，党的领导，马列毛思想）解放和发展生产力的政治保证），坚持改革开放（发展动力与外部条件）</strong>（<em>基本途径</em>），<strong>自力更生，艰苦创业</strong>（<em>实现目标的根本立足点</em>），为把我国建设成为<strong>富强（经济），民主（政治），文明（思想）的社会主义现代化国家</strong>（<em>奋斗目标</em>）而奋斗</li>\n<li>“一个中心（经济建设），两个基本点（四项基本原则（立国之本），改革开放（强国之路））”</li>\n</ul></li>\n<li>社会主义的根本任务是发展生产力，党和国家的工作重点是经济建设\n<ul>\n<li>发展生产力离不开科学技术</li>\n<li>改革是动力，发展是目的，稳定是前提</li>\n</ul></li>\n<li>分“三步走”基本实现现代化![[Pasted image\n20240612214124.png|300]]</li>\n<li>社会主义改革开放理论与市场经济理论\n<ul>\n<li>社会主义市场经济：在社会主义制度条件下，让市场在资源配置中起决定作用\n<ul>\n<li>所有制结构：公有制为主体，多种所有制经济共同发展</li>\n<li>宏观调控：市场在国家宏观调控下对资源配置起到决定性作用</li>\n<li>分配制度：按劳分配为主体，多种分配形式并存</li>\n</ul></li>\n</ul></li>\n<li>“两手抓，两手都要硬”（物质文明和精神文明）（建设和法治）（改革开放和惩治腐败）</li>\n<li>“一国两制”与祖国统一</li>\n<li>中国特色社会主义外交和国际战略\n<ul>\n<li>基本目标：维护我国的独立和主权，促进世界的和平与发展</li>\n<li>冷静观察，稳住阵脚，沉着应付</li>\n</ul></li>\n<li>党的建设\n<ul>\n<li>重视马克思主义理论学习</li>\n<li>加强组织建设</li>\n<li>加强领导班子建设</li>\n<li>打好党风建设</li>\n<li>重视制度建设</li>\n</ul></li>\n<li>“三个有利于”：\n<ul>\n<li>是否有利于发展社会主义社会的生产力</li>\n<li>是否有利于增强社会主义国家的综合国力</li>\n<li>是否有利于提高人民的生活水平</li>\n</ul></li>\n</ul>\n<h4 id=\"重要意义\">重要意义</h4>\n<ul>\n<li>马克思列宁主义，毛泽东思想的继承和发展</li>\n<li>中国特色社会主义理论体系的开篇之作</li>\n<li>改革开放和社会主义现代化建设的科学指南</li>\n</ul>\n<h3\nid=\"三个代表重要思想形成背景与具体内容\">“三个代表”重要思想形成背景与具体内容</h3>\n<h4 id=\"背景与形成过程\">背景与形成过程</h4>\n<ul>\n<li>社会历史条件\n<ul>\n<li>国际背景：发生并经历重大变化，基于冷战结束后国际局势的科学判断\n<ul>\n<li>国际共运遭受重大挫折</li>\n<li>处于两种社会制度对立，斗争的最前沿</li>\n</ul></li>\n<li>历史条件（国内背景）：党的历史方位和党员队伍发生了深刻变化，基于科学判断党的历史方位和总结历史经验\n<ul>\n<li>领导人民为夺取全国政权而奋斗 <span class=\"math inline\">→</span>\n领导人民掌握全国政权并长期执政</li>\n<li>受到外部封锁和实行计划经济条件下领导国家建设 <span\nclass=\"math inline\">→</span>\n对外开放和发展社会主义市场经济条件下领导国家建设</li>\n<li>党员队伍进入整体性交接的关键时刻\n<ul>\n<li>提高党的领导水平和执政水平</li>\n<li>提高拒腐防变和抵御风险的能力</li>\n<li>要求党从新的实际出发，以改革的精神加强和改进党的建设，使党在世界形势深刻变化的历史进程中始终走在时代前列</li>\n</ul></li>\n</ul></li>\n<li>实践基础：在建设中国特色社会主义伟大实践的基础上形成的</li>\n</ul></li>\n<li>“三个代表”重要思想发展过程\n<ul>\n<li>酝酿\n<ul>\n<li>1989.6 / 8\n提出大力加强党的建设，惩治腐败的要求，发布《关于加强党的建设的通知》</li>\n<li>1991.7，中国共产党成立 70\n周年大会上深刻论述了进一步加强党的建设的问题</li>\n<li>1992.10，党的十四大系统论述了加强党的建设和改善党的领导的问题</li>\n</ul></li>\n<li>形成\n<ul>\n<li>1994，十四届四中全会通过了《关于加强党的建设几个重大问题的决定》</li>\n<li>1997，党的十五大，高度概括了新时期党的建设新的伟大工程的总目标</li>\n<li>2000.2，在广东考察，首次对“三个代表”进行了比较全面的阐述</li>\n<li>2000.6，在全国党校工作会议上指出，“三个代表”重要思想回答和解决的事“建设什么样的党，怎样建设党”的问题</li>\n</ul></li>\n<li>深度发展\n<ul>\n<li>2000.10，就“改进党的作风”发表重要讲话</li>\n<li>2001.7，庆祝中国共产党成立 80\n周年大会上的讲话中全面阐述了“三个代表”重要思想的科学内涵和基本内容</li>\n<li>2002.11，党的十六大确立为指导思想，写入党章</li>\n</ul></li>\n</ul></li>\n</ul>\n<h4 id=\"核心观点\">核心观点</h4>\n<ul>\n<li>中国共产党始终代表中国先进生产力的发展要求</li>\n<li>中国共产党始终代表中国先进文化的前进方向</li>\n<li>中国共产党始终代表中国最广大人民的根本利益</li>\n</ul>\n<h4 id=\"主要内容-1\">主要内容</h4>\n<ul>\n<li>发展是党执政兴国的第一要务</li>\n<li>建立社会主义市场经济体制\n<ul>\n<li>毫不动摇巩固发展公有制经济</li>\n<li>毫不动摇鼓励、支持、引导非公有制经济</li>\n<li>本质要求：发挥市场机制的作用和国家宏观调控</li>\n</ul></li>\n<li>全面建设小康社会\n<ul>\n<li>两个百年奋斗目标</li>\n</ul></li>\n<li>建设社会主义政治文明</li>\n<li>实施“引进来”和“走出去”的对外开放战略</li>\n<li>推进党的建设新的伟大工程</li>\n</ul>\n<h4 id=\"历史地位\">历史地位</h4>\n<ul>\n<li>中国特色社会主义理论体系的丰富发展</li>\n<li>加强和改进党的建设，推进中国特色社会主义事业的强大理论武器</li>\n</ul>\n<h3\nid=\"科学发展观的形成过程与具体内容\">科学发展观的形成过程与具体内容</h3>\n<h4 id=\"形成条件\">形成条件</h4>\n<ul>\n<li>国际背景：\n<ul>\n<li>深刻分析国际形势</li>\n<li>顺应世界发展趋势</li>\n<li>借鉴国外发展经验</li>\n</ul></li>\n<li>历史条件\n<ul>\n<li>深刻把握我国国情和新的阶段性特征</li>\n</ul></li>\n<li>实践基础\n<ul>\n<li>总结改革开放尤其是十六大以来实践经验的基础</li>\n</ul></li>\n</ul>\n<h4 id=\"形成过程\">形成过程</h4>\n<ul>\n<li>逐步形成：抗击非典疫情和探索未完善社会主义市场经济体制\n<ul>\n<li>2003.7，总结非典经验：全面发展，协调发展，可持续发展</li>\n<li>2003.10，科学发展观</li>\n</ul></li>\n<li>充实丰富：加强和改善宏观调控的时间\n<ul>\n<li>十四届六中全会，树立和落实科学发展观作为提高党的执政能力的重要内容</li>\n<li>十一五规划的建议 / 纲要：以科学发展观统领经济社会发展全局</li>\n</ul></li>\n<li>走向成熟</li>\n<li>发展完善：十七大后，不断发展完善\n<ul>\n<li>2008.12，在中央经济工作会议上强调，科学发展观第一要义是发展</li>\n<li>十七届五中全会强调，坚持发展是硬道理的本质要求，就是坚持科学发展</li>\n<li>2012，确立为指导思想</li>\n</ul></li>\n</ul>\n<h4 id=\"内涵\">内涵</h4>\n<ul>\n<li>推动经济社会<strong>发展</strong>是科学发展观的<em>第一要义</em>\n（为什么）</li>\n<li><strong>以人为本</strong>是科学发展观的<em>核心立场</em>\n（为了谁和依靠谁）</li>\n<li><strong>全面协调可持续</strong>是科学发展观的<em>基本要求</em>\n（实现什么样的发展）</li>\n<li><strong>统筹兼顾</strong>是科学发展观的<em>根本方法</em>\n（怎么发展）</li>\n</ul>\n<h4 id=\"精神实质\">精神实质</h4>\n<ul>\n<li>解放思想，实事求是，与时俱进，求真务实</li>\n</ul>\n<h4 id=\"内容\">内容</h4>\n<ul>\n<li>转变经济发展方式\n<ul>\n<li>持续健康发展</li>\n<li>创新驱动发展战略</li>\n<li>经济结构战略性调整</li>\n<li>促进区域协调发展战略</li>\n<li>城乡发展一体化</li>\n</ul></li>\n<li>发展社会主义民主政治\n<ul>\n<li>社会主义核心价值体系</li>\n<li>社会主义核心价值观</li>\n</ul></li>\n<li>推进社会主义文化强国建设</li>\n<li>构建社会主义和谐社会</li>\n<li>推进生态文明建设</li>\n<li>全面提高党的建设科学化水平</li>\n</ul>\n<h4 id=\"历史地位-1\">历史地位</h4>\n<ul>\n<li>中国特色社会主义理论体系在新世纪新阶段的接续发展</li>\n<li>全面建设小康社会，加快推进社会主义现代化的根本指针</li>\n</ul>\n","excerpt":"","more":"<h2\nid=\"毛概是什么马克思主义中国化时代化的历史进程和理论结果\">毛概是什么：马克思主义中国化时代化的历史进程和理论结果</h2>\n<ul>\n<li>什么是马克思主义中国化时代化：\n<ul>\n<li>运用马克思主义的立场、观点和方法，观察时代、把握时代、引领时代，解决中国革命、建设、改革中的实际问题。</li>\n<li>总结和提炼中国革命、建设、改革的实践经验并将其上升为理论，不断丰富和发展马克思主义的理论宝库，赋予马克思主义以新的时代内涵。</li>\n<li>用中国人民喜闻乐见的民族语言来阐述马克思主义理论，使之成为具有中国特色，中国风格，中国气派的马克思主义</li>\n</ul></li>\n<li>1938\n党的六届六中全会上，《论新阶段》的报告，标志着“马克思主义的中国化”这一命题的正式提出</li>\n<li>中共七大，刘少奇从理论上做出阐述</li>\n<li>内涵：马克思主义中国化时代化，就是立足<em>中国国情</em>和<em>时代特点</em>，坚持把马克思主义基本原理同中国<em>具体实际</em>相结合、同中华优秀<em>传统文化</em>相结合，深入研究和解决中国革命、建设、改革不同历史时期的实际问题，真正搞懂面临的时代课题，不断吸收新的时代内容，科学回答时代提出的重大理论和实践课题，创造新的理论成果。</li>\n</ul>\n<h2 id=\"马克思主义中国化的理论成果\">马克思主义中国化的理论成果</h2>\n<ul>\n<li>毛泽东思想</li>\n<li>中国特色社会主义理论体系</li>\n</ul>\n<h2\nid=\"马克思主义中国化理论成果的精髓实事求是\">马克思主义中国化理论成果的精髓：实事求是</h2>\n<h2 id=\"理论\">理论</h2>\n<h3 id=\"新民主主义革命理论\">新民主主义革命理论</h3>\n<ul>\n<li>认清中国国情是解决中国革命问题的<em>基本前提</em></li>\n<li>认清中国社会的性质，乃是认清一切革命问题的<em>基本的根据</em></li>\n</ul>\n<h4 id=\"何以形成\">何以形成</h4>\n<ul>\n<li>国情依据：近代中国是一个半殖民地半封建性质的社会\n<ul>\n<li>帝国主义列强进行政治，经济，文化的侵略，中国长期处于帝国主义国家的统治或半统治之下，没有完整的主权与国家的统一</li>\n<li>前述侵略使得自给自足的封建经济基础解体，但封建制度的根基：地主阶级对农民的剥削仍然存在，而且同买办资本和高利贷资本的剥削结合在了一起。</li>\n<li>主要矛盾：<strong>帝国主义和中华民族的矛盾</strong>（主要），封建主义和人民大众的矛盾</li>\n<li>根本任务：推翻帝国主义，封建主义和官僚资本主义的统治，争取民族独立和人民解放</li>\n</ul></li>\n<li>时代背景\n<ul>\n<li>1917 年十月革命，建立了第一个无产阶级专政的政权</li>\n<li>五四运动，中国无产阶级作为独立的政治力量成为革命的领导力量，马克思列宁主义逐步成为中国革命的指导思想，进入新民主主义革命阶段</li>\n</ul></li>\n<li>实践基础\n<ul>\n<li>旧民主主义革命的失败\n<ul>\n<li>旧式的农民战争</li>\n<li>不触动封建根基的自强运动和改良主义</li>\n<li>照搬西方资本主义的方案</li>\n</ul></li>\n<li>包含对上述失败教训的深刻总结</li>\n</ul></li>\n</ul>\n<h4 id=\"基本内容\">基本内容</h4>\n<ul>\n<li>提出\n<ul>\n<li>1939《中国革命和中国共产党》，第一次提出“新民主主义的革命”的概念</li>\n<li>1948《在晋绥干部会议上的讲话》完整总结和概括了新民主主义革命总路线的内容</li>\n</ul></li>\n<li>总路线：<strong>无产阶级领导的，人民大众的，反对帝国主义，封建主义和官僚资本主义的革命</strong>\n<ul>\n<li>无产阶级的领导权是中国革命的中心问题，也是新民主主义革命理论的核心问题，也是新民主主义革命区别于旧民主主义革命的根本标志\n<ul>\n<li>与先进的生产方式相联系，没有私人占有的生产资料，富有组织纪律性</li>\n<li>受“三座大山”的压迫</li>\n<li>集中分布在少数大城市和大企业，利于组织团结</li>\n<li>成员与农民间有天然的联系</li>\n</ul></li>\n<li>革命的对象：分清敌友，是革命的<em>首要问题</em>\n<ul>\n<li>帝国主义（中国革命的首要对象）\n<ul>\n<li>近代中国贫困落后和一切灾难祸害的总根源</li>\n<li>推翻帝国主义的压迫是中国走向独立和富强的前提</li>\n</ul></li>\n<li>封建主义\n<ul>\n<li>帝国主义统治中国和封建军阀实行专制统治的社会基础，是中国经济现代化和政治民主化的主要障碍</li>\n</ul></li>\n<li>官僚资本主义\n<ul>\n<li>对劳动人民 /\n民族工商业的巧取豪夺，严重束缚了中国社会生产力的发展。</li>\n</ul></li>\n</ul></li>\n<li>革命的任务\n<ul>\n<li>民族革命：对外推翻帝国主义的压迫</li>\n<li>民主革命：对内推翻封建地主阶级和官僚资产阶级的压迫</li>\n<li>相互区别，相互联系</li>\n</ul></li>\n<li>革命的动力\n<ul>\n<li>无产阶级：中国革命<em>最基本的动力</em>，中国革命的领导力量</li>\n<li>农民：中国革命的主力军，农民问题是中国革命的<em>基本问题</em>，<strong>新民主主义革命实质上就是党领导下的农民革命，中国革命战争实质上就是党领导下的农民战争</strong></li>\n<li>城市小资产阶级：无产阶级的可靠同盟者（广大知识分子，小商人，手工业者和自由职业者）</li>\n<li>民族资产阶级：带有两面性的阶级，一方面受压迫，一方面政治经济上又有联系，表现出明显的动摇性</li>\n</ul></li>\n</ul></li>\n<li>纲领（总路线的展开）\n<ul>\n<li>政治纲领：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的，以工农联盟为基础的，<em>各革命阶级联合专政</em>（国体）的新民主主义的共和国。（不同于欧美，也不同于苏联）\n<ul>\n<li>革命的根本问题是政权问题</li>\n<li>政体：民主集中制的人民代表大会制度</li>\n</ul></li>\n<li>经济纲领：“两没收，一保护”\n<ul>\n<li>没收封建地主阶级的土地归农民所有（进行土地革命，耕者有其田，扫除封建的剥削关系，解放农村生产力）</li>\n<li>没收官僚资本归新民主主义国家所有（建立具有社会主义性质的国营经济，使它居于领导地位，为建立新民主主义的国家政权实现向社会主义过渡奠定坚实的基础）</li>\n<li>保护民族工商业（保护，推动民族资本主义经济的发展，使它在发展现代技术，发展社会生产力，满足人民生活需要方面发挥作用，但不能让它操纵国计民生）</li>\n</ul></li>\n<li>文化纲领\n<ul>\n<li><strong>“民族的”</strong>：\n<ul>\n<li>内容上：反对帝国主义压迫，主张中华民族的尊严和独立</li>\n<li>形式上：具有鲜明的民族风格，民族形式和民族特色</li>\n</ul></li>\n<li><strong>“科学的”</strong>：\n<ul>\n<li>反对封建迷信，主张实事求是，客观真理，理论和实践的一致性</li>\n<li>历史唯物主义的态度对待古今中外文化，发展民族新文化，提高民族自信</li>\n</ul></li>\n<li><strong>“大众的”</strong>：\n<ul>\n<li>文化工作者要用革命文化教育和武装人民大众</li>\n<li>以人民群众的实践作为创作的源泉</li>\n<li>为人民大众服务</li>\n</ul></li>\n</ul></li>\n</ul></li>\n<li>道路：<strong>农村包围城市，武装夺取政权</strong>\n<ul>\n<li>成功原因\n<ul>\n<li>近代中国的社会性质，社会政治经济发展极端不平衡</li>\n<li>广大农村深受反动统治阶级的多重压迫和剥削，革命愿望强烈</li>\n<li>革命形势的变动</li>\n<li>正式红军的存在</li>\n<li>党的领导</li>\n</ul></li>\n<li>土地革命：是中国革命的基本内容</li>\n<li>农村革命根据地建设：是中国革命的战略阵地，进行武装斗争和土地革命的依托</li>\n<li>武装斗争：中国革命的主要形式，是上述两者的有力保证</li>\n</ul></li>\n<li>基本经验：三大法宝：统一战线，武装斗争，党的建设\n<ul>\n<li>统一战线和武装斗争：针对敌人，是武器\n<ul>\n<li>统一战线：采取区别对待的方针，发展进步势力，争取中间势力，孤立顽固势力</li>\n</ul></li>\n<li>党的建设：针对党自身，是掌握武器的人\n<ul>\n<li>思想建设放在首位</li>\n<li>三大优良作风：理论联系实际，密切联系群众，批评与自我批评相结合</li>\n</ul></li>\n</ul></li>\n</ul>\n<h4 id=\"意义\">意义</h4>\n<ul>\n<li>理论：极大地丰富了马克思主义的理论宝库，是马克思主义中国化时代化的重要理论成果，是对中国革命实际问题做出的分析和研究，是中国共产党集体智慧的结晶</li>\n<li>实践：在新民主主义革命理论的指导下，党团结带领人民完成了新民主主义革命，实现了民族独立和人民解放</li>\n<li>世界：极大改变了世界的政治格局，鼓舞了全世界人民争取解放，反对帝国主义斗争的信心，增强了世界人民争取和平的力量</li>\n</ul>\n<h3 id=\"社会主义改造理论\">社会主义改造理论</h3>\n<h4 id=\"过渡的依据\">过渡的依据</h4>\n<ul>\n<li>新民主主义社会是一个过渡性的社会\n<ul>\n<li>中华人民共和国成立 <span class=\"math inline\">→</span>\n社会主义改造基本完成是我国从新民主主义到社会主义的过渡时期，性质是新民主主义社会</li>\n<li>不是独立的社会形态，而是过渡性社会形态，由经济结构和社会主要矛盾决定</li>\n<li>经济结构\n<ul>\n<li>社会主义性质的国营经济</li>\n<li>半社会主义性质的合作社经济（个体 <span class=\"math inline\">→</span>\n国营）</li>\n<li>农民和手工业者的个体经济</li>\n<li>私人资本主义经济</li>\n<li>国家资本主义经济（私人 <span class=\"math inline\">→</span>\n国营）</li>\n</ul></li>\n<li>阶级构成\n<ul>\n<li>社会主义 <span class=\"math inline\">↔︎</span> 工人阶级</li>\n<li>个体经济 <span class=\"math inline\">↔︎</span>\n农民阶级和其他小资产阶级</li>\n<li>资本主义经济 <span class=\"math inline\">↔︎</span> 民族资产阶级</li>\n</ul></li>\n<li>主要矛盾\n<ul>\n<li>社会主义 <span class=\"math inline\">↔︎</span> 资本主义</li>\n<li>工人阶级 <span class=\"math inline\">↔︎</span> 资产阶级</li>\n</ul></li>\n</ul></li>\n<li>理论依据\n<ul>\n<li>马克思 / 恩格斯：科学社会主义理论\n<ul>\n<li>无产阶级利用自己的政治统治一步一步夺取资产阶级的全部资本，把一切生产工具集中在国家也即成为统治阶级的无产阶级手里，并尽可能增加生产力的宗量</li>\n</ul></li>\n<li>中国共产党人的理论：党的七届二中全会</li>\n</ul></li>\n<li>现实依据\n<ul>\n<li>经济：1949-1952，已经拥有了相对强大和迅速发展的社会主义国营经济，国家掌握了重要工矿企业，铁路，银行等国民经济的命脉，体现了国营经济相比其他成分的优越性。</li>\n<li>政治：新中国是工人阶级领导的以工农联盟为基础的人民民主专政的国家，马克思主义在思想文化领域处于指导地位，中国共产党执政并得到人民群众的广泛拥护</li>\n<li>国际形势：经过二战，资本主义国家也很不景气，尽管帝国主义国家对我国实施了军事上侵略威胁，经济上严密封锁，政治上孤立遏制等策略，但社会主义国家正充满向上发展的活力</li>\n</ul></li>\n</ul>\n<h4 id=\"如何过渡\">如何过渡</h4>\n<ul>\n<li>总路线与总任务（1953.6）\n<ul>\n<li>在一个相当长的时间内，逐步实现国家的社会主义工业化，并初步实现国家对农业、手工业和资本主义工商业的社会主义改造。</li>\n<li>实质：把生产资料的资本主义私有制改变成生产资料的社会主义公有制</li>\n</ul></li>\n<li>核心内容：“一化三改”\n<ul>\n<li>社会主义工业化</li>\n<li>对个体农业、手工业和资本主义工商业进行社会主义改造。\n<ul>\n<li>对农业的社会主义改造首先进行\n<ul>\n<li>积极领导，稳步前进的方针，循序渐进的步骤</li>\n<li>互助组（社会主义萌芽） <span class=\"math inline\">→</span>\n初级农业生产合作社（半社会主义性质） <span class=\"math inline\">→</span>\n高级农业生产合作社（完全社会主义性质）\n<ul>\n<li>互助组：解决生产上的困难，自愿基础上建立，分为临时与常年</li>\n<li>初级农业生产合作社：在互助组的基础上自愿组织，以土地入股，其他生产资料作价入社，实施统一经营，进行集体劳动，以按劳分配和土地入股分红相结合</li>\n<li>高级农业生产合作社：由初级社发展而成，规模更大，生产资料归集体所有，取消了土地报酬，实行按劳分配</li>\n</ul></li>\n</ul></li>\n<li>手工业的社会主义改造\n<ul>\n<li>积极领导，稳步前进</li>\n<li>通过合作化道路，把个体手工业经济改造为社会主义的集体所有制\n<ul>\n<li>个体手工业经济：建立在生产资料私有制和个体劳动基础上</li>\n</ul></li>\n<li>手工业供销小组（社会主义萌芽） <span class=\"math inline\">→</span>\n供销合作社（半社会主义性质） <span class=\"math inline\">→</span>\n生产合作社（社会主义性质）\n<ul>\n<li>手工业供销小组：独立手工业者 / 家庭手工业者由国营商业 /\n供销合作社供给原料和包销产品 / 推销成品，通过加工订货方式组织起来</li>\n<li>手工业供销合作社：随着供销业务的逐步扩大，手工业供销小组发展为合作社。</li>\n<li>手工业生产合作社：社会主义性质的集体经济组织，生产资料归集体所有，在计划指导下，根据市场需要灵活安排，集中\n/ 分散生产，流动服务，独立核算，自负盈亏。</li>\n</ul></li>\n<li>采取说服教育，典型示范和国家帮助的方法</li>\n</ul></li>\n<li>资本主义工商业的社会主义改造\n<ul>\n<li>和平赎买：国家有偿将私营企业变为国营企业（让企业家在一定年限内从企业经营所得中获取一部分利润）</li>\n<li>从低级到高级的过渡形式\n<ul>\n<li>具有社会主义因素的企业，实行初级形式的国家资本主义</li>\n<li>半社会主义性质的企业，实行个别企业的公私合营</li>\n<li>社会主义国营性质的企业，实现全行业的公私合营</li>\n</ul></li>\n<li>采取“包下来”的政策，把资本主义工商业者改造为自食其力的社会主义劳动者</li>\n</ul></li>\n</ul></li>\n</ul></li>\n<li>历史经验\n<ul>\n<li>坚持社会主义工业化建设和社会主义改造同时并举</li>\n<li>采取积极引导和逐步过渡的方式</li>\n<li>用和平方法进行改造</li>\n</ul></li>\n</ul>\n<h4 id=\"意义-1\">意义</h4>\n<ul>\n<li>社会主义基本经济制度确立的标志：1956 年底，三大改造完成</li>\n<li>社会主义基本制度确立的表现\n<ul>\n<li>经济：社会主义公有制成为经济基础\n<ul>\n<li>数千年的阶级剥削制度结束，社会主义制度确立</li>\n</ul></li>\n<li>政治：1954 年《宪法》\n<ul>\n<li>根本政治制度：人民代表大会制度</li>\n<li>基本政治制度：中国共产党领导的多党合作和政治协商制度</li>\n<li>标志着中国从新民主主义国家转变为社会主义国家</li>\n</ul></li>\n<li>社会关系\n<ul>\n<li>工人阶级成为国家的领导阶级</li>\n<li>亿万农民和其他个体劳动者成为社会主义的集体劳动者</li>\n</ul></li>\n</ul></li>\n<li>重大意义\n<ul>\n<li>中国历史上最深刻最伟大的变革\n<ul>\n<li>广大农民真正成为国家的主人</li>\n<li>奠定我国社会主义工业化的初步基础</li>\n</ul></li>\n<li>为当代中国一切发展奠定了制度基础，社会生产力的发展，初步显示了社会主义的优越性</li>\n<li>世界社会主义发展史上一个历史性的伟大胜利</li>\n<li>丰富和发展社会主义理论</li>\n</ul></li>\n<li>经验\n<ul>\n<li>实现伟大复兴，必须建立符合我国实际的先进生产制度</li>\n</ul></li>\n</ul>\n<h3\nid=\"社会主义建设道路初步探索的理论成果\">社会主义建设道路初步探索的理论成果</h3>\n<h4 id=\"理论成果\">理论成果</h4>\n<ul>\n<li>调动一切积极因素为社会主义事业服务（《论十大关系》探索中国特色社会主义建设道路的基本方针）\n<ul>\n<li>回答了如何建设和巩固社会主义的问题</li>\n<li>有利于最大限度团结全国各族人民，为建设社会主义现代化国家而奋斗</li>\n</ul></li>\n<li>正确认识和处理社会主义社会矛盾的思想\n<ul>\n<li>此时无产阶级同资产阶级之间的矛盾已基本解决，但仍面临着其他的矛盾</li>\n<li>社会主义社会的基本矛盾\n<ul>\n<li>生产力 <span class=\"math inline\">↔︎</span> 生产关系</li>\n<li>经济基础 <span class=\"math inline\">↔︎</span> 上层建筑</li>\n<li>与资本主义社会不同，两者的基本矛盾具有根本不同的性质与情况</li>\n<li>“又相适应，又相矛盾”</li>\n<li>非对抗性的矛盾</li>\n</ul></li>\n<li>社会主义社会的主要矛盾\n<ul>\n<li>人民对于经济文化迅速发展的需要</li>\n<li>当前经济文化不能满足人民需要的状况</li>\n<li>主要任务：集中力量发展社会生产力，实现国家工业化，逐步满足人民日益增长的物质和文化需要</li>\n</ul></li>\n<li>两类不同性质的矛盾\n<ul>\n<li>敌我矛盾\n<ul>\n<li>对抗性矛盾，分清敌我</li>\n<li>处理方法：专政</li>\n</ul></li>\n<li>人民内部矛盾\n<ul>\n<li>非对抗性矛盾，分清是非</li>\n<li>处理方法：民主</li>\n<li>处理方针：\n<ul>\n<li>政治思想领域 <span class=\"math inline\">↔︎</span>\n“团结-批评-团结”</li>\n<li>物质利益、分配 <span class=\"math inline\">↔︎</span>\n“统筹兼顾，适当安排”</li>\n<li>人民群众和政府机关 <span class=\"math inline\">↔︎</span>\n坚持民主集中制，克服政府机关的官僚主义，同时加强对群众的教育</li>\n<li>科学文化领域 <span class=\"math inline\">↔︎</span>\n“百花齐放，百家争鸣”</li>\n<li>共产党和民主党派 <span class=\"math inline\">↔︎</span>\n在坚持社会主义道路和共产党领导的前提下“长期共存，互相监督”</li>\n<li>民族矛盾 <span class=\"math inline\">↔︎</span> 民族平等，团结互助</li>\n</ul></li>\n</ul></li>\n</ul></li>\n<li>意义：\n<ul>\n<li>团结全国各族文明发展我们的经济，文化，巩固新制度，建设新国家</li>\n</ul></li>\n</ul></li>\n<li>走中国工业化道路的思想\n<ul>\n<li>为什么要\n<ul>\n<li>实现工业化是中国近代以来历史发展的必然要求，也是民族独立和国家富强的必要条件</li>\n<li>中华人民共和国的成立，为我国实现工业化提供了根本的政治前提</li>\n</ul></li>\n<li>背景\n<ul>\n<li>国内：工业基础薄弱</li>\n<li>国际：受苏联工业化模式影响，比例失调</li>\n</ul></li>\n<li>总方针：\n<ul>\n<li>以农业为基础，以工业为主导</li>\n<li>以农、轻、重为序发展国民经济</li>\n</ul></li>\n<li>“两条腿走路”工业化发展思路\n<ul>\n<li>重工业和轻工业同时并举</li>\n<li>中央工业和地方工业同时并举</li>\n<li>沿海工业和内地工业同时并举</li>\n<li>大型企业和中小型企业同时并举</li>\n</ul></li>\n<li>“两步走”发展战略\n<ul>\n<li>目标：把中国建设成为一个具有现代农业，现代工业，现代国防，现代国防技术的强国</li>\n<li>战略步骤\n<ul>\n<li>建成一个独立的比较完整的工业体系和国民经济体系</li>\n<li>全面实现工业，农业，国防和科学技术现代化，使中国走在世界前列</li>\n</ul></li>\n</ul></li>\n<li>要怎么做\n<ul>\n<li>正确的经济建设方针\n<ul>\n<li>党的八大：既反保守，又反冒进，坚持在综合平衡中稳步前进</li>\n</ul></li>\n<li>调整和完善所有制结构</li>\n<li>探索适合我国情况的经济体制和运行机制</li>\n</ul></li>\n</ul></li>\n<li>其他\n<ul>\n<li>四个现代化：现代化的工业，现代化的农业，现代化的交通运输业和现代化的国防</li>\n</ul></li>\n</ul>\n<h4 id=\"经验教训\">经验教训</h4>\n<ul>\n<li>意义\n<ul>\n<li>巩固和发展了我国的社会主义制度</li>\n<li>为开创中国特色社会主义提供了宝贵经验，理论准备和物质基础</li>\n<li>丰富了科学社会主义的理论和实践</li>\n</ul></li>\n<li>经验教训，“六个必须”\n<ul>\n<li>把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路</li>\n<li>正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力</li>\n<li>从实际出发进行社会主义建设，建设规模和速度要和国力相适应，不能急于求成</li>\n<li>发展社会主义民主，健全社会主义法治</li>\n<li>坚持党的民主集中制和集体领导制度，加强执政党建设</li>\n<li>坚持对外开放，借鉴和吸收人类文明成果建设社会主义</li>\n</ul></li>\n</ul>\n<h2 id=\"历程\">历程</h2>\n<h3 id=\"毛泽东的思想历程-毛泽东思想的形成发展过程\">毛泽东的思想历程 /\n毛泽东思想的形成发展过程</h3>\n<ul>\n<li>19 世纪末 20 世纪初，战争与革命成为时代的主题</li>\n<li>科学含义\n<ul>\n<li>马列主义在中国的运用和发展</li>\n<li>被实践证明了的关于中国革命建设的正确理论原则和经验总结</li>\n<li>中国共产党集体智慧的结晶</li>\n</ul></li>\n<li>中国革命战胜敌人的三大法宝：统一战线，武装斗争，党的建设</li>\n<li>主要内容与活的灵魂：==实事求是，群众路线，独立自主==\n<ul>\n<li>实事求是\n<ul>\n<li>从实际出发，把握客观规律</li>\n<li>清醒认识和正确把握我国基本国情</li>\n<li>推进实践基础上的理论创新</li>\n</ul></li>\n<li>群众路线\n<ul>\n<li>将“人民群众是历史的创造者”（<em>本质</em>）的原理用在党的活动中</li>\n<li>怎么做\n<ul>\n<li>坚持人民是推动历史发展的根本力量</li>\n<li>坚持全心全意为人民服务的根本宗旨</li>\n<li>保持党同人民群众的血肉联系</li>\n</ul></li>\n</ul></li>\n<li>独立自主（针对“左”倾教条主义倾向提出的）\n<ul>\n<li>中华民族的优良传统</li>\n<li>立党立国的重要原则</li>\n<li>外交一以贯之的</li>\n</ul></li>\n</ul></li>\n<li>形成和发展\n<ul>\n<li>形成时期：\n<ul>\n<li>第一次国内革命战争\n<ul>\n<li>《中国社会各阶级的分析》/《湖南农民运动考察报告》</li>\n<li>深刻分析中国社会各阶级在革命中的地位和作用</li>\n<li>提出了新民主主义革命的基本思想</li>\n</ul></li>\n<li>土地革命战争初期\n<ul>\n<li>《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》《反对本本主义》</li>\n<li>农村包围城市，武装夺取政权，中国革命道路理论</li>\n<li>毛泽东思想初步形成</li>\n</ul></li>\n</ul></li>\n<li>成熟时期\n<ul>\n<li>土地革命战争后期，抗日战争时期\n<ul>\n<li>《实践论》《矛盾论》《<共产党人>发刊词》《中国革命和中国共产党》《新民主主义论》</li>\n<li>实现了马克思主义与中国革命实际相结合的历史性飞跃</li>\n<li>毛泽东思想趋于成熟</li>\n</ul></li>\n<li>遵义会议，系统分析了党内左和右的思想根源</li>\n<li>确立指导思想：1945 年 4-6 月召开的党的七大将毛泽东思想写入党章</li>\n</ul></li>\n<li>继续发展\n<ul>\n<li>解放战争时期\n<ul>\n<li>《在中国共产党第七届中央委员会第二次全体会议上的报告》《论人民民主专政》</li>\n<li>人民民主专政理论</li>\n</ul></li>\n<li>新中国成立后\n<ul>\n<li>《论十大关系》《关于正确处理人民内部矛盾的问题》</li>\n<li>社会主义改造理论、建设理论</li>\n</ul></li>\n<li>毛泽东思想进一步丰富和发展</li>\n</ul></li>\n</ul></li>\n<li>历史地位\n<ul>\n<li>马克思主义中国化时代化的第一个重大理论成果</li>\n<li>中国革命和建设的科学指南</li>\n<li>中国共产党和中国人民宝贵的精神财富</li>\n</ul></li>\n<li>科学评价\n<ul>\n<li>完整准确理解和掌握毛泽东思想的科学体系</li>\n<li>坚持辩证唯物主义和历史唯物主义的原则和方法</li>\n<li>在实践中坚持和发展毛泽东思想</li>\n</ul></li>\n<li>辨析：毛泽东思想 <span class=\"math inline\">≠</span> 毛泽东个人的思想\n<ul>\n<li>被实践证明了的正确的理论原则和经验总结</li>\n<li>中国共产党集体智慧的结晶</li>\n<li>主要是“毛泽东同志的思想”，其他领导人也对毛泽东思想的形成和发展做出了重要贡献</li>\n</ul></li>\n</ul>\n<h3 id=\"邓小平理论\">邓小平理论</h3>\n<ul>\n<li><em>中国特色社会主义理论体系的开篇之作</em></li>\n</ul>\n<h4 id=\"邓小平理论的形成\">邓小平理论的形成</h4>\n<ul>\n<li>时代背景：和平与发展\n<ul>\n<li>和平：东西问题</li>\n<li>发展：南北问题</li>\n<li><strong>发展是核心问题</strong></li>\n</ul></li>\n<li>历史依据：社会主义建设的经验教训\n<ul>\n<li>社会主义建设实践中的正确主张在改革开放后得到真正贯彻</li>\n<li>社会主义建设经历的曲折和失误促使党和人民进行深刻反思</li>\n</ul></li>\n<li>现实依据：改革开放和现代化建设的实践</li>\n<li>形成过程\n<ul>\n<li>“文革”结束后，邓小平强调实事求是是毛泽东思想的精髓，旗帜鲜明反对“两个凡是”的错误观点，支持领导开展真理标准问题的打讨论，推进各方面的拨乱反正</li>\n<li>1978，党的十一届三中全会确定了解放思想，实事求是的思想路线，停止“以阶级斗争为纲”的错误，将全党工作的重点转移到社会主义现代化建设上来，做出改革开放的重大决策，实现了党的历史上具有深远意义的伟大转折。</li>\n<li>1982，党的“十二大”提出“中国特色社会主义”，并成为党的全部理论和实践创新的主题</li>\n<li>1984，《中共中央关于经济体制改革的决定》——社会主义经济是在公有制基础上的有计划的商品经济</li>\n<li>1987，党的十三大，系统论述了我国社会主义初级阶段理论，明确概括和全面阐发了党“一个中心，两个基本点”的基本路线，对中国特色社会主义理论的主要内容做了系统概括，标志着邓小平理论轮廓的形成</li>\n<li>1992，南方谈话，重申深化改革、加速发展的必要性和重要性，从理论上解答了当时困扰和束缚人们思想的一系列重大问题，邓小平理论走向成熟；党的十四大强调中国特色社会主义理论第一次比较系统地初步回答了中国这样的社会经济文化比较落后的国家如何建设社会主义，如何巩固和发展社会主义的一系列基本问题，继承和发展了马克思主义</li>\n<li>1997，十五大正式提出“邓小平理论”这一概念，确立为党的指导思想并写入党章</li>\n<li>1999，宪法修正案正式将邓小平理论载入宪法</li>\n</ul></li>\n</ul>\n<h4 id=\"理论问题\">理论问题</h4>\n<ul>\n<li>首要、基本的理论问题：在中国这样一个经济文化比较落后的国家建设什么样的社会主义，怎样建设社会主义</li>\n<li>社会主义本质\n<ul>\n<li>解放生产力</li>\n<li>发展生产力（社会主义的根本任务是发展生产力）</li>\n<li>消灭剥削</li>\n<li>消除两极分化</li>\n<li>达到共同富裕</li>\n</ul></li>\n<li>包括了生产力和生产关系的问题</li>\n</ul>\n<h4 id=\"精髓\">精髓</h4>\n<ul>\n<li><strong>解放思想，实事求是</strong></li>\n</ul>\n<h4 id=\"主要内容\">主要内容</h4>\n<ul>\n<li>社会主义初级阶段（建设中国特色社会主义的总依据）理论\n<ul>\n<li>一切从社会主义初级阶段的实际出发，将社会主义初级阶段作为事关全局的基本国情加以把握</li>\n<li>含义\n<ul>\n<li>我国社会已经是社会主义社会（社会性质）</li>\n<li>我国的社会主义社会还处于初级阶段（发展程度）</li>\n</ul></li>\n<li>社会主义初级阶段具有长期性</li>\n<li>基本特征\n<ul>\n<li>以农业人口占多数的手工劳动为基础的农业国，逐步变为非农产业人口占多数的现代化的工业国的阶段</li>\n<li>自然经济半自然经济占很大比重，变为商品经济高度发达的阶段</li>\n<li>通过改革和探索建立和发展充满活力的社会主义经济、政治，文化体制的阶段</li>\n<li>全民奋起，艰苦创业，实现中华民族伟大复兴的阶段</li>\n</ul></li>\n</ul></li>\n<li>党在社会主义初级阶段的基本路线\n<ul>\n<li><strong>领导和团结全国各族人民</strong>（<em>领导力量和依靠力量</em>），以<strong>经济建设为中心（根本任务），坚持四项基本原则（社会主义道路，人民民主专政，党的领导，马列毛思想）解放和发展生产力的政治保证），坚持改革开放（发展动力与外部条件）</strong>（<em>基本途径</em>），<strong>自力更生，艰苦创业</strong>（<em>实现目标的根本立足点</em>），为把我国建设成为<strong>富强（经济），民主（政治），文明（思想）的社会主义现代化国家</strong>（<em>奋斗目标</em>）而奋斗</li>\n<li>“一个中心（经济建设），两个基本点（四项基本原则（立国之本），改革开放（强国之路））”</li>\n</ul></li>\n<li>社会主义的根本任务是发展生产力，党和国家的工作重点是经济建设\n<ul>\n<li>发展生产力离不开科学技术</li>\n<li>改革是动力，发展是目的，稳定是前提</li>\n</ul></li>\n<li>分“三步走”基本实现现代化![[Pasted image\n20240612214124.png|300]]</li>\n<li>社会主义改革开放理论与市场经济理论\n<ul>\n<li>社会主义市场经济：在社会主义制度条件下，让市场在资源配置中起决定作用\n<ul>\n<li>所有制结构：公有制为主体，多种所有制经济共同发展</li>\n<li>宏观调控：市场在国家宏观调控下对资源配置起到决定性作用</li>\n<li>分配制度：按劳分配为主体，多种分配形式并存</li>\n</ul></li>\n</ul></li>\n<li>“两手抓，两手都要硬”（物质文明和精神文明）（建设和法治）（改革开放和惩治腐败）</li>\n<li>“一国两制”与祖国统一</li>\n<li>中国特色社会主义外交和国际战略\n<ul>\n<li>基本目标：维护我国的独立和主权，促进世界的和平与发展</li>\n<li>冷静观察，稳住阵脚，沉着应付</li>\n</ul></li>\n<li>党的建设\n<ul>\n<li>重视马克思主义理论学习</li>\n<li>加强组织建设</li>\n<li>加强领导班子建设</li>\n<li>打好党风建设</li>\n<li>重视制度建设</li>\n</ul></li>\n<li>“三个有利于”：\n<ul>\n<li>是否有利于发展社会主义社会的生产力</li>\n<li>是否有利于增强社会主义国家的综合国力</li>\n<li>是否有利于提高人民的生活水平</li>\n</ul></li>\n</ul>\n<h4 id=\"重要意义\">重要意义</h4>\n<ul>\n<li>马克思列宁主义，毛泽东思想的继承和发展</li>\n<li>中国特色社会主义理论体系的开篇之作</li>\n<li>改革开放和社会主义现代化建设的科学指南</li>\n</ul>\n<h3\nid=\"三个代表重要思想形成背景与具体内容\">“三个代表”重要思想形成背景与具体内容</h3>\n<h4 id=\"背景与形成过程\">背景与形成过程</h4>\n<ul>\n<li>社会历史条件\n<ul>\n<li>国际背景：发生并经历重大变化，基于冷战结束后国际局势的科学判断\n<ul>\n<li>国际共运遭受重大挫折</li>\n<li>处于两种社会制度对立，斗争的最前沿</li>\n</ul></li>\n<li>历史条件（国内背景）：党的历史方位和党员队伍发生了深刻变化，基于科学判断党的历史方位和总结历史经验\n<ul>\n<li>领导人民为夺取全国政权而奋斗 <span class=\"math inline\">→</span>\n领导人民掌握全国政权并长期执政</li>\n<li>受到外部封锁和实行计划经济条件下领导国家建设 <span\nclass=\"math inline\">→</span>\n对外开放和发展社会主义市场经济条件下领导国家建设</li>\n<li>党员队伍进入整体性交接的关键时刻\n<ul>\n<li>提高党的领导水平和执政水平</li>\n<li>提高拒腐防变和抵御风险的能力</li>\n<li>要求党从新的实际出发，以改革的精神加强和改进党的建设，使党在世界形势深刻变化的历史进程中始终走在时代前列</li>\n</ul></li>\n</ul></li>\n<li>实践基础：在建设中国特色社会主义伟大实践的基础上形成的</li>\n</ul></li>\n<li>“三个代表”重要思想发展过程\n<ul>\n<li>酝酿\n<ul>\n<li>1989.6 / 8\n提出大力加强党的建设，惩治腐败的要求，发布《关于加强党的建设的通知》</li>\n<li>1991.7，中国共产党成立 70\n周年大会上深刻论述了进一步加强党的建设的问题</li>\n<li>1992.10，党的十四大系统论述了加强党的建设和改善党的领导的问题</li>\n</ul></li>\n<li>形成\n<ul>\n<li>1994，十四届四中全会通过了《关于加强党的建设几个重大问题的决定》</li>\n<li>1997，党的十五大，高度概括了新时期党的建设新的伟大工程的总目标</li>\n<li>2000.2，在广东考察，首次对“三个代表”进行了比较全面的阐述</li>\n<li>2000.6，在全国党校工作会议上指出，“三个代表”重要思想回答和解决的事“建设什么样的党，怎样建设党”的问题</li>\n</ul></li>\n<li>深度发展\n<ul>\n<li>2000.10，就“改进党的作风”发表重要讲话</li>\n<li>2001.7，庆祝中国共产党成立 80\n周年大会上的讲话中全面阐述了“三个代表”重要思想的科学内涵和基本内容</li>\n<li>2002.11，党的十六大确立为指导思想，写入党章</li>\n</ul></li>\n</ul></li>\n</ul>\n<h4 id=\"核心观点\">核心观点</h4>\n<ul>\n<li>中国共产党始终代表中国先进生产力的发展要求</li>\n<li>中国共产党始终代表中国先进文化的前进方向</li>\n<li>中国共产党始终代表中国最广大人民的根本利益</li>\n</ul>\n<h4 id=\"主要内容-1\">主要内容</h4>\n<ul>\n<li>发展是党执政兴国的第一要务</li>\n<li>建立社会主义市场经济体制\n<ul>\n<li>毫不动摇巩固发展公有制经济</li>\n<li>毫不动摇鼓励、支持、引导非公有制经济</li>\n<li>本质要求：发挥市场机制的作用和国家宏观调控</li>\n</ul></li>\n<li>全面建设小康社会\n<ul>\n<li>两个百年奋斗目标</li>\n</ul></li>\n<li>建设社会主义政治文明</li>\n<li>实施“引进来”和“走出去”的对外开放战略</li>\n<li>推进党的建设新的伟大工程</li>\n</ul>\n<h4 id=\"历史地位\">历史地位</h4>\n<ul>\n<li>中国特色社会主义理论体系的丰富发展</li>\n<li>加强和改进党的建设，推进中国特色社会主义事业的强大理论武器</li>\n</ul>\n<h3\nid=\"科学发展观的形成过程与具体内容\">科学发展观的形成过程与具体内容</h3>\n<h4 id=\"形成条件\">形成条件</h4>\n<ul>\n<li>国际背景：\n<ul>\n<li>深刻分析国际形势</li>\n<li>顺应世界发展趋势</li>\n<li>借鉴国外发展经验</li>\n</ul></li>\n<li>历史条件\n<ul>\n<li>深刻把握我国国情和新的阶段性特征</li>\n</ul></li>\n<li>实践基础\n<ul>\n<li>总结改革开放尤其是十六大以来实践经验的基础</li>\n</ul></li>\n</ul>\n<h4 id=\"形成过程\">形成过程</h4>\n<ul>\n<li>逐步形成：抗击非典疫情和探索未完善社会主义市场经济体制\n<ul>\n<li>2003.7，总结非典经验：全面发展，协调发展，可持续发展</li>\n<li>2003.10，科学发展观</li>\n</ul></li>\n<li>充实丰富：加强和改善宏观调控的时间\n<ul>\n<li>十四届六中全会，树立和落实科学发展观作为提高党的执政能力的重要内容</li>\n<li>十一五规划的建议 / 纲要：以科学发展观统领经济社会发展全局</li>\n</ul></li>\n<li>走向成熟</li>\n<li>发展完善：十七大后，不断发展完善\n<ul>\n<li>2008.12，在中央经济工作会议上强调，科学发展观第一要义是发展</li>\n<li>十七届五中全会强调，坚持发展是硬道理的本质要求，就是坚持科学发展</li>\n<li>2012，确立为指导思想</li>\n</ul></li>\n</ul>\n<h4 id=\"内涵\">内涵</h4>\n<ul>\n<li>推动经济社会<strong>发展</strong>是科学发展观的<em>第一要义</em>\n（为什么）</li>\n<li><strong>以人为本</strong>是科学发展观的<em>核心立场</em>\n（为了谁和依靠谁）</li>\n<li><strong>全面协调可持续</strong>是科学发展观的<em>基本要求</em>\n（实现什么样的发展）</li>\n<li><strong>统筹兼顾</strong>是科学发展观的<em>根本方法</em>\n（怎么发展）</li>\n</ul>\n<h4 id=\"精神实质\">精神实质</h4>\n<ul>\n<li>解放思想，实事求是，与时俱进，求真务实</li>\n</ul>\n<h4 id=\"内容\">内容</h4>\n<ul>\n<li>转变经济发展方式\n<ul>\n<li>持续健康发展</li>\n<li>创新驱动发展战略</li>\n<li>经济结构战略性调整</li>\n<li>促进区域协调发展战略</li>\n<li>城乡发展一体化</li>\n</ul></li>\n<li>发展社会主义民主政治\n<ul>\n<li>社会主义核心价值体系</li>\n<li>社会主义核心价值观</li>\n</ul></li>\n<li>推进社会主义文化强国建设</li>\n<li>构建社会主义和谐社会</li>\n<li>推进生态文明建设</li>\n<li>全面提高党的建设科学化水平</li>\n</ul>\n<h4 id=\"历史地位-1\">历史地位</h4>\n<ul>\n<li>中国特色社会主义理论体系在新世纪新阶段的接续发展</li>\n<li>全面建设小康社会，加快推进社会主义现代化的根本指针</li>\n</ul>\n"},{"title":"毛概整理","_content":"\n## 马克思主义中国化时代化的历史进程与理论成果\n\n### 马克思主义中国化时代化的提出\n\n1938 年，毛泽东在党的六届六中全会上作了《**论新阶段**》的报告，标志着“马克思主义中国化”这一命题的正式提出。1945 年在党的七大上，刘少奇代表党中央作了《关于修改党章的报告》，指出毛泽东思想是“中国化的马克思主义”。\n\n### 马克思主义中国化时代化的内涵\n\n马克思主义中国化时代化，就是立足中国国情和时代特点，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，深入研究和解决中国革命、建设、改革不同历史时期的实际问题，真正搞懂面临的时代课题，不断吸收新的时代内容，科学回答时代提出的重大理论和实践课题，创造新的理论成果。\n\n### 马克思主义中国化时代化的历史进程\n\n毛泽东思想是马克思主义中国化的第一次历史性飞跃\n\n1978 年党的十一届三中全会以后，以==邓小平==同志为主要代表的中国共产党人，团结带领全党全国各族人民，深刻总结新中国成立以来正反两方面经验，围绕==什么是社会主义、怎样建设社会主义==这一根本问题，借鉴世界社会主义历史经验，创立了**邓小平理论**。\n\n党的十三届四中全会以后，以==江泽民==同志为主要代表的中国共产党人，坚持党的基本理论、基本路线，加深了对==什么是社会主义、怎样建设社会主义和建设什么样的党、怎样建设党==的认识，形成了 **“三个代表”重要思想**\n\n党的十六大以后，以==胡锦涛==同志为主要代表的中国共产党人，在全面建设小康社会进程中推进实践创新、理论创新、制度创新，深刻认识和回答了==新形势下实现什么样的发展、怎样发展等==重大问题，形成了**科学发展观**\n\n形成中国特色社会主义理论体系，实现了马克思主义中国化时代化新的飞跃。\n\n创立了**习近平新时代中国特色社会主义思想**，实现了==马克思主义中国化时代化新的飞跃==。\n\n## 毛泽东思想及其历史地位\n\n### 毛泽东思想的形成和发展\n\n#### 毛泽东思想形成发展的过程（p17）\n\n1. 毛泽东思想的形成\n\n   形成：\n\n   - ==《中国社会各阶级的分析》《湖南农民运动考察报告》==，提出==新民主主义思想，标志毛泽东思想萌芽==\n\n   - ==《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》《反对本本主义》==，指明==中国革命的发展规律，提出农村包围城市，武装夺取政权==\n\n2. 毛泽东思想的成熟\n\n   ==遵义会议==确立了毛泽东同志在党中央和红军的==领导地位==，开始确立以毛泽东同志为主要代表的马克思主义正确路线在党中央的领导地位，开始形成以毛泽东同志为核心的党的第一代中央领导集体，开启了党独立自主解决中国革命实际问题的新阶段，在最危急关头挽救了党、挽救了红军、挽救了中国革命，是一次具有伟大转折意义的重要会议。\n\n   成熟：《实践论》《矛盾论》《<共产党人>发刊词》《中国革命和中国共产党》《新民主主义论》《改造我们的学习》《论联合政府》 阐述 提出 指明 p18\n\n   ==党的六届七中全==会通过的==《关于若干历史问题的决议》==充分肯定了确立毛泽东在全党领导地位的重大意义，==1945 年党的七大==通过的==《中国共产党党章》==明确规定，“中国共产党，以马克思列宁主义的理论与中国革命的实践统一的思想——毛泽东思想，作为自己一切工作的指针”，标志==把毛泽东思想确立为党必须长期坚持的指导思想==。\n\n3. 毛泽东思想的继续发展\n\n继续发展：==《在中国共产党第七届中央委员会第二次全体会议上的报告》《论人民民主专政》《论十大关系》《关于正确处理人民内部矛盾的问题》==\n\n### 毛泽东思想的主要内容和活的灵魂\n\n#### 毛泽东思想的主要内容\n\n1.  新民主主义革命理论\n\n毛泽东指出，==统一战线、武装斗争和党的建设==，是中国共产党在中国革命战争中战胜敌人的==三大法宝==\n\n2. 社会主义革命和社会主义建设理论\n\n   民主管理==“两参一改三结合”==的思想：==干部参加劳动，工人参加管理，改革不合理的规章制度，工人群众、领导干部和技术人员三结合==\n\n3. 革命军队建设和军事战略的理论\n\n   无产阶级及其政党要实现自己对同盟者的领导，必须具备两个条件：\n\n   1. 率领被领导者向着共同的敌人作坚决斗争并==取得胜利==\n   2. 对被领导者==给以物质利益，至少不损害其利益，同时给以政治教育==\n\n#### 毛泽东思想活的灵魂\n\n1981 年党的十一届六中全会通过的《中国共产党中央委员会关于建国以来党的若干历史问题的决议》指出：“毛泽东思想的==活的灵魂==，是贯穿于上述各个组成部分的立场、观点和方法，它们有三个基本方面，即==实事求是，群众路线，独立自主== （三个坚持）\n\n## 新民主主义革命理论\n\n### 新民主主义革命的总路线和基本纲领\n\n#### 新民主主义革命的总路线\n\n1939 年，毛泽东在==《中国革命和中国共产党》==一文中第一次提出了==“新民主主义的革命”==的科学概念，1948 年，毛泽东在==《在晋绥干部会议上的讲话》==中完整的总结和概括了==新民主主义革命的总路线的内容==，即==无产阶级领导的、人民大众的，反对帝国主义、封建主义和官僚资本主义的革命==。新民主主义革命总路线反映了中国革命的基本规律，指明了中国革命的对象、动力、领导力量、性质和前途，是新民主主义革命的指导路线\n\n##### 新民主主义革命的领导力量\n\n无产阶级的领导权是中国革命的中心问题，也是新民主主义革命理论的核心问题，区别于新旧两种不同范畴的民主主义革命的根本标志是，革命的领导权掌握在无产阶级手中还是掌握在资产阶级手中\n\n中国无产阶级除了具有与先进的生产方式相联系、没有私人占有的生产资料、富于组织纪律性等一般无产阶级的基本有点外，还具有自身的特点和优点。\n\n1. 从诞生之日起，就深受外国资本主义、本国封建势力和资产阶级的三重压迫，而这些压迫的研中心和残酷性，是世界各民族中少见的。因此，中国无产阶级在革命斗争中比任何别的阶级都来得坚决和彻底。\n\n2. 集中分布在少数大城市和大企业，有利于组织和团结，有利于革命思想的传播和强大革命力量的形成。\n\n3. 成员中大部分出身于破产农民，和农民有着天然的联系，便于和农民结成亲密的联盟，共同团结战斗。\n\n##### 新民主主义革命的性质和前途\n\n新民主主义革命的性质不是无产阶级社会主义革命，而是==资产阶级民主主义革命==。\n\n新民主主义革命与旧民主主义革命相比有新的内容和特点，与社会主义革命性质不同，又是与社会主义革命互相联系、紧密衔接的。\n\n#### 新民主主义的基本纲领\n\n1945 年，毛泽东在党的七大所作的政治报告《论联合政府》中，进一步把新民主主义的政治、经济和文化与党的基本纲领联系起来。\n\n##### 新民主主义的政治纲领\n\n==推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国==。\n\n既不同于欧美式的资产阶级专政的共和国，又和苏联式的无产阶级专政和社会主义共和国相区别。\n\n新民主主义国家的国体是无产阶级领导的以工农联盟为基础，包括小资产阶级、民族资产阶级和其他反帝反封建的人们在内的各革命阶级的联合专政。\n\n##### 新民主主义的经济纲领\n\n==没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有==。\n\n在新民主主义条件下保护民族工商业，发展资本主义，是由中国落后的生产力和新民主主义革命的性质所决定的。\n\n##### 新民主主义的文化纲领\n\n==新民主主义文化，就是无产阶级领导的人民大众的反帝反封建的文化，即民族科学的大众文化==。\n\n### 新民主主义革命的道路和基本经验\n\n#### 新民主主义革命的道路\n\n新民主主义革命的道路：==农村包围城市、武装夺取政权==。\n\n##### 新民主主义革命道路的提出\n\n==《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》==，提出==“工农武装割据”==的思想，初步形成了农村包围城市的革命道路理论。\n\n##### 新民主主义革命道路形成的必然性\n\n1. 近代中国是多个帝国主义间接统治的经济落后的半殖民地国家，社会政治经济发展极端不平衡，四分五裂，军阀割据，存在不少的统治薄弱环节，为党在农村开展革命斗争、建设革命根据地提供了缝隙和可能\n2. 近代中国的广大农村深受反动统治阶级的多重压迫和剥削，人民革命愿望强烈，加之经历过大革命的洗礼，革命的群众基础好\n3. 全国革命形势的继续向前发展，为在农村建设革命根据地提供了客观条件\n4. 相当力量正式红军的存在，为农村革命根据地的创立、巩固和发展提供了坚强后盾\n5. 党的领导的有力量及其政策的不错误，为农村革命根据地建设和发展提供了重要的主观条件。\n\n#### 新民主主义革命的三大法宝\n\n==统一战线、武装斗争和党的建设==，是中国共产党在中国革命战争中战胜敌人的三大法宝==《共产党人发刊词》==\n\n##### 统一战线\n\n党建立、巩固和发展统一战线的实践经验：\n\n1. 建立巩固的工农联盟\n2. 正确对待资产阶级，尤其是民族资产阶级\n3. 采取区别对待的方针\n4. 坚持独立自主的原则\n\n##### 武装斗争\n\n1. 坚持党对军队的绝对领导，这是建设新型人民军队的根本原则，是保持人民军队无产阶级性质和建军宗旨的根本前提，也是毛泽东建军思想的核心。\n2. 建设全心全意为人民服务的人民军队，须以全心全意为人民服务为唯一宗旨。\n3. 开展革命的政治工作\n4. 坚持正确的战略战术原则\n\n##### 党的建设\n\n党加强自身建设的经验：\n\n1. 把思想建设始终放在党的建设的首位\n2. 在任何时候都重视党的组织建设\n3. 重视党的作风建设\n4. 联系党的政治路线加强党的建设\n\n## 社会主义改造理论\n\n### 从新民主主义到社会主义的转变\n\n#### 新民主主义社会是一个过渡性的社会\n\n新民主主义社会不是一个独立的社会形态，而是由新民主主义向社会主义转变的==过渡性社会形态==\n\n主要的经济成分是三种\n\n1. 社会主义经济\n2. 个体经济\n3. 资本主义经济\n\n逐渐扩大国营经济，逐步将资本主义经济和个体经济改编为社会主义经济，使社会主义经济逐步称为我国的经济基础\n\n#### 党在过渡时期的总路线及其依据\n\n##### 党在过渡时期的总路线的提出\n\n党在过渡时期总路线的主要内容为==“一化三改”==。“一化”即==社会主义工业化==，“三改”即对==个体农业、手工业和资本主义工商业的社会主义改造==，它们之间相互联系，不可分离。其中“一化”是主体，“三改”是“两翼”，两者相辅相成，相互促进。这是一条社会主义建设和社会主义改造同时并举的路线，体现了社会主义工业化和社会主义改造的紧密结合，体现了解放生产力、变革生产关系与发展生产力的有机统一\n\n### 社会主义改造道路和历史经验\n\n#### 适合中国特点的社会主义改造道路\n\n##### 农业、手工业的社会主义改造\n\n对于农业的改造\n\n1.  积极引导农民组织起来，走互助合作道路。\n2.  遵循自愿互利、典型示范和国家帮助的原则，以互助合作的优越性吸引农民走互助合作道路。\n3.  正确分析农村的阶级和阶层状况，制定正确的阶级政策。党制定并贯彻执行了依靠贫下中农, 发展互助合作，由逐步限制到最后消灭富农剥削的农村阶级政策。这使农业合作化有了坚实的阶级基础和群众基础。\n4.  坚持积极领导、稳步前进的方针，采取循序渐进的步骤。\n\n对于手工业的改造\n\n1. 办手工业供销小组\n2. 办手工业供销合作社\n3. 建立手工业生产合作社\n\n##### 资本主义工商业的社会主义改造\n\n1. 用==和平赎买==的方法改造资本主义工商业，使被资本家占有的生产资料变成人民的财产，这是社会主义革命的一个基本原则。\n2. 采取从低级到高级的国家资本主义的过渡形式\n\n资本主义工商业社会主义改造的步骤\n\n1. 主要实行初级形式的国家资本主义\n\n   这些企业的利润，按==国家所得税、企业公积金、 工人福利费、资方红利==这四个方面进行分配，即“四马分肥”\n\n2. 主要实行个别企业的公私合营\n3. 实行全行业的公私合营\n\n### 社会主义基本制度在中国的确立\n\n#### 社会主义基本制度的确立及其理论依据\n\n==1954 年 9 月==，==第一届全国人民代表大会==的召开和==《中华人民共和国宪法》==的制定及颁布施行，成为我国社会主义民主政治建设的里程碑\n\n#### 确立社会主义基本制度的重大意义\n\n1. 社会主义基本制度的确立，为当代中国一切发展进步奠定了制度基础。\n2. 社会主义制度的建立极大地提高了工人阶级和广大劳动人民的积极性、创造性，极大地促进了我国社会生产力的发展。\n3. 社会主义基本制度以 其与社会化大生产的一致性和能够在经济落后条件下尽可能地集中力量办大事的优势，为发展社会生产力开辟了广阔的道路。\n4. 我国社会生产力的发展，初步显示了社会主义的优越性\n5. 社会主义基本制度的确立，是以毛泽东同志为主要代表的中国共产党人对一个脱胎于半殖民地半封建的东方大国如何进行社会主义革命问题的系统回答和正确解决，是马克思列宁主义关于社会主义革命理论在中国的正确运用和创造性发展的结果。它不仅再次证明了马克思列宁主义的真理性，而且以其独创性的理论原则和经验总结丰富和发展了科学社会主义理论。\n\n## 社会主义建设道路初步探索的理论成果\n\n### 初步探索的重要理论成果\n\n#### 调动一切积极因素为社会主义事业服务\n\n==《论十大关系》==确定了一个==基本方针==，就是==“努力把党内党外、国内国外的一切积极的因素，直接的、间接的积极因素，全部调动起来”==\n\n![十大关系](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202506112209282.png)\n\n#### 正确认识和处理社会主义社会矛盾的思想\n\n==《关于正确处理人民内部矛盾的问题》==系统论述了社会主义社会矛盾的理论\n\n关于社会主义社会的基本矛盾：在社会主义社会中， 基本的矛盾仍然是生产关系和生产力之间的矛盾，上层建筑和经济基础之间的矛盾。但社会主义社会的基本矛盾同以往社会的基本矛盾“具有根本不同的性质和情况”\n\n## 中国特色社会主义理论体系的形成发展\n\n### 中国特色社会主义理论体系形成发展的社会历史条件\n\n#### 中国特色社会主义理论体系形成发展的国际背景\n\n#### 中国特色社会主义理论体系形成发展的历史条件\n\n#### 中国特色社会主义理论体系形成发展的实践基础\n\n### 中国特色社会主义理论体系形成发展过程\n\n#### 中国特色社会主义理论体系的形成\n\n1978 年 12 月召开的党的==十一届三中全会==，重新确立了==实事求是==的思想路线，彻底否定了“以阶级斗争为纲”的错误理论和实践，确定把全党工作的着重点转移到==社会主义现代化建设==上来，作出==施行改革开放==的重大决策，实现了党的历史上具有深远意义的伟大转折。\n\n## 邓小平理论\n\n### 邓小平理论首要的基本的理论问题和精髓\n\n#### 邓小平理论首要的基本的理论问题（p152）\n\n1992 年，邓小平在南方谈话中对社会主义本质作出了总结性的理论概括，指出==“社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕”==\n\n#### 邓小平理论的精髓\n\n==解放思想、实事求是==是邓小平理论的精髓\n\n### 邓小平理论的主要内容\n\n#### 社会主义初级阶段理论和党的基本路线\n\n##### 社会主义初级阶段理论\n\n社会主义初级阶段这个论断包括两层含义\n\n1. 我国社会已经是社会主义社会。我们必须坚持而不能离开谁会主义。\n2. 我国的社会主义社会还处在初级阶段。我们必须从这个实际出发，而不能超越这个阶段。\n\n##### 社会主义初级阶段的基本路线\n\n党在社会主义初级阶段基本路线==“一个中心、两个基本点”==，即==“以经济建设为中心，坚持四项基本原则，坚持改革开放”==\n\n要把以经济建设为中心同坚持四项基本原则、坚持改革开放这两个基本点，统一于中国特色社会主义的伟大实践，贯穿于社会主义现代化建设的整个过程\n\n党的==十九大==提出“为把我国建设成为富强民主文明和谐美丽的社会主义现代化强国而奋斗”、进一步拓展了党的基本路线\n\n#### 社会主义改革开放和社会主义市场经济理论\n\n##### 社会主义改革开放理论\n\n改革是一场深刻的社会变革，是中国的第二次革命，是实现中国现代化的必经之路。\n\n开放也是改革\n\n##### 社会主义市场经济理论\n\n1984 年，党的==十二届三中全==会提出==“公有制基础上的有计划的商品经济”==的概念\n\n1992 年，邓小平在南方谈话中明确指出“计划多一点还是市场多一点，不是社会主义与资本主义的本质区别。计划经济不等于社会主义，资本主义也有计划；市场经济不等于资本主义，社会主义也有市场。计划和市场都是经济手段”。这一精辟论述，从理论上突破了计划经济和市场经济是制度属性的观念，从根本上解除了把计划经济和市场经济看做属于社会基本制度范畴的思想束缚，标志着邓小平的社会主义市场经济理论的形成\n\n## “三个代表”重要思想\n\n### “三个代表”重要思想的核心观点\n\n##### ==始终代表中国先进生产力的发展要求==\n\n“三个代表”：始终代表中国先进生产力的发展要求，始终代表中国先进文化的前进方向，始终代表中国最广大人民的根本利益\n\n科学技术是第一生产力，是先进生产力的集中体现和主要标志\n\n##### ==始终代表中国先进文化的前进方向==\n\n江泽民指出，加强文化建设，必须“以科学的理论武装人，以正确的舆论引导人，以高尚的精神塑造人，以优秀的作品鼓舞人”\n\n加强社会主义思想道德建设，是发展先进文化的重要内容和中心环节。弘扬爱国主义精神，以为人民服务为核心、以集体主义为原则、以诚实守信为重点\n\n##### ==始终代表中国最广大人民的根本利益==\n\n妥善处理各方面的利益（如何认识）p202\n\n### “三个代表”重要思想的主要内容\n\n#### 发展是党执政兴国的第一要务\n\n#### 建立社会主义市场经济体制\n\n江泽民根据邓小平南方谈话精神，明确提出使用==“社会主义市场经济体制”==这个想法\n\n两个“毫不动摇”：\n\n1. 必须毫不动摇地巩固和发展公有制经济，公有制经济不仅包括国有经济和集体经济，还包括混合所有制经济中的国有成分和集体成分。\n\n2. 必须毫不动摇地鼓励、支持和引导非公有制经济发展。个体、私营等各种形式的非公有制经济是社会主义市场经济的重要组成部分，对充分调动社会各方面的积极性、加快生产力发展具有重要作用（如何理解）\n\n#### 建设社会主义政治文明\n\n江泽民在==党的十五大报告==中明确指出：“依法治国，就是广大人民群众在党的领导下，依照宪法和法律规定，通过各种途径和形式管理国家事务，管理经济文化事业，管理社会事务，保证国家各项工作都依法进行，逐步实现社会主义民主的制度化、法律化，是这种制度和法律不因领导人的改变而改变，不因领导人的看法和注意力的改变而改变。依法治国，是党领导人民治理国家的基本方略，是发展社会主义市场经济的客观需要，是社会文明进步的重要标志，是国家长治久安的重要保障”\n\n#### 实施“引进来”和“走出去”相结合的对外开放战略\n\n#### 推进党的建设新的伟大工程\n\n坚持中国共产党的领导，核心是坚持党的先进性\n\n党的两大历史性课题：提高党的领导水平和执政水平、提高拒腐防变和抵御风险能力（两个一定要)\n\n## 科学发展观\n\n### 科学发展观的科学内涵\n\n#### 推动经济社会发展是科学发展观的第一要义\n\n#### 以人为本是科学发展观的核心立场（民本思想）\n\n#### 全面协调可持续是科学发展观的基本要求。\n\n“全面”是指发展要有全面性、整体性，不仅经济要发展，各个方面都要发展；“协调”是指发展要有协调性、均衡性，各个方面、各个环节的发展要相互适应、相互促进；“可持续”是指发展要有持久性、连续性，不仅当前要发展，而且要保证长远发展\n\n坚持可持续发展，坚定走生产发展、生活富裕、生态良好的文明道路。\n\n坚持以生产发展为基础，以生活富裕为目的，以生态良好为条件\n\n#### 统筹兼顾是科学发展观的根本方法\n\n### 科学发展观的主要内容\n\n#### 加快转变经济发展方式\n\n#### 发展社会主义民主政治\n\n#### 推进社会主义文化强国建设\n\n社会主义核心价值体系。社会主义核心价值体系是兴国之魂，决定着中国特色社会主义发展方向。马克思主义指导思想、中国特色社会主义共同理想、以爱国主义为核心的民族精神和以改革创新为核心的时代精神、社会主义荣辱观，共同构成社会主义核心价值体系的基本内容\n\n#### 构建社会主义和谐社会\n\n民主法治、公平正义、诚信有爱、充满活力、安定有序、人与自然和谐相处，是构建社会主义和谐社会的总要求\n\n#### 推进生态文明建设\n\n#### 全面提高党的建设科学化水平\n\n## 课后思考题\n\n### 第一章 毛泽东思想及其历史地位\n\n##### 毛泽东思想形成和发展的社会历史条件是什么\n\n**解答：**\n","source":"_posts/毛概整理.md","raw":"---\ntitle: 毛概整理\n---\n\n## 马克思主义中国化时代化的历史进程与理论成果\n\n### 马克思主义中国化时代化的提出\n\n1938 年，毛泽东在党的六届六中全会上作了《**论新阶段**》的报告，标志着“马克思主义中国化”这一命题的正式提出。1945 年在党的七大上，刘少奇代表党中央作了《关于修改党章的报告》，指出毛泽东思想是“中国化的马克思主义”。\n\n### 马克思主义中国化时代化的内涵\n\n马克思主义中国化时代化，就是立足中国国情和时代特点，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，深入研究和解决中国革命、建设、改革不同历史时期的实际问题，真正搞懂面临的时代课题，不断吸收新的时代内容，科学回答时代提出的重大理论和实践课题，创造新的理论成果。\n\n### 马克思主义中国化时代化的历史进程\n\n毛泽东思想是马克思主义中国化的第一次历史性飞跃\n\n1978 年党的十一届三中全会以后，以==邓小平==同志为主要代表的中国共产党人，团结带领全党全国各族人民，深刻总结新中国成立以来正反两方面经验，围绕==什么是社会主义、怎样建设社会主义==这一根本问题，借鉴世界社会主义历史经验，创立了**邓小平理论**。\n\n党的十三届四中全会以后，以==江泽民==同志为主要代表的中国共产党人，坚持党的基本理论、基本路线，加深了对==什么是社会主义、怎样建设社会主义和建设什么样的党、怎样建设党==的认识，形成了 **“三个代表”重要思想**\n\n党的十六大以后，以==胡锦涛==同志为主要代表的中国共产党人，在全面建设小康社会进程中推进实践创新、理论创新、制度创新，深刻认识和回答了==新形势下实现什么样的发展、怎样发展等==重大问题，形成了**科学发展观**\n\n形成中国特色社会主义理论体系，实现了马克思主义中国化时代化新的飞跃。\n\n创立了**习近平新时代中国特色社会主义思想**，实现了==马克思主义中国化时代化新的飞跃==。\n\n## 毛泽东思想及其历史地位\n\n### 毛泽东思想的形成和发展\n\n#### 毛泽东思想形成发展的过程（p17）\n\n1. 毛泽东思想的形成\n\n   形成：\n\n   - ==《中国社会各阶级的分析》《湖南农民运动考察报告》==，提出==新民主主义思想，标志毛泽东思想萌芽==\n\n   - ==《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》《反对本本主义》==，指明==中国革命的发展规律，提出农村包围城市，武装夺取政权==\n\n2. 毛泽东思想的成熟\n\n   ==遵义会议==确立了毛泽东同志在党中央和红军的==领导地位==，开始确立以毛泽东同志为主要代表的马克思主义正确路线在党中央的领导地位，开始形成以毛泽东同志为核心的党的第一代中央领导集体，开启了党独立自主解决中国革命实际问题的新阶段，在最危急关头挽救了党、挽救了红军、挽救了中国革命，是一次具有伟大转折意义的重要会议。\n\n   成熟：《实践论》《矛盾论》《<共产党人>发刊词》《中国革命和中国共产党》《新民主主义论》《改造我们的学习》《论联合政府》 阐述 提出 指明 p18\n\n   ==党的六届七中全==会通过的==《关于若干历史问题的决议》==充分肯定了确立毛泽东在全党领导地位的重大意义，==1945 年党的七大==通过的==《中国共产党党章》==明确规定，“中国共产党，以马克思列宁主义的理论与中国革命的实践统一的思想——毛泽东思想，作为自己一切工作的指针”，标志==把毛泽东思想确立为党必须长期坚持的指导思想==。\n\n3. 毛泽东思想的继续发展\n\n继续发展：==《在中国共产党第七届中央委员会第二次全体会议上的报告》《论人民民主专政》《论十大关系》《关于正确处理人民内部矛盾的问题》==\n\n### 毛泽东思想的主要内容和活的灵魂\n\n#### 毛泽东思想的主要内容\n\n1.  新民主主义革命理论\n\n毛泽东指出，==统一战线、武装斗争和党的建设==，是中国共产党在中国革命战争中战胜敌人的==三大法宝==\n\n2. 社会主义革命和社会主义建设理论\n\n   民主管理==“两参一改三结合”==的思想：==干部参加劳动，工人参加管理，改革不合理的规章制度，工人群众、领导干部和技术人员三结合==\n\n3. 革命军队建设和军事战略的理论\n\n   无产阶级及其政党要实现自己对同盟者的领导，必须具备两个条件：\n\n   1. 率领被领导者向着共同的敌人作坚决斗争并==取得胜利==\n   2. 对被领导者==给以物质利益，至少不损害其利益，同时给以政治教育==\n\n#### 毛泽东思想活的灵魂\n\n1981 年党的十一届六中全会通过的《中国共产党中央委员会关于建国以来党的若干历史问题的决议》指出：“毛泽东思想的==活的灵魂==，是贯穿于上述各个组成部分的立场、观点和方法，它们有三个基本方面，即==实事求是，群众路线，独立自主== （三个坚持）\n\n## 新民主主义革命理论\n\n### 新民主主义革命的总路线和基本纲领\n\n#### 新民主主义革命的总路线\n\n1939 年，毛泽东在==《中国革命和中国共产党》==一文中第一次提出了==“新民主主义的革命”==的科学概念，1948 年，毛泽东在==《在晋绥干部会议上的讲话》==中完整的总结和概括了==新民主主义革命的总路线的内容==，即==无产阶级领导的、人民大众的，反对帝国主义、封建主义和官僚资本主义的革命==。新民主主义革命总路线反映了中国革命的基本规律，指明了中国革命的对象、动力、领导力量、性质和前途，是新民主主义革命的指导路线\n\n##### 新民主主义革命的领导力量\n\n无产阶级的领导权是中国革命的中心问题，也是新民主主义革命理论的核心问题，区别于新旧两种不同范畴的民主主义革命的根本标志是，革命的领导权掌握在无产阶级手中还是掌握在资产阶级手中\n\n中国无产阶级除了具有与先进的生产方式相联系、没有私人占有的生产资料、富于组织纪律性等一般无产阶级的基本有点外，还具有自身的特点和优点。\n\n1. 从诞生之日起，就深受外国资本主义、本国封建势力和资产阶级的三重压迫，而这些压迫的研中心和残酷性，是世界各民族中少见的。因此，中国无产阶级在革命斗争中比任何别的阶级都来得坚决和彻底。\n\n2. 集中分布在少数大城市和大企业，有利于组织和团结，有利于革命思想的传播和强大革命力量的形成。\n\n3. 成员中大部分出身于破产农民，和农民有着天然的联系，便于和农民结成亲密的联盟，共同团结战斗。\n\n##### 新民主主义革命的性质和前途\n\n新民主主义革命的性质不是无产阶级社会主义革命，而是==资产阶级民主主义革命==。\n\n新民主主义革命与旧民主主义革命相比有新的内容和特点，与社会主义革命性质不同，又是与社会主义革命互相联系、紧密衔接的。\n\n#### 新民主主义的基本纲领\n\n1945 年，毛泽东在党的七大所作的政治报告《论联合政府》中，进一步把新民主主义的政治、经济和文化与党的基本纲领联系起来。\n\n##### 新民主主义的政治纲领\n\n==推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国==。\n\n既不同于欧美式的资产阶级专政的共和国，又和苏联式的无产阶级专政和社会主义共和国相区别。\n\n新民主主义国家的国体是无产阶级领导的以工农联盟为基础，包括小资产阶级、民族资产阶级和其他反帝反封建的人们在内的各革命阶级的联合专政。\n\n##### 新民主主义的经济纲领\n\n==没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有==。\n\n在新民主主义条件下保护民族工商业，发展资本主义，是由中国落后的生产力和新民主主义革命的性质所决定的。\n\n##### 新民主主义的文化纲领\n\n==新民主主义文化，就是无产阶级领导的人民大众的反帝反封建的文化，即民族科学的大众文化==。\n\n### 新民主主义革命的道路和基本经验\n\n#### 新民主主义革命的道路\n\n新民主主义革命的道路：==农村包围城市、武装夺取政权==。\n\n##### 新民主主义革命道路的提出\n\n==《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》==，提出==“工农武装割据”==的思想，初步形成了农村包围城市的革命道路理论。\n\n##### 新民主主义革命道路形成的必然性\n\n1. 近代中国是多个帝国主义间接统治的经济落后的半殖民地国家，社会政治经济发展极端不平衡，四分五裂，军阀割据，存在不少的统治薄弱环节，为党在农村开展革命斗争、建设革命根据地提供了缝隙和可能\n2. 近代中国的广大农村深受反动统治阶级的多重压迫和剥削，人民革命愿望强烈，加之经历过大革命的洗礼，革命的群众基础好\n3. 全国革命形势的继续向前发展，为在农村建设革命根据地提供了客观条件\n4. 相当力量正式红军的存在，为农村革命根据地的创立、巩固和发展提供了坚强后盾\n5. 党的领导的有力量及其政策的不错误，为农村革命根据地建设和发展提供了重要的主观条件。\n\n#### 新民主主义革命的三大法宝\n\n==统一战线、武装斗争和党的建设==，是中国共产党在中国革命战争中战胜敌人的三大法宝==《共产党人发刊词》==\n\n##### 统一战线\n\n党建立、巩固和发展统一战线的实践经验：\n\n1. 建立巩固的工农联盟\n2. 正确对待资产阶级，尤其是民族资产阶级\n3. 采取区别对待的方针\n4. 坚持独立自主的原则\n\n##### 武装斗争\n\n1. 坚持党对军队的绝对领导，这是建设新型人民军队的根本原则，是保持人民军队无产阶级性质和建军宗旨的根本前提，也是毛泽东建军思想的核心。\n2. 建设全心全意为人民服务的人民军队，须以全心全意为人民服务为唯一宗旨。\n3. 开展革命的政治工作\n4. 坚持正确的战略战术原则\n\n##### 党的建设\n\n党加强自身建设的经验：\n\n1. 把思想建设始终放在党的建设的首位\n2. 在任何时候都重视党的组织建设\n3. 重视党的作风建设\n4. 联系党的政治路线加强党的建设\n\n## 社会主义改造理论\n\n### 从新民主主义到社会主义的转变\n\n#### 新民主主义社会是一个过渡性的社会\n\n新民主主义社会不是一个独立的社会形态，而是由新民主主义向社会主义转变的==过渡性社会形态==\n\n主要的经济成分是三种\n\n1. 社会主义经济\n2. 个体经济\n3. 资本主义经济\n\n逐渐扩大国营经济，逐步将资本主义经济和个体经济改编为社会主义经济，使社会主义经济逐步称为我国的经济基础\n\n#### 党在过渡时期的总路线及其依据\n\n##### 党在过渡时期的总路线的提出\n\n党在过渡时期总路线的主要内容为==“一化三改”==。“一化”即==社会主义工业化==，“三改”即对==个体农业、手工业和资本主义工商业的社会主义改造==，它们之间相互联系，不可分离。其中“一化”是主体，“三改”是“两翼”，两者相辅相成，相互促进。这是一条社会主义建设和社会主义改造同时并举的路线，体现了社会主义工业化和社会主义改造的紧密结合，体现了解放生产力、变革生产关系与发展生产力的有机统一\n\n### 社会主义改造道路和历史经验\n\n#### 适合中国特点的社会主义改造道路\n\n##### 农业、手工业的社会主义改造\n\n对于农业的改造\n\n1.  积极引导农民组织起来，走互助合作道路。\n2.  遵循自愿互利、典型示范和国家帮助的原则，以互助合作的优越性吸引农民走互助合作道路。\n3.  正确分析农村的阶级和阶层状况，制定正确的阶级政策。党制定并贯彻执行了依靠贫下中农, 发展互助合作，由逐步限制到最后消灭富农剥削的农村阶级政策。这使农业合作化有了坚实的阶级基础和群众基础。\n4.  坚持积极领导、稳步前进的方针，采取循序渐进的步骤。\n\n对于手工业的改造\n\n1. 办手工业供销小组\n2. 办手工业供销合作社\n3. 建立手工业生产合作社\n\n##### 资本主义工商业的社会主义改造\n\n1. 用==和平赎买==的方法改造资本主义工商业，使被资本家占有的生产资料变成人民的财产，这是社会主义革命的一个基本原则。\n2. 采取从低级到高级的国家资本主义的过渡形式\n\n资本主义工商业社会主义改造的步骤\n\n1. 主要实行初级形式的国家资本主义\n\n   这些企业的利润，按==国家所得税、企业公积金、 工人福利费、资方红利==这四个方面进行分配，即“四马分肥”\n\n2. 主要实行个别企业的公私合营\n3. 实行全行业的公私合营\n\n### 社会主义基本制度在中国的确立\n\n#### 社会主义基本制度的确立及其理论依据\n\n==1954 年 9 月==，==第一届全国人民代表大会==的召开和==《中华人民共和国宪法》==的制定及颁布施行，成为我国社会主义民主政治建设的里程碑\n\n#### 确立社会主义基本制度的重大意义\n\n1. 社会主义基本制度的确立，为当代中国一切发展进步奠定了制度基础。\n2. 社会主义制度的建立极大地提高了工人阶级和广大劳动人民的积极性、创造性，极大地促进了我国社会生产力的发展。\n3. 社会主义基本制度以 其与社会化大生产的一致性和能够在经济落后条件下尽可能地集中力量办大事的优势，为发展社会生产力开辟了广阔的道路。\n4. 我国社会生产力的发展，初步显示了社会主义的优越性\n5. 社会主义基本制度的确立，是以毛泽东同志为主要代表的中国共产党人对一个脱胎于半殖民地半封建的东方大国如何进行社会主义革命问题的系统回答和正确解决，是马克思列宁主义关于社会主义革命理论在中国的正确运用和创造性发展的结果。它不仅再次证明了马克思列宁主义的真理性，而且以其独创性的理论原则和经验总结丰富和发展了科学社会主义理论。\n\n## 社会主义建设道路初步探索的理论成果\n\n### 初步探索的重要理论成果\n\n#### 调动一切积极因素为社会主义事业服务\n\n==《论十大关系》==确定了一个==基本方针==，就是==“努力把党内党外、国内国外的一切积极的因素，直接的、间接的积极因素，全部调动起来”==\n\n![十大关系](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202506112209282.png)\n\n#### 正确认识和处理社会主义社会矛盾的思想\n\n==《关于正确处理人民内部矛盾的问题》==系统论述了社会主义社会矛盾的理论\n\n关于社会主义社会的基本矛盾：在社会主义社会中， 基本的矛盾仍然是生产关系和生产力之间的矛盾，上层建筑和经济基础之间的矛盾。但社会主义社会的基本矛盾同以往社会的基本矛盾“具有根本不同的性质和情况”\n\n## 中国特色社会主义理论体系的形成发展\n\n### 中国特色社会主义理论体系形成发展的社会历史条件\n\n#### 中国特色社会主义理论体系形成发展的国际背景\n\n#### 中国特色社会主义理论体系形成发展的历史条件\n\n#### 中国特色社会主义理论体系形成发展的实践基础\n\n### 中国特色社会主义理论体系形成发展过程\n\n#### 中国特色社会主义理论体系的形成\n\n1978 年 12 月召开的党的==十一届三中全会==，重新确立了==实事求是==的思想路线，彻底否定了“以阶级斗争为纲”的错误理论和实践，确定把全党工作的着重点转移到==社会主义现代化建设==上来，作出==施行改革开放==的重大决策，实现了党的历史上具有深远意义的伟大转折。\n\n## 邓小平理论\n\n### 邓小平理论首要的基本的理论问题和精髓\n\n#### 邓小平理论首要的基本的理论问题（p152）\n\n1992 年，邓小平在南方谈话中对社会主义本质作出了总结性的理论概括，指出==“社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕”==\n\n#### 邓小平理论的精髓\n\n==解放思想、实事求是==是邓小平理论的精髓\n\n### 邓小平理论的主要内容\n\n#### 社会主义初级阶段理论和党的基本路线\n\n##### 社会主义初级阶段理论\n\n社会主义初级阶段这个论断包括两层含义\n\n1. 我国社会已经是社会主义社会。我们必须坚持而不能离开谁会主义。\n2. 我国的社会主义社会还处在初级阶段。我们必须从这个实际出发，而不能超越这个阶段。\n\n##### 社会主义初级阶段的基本路线\n\n党在社会主义初级阶段基本路线==“一个中心、两个基本点”==，即==“以经济建设为中心，坚持四项基本原则，坚持改革开放”==\n\n要把以经济建设为中心同坚持四项基本原则、坚持改革开放这两个基本点，统一于中国特色社会主义的伟大实践，贯穿于社会主义现代化建设的整个过程\n\n党的==十九大==提出“为把我国建设成为富强民主文明和谐美丽的社会主义现代化强国而奋斗”、进一步拓展了党的基本路线\n\n#### 社会主义改革开放和社会主义市场经济理论\n\n##### 社会主义改革开放理论\n\n改革是一场深刻的社会变革，是中国的第二次革命，是实现中国现代化的必经之路。\n\n开放也是改革\n\n##### 社会主义市场经济理论\n\n1984 年，党的==十二届三中全==会提出==“公有制基础上的有计划的商品经济”==的概念\n\n1992 年，邓小平在南方谈话中明确指出“计划多一点还是市场多一点，不是社会主义与资本主义的本质区别。计划经济不等于社会主义，资本主义也有计划；市场经济不等于资本主义，社会主义也有市场。计划和市场都是经济手段”。这一精辟论述，从理论上突破了计划经济和市场经济是制度属性的观念，从根本上解除了把计划经济和市场经济看做属于社会基本制度范畴的思想束缚，标志着邓小平的社会主义市场经济理论的形成\n\n## “三个代表”重要思想\n\n### “三个代表”重要思想的核心观点\n\n##### ==始终代表中国先进生产力的发展要求==\n\n“三个代表”：始终代表中国先进生产力的发展要求，始终代表中国先进文化的前进方向，始终代表中国最广大人民的根本利益\n\n科学技术是第一生产力，是先进生产力的集中体现和主要标志\n\n##### ==始终代表中国先进文化的前进方向==\n\n江泽民指出，加强文化建设，必须“以科学的理论武装人，以正确的舆论引导人，以高尚的精神塑造人，以优秀的作品鼓舞人”\n\n加强社会主义思想道德建设，是发展先进文化的重要内容和中心环节。弘扬爱国主义精神，以为人民服务为核心、以集体主义为原则、以诚实守信为重点\n\n##### ==始终代表中国最广大人民的根本利益==\n\n妥善处理各方面的利益（如何认识）p202\n\n### “三个代表”重要思想的主要内容\n\n#### 发展是党执政兴国的第一要务\n\n#### 建立社会主义市场经济体制\n\n江泽民根据邓小平南方谈话精神，明确提出使用==“社会主义市场经济体制”==这个想法\n\n两个“毫不动摇”：\n\n1. 必须毫不动摇地巩固和发展公有制经济，公有制经济不仅包括国有经济和集体经济，还包括混合所有制经济中的国有成分和集体成分。\n\n2. 必须毫不动摇地鼓励、支持和引导非公有制经济发展。个体、私营等各种形式的非公有制经济是社会主义市场经济的重要组成部分，对充分调动社会各方面的积极性、加快生产力发展具有重要作用（如何理解）\n\n#### 建设社会主义政治文明\n\n江泽民在==党的十五大报告==中明确指出：“依法治国，就是广大人民群众在党的领导下，依照宪法和法律规定，通过各种途径和形式管理国家事务，管理经济文化事业，管理社会事务，保证国家各项工作都依法进行，逐步实现社会主义民主的制度化、法律化，是这种制度和法律不因领导人的改变而改变，不因领导人的看法和注意力的改变而改变。依法治国，是党领导人民治理国家的基本方略，是发展社会主义市场经济的客观需要，是社会文明进步的重要标志，是国家长治久安的重要保障”\n\n#### 实施“引进来”和“走出去”相结合的对外开放战略\n\n#### 推进党的建设新的伟大工程\n\n坚持中国共产党的领导，核心是坚持党的先进性\n\n党的两大历史性课题：提高党的领导水平和执政水平、提高拒腐防变和抵御风险能力（两个一定要)\n\n## 科学发展观\n\n### 科学发展观的科学内涵\n\n#### 推动经济社会发展是科学发展观的第一要义\n\n#### 以人为本是科学发展观的核心立场（民本思想）\n\n#### 全面协调可持续是科学发展观的基本要求。\n\n“全面”是指发展要有全面性、整体性，不仅经济要发展，各个方面都要发展；“协调”是指发展要有协调性、均衡性，各个方面、各个环节的发展要相互适应、相互促进；“可持续”是指发展要有持久性、连续性，不仅当前要发展，而且要保证长远发展\n\n坚持可持续发展，坚定走生产发展、生活富裕、生态良好的文明道路。\n\n坚持以生产发展为基础，以生活富裕为目的，以生态良好为条件\n\n#### 统筹兼顾是科学发展观的根本方法\n\n### 科学发展观的主要内容\n\n#### 加快转变经济发展方式\n\n#### 发展社会主义民主政治\n\n#### 推进社会主义文化强国建设\n\n社会主义核心价值体系。社会主义核心价值体系是兴国之魂，决定着中国特色社会主义发展方向。马克思主义指导思想、中国特色社会主义共同理想、以爱国主义为核心的民族精神和以改革创新为核心的时代精神、社会主义荣辱观，共同构成社会主义核心价值体系的基本内容\n\n#### 构建社会主义和谐社会\n\n民主法治、公平正义、诚信有爱、充满活力、安定有序、人与自然和谐相处，是构建社会主义和谐社会的总要求\n\n#### 推进生态文明建设\n\n#### 全面提高党的建设科学化水平\n\n## 课后思考题\n\n### 第一章 毛泽东思想及其历史地位\n\n##### 毛泽东思想形成和发展的社会历史条件是什么\n\n**解答：**\n","slug":"毛概整理","published":1,"date":"2025-09-11T11:36:20.597Z","updated":"2025-09-11T11:36:20.597Z","comments":1,"layout":"post","photos":[],"_id":"cmffo52nu000d6xzd3fpc21np","content":"<h2\nid=\"马克思主义中国化时代化的历史进程与理论成果\">马克思主义中国化时代化的历史进程与理论成果</h2>\n<h3 id=\"马克思主义中国化时代化的提出\">马克思主义中国化时代化的提出</h3>\n<p>1938\n年，毛泽东在党的六届六中全会上作了《<strong>论新阶段</strong>》的报告，标志着“马克思主义中国化”这一命题的正式提出。1945\n年在党的七大上，刘少奇代表党中央作了《关于修改党章的报告》，指出毛泽东思想是“中国化的马克思主义”。</p>\n<h3 id=\"马克思主义中国化时代化的内涵\">马克思主义中国化时代化的内涵</h3>\n<p>马克思主义中国化时代化，就是立足中国国情和时代特点，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，深入研究和解决中国革命、建设、改革不同历史时期的实际问题，真正搞懂面临的时代课题，不断吸收新的时代内容，科学回答时代提出的重大理论和实践课题，创造新的理论成果。</p>\n<h3\nid=\"马克思主义中国化时代化的历史进程\">马克思主义中国化时代化的历史进程</h3>\n<p>毛泽东思想是马克思主义中国化的第一次历史性飞跃</p>\n<p>1978\n年党的十一届三中全会以后，以==邓小平==同志为主要代表的中国共产党人，团结带领全党全国各族人民，深刻总结新中国成立以来正反两方面经验，围绕==什么是社会主义、怎样建设社会主义==这一根本问题，借鉴世界社会主义历史经验，创立了<strong>邓小平理论</strong>。</p>\n<p>党的十三届四中全会以后，以==江泽民==同志为主要代表的中国共产党人，坚持党的基本理论、基本路线，加深了对==什么是社会主义、怎样建设社会主义和建设什么样的党、怎样建设党==的认识，形成了\n<strong>“三个代表”重要思想</strong></p>\n<p>党的十六大以后，以==胡锦涛==同志为主要代表的中国共产党人，在全面建设小康社会进程中推进实践创新、理论创新、制度创新，深刻认识和回答了==新形势下实现什么样的发展、怎样发展等==重大问题，形成了<strong>科学发展观</strong></p>\n<p>形成中国特色社会主义理论体系，实现了马克思主义中国化时代化新的飞跃。</p>\n<p>创立了<strong>习近平新时代中国特色社会主义思想</strong>，实现了==马克思主义中国化时代化新的飞跃==。</p>\n<h2 id=\"毛泽东思想及其历史地位\">毛泽东思想及其历史地位</h2>\n<h3 id=\"毛泽东思想的形成和发展\">毛泽东思想的形成和发展</h3>\n<h4\nid=\"毛泽东思想形成发展的过程p17\">毛泽东思想形成发展的过程（p17）</h4>\n<ol type=\"1\">\n<li><p>毛泽东思想的形成</p>\n<p>形成：</p>\n<ul>\n<li><p>==《中国社会各阶级的分析》《湖南农民运动考察报告》==，提出==新民主主义思想，标志毛泽东思想萌芽==</p></li>\n<li><p>==《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》《反对本本主义》==，指明==中国革命的发展规律，提出农村包围城市，武装夺取政权==</p></li>\n</ul></li>\n<li><p>毛泽东思想的成熟</p>\n<p>==遵义会议==确立了毛泽东同志在党中央和红军的==领导地位==，开始确立以毛泽东同志为主要代表的马克思主义正确路线在党中央的领导地位，开始形成以毛泽东同志为核心的党的第一代中央领导集体，开启了党独立自主解决中国革命实际问题的新阶段，在最危急关头挽救了党、挽救了红军、挽救了中国革命，是一次具有伟大转折意义的重要会议。</p>\n<p>成熟：《实践论》《矛盾论》《<共产党人>发刊词》《中国革命和中国共产党》《新民主主义论》《改造我们的学习》《论联合政府》\n阐述 提出 指明 p18</p>\n<p>==党的六届七中全==会通过的==《关于若干历史问题的决议》==充分肯定了确立毛泽东在全党领导地位的重大意义，==1945\n年党的七大==通过的==《中国共产党党章》==明确规定，“中国共产党，以马克思列宁主义的理论与中国革命的实践统一的思想——毛泽东思想，作为自己一切工作的指针”，标志==把毛泽东思想确立为党必须长期坚持的指导思想==。</p></li>\n<li><p>毛泽东思想的继续发展</p></li>\n</ol>\n<p>继续发展：==《在中国共产党第七届中央委员会第二次全体会议上的报告》《论人民民主专政》《论十大关系》《关于正确处理人民内部矛盾的问题》==</p>\n<h3\nid=\"毛泽东思想的主要内容和活的灵魂\">毛泽东思想的主要内容和活的灵魂</h3>\n<h4 id=\"毛泽东思想的主要内容\">毛泽东思想的主要内容</h4>\n<ol type=\"1\">\n<li>新民主主义革命理论</li>\n</ol>\n<p>毛泽东指出，==统一战线、武装斗争和党的建设==，是中国共产党在中国革命战争中战胜敌人的==三大法宝==</p>\n<ol start=\"2\" type=\"1\">\n<li><p>社会主义革命和社会主义建设理论</p>\n<p>民主管理==“两参一改三结合”==的思想：==干部参加劳动，工人参加管理，改革不合理的规章制度，工人群众、领导干部和技术人员三结合==</p></li>\n<li><p>革命军队建设和军事战略的理论</p>\n<p>无产阶级及其政党要实现自己对同盟者的领导，必须具备两个条件：</p>\n<ol type=\"1\">\n<li>率领被领导者向着共同的敌人作坚决斗争并==取得胜利==</li>\n<li>对被领导者==给以物质利益，至少不损害其利益，同时给以政治教育==</li>\n</ol></li>\n</ol>\n<h4 id=\"毛泽东思想活的灵魂\">毛泽东思想活的灵魂</h4>\n<p>1981\n年党的十一届六中全会通过的《中国共产党中央委员会关于建国以来党的若干历史问题的决议》指出：“毛泽东思想的==活的灵魂==，是贯穿于上述各个组成部分的立场、观点和方法，它们有三个基本方面，即==实事求是，群众路线，独立自主==\n（三个坚持）</p>\n<h2 id=\"新民主主义革命理论\">新民主主义革命理论</h2>\n<h3\nid=\"新民主主义革命的总路线和基本纲领\">新民主主义革命的总路线和基本纲领</h3>\n<h4 id=\"新民主主义革命的总路线\">新民主主义革命的总路线</h4>\n<p>1939\n年，毛泽东在==《中国革命和中国共产党》==一文中第一次提出了==“新民主主义的革命”==的科学概念，1948\n年，毛泽东在==《在晋绥干部会议上的讲话》==中完整的总结和概括了==新民主主义革命的总路线的内容==，即==无产阶级领导的、人民大众的，反对帝国主义、封建主义和官僚资本主义的革命==。新民主主义革命总路线反映了中国革命的基本规律，指明了中国革命的对象、动力、领导力量、性质和前途，是新民主主义革命的指导路线</p>\n<h5 id=\"新民主主义革命的领导力量\">新民主主义革命的领导力量</h5>\n<p>无产阶级的领导权是中国革命的中心问题，也是新民主主义革命理论的核心问题，区别于新旧两种不同范畴的民主主义革命的根本标志是，革命的领导权掌握在无产阶级手中还是掌握在资产阶级手中</p>\n<p>中国无产阶级除了具有与先进的生产方式相联系、没有私人占有的生产资料、富于组织纪律性等一般无产阶级的基本有点外，还具有自身的特点和优点。</p>\n<ol type=\"1\">\n<li><p>从诞生之日起，就深受外国资本主义、本国封建势力和资产阶级的三重压迫，而这些压迫的研中心和残酷性，是世界各民族中少见的。因此，中国无产阶级在革命斗争中比任何别的阶级都来得坚决和彻底。</p></li>\n<li><p>集中分布在少数大城市和大企业，有利于组织和团结，有利于革命思想的传播和强大革命力量的形成。</p></li>\n<li><p>成员中大部分出身于破产农民，和农民有着天然的联系，便于和农民结成亲密的联盟，共同团结战斗。</p></li>\n</ol>\n<h5 id=\"新民主主义革命的性质和前途\">新民主主义革命的性质和前途</h5>\n<p>新民主主义革命的性质不是无产阶级社会主义革命，而是==资产阶级民主主义革命==。</p>\n<p>新民主主义革命与旧民主主义革命相比有新的内容和特点，与社会主义革命性质不同，又是与社会主义革命互相联系、紧密衔接的。</p>\n<h4 id=\"新民主主义的基本纲领\">新民主主义的基本纲领</h4>\n<p>1945\n年，毛泽东在党的七大所作的政治报告《论联合政府》中，进一步把新民主主义的政治、经济和文化与党的基本纲领联系起来。</p>\n<h5 id=\"新民主主义的政治纲领\">新民主主义的政治纲领</h5>\n<p>==推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国==。</p>\n<p>既不同于欧美式的资产阶级专政的共和国，又和苏联式的无产阶级专政和社会主义共和国相区别。</p>\n<p>新民主主义国家的国体是无产阶级领导的以工农联盟为基础，包括小资产阶级、民族资产阶级和其他反帝反封建的人们在内的各革命阶级的联合专政。</p>\n<h5 id=\"新民主主义的经济纲领\">新民主主义的经济纲领</h5>\n<p>==没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有==。</p>\n<p>在新民主主义条件下保护民族工商业，发展资本主义，是由中国落后的生产力和新民主主义革命的性质所决定的。</p>\n<h5 id=\"新民主主义的文化纲领\">新民主主义的文化纲领</h5>\n<p>==新民主主义文化，就是无产阶级领导的人民大众的反帝反封建的文化，即民族科学的大众文化==。</p>\n<h3\nid=\"新民主主义革命的道路和基本经验\">新民主主义革命的道路和基本经验</h3>\n<h4 id=\"新民主主义革命的道路\">新民主主义革命的道路</h4>\n<p>新民主主义革命的道路：==农村包围城市、武装夺取政权==。</p>\n<h5 id=\"新民主主义革命道路的提出\">新民主主义革命道路的提出</h5>\n<p>==《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》==，提出==“工农武装割据”==的思想，初步形成了农村包围城市的革命道路理论。</p>\n<h5\nid=\"新民主主义革命道路形成的必然性\">新民主主义革命道路形成的必然性</h5>\n<ol type=\"1\">\n<li>近代中国是多个帝国主义间接统治的经济落后的半殖民地国家，社会政治经济发展极端不平衡，四分五裂，军阀割据，存在不少的统治薄弱环节，为党在农村开展革命斗争、建设革命根据地提供了缝隙和可能</li>\n<li>近代中国的广大农村深受反动统治阶级的多重压迫和剥削，人民革命愿望强烈，加之经历过大革命的洗礼，革命的群众基础好</li>\n<li>全国革命形势的继续向前发展，为在农村建设革命根据地提供了客观条件</li>\n<li>相当力量正式红军的存在，为农村革命根据地的创立、巩固和发展提供了坚强后盾</li>\n<li>党的领导的有力量及其政策的不错误，为农村革命根据地建设和发展提供了重要的主观条件。</li>\n</ol>\n<h4 id=\"新民主主义革命的三大法宝\">新民主主义革命的三大法宝</h4>\n<p>==统一战线、武装斗争和党的建设==，是中国共产党在中国革命战争中战胜敌人的三大法宝==《共产党人发刊词》==</p>\n<h5 id=\"统一战线\">统一战线</h5>\n<p>党建立、巩固和发展统一战线的实践经验：</p>\n<ol type=\"1\">\n<li>建立巩固的工农联盟</li>\n<li>正确对待资产阶级，尤其是民族资产阶级</li>\n<li>采取区别对待的方针</li>\n<li>坚持独立自主的原则</li>\n</ol>\n<h5 id=\"武装斗争\">武装斗争</h5>\n<ol type=\"1\">\n<li>坚持党对军队的绝对领导，这是建设新型人民军队的根本原则，是保持人民军队无产阶级性质和建军宗旨的根本前提，也是毛泽东建军思想的核心。</li>\n<li>建设全心全意为人民服务的人民军队，须以全心全意为人民服务为唯一宗旨。</li>\n<li>开展革命的政治工作</li>\n<li>坚持正确的战略战术原则</li>\n</ol>\n<h5 id=\"党的建设\">党的建设</h5>\n<p>党加强自身建设的经验：</p>\n<ol type=\"1\">\n<li>把思想建设始终放在党的建设的首位</li>\n<li>在任何时候都重视党的组织建设</li>\n<li>重视党的作风建设</li>\n<li>联系党的政治路线加强党的建设</li>\n</ol>\n<h2 id=\"社会主义改造理论\">社会主义改造理论</h2>\n<h3 id=\"从新民主主义到社会主义的转变\">从新民主主义到社会主义的转变</h3>\n<h4\nid=\"新民主主义社会是一个过渡性的社会\">新民主主义社会是一个过渡性的社会</h4>\n<p>新民主主义社会不是一个独立的社会形态，而是由新民主主义向社会主义转变的==过渡性社会形态==</p>\n<p>主要的经济成分是三种</p>\n<ol type=\"1\">\n<li>社会主义经济</li>\n<li>个体经济</li>\n<li>资本主义经济</li>\n</ol>\n<p>逐渐扩大国营经济，逐步将资本主义经济和个体经济改编为社会主义经济，使社会主义经济逐步称为我国的经济基础</p>\n<h4 id=\"党在过渡时期的总路线及其依据\">党在过渡时期的总路线及其依据</h4>\n<h5 id=\"党在过渡时期的总路线的提出\">党在过渡时期的总路线的提出</h5>\n<p>党在过渡时期总路线的主要内容为==“一化三改”==。“一化”即==社会主义工业化==，“三改”即对==个体农业、手工业和资本主义工商业的社会主义改造==，它们之间相互联系，不可分离。其中“一化”是主体，“三改”是“两翼”，两者相辅相成，相互促进。这是一条社会主义建设和社会主义改造同时并举的路线，体现了社会主义工业化和社会主义改造的紧密结合，体现了解放生产力、变革生产关系与发展生产力的有机统一</p>\n<h3 id=\"社会主义改造道路和历史经验\">社会主义改造道路和历史经验</h3>\n<h4\nid=\"适合中国特点的社会主义改造道路\">适合中国特点的社会主义改造道路</h4>\n<h5 id=\"农业手工业的社会主义改造\">农业、手工业的社会主义改造</h5>\n<p>对于农业的改造</p>\n<ol type=\"1\">\n<li>积极引导农民组织起来，走互助合作道路。</li>\n<li>遵循自愿互利、典型示范和国家帮助的原则，以互助合作的优越性吸引农民走互助合作道路。</li>\n<li>正确分析农村的阶级和阶层状况，制定正确的阶级政策。党制定并贯彻执行了依靠贫下中农,\n发展互助合作，由逐步限制到最后消灭富农剥削的农村阶级政策。这使农业合作化有了坚实的阶级基础和群众基础。</li>\n<li>坚持积极领导、稳步前进的方针，采取循序渐进的步骤。</li>\n</ol>\n<p>对于手工业的改造</p>\n<ol type=\"1\">\n<li>办手工业供销小组</li>\n<li>办手工业供销合作社</li>\n<li>建立手工业生产合作社</li>\n</ol>\n<h5 id=\"资本主义工商业的社会主义改造\">资本主义工商业的社会主义改造</h5>\n<ol type=\"1\">\n<li>用==和平赎买==的方法改造资本主义工商业，使被资本家占有的生产资料变成人民的财产，这是社会主义革命的一个基本原则。</li>\n<li>采取从低级到高级的国家资本主义的过渡形式</li>\n</ol>\n<p>资本主义工商业社会主义改造的步骤</p>\n<ol type=\"1\">\n<li><p>主要实行初级形式的国家资本主义</p>\n<p>这些企业的利润，按==国家所得税、企业公积金、\n工人福利费、资方红利==这四个方面进行分配，即“四马分肥”</p></li>\n<li><p>主要实行个别企业的公私合营</p></li>\n<li><p>实行全行业的公私合营</p></li>\n</ol>\n<h3 id=\"社会主义基本制度在中国的确立\">社会主义基本制度在中国的确立</h3>\n<h4\nid=\"社会主义基本制度的确立及其理论依据\">社会主义基本制度的确立及其理论依据</h4>\n<p>==1954 年 9\n月==，==第一届全国人民代表大会==的召开和==《中华人民共和国宪法》==的制定及颁布施行，成为我国社会主义民主政治建设的里程碑</p>\n<h4\nid=\"确立社会主义基本制度的重大意义\">确立社会主义基本制度的重大意义</h4>\n<ol type=\"1\">\n<li>社会主义基本制度的确立，为当代中国一切发展进步奠定了制度基础。</li>\n<li>社会主义制度的建立极大地提高了工人阶级和广大劳动人民的积极性、创造性，极大地促进了我国社会生产力的发展。</li>\n<li>社会主义基本制度以\n其与社会化大生产的一致性和能够在经济落后条件下尽可能地集中力量办大事的优势，为发展社会生产力开辟了广阔的道路。</li>\n<li>我国社会生产力的发展，初步显示了社会主义的优越性</li>\n<li>社会主义基本制度的确立，是以毛泽东同志为主要代表的中国共产党人对一个脱胎于半殖民地半封建的东方大国如何进行社会主义革命问题的系统回答和正确解决，是马克思列宁主义关于社会主义革命理论在中国的正确运用和创造性发展的结果。它不仅再次证明了马克思列宁主义的真理性，而且以其独创性的理论原则和经验总结丰富和发展了科学社会主义理论。</li>\n</ol>\n<h2\nid=\"社会主义建设道路初步探索的理论成果\">社会主义建设道路初步探索的理论成果</h2>\n<h3 id=\"初步探索的重要理论成果\">初步探索的重要理论成果</h3>\n<h4\nid=\"调动一切积极因素为社会主义事业服务\">调动一切积极因素为社会主义事业服务</h4>\n<p>==《论十大关系》==确定了一个==基本方针==，就是==“努力把党内党外、国内国外的一切积极的因素，直接的、间接的积极因素，全部调动起来”==</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202506112209282.png\"\nalt=\"十大关系\" />\n<figcaption aria-hidden=\"true\">十大关系</figcaption>\n</figure>\n<h4\nid=\"正确认识和处理社会主义社会矛盾的思想\">正确认识和处理社会主义社会矛盾的思想</h4>\n<p>==《关于正确处理人民内部矛盾的问题》==系统论述了社会主义社会矛盾的理论</p>\n<p>关于社会主义社会的基本矛盾：在社会主义社会中，\n基本的矛盾仍然是生产关系和生产力之间的矛盾，上层建筑和经济基础之间的矛盾。但社会主义社会的基本矛盾同以往社会的基本矛盾“具有根本不同的性质和情况”</p>\n<h2\nid=\"中国特色社会主义理论体系的形成发展\">中国特色社会主义理论体系的形成发展</h2>\n<h3\nid=\"中国特色社会主义理论体系形成发展的社会历史条件\">中国特色社会主义理论体系形成发展的社会历史条件</h3>\n<h4\nid=\"中国特色社会主义理论体系形成发展的国际背景\">中国特色社会主义理论体系形成发展的国际背景</h4>\n<h4\nid=\"中国特色社会主义理论体系形成发展的历史条件\">中国特色社会主义理论体系形成发展的历史条件</h4>\n<h4\nid=\"中国特色社会主义理论体系形成发展的实践基础\">中国特色社会主义理论体系形成发展的实践基础</h4>\n<h3\nid=\"中国特色社会主义理论体系形成发展过程\">中国特色社会主义理论体系形成发展过程</h3>\n<h4\nid=\"中国特色社会主义理论体系的形成\">中国特色社会主义理论体系的形成</h4>\n<p>1978 年 12\n月召开的党的==十一届三中全会==，重新确立了==实事求是==的思想路线，彻底否定了“以阶级斗争为纲”的错误理论和实践，确定把全党工作的着重点转移到==社会主义现代化建设==上来，作出==施行改革开放==的重大决策，实现了党的历史上具有深远意义的伟大转折。</p>\n<h2 id=\"邓小平理论\">邓小平理论</h2>\n<h3\nid=\"邓小平理论首要的基本的理论问题和精髓\">邓小平理论首要的基本的理论问题和精髓</h3>\n<h4\nid=\"邓小平理论首要的基本的理论问题p152\">邓小平理论首要的基本的理论问题（p152）</h4>\n<p>1992\n年，邓小平在南方谈话中对社会主义本质作出了总结性的理论概括，指出==“社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕”==</p>\n<h4 id=\"邓小平理论的精髓\">邓小平理论的精髓</h4>\n<p>==解放思想、实事求是==是邓小平理论的精髓</p>\n<h3 id=\"邓小平理论的主要内容\">邓小平理论的主要内容</h3>\n<h4\nid=\"社会主义初级阶段理论和党的基本路线\">社会主义初级阶段理论和党的基本路线</h4>\n<h5 id=\"社会主义初级阶段理论\">社会主义初级阶段理论</h5>\n<p>社会主义初级阶段这个论断包括两层含义</p>\n<ol type=\"1\">\n<li>我国社会已经是社会主义社会。我们必须坚持而不能离开谁会主义。</li>\n<li>我国的社会主义社会还处在初级阶段。我们必须从这个实际出发，而不能超越这个阶段。</li>\n</ol>\n<h5 id=\"社会主义初级阶段的基本路线\">社会主义初级阶段的基本路线</h5>\n<p>党在社会主义初级阶段基本路线==“一个中心、两个基本点”==，即==“以经济建设为中心，坚持四项基本原则，坚持改革开放”==</p>\n<p>要把以经济建设为中心同坚持四项基本原则、坚持改革开放这两个基本点，统一于中国特色社会主义的伟大实践，贯穿于社会主义现代化建设的整个过程</p>\n<p>党的==十九大==提出“为把我国建设成为富强民主文明和谐美丽的社会主义现代化强国而奋斗”、进一步拓展了党的基本路线</p>\n<h4\nid=\"社会主义改革开放和社会主义市场经济理论\">社会主义改革开放和社会主义市场经济理论</h4>\n<h5 id=\"社会主义改革开放理论\">社会主义改革开放理论</h5>\n<p>改革是一场深刻的社会变革，是中国的第二次革命，是实现中国现代化的必经之路。</p>\n<p>开放也是改革</p>\n<h5 id=\"社会主义市场经济理论\">社会主义市场经济理论</h5>\n<p>1984\n年，党的==十二届三中全==会提出==“公有制基础上的有计划的商品经济”==的概念</p>\n<p>1992\n年，邓小平在南方谈话中明确指出“计划多一点还是市场多一点，不是社会主义与资本主义的本质区别。计划经济不等于社会主义，资本主义也有计划；市场经济不等于资本主义，社会主义也有市场。计划和市场都是经济手段”。这一精辟论述，从理论上突破了计划经济和市场经济是制度属性的观念，从根本上解除了把计划经济和市场经济看做属于社会基本制度范畴的思想束缚，标志着邓小平的社会主义市场经济理论的形成</p>\n<h2 id=\"三个代表重要思想\">“三个代表”重要思想</h2>\n<h3 id=\"三个代表重要思想的核心观点\">“三个代表”重要思想的核心观点</h3>\n<h5\nid=\"始终代表中国先进生产力的发展要求\">==始终代表中国先进生产力的发展要求==</h5>\n<p>“三个代表”：始终代表中国先进生产力的发展要求，始终代表中国先进文化的前进方向，始终代表中国最广大人民的根本利益</p>\n<p>科学技术是第一生产力，是先进生产力的集中体现和主要标志</p>\n<h5\nid=\"始终代表中国先进文化的前进方向\">==始终代表中国先进文化的前进方向==</h5>\n<p>江泽民指出，加强文化建设，必须“以科学的理论武装人，以正确的舆论引导人，以高尚的精神塑造人，以优秀的作品鼓舞人”</p>\n<p>加强社会主义思想道德建设，是发展先进文化的重要内容和中心环节。弘扬爱国主义精神，以为人民服务为核心、以集体主义为原则、以诚实守信为重点</p>\n<h5\nid=\"始终代表中国最广大人民的根本利益\">==始终代表中国最广大人民的根本利益==</h5>\n<p>妥善处理各方面的利益（如何认识）p202</p>\n<h3 id=\"三个代表重要思想的主要内容\">“三个代表”重要思想的主要内容</h3>\n<h4 id=\"发展是党执政兴国的第一要务\">发展是党执政兴国的第一要务</h4>\n<h4 id=\"建立社会主义市场经济体制\">建立社会主义市场经济体制</h4>\n<p>江泽民根据邓小平南方谈话精神，明确提出使用==“社会主义市场经济体制”==这个想法</p>\n<p>两个“毫不动摇”：</p>\n<ol type=\"1\">\n<li><p>必须毫不动摇地巩固和发展公有制经济，公有制经济不仅包括国有经济和集体经济，还包括混合所有制经济中的国有成分和集体成分。</p></li>\n<li><p>必须毫不动摇地鼓励、支持和引导非公有制经济发展。个体、私营等各种形式的非公有制经济是社会主义市场经济的重要组成部分，对充分调动社会各方面的积极性、加快生产力发展具有重要作用（如何理解）</p></li>\n</ol>\n<h4 id=\"建设社会主义政治文明\">建设社会主义政治文明</h4>\n<p>江泽民在==党的十五大报告==中明确指出：“依法治国，就是广大人民群众在党的领导下，依照宪法和法律规定，通过各种途径和形式管理国家事务，管理经济文化事业，管理社会事务，保证国家各项工作都依法进行，逐步实现社会主义民主的制度化、法律化，是这种制度和法律不因领导人的改变而改变，不因领导人的看法和注意力的改变而改变。依法治国，是党领导人民治理国家的基本方略，是发展社会主义市场经济的客观需要，是社会文明进步的重要标志，是国家长治久安的重要保障”</p>\n<h4\nid=\"实施引进来和走出去相结合的对外开放战略\">实施“引进来”和“走出去”相结合的对外开放战略</h4>\n<h4 id=\"推进党的建设新的伟大工程\">推进党的建设新的伟大工程</h4>\n<p>坚持中国共产党的领导，核心是坚持党的先进性</p>\n<p>党的两大历史性课题：提高党的领导水平和执政水平、提高拒腐防变和抵御风险能力（两个一定要)</p>\n<h2 id=\"科学发展观\">科学发展观</h2>\n<h3 id=\"科学发展观的科学内涵\">科学发展观的科学内涵</h3>\n<h4\nid=\"推动经济社会发展是科学发展观的第一要义\">推动经济社会发展是科学发展观的第一要义</h4>\n<h4\nid=\"以人为本是科学发展观的核心立场民本思想\">以人为本是科学发展观的核心立场（民本思想）</h4>\n<h4\nid=\"全面协调可持续是科学发展观的基本要求\">全面协调可持续是科学发展观的基本要求。</h4>\n<p>“全面”是指发展要有全面性、整体性，不仅经济要发展，各个方面都要发展；“协调”是指发展要有协调性、均衡性，各个方面、各个环节的发展要相互适应、相互促进；“可持续”是指发展要有持久性、连续性，不仅当前要发展，而且要保证长远发展</p>\n<p>坚持可持续发展，坚定走生产发展、生活富裕、生态良好的文明道路。</p>\n<p>坚持以生产发展为基础，以生活富裕为目的，以生态良好为条件</p>\n<h4\nid=\"统筹兼顾是科学发展观的根本方法\">统筹兼顾是科学发展观的根本方法</h4>\n<h3 id=\"科学发展观的主要内容\">科学发展观的主要内容</h3>\n<h4 id=\"加快转变经济发展方式\">加快转变经济发展方式</h4>\n<h4 id=\"发展社会主义民主政治\">发展社会主义民主政治</h4>\n<h4 id=\"推进社会主义文化强国建设\">推进社会主义文化强国建设</h4>\n<p>社会主义核心价值体系。社会主义核心价值体系是兴国之魂，决定着中国特色社会主义发展方向。马克思主义指导思想、中国特色社会主义共同理想、以爱国主义为核心的民族精神和以改革创新为核心的时代精神、社会主义荣辱观，共同构成社会主义核心价值体系的基本内容</p>\n<h4 id=\"构建社会主义和谐社会\">构建社会主义和谐社会</h4>\n<p>民主法治、公平正义、诚信有爱、充满活力、安定有序、人与自然和谐相处，是构建社会主义和谐社会的总要求</p>\n<h4 id=\"推进生态文明建设\">推进生态文明建设</h4>\n<h4 id=\"全面提高党的建设科学化水平\">全面提高党的建设科学化水平</h4>\n<h2 id=\"课后思考题\">课后思考题</h2>\n<h3 id=\"第一章-毛泽东思想及其历史地位\">第一章\n毛泽东思想及其历史地位</h3>\n<h5\nid=\"毛泽东思想形成和发展的社会历史条件是什么\">毛泽东思想形成和发展的社会历史条件是什么</h5>\n<p><strong>解答：</strong></p>\n","excerpt":"","more":"<h2\nid=\"马克思主义中国化时代化的历史进程与理论成果\">马克思主义中国化时代化的历史进程与理论成果</h2>\n<h3 id=\"马克思主义中国化时代化的提出\">马克思主义中国化时代化的提出</h3>\n<p>1938\n年，毛泽东在党的六届六中全会上作了《<strong>论新阶段</strong>》的报告，标志着“马克思主义中国化”这一命题的正式提出。1945\n年在党的七大上，刘少奇代表党中央作了《关于修改党章的报告》，指出毛泽东思想是“中国化的马克思主义”。</p>\n<h3 id=\"马克思主义中国化时代化的内涵\">马克思主义中国化时代化的内涵</h3>\n<p>马克思主义中国化时代化，就是立足中国国情和时代特点，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，深入研究和解决中国革命、建设、改革不同历史时期的实际问题，真正搞懂面临的时代课题，不断吸收新的时代内容，科学回答时代提出的重大理论和实践课题，创造新的理论成果。</p>\n<h3\nid=\"马克思主义中国化时代化的历史进程\">马克思主义中国化时代化的历史进程</h3>\n<p>毛泽东思想是马克思主义中国化的第一次历史性飞跃</p>\n<p>1978\n年党的十一届三中全会以后，以==邓小平==同志为主要代表的中国共产党人，团结带领全党全国各族人民，深刻总结新中国成立以来正反两方面经验，围绕==什么是社会主义、怎样建设社会主义==这一根本问题，借鉴世界社会主义历史经验，创立了<strong>邓小平理论</strong>。</p>\n<p>党的十三届四中全会以后，以==江泽民==同志为主要代表的中国共产党人，坚持党的基本理论、基本路线，加深了对==什么是社会主义、怎样建设社会主义和建设什么样的党、怎样建设党==的认识，形成了\n<strong>“三个代表”重要思想</strong></p>\n<p>党的十六大以后，以==胡锦涛==同志为主要代表的中国共产党人，在全面建设小康社会进程中推进实践创新、理论创新、制度创新，深刻认识和回答了==新形势下实现什么样的发展、怎样发展等==重大问题，形成了<strong>科学发展观</strong></p>\n<p>形成中国特色社会主义理论体系，实现了马克思主义中国化时代化新的飞跃。</p>\n<p>创立了<strong>习近平新时代中国特色社会主义思想</strong>，实现了==马克思主义中国化时代化新的飞跃==。</p>\n<h2 id=\"毛泽东思想及其历史地位\">毛泽东思想及其历史地位</h2>\n<h3 id=\"毛泽东思想的形成和发展\">毛泽东思想的形成和发展</h3>\n<h4\nid=\"毛泽东思想形成发展的过程p17\">毛泽东思想形成发展的过程（p17）</h4>\n<ol type=\"1\">\n<li><p>毛泽东思想的形成</p>\n<p>形成：</p>\n<ul>\n<li><p>==《中国社会各阶级的分析》《湖南农民运动考察报告》==，提出==新民主主义思想，标志毛泽东思想萌芽==</p></li>\n<li><p>==《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》《反对本本主义》==，指明==中国革命的发展规律，提出农村包围城市，武装夺取政权==</p></li>\n</ul></li>\n<li><p>毛泽东思想的成熟</p>\n<p>==遵义会议==确立了毛泽东同志在党中央和红军的==领导地位==，开始确立以毛泽东同志为主要代表的马克思主义正确路线在党中央的领导地位，开始形成以毛泽东同志为核心的党的第一代中央领导集体，开启了党独立自主解决中国革命实际问题的新阶段，在最危急关头挽救了党、挽救了红军、挽救了中国革命，是一次具有伟大转折意义的重要会议。</p>\n<p>成熟：《实践论》《矛盾论》《<共产党人>发刊词》《中国革命和中国共产党》《新民主主义论》《改造我们的学习》《论联合政府》\n阐述 提出 指明 p18</p>\n<p>==党的六届七中全==会通过的==《关于若干历史问题的决议》==充分肯定了确立毛泽东在全党领导地位的重大意义，==1945\n年党的七大==通过的==《中国共产党党章》==明确规定，“中国共产党，以马克思列宁主义的理论与中国革命的实践统一的思想——毛泽东思想，作为自己一切工作的指针”，标志==把毛泽东思想确立为党必须长期坚持的指导思想==。</p></li>\n<li><p>毛泽东思想的继续发展</p></li>\n</ol>\n<p>继续发展：==《在中国共产党第七届中央委员会第二次全体会议上的报告》《论人民民主专政》《论十大关系》《关于正确处理人民内部矛盾的问题》==</p>\n<h3\nid=\"毛泽东思想的主要内容和活的灵魂\">毛泽东思想的主要内容和活的灵魂</h3>\n<h4 id=\"毛泽东思想的主要内容\">毛泽东思想的主要内容</h4>\n<ol type=\"1\">\n<li>新民主主义革命理论</li>\n</ol>\n<p>毛泽东指出，==统一战线、武装斗争和党的建设==，是中国共产党在中国革命战争中战胜敌人的==三大法宝==</p>\n<ol start=\"2\" type=\"1\">\n<li><p>社会主义革命和社会主义建设理论</p>\n<p>民主管理==“两参一改三结合”==的思想：==干部参加劳动，工人参加管理，改革不合理的规章制度，工人群众、领导干部和技术人员三结合==</p></li>\n<li><p>革命军队建设和军事战略的理论</p>\n<p>无产阶级及其政党要实现自己对同盟者的领导，必须具备两个条件：</p>\n<ol type=\"1\">\n<li>率领被领导者向着共同的敌人作坚决斗争并==取得胜利==</li>\n<li>对被领导者==给以物质利益，至少不损害其利益，同时给以政治教育==</li>\n</ol></li>\n</ol>\n<h4 id=\"毛泽东思想活的灵魂\">毛泽东思想活的灵魂</h4>\n<p>1981\n年党的十一届六中全会通过的《中国共产党中央委员会关于建国以来党的若干历史问题的决议》指出：“毛泽东思想的==活的灵魂==，是贯穿于上述各个组成部分的立场、观点和方法，它们有三个基本方面，即==实事求是，群众路线，独立自主==\n（三个坚持）</p>\n<h2 id=\"新民主主义革命理论\">新民主主义革命理论</h2>\n<h3\nid=\"新民主主义革命的总路线和基本纲领\">新民主主义革命的总路线和基本纲领</h3>\n<h4 id=\"新民主主义革命的总路线\">新民主主义革命的总路线</h4>\n<p>1939\n年，毛泽东在==《中国革命和中国共产党》==一文中第一次提出了==“新民主主义的革命”==的科学概念，1948\n年，毛泽东在==《在晋绥干部会议上的讲话》==中完整的总结和概括了==新民主主义革命的总路线的内容==，即==无产阶级领导的、人民大众的，反对帝国主义、封建主义和官僚资本主义的革命==。新民主主义革命总路线反映了中国革命的基本规律，指明了中国革命的对象、动力、领导力量、性质和前途，是新民主主义革命的指导路线</p>\n<h5 id=\"新民主主义革命的领导力量\">新民主主义革命的领导力量</h5>\n<p>无产阶级的领导权是中国革命的中心问题，也是新民主主义革命理论的核心问题，区别于新旧两种不同范畴的民主主义革命的根本标志是，革命的领导权掌握在无产阶级手中还是掌握在资产阶级手中</p>\n<p>中国无产阶级除了具有与先进的生产方式相联系、没有私人占有的生产资料、富于组织纪律性等一般无产阶级的基本有点外，还具有自身的特点和优点。</p>\n<ol type=\"1\">\n<li><p>从诞生之日起，就深受外国资本主义、本国封建势力和资产阶级的三重压迫，而这些压迫的研中心和残酷性，是世界各民族中少见的。因此，中国无产阶级在革命斗争中比任何别的阶级都来得坚决和彻底。</p></li>\n<li><p>集中分布在少数大城市和大企业，有利于组织和团结，有利于革命思想的传播和强大革命力量的形成。</p></li>\n<li><p>成员中大部分出身于破产农民，和农民有着天然的联系，便于和农民结成亲密的联盟，共同团结战斗。</p></li>\n</ol>\n<h5 id=\"新民主主义革命的性质和前途\">新民主主义革命的性质和前途</h5>\n<p>新民主主义革命的性质不是无产阶级社会主义革命，而是==资产阶级民主主义革命==。</p>\n<p>新民主主义革命与旧民主主义革命相比有新的内容和特点，与社会主义革命性质不同，又是与社会主义革命互相联系、紧密衔接的。</p>\n<h4 id=\"新民主主义的基本纲领\">新民主主义的基本纲领</h4>\n<p>1945\n年，毛泽东在党的七大所作的政治报告《论联合政府》中，进一步把新民主主义的政治、经济和文化与党的基本纲领联系起来。</p>\n<h5 id=\"新民主主义的政治纲领\">新民主主义的政治纲领</h5>\n<p>==推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国==。</p>\n<p>既不同于欧美式的资产阶级专政的共和国，又和苏联式的无产阶级专政和社会主义共和国相区别。</p>\n<p>新民主主义国家的国体是无产阶级领导的以工农联盟为基础，包括小资产阶级、民族资产阶级和其他反帝反封建的人们在内的各革命阶级的联合专政。</p>\n<h5 id=\"新民主主义的经济纲领\">新民主主义的经济纲领</h5>\n<p>==没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有==。</p>\n<p>在新民主主义条件下保护民族工商业，发展资本主义，是由中国落后的生产力和新民主主义革命的性质所决定的。</p>\n<h5 id=\"新民主主义的文化纲领\">新民主主义的文化纲领</h5>\n<p>==新民主主义文化，就是无产阶级领导的人民大众的反帝反封建的文化，即民族科学的大众文化==。</p>\n<h3\nid=\"新民主主义革命的道路和基本经验\">新民主主义革命的道路和基本经验</h3>\n<h4 id=\"新民主主义革命的道路\">新民主主义革命的道路</h4>\n<p>新民主主义革命的道路：==农村包围城市、武装夺取政权==。</p>\n<h5 id=\"新民主主义革命道路的提出\">新民主主义革命道路的提出</h5>\n<p>==《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》==，提出==“工农武装割据”==的思想，初步形成了农村包围城市的革命道路理论。</p>\n<h5\nid=\"新民主主义革命道路形成的必然性\">新民主主义革命道路形成的必然性</h5>\n<ol type=\"1\">\n<li>近代中国是多个帝国主义间接统治的经济落后的半殖民地国家，社会政治经济发展极端不平衡，四分五裂，军阀割据，存在不少的统治薄弱环节，为党在农村开展革命斗争、建设革命根据地提供了缝隙和可能</li>\n<li>近代中国的广大农村深受反动统治阶级的多重压迫和剥削，人民革命愿望强烈，加之经历过大革命的洗礼，革命的群众基础好</li>\n<li>全国革命形势的继续向前发展，为在农村建设革命根据地提供了客观条件</li>\n<li>相当力量正式红军的存在，为农村革命根据地的创立、巩固和发展提供了坚强后盾</li>\n<li>党的领导的有力量及其政策的不错误，为农村革命根据地建设和发展提供了重要的主观条件。</li>\n</ol>\n<h4 id=\"新民主主义革命的三大法宝\">新民主主义革命的三大法宝</h4>\n<p>==统一战线、武装斗争和党的建设==，是中国共产党在中国革命战争中战胜敌人的三大法宝==《共产党人发刊词》==</p>\n<h5 id=\"统一战线\">统一战线</h5>\n<p>党建立、巩固和发展统一战线的实践经验：</p>\n<ol type=\"1\">\n<li>建立巩固的工农联盟</li>\n<li>正确对待资产阶级，尤其是民族资产阶级</li>\n<li>采取区别对待的方针</li>\n<li>坚持独立自主的原则</li>\n</ol>\n<h5 id=\"武装斗争\">武装斗争</h5>\n<ol type=\"1\">\n<li>坚持党对军队的绝对领导，这是建设新型人民军队的根本原则，是保持人民军队无产阶级性质和建军宗旨的根本前提，也是毛泽东建军思想的核心。</li>\n<li>建设全心全意为人民服务的人民军队，须以全心全意为人民服务为唯一宗旨。</li>\n<li>开展革命的政治工作</li>\n<li>坚持正确的战略战术原则</li>\n</ol>\n<h5 id=\"党的建设\">党的建设</h5>\n<p>党加强自身建设的经验：</p>\n<ol type=\"1\">\n<li>把思想建设始终放在党的建设的首位</li>\n<li>在任何时候都重视党的组织建设</li>\n<li>重视党的作风建设</li>\n<li>联系党的政治路线加强党的建设</li>\n</ol>\n<h2 id=\"社会主义改造理论\">社会主义改造理论</h2>\n<h3 id=\"从新民主主义到社会主义的转变\">从新民主主义到社会主义的转变</h3>\n<h4\nid=\"新民主主义社会是一个过渡性的社会\">新民主主义社会是一个过渡性的社会</h4>\n<p>新民主主义社会不是一个独立的社会形态，而是由新民主主义向社会主义转变的==过渡性社会形态==</p>\n<p>主要的经济成分是三种</p>\n<ol type=\"1\">\n<li>社会主义经济</li>\n<li>个体经济</li>\n<li>资本主义经济</li>\n</ol>\n<p>逐渐扩大国营经济，逐步将资本主义经济和个体经济改编为社会主义经济，使社会主义经济逐步称为我国的经济基础</p>\n<h4 id=\"党在过渡时期的总路线及其依据\">党在过渡时期的总路线及其依据</h4>\n<h5 id=\"党在过渡时期的总路线的提出\">党在过渡时期的总路线的提出</h5>\n<p>党在过渡时期总路线的主要内容为==“一化三改”==。“一化”即==社会主义工业化==，“三改”即对==个体农业、手工业和资本主义工商业的社会主义改造==，它们之间相互联系，不可分离。其中“一化”是主体，“三改”是“两翼”，两者相辅相成，相互促进。这是一条社会主义建设和社会主义改造同时并举的路线，体现了社会主义工业化和社会主义改造的紧密结合，体现了解放生产力、变革生产关系与发展生产力的有机统一</p>\n<h3 id=\"社会主义改造道路和历史经验\">社会主义改造道路和历史经验</h3>\n<h4\nid=\"适合中国特点的社会主义改造道路\">适合中国特点的社会主义改造道路</h4>\n<h5 id=\"农业手工业的社会主义改造\">农业、手工业的社会主义改造</h5>\n<p>对于农业的改造</p>\n<ol type=\"1\">\n<li>积极引导农民组织起来，走互助合作道路。</li>\n<li>遵循自愿互利、典型示范和国家帮助的原则，以互助合作的优越性吸引农民走互助合作道路。</li>\n<li>正确分析农村的阶级和阶层状况，制定正确的阶级政策。党制定并贯彻执行了依靠贫下中农,\n发展互助合作，由逐步限制到最后消灭富农剥削的农村阶级政策。这使农业合作化有了坚实的阶级基础和群众基础。</li>\n<li>坚持积极领导、稳步前进的方针，采取循序渐进的步骤。</li>\n</ol>\n<p>对于手工业的改造</p>\n<ol type=\"1\">\n<li>办手工业供销小组</li>\n<li>办手工业供销合作社</li>\n<li>建立手工业生产合作社</li>\n</ol>\n<h5 id=\"资本主义工商业的社会主义改造\">资本主义工商业的社会主义改造</h5>\n<ol type=\"1\">\n<li>用==和平赎买==的方法改造资本主义工商业，使被资本家占有的生产资料变成人民的财产，这是社会主义革命的一个基本原则。</li>\n<li>采取从低级到高级的国家资本主义的过渡形式</li>\n</ol>\n<p>资本主义工商业社会主义改造的步骤</p>\n<ol type=\"1\">\n<li><p>主要实行初级形式的国家资本主义</p>\n<p>这些企业的利润，按==国家所得税、企业公积金、\n工人福利费、资方红利==这四个方面进行分配，即“四马分肥”</p></li>\n<li><p>主要实行个别企业的公私合营</p></li>\n<li><p>实行全行业的公私合营</p></li>\n</ol>\n<h3 id=\"社会主义基本制度在中国的确立\">社会主义基本制度在中国的确立</h3>\n<h4\nid=\"社会主义基本制度的确立及其理论依据\">社会主义基本制度的确立及其理论依据</h4>\n<p>==1954 年 9\n月==，==第一届全国人民代表大会==的召开和==《中华人民共和国宪法》==的制定及颁布施行，成为我国社会主义民主政治建设的里程碑</p>\n<h4\nid=\"确立社会主义基本制度的重大意义\">确立社会主义基本制度的重大意义</h4>\n<ol type=\"1\">\n<li>社会主义基本制度的确立，为当代中国一切发展进步奠定了制度基础。</li>\n<li>社会主义制度的建立极大地提高了工人阶级和广大劳动人民的积极性、创造性，极大地促进了我国社会生产力的发展。</li>\n<li>社会主义基本制度以\n其与社会化大生产的一致性和能够在经济落后条件下尽可能地集中力量办大事的优势，为发展社会生产力开辟了广阔的道路。</li>\n<li>我国社会生产力的发展，初步显示了社会主义的优越性</li>\n<li>社会主义基本制度的确立，是以毛泽东同志为主要代表的中国共产党人对一个脱胎于半殖民地半封建的东方大国如何进行社会主义革命问题的系统回答和正确解决，是马克思列宁主义关于社会主义革命理论在中国的正确运用和创造性发展的结果。它不仅再次证明了马克思列宁主义的真理性，而且以其独创性的理论原则和经验总结丰富和发展了科学社会主义理论。</li>\n</ol>\n<h2\nid=\"社会主义建设道路初步探索的理论成果\">社会主义建设道路初步探索的理论成果</h2>\n<h3 id=\"初步探索的重要理论成果\">初步探索的重要理论成果</h3>\n<h4\nid=\"调动一切积极因素为社会主义事业服务\">调动一切积极因素为社会主义事业服务</h4>\n<p>==《论十大关系》==确定了一个==基本方针==，就是==“努力把党内党外、国内国外的一切积极的因素，直接的、间接的积极因素，全部调动起来”==</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202506112209282.png\"\nalt=\"十大关系\" />\n<figcaption aria-hidden=\"true\">十大关系</figcaption>\n</figure>\n<h4\nid=\"正确认识和处理社会主义社会矛盾的思想\">正确认识和处理社会主义社会矛盾的思想</h4>\n<p>==《关于正确处理人民内部矛盾的问题》==系统论述了社会主义社会矛盾的理论</p>\n<p>关于社会主义社会的基本矛盾：在社会主义社会中，\n基本的矛盾仍然是生产关系和生产力之间的矛盾，上层建筑和经济基础之间的矛盾。但社会主义社会的基本矛盾同以往社会的基本矛盾“具有根本不同的性质和情况”</p>\n<h2\nid=\"中国特色社会主义理论体系的形成发展\">中国特色社会主义理论体系的形成发展</h2>\n<h3\nid=\"中国特色社会主义理论体系形成发展的社会历史条件\">中国特色社会主义理论体系形成发展的社会历史条件</h3>\n<h4\nid=\"中国特色社会主义理论体系形成发展的国际背景\">中国特色社会主义理论体系形成发展的国际背景</h4>\n<h4\nid=\"中国特色社会主义理论体系形成发展的历史条件\">中国特色社会主义理论体系形成发展的历史条件</h4>\n<h4\nid=\"中国特色社会主义理论体系形成发展的实践基础\">中国特色社会主义理论体系形成发展的实践基础</h4>\n<h3\nid=\"中国特色社会主义理论体系形成发展过程\">中国特色社会主义理论体系形成发展过程</h3>\n<h4\nid=\"中国特色社会主义理论体系的形成\">中国特色社会主义理论体系的形成</h4>\n<p>1978 年 12\n月召开的党的==十一届三中全会==，重新确立了==实事求是==的思想路线，彻底否定了“以阶级斗争为纲”的错误理论和实践，确定把全党工作的着重点转移到==社会主义现代化建设==上来，作出==施行改革开放==的重大决策，实现了党的历史上具有深远意义的伟大转折。</p>\n<h2 id=\"邓小平理论\">邓小平理论</h2>\n<h3\nid=\"邓小平理论首要的基本的理论问题和精髓\">邓小平理论首要的基本的理论问题和精髓</h3>\n<h4\nid=\"邓小平理论首要的基本的理论问题p152\">邓小平理论首要的基本的理论问题（p152）</h4>\n<p>1992\n年，邓小平在南方谈话中对社会主义本质作出了总结性的理论概括，指出==“社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕”==</p>\n<h4 id=\"邓小平理论的精髓\">邓小平理论的精髓</h4>\n<p>==解放思想、实事求是==是邓小平理论的精髓</p>\n<h3 id=\"邓小平理论的主要内容\">邓小平理论的主要内容</h3>\n<h4\nid=\"社会主义初级阶段理论和党的基本路线\">社会主义初级阶段理论和党的基本路线</h4>\n<h5 id=\"社会主义初级阶段理论\">社会主义初级阶段理论</h5>\n<p>社会主义初级阶段这个论断包括两层含义</p>\n<ol type=\"1\">\n<li>我国社会已经是社会主义社会。我们必须坚持而不能离开谁会主义。</li>\n<li>我国的社会主义社会还处在初级阶段。我们必须从这个实际出发，而不能超越这个阶段。</li>\n</ol>\n<h5 id=\"社会主义初级阶段的基本路线\">社会主义初级阶段的基本路线</h5>\n<p>党在社会主义初级阶段基本路线==“一个中心、两个基本点”==，即==“以经济建设为中心，坚持四项基本原则，坚持改革开放”==</p>\n<p>要把以经济建设为中心同坚持四项基本原则、坚持改革开放这两个基本点，统一于中国特色社会主义的伟大实践，贯穿于社会主义现代化建设的整个过程</p>\n<p>党的==十九大==提出“为把我国建设成为富强民主文明和谐美丽的社会主义现代化强国而奋斗”、进一步拓展了党的基本路线</p>\n<h4\nid=\"社会主义改革开放和社会主义市场经济理论\">社会主义改革开放和社会主义市场经济理论</h4>\n<h5 id=\"社会主义改革开放理论\">社会主义改革开放理论</h5>\n<p>改革是一场深刻的社会变革，是中国的第二次革命，是实现中国现代化的必经之路。</p>\n<p>开放也是改革</p>\n<h5 id=\"社会主义市场经济理论\">社会主义市场经济理论</h5>\n<p>1984\n年，党的==十二届三中全==会提出==“公有制基础上的有计划的商品经济”==的概念</p>\n<p>1992\n年，邓小平在南方谈话中明确指出“计划多一点还是市场多一点，不是社会主义与资本主义的本质区别。计划经济不等于社会主义，资本主义也有计划；市场经济不等于资本主义，社会主义也有市场。计划和市场都是经济手段”。这一精辟论述，从理论上突破了计划经济和市场经济是制度属性的观念，从根本上解除了把计划经济和市场经济看做属于社会基本制度范畴的思想束缚，标志着邓小平的社会主义市场经济理论的形成</p>\n<h2 id=\"三个代表重要思想\">“三个代表”重要思想</h2>\n<h3 id=\"三个代表重要思想的核心观点\">“三个代表”重要思想的核心观点</h3>\n<h5\nid=\"始终代表中国先进生产力的发展要求\">==始终代表中国先进生产力的发展要求==</h5>\n<p>“三个代表”：始终代表中国先进生产力的发展要求，始终代表中国先进文化的前进方向，始终代表中国最广大人民的根本利益</p>\n<p>科学技术是第一生产力，是先进生产力的集中体现和主要标志</p>\n<h5\nid=\"始终代表中国先进文化的前进方向\">==始终代表中国先进文化的前进方向==</h5>\n<p>江泽民指出，加强文化建设，必须“以科学的理论武装人，以正确的舆论引导人，以高尚的精神塑造人，以优秀的作品鼓舞人”</p>\n<p>加强社会主义思想道德建设，是发展先进文化的重要内容和中心环节。弘扬爱国主义精神，以为人民服务为核心、以集体主义为原则、以诚实守信为重点</p>\n<h5\nid=\"始终代表中国最广大人民的根本利益\">==始终代表中国最广大人民的根本利益==</h5>\n<p>妥善处理各方面的利益（如何认识）p202</p>\n<h3 id=\"三个代表重要思想的主要内容\">“三个代表”重要思想的主要内容</h3>\n<h4 id=\"发展是党执政兴国的第一要务\">发展是党执政兴国的第一要务</h4>\n<h4 id=\"建立社会主义市场经济体制\">建立社会主义市场经济体制</h4>\n<p>江泽民根据邓小平南方谈话精神，明确提出使用==“社会主义市场经济体制”==这个想法</p>\n<p>两个“毫不动摇”：</p>\n<ol type=\"1\">\n<li><p>必须毫不动摇地巩固和发展公有制经济，公有制经济不仅包括国有经济和集体经济，还包括混合所有制经济中的国有成分和集体成分。</p></li>\n<li><p>必须毫不动摇地鼓励、支持和引导非公有制经济发展。个体、私营等各种形式的非公有制经济是社会主义市场经济的重要组成部分，对充分调动社会各方面的积极性、加快生产力发展具有重要作用（如何理解）</p></li>\n</ol>\n<h4 id=\"建设社会主义政治文明\">建设社会主义政治文明</h4>\n<p>江泽民在==党的十五大报告==中明确指出：“依法治国，就是广大人民群众在党的领导下，依照宪法和法律规定，通过各种途径和形式管理国家事务，管理经济文化事业，管理社会事务，保证国家各项工作都依法进行，逐步实现社会主义民主的制度化、法律化，是这种制度和法律不因领导人的改变而改变，不因领导人的看法和注意力的改变而改变。依法治国，是党领导人民治理国家的基本方略，是发展社会主义市场经济的客观需要，是社会文明进步的重要标志，是国家长治久安的重要保障”</p>\n<h4\nid=\"实施引进来和走出去相结合的对外开放战略\">实施“引进来”和“走出去”相结合的对外开放战略</h4>\n<h4 id=\"推进党的建设新的伟大工程\">推进党的建设新的伟大工程</h4>\n<p>坚持中国共产党的领导，核心是坚持党的先进性</p>\n<p>党的两大历史性课题：提高党的领导水平和执政水平、提高拒腐防变和抵御风险能力（两个一定要)</p>\n<h2 id=\"科学发展观\">科学发展观</h2>\n<h3 id=\"科学发展观的科学内涵\">科学发展观的科学内涵</h3>\n<h4\nid=\"推动经济社会发展是科学发展观的第一要义\">推动经济社会发展是科学发展观的第一要义</h4>\n<h4\nid=\"以人为本是科学发展观的核心立场民本思想\">以人为本是科学发展观的核心立场（民本思想）</h4>\n<h4\nid=\"全面协调可持续是科学发展观的基本要求\">全面协调可持续是科学发展观的基本要求。</h4>\n<p>“全面”是指发展要有全面性、整体性，不仅经济要发展，各个方面都要发展；“协调”是指发展要有协调性、均衡性，各个方面、各个环节的发展要相互适应、相互促进；“可持续”是指发展要有持久性、连续性，不仅当前要发展，而且要保证长远发展</p>\n<p>坚持可持续发展，坚定走生产发展、生活富裕、生态良好的文明道路。</p>\n<p>坚持以生产发展为基础，以生活富裕为目的，以生态良好为条件</p>\n<h4\nid=\"统筹兼顾是科学发展观的根本方法\">统筹兼顾是科学发展观的根本方法</h4>\n<h3 id=\"科学发展观的主要内容\">科学发展观的主要内容</h3>\n<h4 id=\"加快转变经济发展方式\">加快转变经济发展方式</h4>\n<h4 id=\"发展社会主义民主政治\">发展社会主义民主政治</h4>\n<h4 id=\"推进社会主义文化强国建设\">推进社会主义文化强国建设</h4>\n<p>社会主义核心价值体系。社会主义核心价值体系是兴国之魂，决定着中国特色社会主义发展方向。马克思主义指导思想、中国特色社会主义共同理想、以爱国主义为核心的民族精神和以改革创新为核心的时代精神、社会主义荣辱观，共同构成社会主义核心价值体系的基本内容</p>\n<h4 id=\"构建社会主义和谐社会\">构建社会主义和谐社会</h4>\n<p>民主法治、公平正义、诚信有爱、充满活力、安定有序、人与自然和谐相处，是构建社会主义和谐社会的总要求</p>\n<h4 id=\"推进生态文明建设\">推进生态文明建设</h4>\n<h4 id=\"全面提高党的建设科学化水平\">全面提高党的建设科学化水平</h4>\n<h2 id=\"课后思考题\">课后思考题</h2>\n<h3 id=\"第一章-毛泽东思想及其历史地位\">第一章\n毛泽东思想及其历史地位</h3>\n<h5\nid=\"毛泽东思想形成和发展的社会历史条件是什么\">毛泽东思想形成和发展的社会历史条件是什么</h5>\n<p><strong>解答：</strong></p>\n"},{"title":"高数2笔记","math":true,"_content":"\n## 重积分\n\n### 重积分的概念和性质\n\n#### 二重积分的概念\n\n**定义：**\n\n设 $D$ 是平面上的有界闭区域，$f(x,y)$ 为 $D$ 上的有界函数，$I$ 为实数.若对 $D$ 的任意分割 $\\Delta D_1 , \\Delta D_2 , \\cdots , \\Delta D_n$ ，任取 $(\\xi_i , \\eta_i)\\in\\Delta D_i(i=1,\\ldots,n)$，作和 $\\displaystyle\\sum_{i=1}^nf(\\xi_i,\\eta_i)\\Delta \\sigma_i$ （$\\Delta \\sigma_i$ 为 $D_i$ 的面积），总有\n\n$$\n\\lim_{\\lambda\\to 0}\\sum_{i=1}^nf(\\xi_i,\\eta_i)\\Delta \\sigma_i = I\n$$\n\n其中 $\\displaystyle\\lambda = \\max_{1\\leq i\\leq d} \\{d_i\\}$，$d_i$ 是小区域 $\\Delta D_i$ 的直径，则称函数 $f(x,y)$ 在 $D$ 上**可积**，记为 $f\\in R(D)$；极限值 $I$ 称为 $f(x,y)$ 在 $D$ 上的**二重积分**，记作\n\n$$\n\\iint_D f(x,y)\\,\\mathrm{d}\\sigma.\n$$\n\n- $\\displaystyle \\iint$ 积分号\n- $D$ 积分区域\n- $f(x,y)$ 被积函数\n- $\\mathrm{d}\\sigma$ 面积元素（微元）\n\n- 二重积分的几何意义\n\n  - 当被积函数大于 $0$ 时，二重积分是柱体体积\n  - 当被积函数小于 $0$ 时，二重积分是柱体体积的负值\n  - 一般的，为曲顶柱体体积的代数和\n\n- 可积的充分条件\n\n  - **定理：** 若函数 $f(x,y)$ 在区域 $D$ 上连续，则 $f(x,y)\\in D$.\n\n- $f(x,y)$ 在 $D$ 上的可积性及积分值与其在 $D$ 内**有限条光滑曲线**上的定义无关\n\n### 二重积分的性质\n\n1. $\\displaystyle\\iint_D\\,\\mathrm{d}\\sigma = \\iint_D 1\\,\\mathrm{d}\\sigma = A_D \\quad\\left(\\text{D 的面积}\\right)$.\n2. **线性性：** 设 $f,g\\in R(D)$，$\\alpha , \\beta$，是任意常数，则 $\\alpha f +\\beta g \\in R(D)$，且\n\n   $$\n   \\iint_D (\\alpha f +\\beta g)\\,\\mathrm{d}\\sigma = \\alpha \\iint_D f\\,\\mathrm{d}\\sigma + \\beta \\iint_D g\\,\\mathrm{d}\\sigma\n   $$\n\n3. **区域可加性：** 若 $f\\in R(D)$ 且积分区域 $D$ 分为内部不相交的子区域 $D_1 , D_2$，则\n\n   $$\n   \\iint_D f(x,y) \\,\\mathrm{d}\\sigma = \\iint_{D_1} f(x,y)\\,\\mathrm{d}\\sigma + \\iint_{D_2} f(x,y)\\,\\mathrm{d}\\sigma\n   $$\n\n4. **保序性：** 若 $f,g\\in R(D)$，且当 $(x,y)\\in D$ 时，$f(x,y)\\leq g(x,y)$，则\n\n   $$\n   \\iint_D f(x,y)\\,\\mathrm{d}\\sigma \\leq \\iint_D g(x,y)\\,\\mathrm{d}\\sigma\n   $$\n\n   - **推论 1：** 若 $f\\in R(D)$ ,则 $\\vert f(x,y) \\vert \\in R(D)$，且\n\n   $$\n    \\left\\vert \\iint_D f(x,y)\\,\\mathrm{d}\\sigma \\right\\vert \\leq \\iint_D \\vert f(x,y) \\vert \\,\\mathrm{d}\\sigma\n   $$\n\n   - **推论 2：** 若 $f\\in R(D)$，且当 $(x,y)\\in D$ 时， $m\\leq f(x,y) \\leq M$，则\n\n   $$\n    mA_D \\leq \\iint_D f(x,y)\\,\\mathrm{d}\\sigma \\leq MA_D\n   $$\n\n   - **推论 3：** 若 $f\\in R(D)$，且当 $(x,y)\\in D$ 时，$f(x,y) \\geq 0$，则\n\n   $$\n    \\iint_D f(x,y)\\,\\mathrm{d}\\sigma \\geq 0\n   $$\n\n5. **积分中值定理：** 若 $f(x,y)\\in C(D)$ ，$g(x,y)\\in R(D)$，且 $g$ 在 $D$ 上不变号，则 $\\exists \\xi , \\eta \\in D$，使得\n\n   $$\n   \\iint_D f(x,y)g(x,y)\\,\\mathrm{d}\\sigma = f(\\xi ,\\eta )\\iint_D g(x,y)\\,\\mathrm{d}\\sigma\n   $$\n\n   - **推论：** 若 $f(x,y)\\in C(D)$，则存在 $(\\xi , \\eta )\\in D$，使得\n\n   $$\n    \\iint_D f(x,y)\\,\\mathrm{d}\\sigma = f(\\xi ,\\eta )A_D\n   $$\n\n   称 $f(\\xi,\\eta) = \\frac{\\iint_D f\\,\\mathrm{d}\\sigma}{A_D}$ 为函数 $f(x,y)$ 在有界闭区域 $D$ 上的**平均值**\n\n### 二重积分的计算\n\n#### 直角坐标系下的计算\n\n当二重积分存在时，可利用平行于坐标轴的直线来划分积分区域 $D$，此时，面积元素\n\n$$\n\\mathrm{d}\\sigma = \\mathrm{d}x\\mathrm{d}y\n$$\n\n故二重积分在直角坐标系下可表示为\n\n$$\n\\iint_D f(x,y)\\,\\mathrm{d}\\sigma = \\iint_D f(x,y)\\,\\mathrm{d}x\\mathrm{d}y\n$$\n\n##### $x$ 型正则区域\n\n$$\nD = \\left\\{(x,y)\\bigg| \\varphi_1(x)\\leq y\\leq \\varphi_2(x),a\\leq x\\leq b\\right\\}\n$$\n\n化为先 $y$ 后 $x$ 的二次积分\n\n$$\n\\begin{aligned}\n    \\iint_D f(x,y)\\,\\mathrm{d}x\\mathrm{d}y &= \\int_a^b\\left[\\int_{\\varphi_1(x)}^{\\varphi_2(x)} f(x,y)\\,\\mathrm{d}y\\right]\\mathrm{d}x \\\\\n    &\\equiv \\int_a^b f(x,y)\\,\\mathrm{d}x\\mathrm{d}y\n\\end{aligned}\n$$\n\n##### $y$ 型正则区域\n\n$$\nD = \\left\\{(x,y)\\bigg| \\varphi_1(y)\\leq x\\leq \\varphi_2(y),c\\leq y\\leq d\\right\\}\n$$\n\n化为先 $x$ 后 $y$ 的二次积分\n\n$$\n\\begin{aligned}\n    \\iint_D f(x,y)\\,\\mathrm{d}x\\mathrm{d}y &= \\int_c^d\\left[\\int_{\\varphi_1(y)}^{\\varphi_2(y)} f(x,y)\\,\\mathrm{d}x\\right]\\mathrm{d}y \\\\\n    &\\equiv \\int_c^d f(x,y)\\,\\mathrm{d}x\\mathrm{d}y\n\\end{aligned}\n$$\n\n##### 一般区域的二重积分\n\n分割成若干个正则子区域，利用积分区域可加性，分别在子区域上积分后求和\n\n> 直角坐标计算二重积分的步骤\n>\n> 1. **画出积分区域** $D$ 的草图，并**确定类型**\n> 2. 按照所确定的类型**表示区域** $D$\n> 3. **化二重积分为二次积分**（注意上下限）\n> 4. **计算**二重积分\n\n#### 极坐标系下的计算\n\n当积分区域的边界曲线或被积函数用极坐标表示较为简单时，可用极坐标来计算二重积分.\n\n面积元素 $\\Delta \\sigma$ 在极坐标下为\n\n$$\n\\boxed{\\Delta\\sigma= r\\mathrm{d}r\\mathrm{d}\\theta}\n$$\n\n从直角坐标到极坐标时的二重积分变换公式为\n\n$$\n\\iint_D f(x,y)\\,\\mathrm{d}\\sigma = \\iint_D f(r\\cos\\theta,r\\sin\\theta)r\\,\\mathrm{d}r\\mathrm{d}\\theta\n$$\n\n$$\n\\left\\{\\left(r,\\theta\\right)\\left \\vert r_1(\\theta)\\leq r \\leq r_2(\\theta) , \\alpha \\leq \\theta \\leq \\beta \\right.\\right\\}\n$$\n\n则\n\n$$\n\\iint_D f(x,y)\\,\\mathrm{d}\\sigma = \\int_\\alpha^\\beta\\, \\mathrm{d}\\theta\\int_{r_1(\\theta)}^{r_2(\\theta)} f(r\\cos\\theta,r\\sin\\theta)r\\,\\mathrm{d}r\n$$\n\n#### 二重积分的变量代换\n\n**定理：**\n\n设变换 $\\displaystyle T :\\begin{cases}x=x(u,v)\\\\y=y(u,v)\\end{cases}$ 有连续偏导数，且满足 $\\displaystyle J = \\frac{\\partial (x,y)}{\\partial (u,v)}\\coloneqq \\begin{vmatrix}x_u ,x_v\\newline y_u,y_v\\end{vmatrix} \\left(\\text{Jacobi 行列式}\\right)\\neq 0$，而 $f(x,y)\\in C(D)$，则\n\n$$\n\\iint_D f(x,y)\\,\\mathrm{d}\\sigma = \\iint_{D^*} f(x(u,v),y(u,v))\\left\\vert J \\right\\vert \\,\\mathrm{d}u\\mathrm{d}v\n$$\n\n- 在定理条件下，变换 $T$ 一定存在逆变换 $T^{-1}:\\begin{cases}u=u(x,y)\\\\v=v(x,y)\\end{cases}$，且 $\\frac{\\partial (u,v)}{\\partial (x,y)}\\cdot \\frac{\\partial (x,y)}{\\partial (u,v)} = 1$\n\n  有时，借助此式求 $J$ 较为简单\n\n- 当 Jacobi 行列式仅在区域 $D^*$ 内个别点上或个别曲线上为 $0$ 时，定理结论仍成立\n- 在广义极坐标 $\\begin{cases}x=ar\\cos\\theta\\\\y=br\\sin\\theta\\end{cases}$ 下，$J = abr$\n\n### 三重积分\n\n#### 三重积分的定义\n\n**定义：**\n\n设 $\\Omega$ 是 $\\mathbb{R}^3$ 中的有界闭区域，三元函数 $f(x,y,z)$ 在 $\\Omega$ 上有界，$I$ 为实数. 若将 $\\Omega$ 任意分割成 $n$ 个小区域 $\\Delta \\Omega_1,\\Delta\\Omega_2,\\ldots,\\Delta\\Omega_n$，任取 $\\left(\\varepsilon_i,\\eta_i,\\xi_i \\right)\\in\\Delta\\Omega_i\\left(i=1,2,\\ldotp,n\\right)$，作和 $\\displaystyle\\sum_{i=1}^nf\\left(\\varepsilon_i,\\eta_i,\\xi_i \\right)\\Delta V_i$，（$\\Delta V_i$ 是 $\\Delta\\Omega_i$ 的体积），总有\n\n$$\n\\lim_{\\lambda\\to 0}\\sum_{i=1}^nf\\left(\\varepsilon_i,\\eta_i,\\xi_i \\right)\\Delta V_i = I\n$$\n\n其中 $\\lambda = \\max_{1\\leq i\\leq n}\\{d_i\\}$，$d_i$ 是 $\\Delta\\Omega_i$ 的直径，则称函数 $f(x,y,z)$ 在 $\\Omega$ 上**可积**，记为 $f\\in R(\\Omega)$； $I$ 称为 $f(x,y,z)$ 在 $\\Omega$ 上的**三重积分**，记作\n\n$$\n\\iiint_\\Omega f(x,y,z)\\,\\mathrm{d}V\n$$\n\n其中 $V_\\Omega$ 是区域 $\\Omega$ 的体积\n\n- 若 $f(x,y,z)$ 表示占有三维空间区域 $\\Omega$ 的物体的体密度函数，则 $\\displaystyle\\iiint_\\Omega f(x,y,z)\\,\\mathrm{d}V$ 给出了物体的**质量**\n- 类似二重积分，三重积分具有线性性，区域可加性，保序性以及推论和积分中值定理，并且有 $\\displaystyle\\iiint_\\Omega \\,\\mathrm{d}V = V_\\Omega$\n\n#### 直角坐标系下的计算\n\n直角坐标系下，由于 $\\mathrm{d}V=\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z$，故\n\n$$\n\\iiint_\\Omega f(x,y,z)\\,\\mathrm{d}V = \\iiint_\\Omega f(x,y,z)\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z\n$$\n\n##### 柱线法（坐标面投影法）\n\n设 $\\Omega$ 是以曲面 $z=z_1(x,y)$ 为底，曲面 $x=x_2(x,y)$，而侧面是母线平行于 $z$ 轴的柱体所围成的区域\n\n设 $\\Omega$ 在 $xOy$ 面上的投影区域为 $D_1$ ，则 $\\Omega$ 可表示为\n\n$$\n\\Omega = \\left\\{(x,y,z)\\bigg| (x,y)\\in D_1 , z_1(x,y)\\leq z\\leq z_2(x,y)(x,y)\\in D\\right\\}\n$$\n\n则物体总质量为\n\n$$\n\\iint_D\\left(\\int_{z_1(x,y)}^{z_2(x,y)}f(x,y,z)\\,\\mathrm{d}z\\right) \\,\\mathrm{d}x\\mathrm{d}y\n$$\n\n故有\n\n$$\n\\iiint_\\Omega f(x,y,z)\\,\\mathrm{d}V = \\iint_{D_1} \\,\\mathrm{d}x\\mathrm{d}y\\int_{z_1(x,y)}^{z_2(x,y)} f(x,y,z)\\,\\mathrm{d}z\n$$\n\n##### 截面法（坐标轴投影法）\n\n设区域 $\\Omega$ 在 $z$ 轴上的投影区间为 $[h_1,h_2]$，即 $\\Omega$ 介于平面 $z=h_1$ 和 $z=h_2$ 之间，过 $z$ 处且垂直于 $z$ 轴的平面截 $\\Omega$ 得截面区域 $D_z$，则 $\\Omega$ 可表示为\n\n$$\n\\Omega = \\left\\{(x,y,z)\\bigg| h_1\\leq z\\leq h_2 , (x,y)\\in D_z\\right\\}\n$$\n\n物体总质量为\n\n$$\n\\int_{h_1}^{h_2}\\left(\\iint_{D_z} f(x,y,z)\\,\\mathrm{d}x\\mathrm{d}y\\right) \\,\\mathrm{d}z\n$$\n\n故有\n\n$$\n\\iiint_\\Omega f(x,y,z)\\,\\mathrm{d}V = \\int_{h_1}^{h_2}\\,\\mathrm{d}z\\iint_{D_z} f(x,y,z)\\,\\mathrm{d}x\\mathrm{d}y\n$$\n\n#### 三重积分的变量代换\n\n**定理：**\n\n设变换 $T:\\begin{cases}x=x(u,v,w)\\\\y=y(u,v,w)\\\\z=z(u,v,w)\\end{cases}$ 有连续偏导数，且满足 $J=\\frac{\\partial (x,y,z)}{\\partial (u,v,w)}\\neq 0$，而 $f(x,y,z)\\in C(\\Omega)$，则\n\n$$\n  \\iiint_\\Omega f(x,y,z)\\,\\mathrm{d}V = \\iiint_{\\Omega^*} f(x(u,v,w),y(u,v,w),z(u,v,w))\\left\\vert J \\right\\vert \\,\\mathrm{d}u\\mathrm{d}v\\mathrm{d}w\n$$\n\n##### 柱面坐标系下的计算\n\n柱面坐标系，实际上就是将 $x,y$ 坐标转换为极坐标\n\n$$\n\\begin{cases}\nx = r\\cos\\theta\\\\\ny = r\\sin\\theta\\\\\nz = z\n\\end{cases}\n$$\n\n其 Jacobi 行列式为\n\n$$\nJ = \\frac{\\partial (x,y,z)}{\\partial (r,\\theta,z)} = \\begin{vmatrix}\n\\cos\\theta & -r\\sin\\theta & 0\\\\\n\\sin\\theta & r\\cos\\theta & 0\\\\\n0 & 0 & 1\n\\end{vmatrix} = r\n$$\n\n则柱面积分积分公式为\n\n$$\n\\iiint_\\Omega f(x,y,z)\\,\\mathrm{d}V = \\iiint_{\\Omega^*} f(r\\cos\\theta,r\\sin\\theta,z)r\\,\\mathrm{d}r\\mathrm{d}\\theta\\mathrm{d}z\n$$\n\n##### 球面坐标系下的计算\n\n球面坐标系，实际上就是将 $x,y,z$ 坐标转换为球坐标\n\n$$\n\\begin{cases}\nx = \\rho\\sin\\varphi\\cos\\theta\\\\\ny = \\rho\\sin\\varphi\\sin\\theta\\\\\nz = \\rho\\cos\\varphi\n\\end{cases}\n$$\n\n其 Jacobi 行列式为\n\n$$\nJ = \\frac{\\partial (x,y,z)}{\\partial (\\rho,\\varphi,\\theta)} = \\begin{vmatrix}\n\\sin\\varphi\\cos\\theta & \\rho\\cos\\varphi\\cos\\theta & -\\rho\\sin\\varphi\\sin\\theta\\\\\n\\sin\\varphi\\sin\\theta & \\rho\\cos\\varphi\\sin\\theta & \\rho\\sin\\varphi\\cos\\theta\\\\\n\\cos\\varphi & -\\rho\\sin\\varphi & 0\n\\end{vmatrix} = \\rho^2\\sin\\varphi\n$$\n\n则球面积分积分公式为\n\n$$\n\\iiint_\\Omega f(x,y,z)\\,\\mathrm{d}V = \\iiint_{\\Omega^*} f(\\rho\\sin\\varphi\\cos\\theta,\\rho\\sin\\varphi\\sin\\theta,\\rho\\cos\\varphi)\\rho^2\\sin\\varphi\\,\\mathrm{d}\\rho\\mathrm{d}\\varphi\\mathrm{d}\\theta\n$$\n\n### 重积分的应用\n\n#### 重积分的几何应用\n\n##### 平面图形的面积\n\n$$\nA(D) = \\iint_D \\,\\mathrm{d}\\sigma = \\iint_D \\,\\mathrm{d}x\\mathrm{d}y\n$$\n\n##### 立体的体积\n\n$$\nV(\\Omega) = \\iiint_\\Omega \\,\\mathrm{d}V = \\iiint_\\Omega \\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z\n$$\n\n##### 曲面的面积\n\n设空间曲面 $S:z=f(x,y),(x,y)\\in D$.\n\n则曲面 $S$ 的面积为\n\n$$\nA(S) = \\iint_D \\sqrt{1+z_x^2+z_y^2}\\,\\mathrm{d}x\\mathrm{d}y\n$$\n\n#### 重积分的物理应用\n\n###### 质心\n\n体密度为 $\\rho(x, y)$ 的物体占据空间 $\\Omega$，其质心坐标为\n\n$$\n\\begin{cases}\n  \\displaystyle\\bar{x} = \\frac{\\iiint_\\Omega x\\rho(x,y,z)\\,\\mathrm{d}V}{\\iiint_\\Omega\\mu(x,y,z)\\,\\mathrm{d}V} \\\\\n  \\displaystyle\\bar{y} = \\frac{\\iiint_\\Omega y\\rho(x,y,z)\\,\\mathrm{d}V}{\\iiint_\\Omega\\mu(x,y,z)\\,\\mathrm{d}V}\\\\\n  \\displaystyle\\bar{z} = \\frac{\\iiint_\\Omega z\\rho(x,y,z)\\,\\mathrm{d}V}{\\iiint_\\Omega\\mu(x,y,z)\\,\\mathrm{d}V}\n\\end{cases}\n$$\n\n##### 转动惯量\n\n设物体的密度为 $\\rho(x,y,z)$，则物体分别关于 $x$，$y$，$z$ 轴的转动惯量为\n\n$$\n\\begin{cases}\n  I_x = \\iiint_\\Omega \\rho(x,y,z)(y^2+z^2)\\,\\mathrm{d}V\\\\\n  I_y = \\iiint_\\Omega \\rho(x,y,z)(x^2+z^2)\\,\\mathrm{d}V\\\\\n  I_z = \\iiint_\\Omega \\rho(x,y,z)(x^2+y^2)\\,\\mathrm{d}V\n\\end{cases}\n$$\n\n##### 引力\n\n$$\n\\begin{aligned}\n  &\\mathrm{d}\\vec{F} = G\\frac{m_0\\mathrm{d}m}{r^3}\\vec{r}\\\\\n  =& G\\frac{m_0\\rho(x,y,z)\\mathrm{d}V}{r^3}\\cdot\\left(x-x_0,y-y_0,z-z_0\\right)\\\\\n  =&\\left(\\mathrm{d}F_x,\\mathrm{d}F_y,\\mathrm{d}F_z\\right)\n\\end{aligned}\n$$\n\n## 曲线积分和曲面积分\n\n### 第一类曲线积分和曲面积分\n\n#### 第一类曲线积分的概念\n\n**定义：**\n\n设 $C$ 是 $xOy$ 面上的一条光滑曲线弧，函数 $f(x,y)$ 是定义在 $C$ 上的有界函数，在 $C$ 上任意插入分点 $A = A_0,A_1,\\ldots,A_{n-1},A_n=B$，将其分成 $n$ 个小弧段，记第 $i$ 个小弧段的弧长为 $\\Delta s_i$，在第 $i$ 个小段上任取点 $(\\epsilon_i,\\eta_i)$，和式 $\\displaystyle\\sum_{i=1}^{+\\infty}f(\\epsilon_i,\\eta_i)\\Delta s_i$，当 $\\displaystyle\\lambda=\\max_{1\\leq i\\leq n}\\{\\Delta s_i\\}\\to 0$ 时，有确定的极限值 $I$，即\n\n$$\n\\lim_{\\lambda\\to 0}\\sum_{i=1}^nf(\\epsilon_i,\\eta_i)\\Delta s_i = I\n$$\n\n则称函数 $f(x,y)$ 在曲线 $C$ 上**可积**，并将此极限值 $I$ 称为函数 $f(x,y)$ 在曲线 $C$ 上的**第一类曲线积分**，记作 $\\displaystyle\\int_Cf(x,y)\\,\\mathrm{d}s$，即\n\n$$\nI = \\int_C f(x,y)\\,\\mathrm{d}s = \\lim_{\\lambda\\to 0}\\sum_{i=1}^nf(\\epsilon_i,\\eta_i)\\Delta s_i\n$$\n\n- 第一类曲线积分的几何含义为柱面的面积\n- $\\displaystyle\\int_C\\,\\mathrm{d}s = \\displaystyle\\int_c1\\,\\mathrm{d}s=s_C$\n- 若 $C$ 是封闭曲线，即 $C$ 的二端点重合，则记第一类曲线积分为 $\\displaystyle\\oint_Cf(x,y)\\,\\mathrm{d}s$\n\n#### 第一类曲线积分的性质\n\n##### 与曲线方向无关\n\n若曲线 $C$ 的端点为 $A$ 和 $B$，$f(x,y)$ 在曲线 $C$ 上可积，则\n\n$$\n\\int_{\\widehat{AB}} f(x,y)\\,\\mathrm{d}s=\\oint_{\\widehat{BA}} f(x,y)\\,\\mathrm{d}s\n$$\n\n##### 线性性\n\n若 $f,g$ 在曲线 $C$ 上可积，$\\alpha , \\beta$ 是任意常数，则 $\\alpha f + \\beta g$ 在曲线 $C$ 上可积，且\n\n$$\n\\int_C (\\alpha f + \\beta g)\\,\\mathrm{d}s = \\alpha \\int_C f(x,y)\\,\\mathrm{d}s + \\beta \\int_C g(x,y)\\,\\mathrm{d}s\n$$\n\n##### 路径可加性\n\n若曲线 $C$ 由两段光滑曲线 $C_1$ 和 $C_2$ 首尾连接而成，则 $f(x,y)$ 在曲线 $C$ 上可积，等价于 $f(x,y)$ 在曲线 $C_1$ 和 $C_2$ 上均可积，且\n\n$$\n\\int_C f(x,y)\\,\\mathrm{d}s = \\int_{C_1} f(x,y)\\,\\mathrm{d}s + \\int_{C_2} f(x,y)\\,\\mathrm{d}s\n$$\n\n##### 中值定理\n\n设函数 $f$ 在光滑曲线 $C$ 上连续，则 $\\exists (\\epsilon,\\eta)\\in C$，使得\n\n$$\n\\int_C f(x,y)\\,\\mathrm{d}s = f(\\epsilon,\\eta)\\cdot s_C\n$$\n\n其中 $s_C$ 是曲线段 $C$ 的长度\n\n#### 第一类曲线积分的计算\n\n设函数 $f(x,y)$ 在光滑曲线 $C$ 上连续，$C$ 的参数方程为 $\\begin{cases}x=x(t)\\\\y=y(t)\\end{cases}$，$t\\in [a,b]$，满足 $x'(t)$，$y'(t)$ 连续，且 $x'(t)^2 + y'(t)^2 \\neq 0$，则\n\n$$\n\\int_C f(x,y)\\,\\mathrm{d}s = \\int_\\alpha^\\beta f(x(t),y(t))\\sqrt{x'(t)^2 + y'(t)^2}\\,\\mathrm{d}t\n$$\n\n- 右端积分限应 $\\alpha < \\beta$\n- 当曲线 $C$ 形式为 $y=y(x)$，$x\\in [a,b]$ 时，则 $\\displaystyle\\int_Cf(x,y)\\,\\mathrm{d}s =\\int_a^bf(x,y(x))\\sqrt{1+y'^2(x)}\\,\\mathrm{d}x$\n- 当曲线 $C$ 为极坐标 $r=r(\\theta)$，$\\theta\\in [\\alpha,\\beta]$ 时，则 $\\displaystyle\\int_Cf(x,y)\\,\\mathrm{d}s = \\int_\\alpha^\\beta f(r(\\theta)\\cos\\theta,r(\\theta)\\sin\\theta)\\sqrt{r(\\theta)^2+r'^2(\\theta)}\\,\\mathrm{d}\\theta$\n\n### 第二类曲线积分与曲面积分\n\n#### 第二类曲线积分的概念\n\n**定义：**\n\n设 $C$ 为平面光滑定向曲线($A\\rightarrow B$)，且向量值函数 $\\vec{F}(x,y) = R(x,y)\\vec{i}+Q(x,y)\\vec{j}$ 在 $C$ 上有界，$\\vec{e}_\\tau$ 为 $C$ 上点 $(x,y)$ 处于定向一致的单位切向量，若\n\n$$\n\\int_C \\vec{F}(x,y) \\cdot \\vec{e}_\\tau \\,\\mathrm{d}s\n$$\n\n存在，则称为**向量值函数 $\\vec{F}$ 在定向曲线 $C$ 上的曲线积分或第二类曲线积分**\n\n若 $\\vec{e}_\\tau(x,y) = (\\cos\\alpha,\\cos\\beta)$，则\n\n$$\n\\begin{aligned}\n  \\int_C \\vec{F}(x,y) \\cdot \\vec{e}_\\tau \\,\\mathrm{d}s &= \\int_C P(x,y)\\cos\\alpha + Q(x,y)\\cos\\beta \\,\\mathrm{d}s \\\\\n  &= \\int_C P(x,y)\\cos\\alpha \\,\\mathrm{d}s + \\int_C Q(x,y)\\cos\\beta \\,\\mathrm{d}s \\\\\n  &= \\int_C P(x,y)\\,\\mathrm{d}x +  Q(x,y)\\,\\mathrm{d}y\n\\end{aligned}\n$$\n\n这是对坐标的曲线积分\n\n记 $\\vec{r} = (x,y)$，则 $\\mathrm{d}\\vec{e} = \\vec{e}_\\tau \\,\\mathrm{d}s$ 称为**定向弧微分**\n\n从而有向量形式的第一类曲线积分\n\n$$\n\\int_C \\vec{F}(x,y) \\cdot \\mathrm{d}\\vec{e} = \\int_C \\vec{F}\\cdot \\mathrm{d}\\vec{r}\n$$\n\n##### 第二类曲线积分的性质\n\n第二类曲线积分与**曲线方向有关**，即\n\n$$\n\\int_{\\widehat{AB}} \\vec{F}(x,y) \\cdot \\mathrm{d}\\vec{r} = -\\oint_{\\widehat{BA}} \\vec{F}(x,y) \\cdot \\mathrm{d}\\vec{r}\n$$\n\n此外线性性与对定向积分路径的可加性等仍然成立\n\n##### 第二类曲线积分的计算\n\n若曲线 $C$ 为 $\\begin{cases}x=x(t)\\\\y=y(t)\\end{cases}$，$t:\\alpha\\rightarrow \\beta$\n\n起点 $A$ 对应 $\\alpha$，终点 $B$ 对应 $\\beta$\n\n考察 $\\displaystyle\\int_C P\\,\\mathrm{d}x + Q\\,\\mathrm{d}y = \\int_C \\vec{F}\\cdot\\vec{e}_\\tau \\,\\mathrm{d}s$，沿曲线 $C$ 有 $\\vec{F} = \\left(P\\left(x(t),y(t)\\right),Q\\left(x(t),y(t)\\right)\\right)$，则\n\n$$\n\\int_C P\\,\\mathrm{d}x + Q\\,\\mathrm{d}y = \\int_\\alpha^\\beta P\\left(x(t),y(t)\\right)\\,\\mathrm{d}x(t) + Q\\left(x(t),y(t)\\right)\\,\\mathrm{d}y(t)\n$$\n\n#### 第二类曲面积分的概念\n\n##### 双侧曲面\n\n**定义：**\n\n若点 $P$ 沿曲面 $S$ 上任何不越过曲面边界的连续闭曲线移动后回到起始位置时，法向量 $\\vec{n}$ 保持原来的指向，则称 $S$ 为**双侧曲面**\n\n典型的，Mobius 面不是双侧曲面\n\n选定双侧曲面 $S$ 一侧为正向，称为**正侧**，记为 $S^+$ ，其相反测记作 $S^-$\n\n##### 双侧曲面定侧\n\n若 $S:z=z(x,y)$，$(x,y)\\in D_{xy}$，$\\vec{n}_0=\\left(\\cos\\alpha,\\cos\\beta,\\cos\\gamma\\right)=\\pm\\frac{\\left(-z_x,-z_y,1\\right)}{\\sqrt{1+z_x^2+z_y^2}}$\n\n若选取 $\\vec{n}_0=\\left(\\cos\\alpha,\\cos\\beta,\\cos\\gamma\\right)=\\frac{\\left(-z_x,-z_y,1\\right)}{\\sqrt{1+z_x^2+z_y^2}}$，则说明 $\\cos\\gamma > 0$，选取了曲面的上侧\n\n一般的\n\n$$\n\\begin{cases}\n  \\cos\\alpha >0 \\Leftrightarrow \\text{前侧}，\\cos\\alpha < 0 \\Leftrightarrow \\text{后侧}\\\\\n  \\cos\\beta >0 \\Leftrightarrow \\text{右侧}，\\cos\\beta < 0 \\Leftrightarrow \\text{左侧}\\\\\n  \\cos\\gamma >0 \\Leftrightarrow \\text{上侧}，\\cos\\gamma < 0 \\Leftrightarrow \\text{下侧}\n\\end{cases}\n$$\n\n习惯上选取曲面片的上侧为 $S^+$；对于封闭曲面，选取外侧为 $S^+$\n\n对于向量值函数 $\\vec{F} = (P,Q,R)$\n\n$$\n\\int_C \\vec{F}\\cdot\\,\\mathrm{d}S = \\int_c P\\,\\mathrm{d}x\\mathrm{d}y + Q\\,\\mathrm{d}y\\mathrm{d}z + R\\,\\mathrm{d}z\\mathrm{d}x\n$$\n\n##### 第二类曲面积分的性质\n\n第二类曲面积分与在曲面的哪一侧积分有关\n\n$$\n\\iint_{S^+}P\\,\\mathrm{d}x\\mathrm{d}y + Q\\,\\mathrm{d}y\\mathrm{d}z + R\\,\\mathrm{d}z\\mathrm{d}x = -\\iint_{S^-}P\\,\\mathrm{d}x\\mathrm{d}y + Q\\,\\mathrm{d}y\\mathrm{d}z + R\\,\\mathrm{d}z\\mathrm{d}x\n$$\n\n此外第二类曲面积分也具有线性性和可加性等性质\n\n#### 第二类曲面积分的计算\n\n##### 合一投影法\n\n$$\n\\iint_{S^+}P\\,\\mathrm{d}x\\mathrm{d}y + Q\\,\\mathrm{d}y\\mathrm{d}z + R\\,\\mathrm{d}z\\mathrm{d}x = \\iint_{D_{xy}} \\left(-Pz_x-Qz_y+R\\right)\\,\\mathrm{d}x\\mathrm{d}y\n$$\n\n##### 分面投影法\n\n分 $P\\,\\mathrm{d}x\\mathrm{d}y$，$Q\\,\\mathrm{d}y\\mathrm{d}z$，$R\\,\\mathrm{d}z\\mathrm{d}x$ 三个部分进行积分\n\n常在部分曲面垂直坐标轴时进行\n\n##### 公式法\n\n常用于参数方程确定的曲面\n\n设 $S:\\vec{r} = \\left(x(u,v),y(u,v),z(u,v)\\right)$，其中 $(u,v)\\in D_{xy}$，则\n\n$$\n\\iint_{S^+}\\vec{F}\\cdot\\,\\mathrm{d}\\vec{S} = \\iint_{D_{uv}}\\vec{F}\\cdot\\left(\\vec{r}_u\\times\\vec{r_v}\\right)\\,\\mathrm{d}u\\mathrm{d}v\n$$\n\n### Green 公式及其应用\n\n#### Green 公式\n\n##### 连通区域及其边界方向\n\n设 $D$ 为平面区域, 若 $D$ 内的任意一条闭曲线所围的区域都落在 $D$ 内, 则称 $D$ 是单连通的, 否则称 $D$ 为复连通的\n\n当点沿区域边界朝一个方向前进时, 区域总在它的左侧, 则将此方向规定为边界曲线 $C$ 的正向,记为 $C^+$, 与 $C^+$ 相反方向为 $C^−$\n\n##### Green 公式\n\n**定理：**\n\n设有界闭区域 $D$ 由分段光滑曲线 $C$ 围成，函数 $P(x, y)$, $Q(x, y)$ 在 $D$ 上有一阶连续偏导数, 则\n\n$$\n\\oint_{C^+} P\\,\\mathrm{d}x + Q\\,\\mathrm{d}y = \\iint_D \\left(\\frac{\\partial Q}{\\partial x} - \\frac{\\partial P}{\\partial y}\\right)\\,\\mathrm{d}x\\mathrm{d}y\n$$\n\n- 对于复连通区域 $D$，Green 公式仍然成立，但需将 $C$ 分成若干个单连通区域 $D_i$，并对每个区域应用 Green 公式\n- 公式也可以记为 $\\displaystyle\\oint_{C^+} P\\,\\mathrm{d}x + Q\\,\\mathrm{d}y = \\iint_D \\begin{vmatrix}\\frac{\\partial}{\\partial x}&\\frac{\\partial}{\\partial y}\\newline P&Q\\end{vmatrix}\\,\\mathrm{d}x\\mathrm{d}y$\n\n##### Green 公式的向量形式\n\n$$\n\\oint_{C^+} \\vec{F}\\cdot\\,\\mathrm{d}\\vec{r} = \\iint_D \\nabla\\times\\vec{F}\\,\\mathrm{d}x\\mathrm{d}y\n$$\n\n#### 曲线积分与路径无关的条件\n\n**定义：**\n\n设 $P(x,y)$，$Q(x,y)$ 在区域 $D$ 内连续，若对 $D$ 内任意两点 $A$，$B$ 以及 $D$ 内连接 $A,B$ 的任意二分段光滑曲线 $C_1$，$C_2$，均有\n\n$$\n\\int_{C_1} P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y = \\int_{C_2} P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y\n$$\n\n则称曲线积分 $\\displaystyle\\int_C P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y$ 在 $D$ 内**与路径无关**\n\n**定理：**\n\n设函数 $P$，$Q$ 在**单连通**区域 $D$ 上有连续偏导数，则下述四命题等价\n\n1. 在 $D$ 内的任一条分段光滑闭曲线 $C$ 上，有 $\\displaystyle \\int_C P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y = 0$\n2. 曲线积分 $\\displaystyle \\int_C P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y$ 在 $D$ 内与路径无关\n3. 存在 $D$ 上的可微函数 $u(x,y)$ 使得 $\\displaystyle \\mathrm{d}u = P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y$，此时称 $u(x,y)$ 为 $\\displaystyle P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y$ 的一个**原函数**\n4. $\\displaystyle \\frac{\\partial Q}{\\partial x} = \\frac{\\partial P}{\\partial y}$ 在 $D$ 内恒成立\n\n#### 全微分求积与全微分方程\n\n设函数 $P$，$Q$ 在单连通区域 $D$ 上有连续偏导数，且 $\\displaystyle \\frac{\\partial Q}{\\partial x} = \\frac{\\partial P}{\\partial y}$ ，则 $\\displaystyle P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y$ 为某函数 $u$ 的全微分，且取定 $(x_0,y_0)\\in D$\n\n$$\nu(x,y) = u(x_0,y_0) + \\int_{(x_0,y_0)}^{(x,y)} P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y,\\quad (x,y)\\in D\n$$\n\n从而全体函数为 $u(x,y) + C$\n\n称求 $P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y$ 的原函数的过程为**全微分求积**\n\n若 $P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y$ 是某二元函数的全微分，称方程\n\n$$\nP(x,y)\\,\\mathrm{d}x +Q(x,y)\\,\\mathrm{d}y = 0\n$$\n\n为**全微分方程**\n\n求出一个原函数 $u(x,y)$，则方程的通解为 $u(x,y) = C$，其中 $C$ 是任意常数\n\n### Gauss 公式和 Strokes 公式\n\n#### Gauss 公式\n\n**定理：**\n\n设函数 $P(x,y,z)$，$Q(x,y,z)$，$R(x,y,z)$ 在空间有界闭区域 $\\Omega$ 上有连续偏导数，$\\Omega$ 的边界时光滑或分片光滑的闭曲面 $\\Sigma$，则\n\n$$\n\\oiint_{\\Sigma^+} P\\,\\mathrm{d}x\\mathrm{d}y + Q\\,\\mathrm{d}y\\mathrm{d}z + R\\,\\mathrm{d}z\\mathrm{d}x = \\iiint_\\Omega \\left(\\frac{\\partial P}{\\partial x} + \\frac{\\partial Q}{\\partial y} + \\frac{\\partial R}{\\partial z}\\right)\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z\n$$\n\n- 令 $P=\\frac{x}{3}$，$Q=\\frac{y}{3}$，$R=\\frac{z}{3}$，则可导出 $\\displaystyle V_\\Omega = \\frac{1}{3}\\oiint_{\\Sigma^+} x\\,\\mathrm{d}y\\mathrm{d}z + y\\,\\mathrm{d}z\\mathrm{d}x + z\\,\\mathrm{d}x\\mathrm{d}y$，即体积公式\n- 使用 Gauss 公式时，注意 $\\Sigma^+$ 的方向应与 $\\Omega$ 的外侧一致\n\n##### 向量形式的 Gauss 公式\n\n$$\n\\oiint_{\\Sigma^+} \\vec{F}\\cdot\\,\\mathrm{d}\\vec{S} = \\iiint_\\Omega \\nabla\\cdot\\vec{F}\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z\n$$\n\n#### 通量和散度\n\n##### 通量\n\n若给定向量场\n\n$$\n\\vec{F} = \\left(P(x,y,z),Q(x,y,z),R(x,y,z)\\right)\n$$\n\n则称曲面积分\n\n$$\n\\Phi = \\oiint_{\\Sigma^+} \\vec{F}\\cdot\\,\\mathrm{d}\\vec{S} = \\oiint_{\\Sigma^+} P\\,\\mathrm{d}x\\mathrm{d}y + Q\\,\\mathrm{d}y\\mathrm{d}z + R\\,\\mathrm{d}z\\mathrm{d}x\n$$\n\n为向量场 $\\vec{F}$ 在通过定侧曲面 $\\Sigma^+$ 的**通量**\n\n##### 散度\n\n称\n\n$$\n\\mathrm{div}\\vec{F} = \\nabla\\cdot\\vec{F}=\\frac{\\partial P}{\\partial x} + \\frac{\\partial Q}{\\partial y} + \\frac{\\partial R}{\\partial z}\n$$\n\n为向量场 $\\vec{F}$ 的**散度**\n\n则 Gauss 公式可写为\n\n$$\n\\Phi =\\oiint_{\\Sigma^+} \\vec{F}\\cdot\\,\\mathrm{d}\\vec{S} = \\iiint_\\Omega \\mathrm{div}\\vec{F}\\,\\mathrm{d}V\n$$\n\n## 级数\n\n### 数项级数\n\n#### 数项级数的概念\n\n**定义：**\n\n给定数列 $\\{a_n\\}$ ，和式\n\n$$\n\\sum_{n=1}^{\\infty} a_n = a_1 + a_2 + \\cdots + a_n + \\cdots\n$$\n\n称为 **（无穷）极数** ，$a_n$ 称为级数的**通项**（或**一般项**）\n\n- $\\displaystyle S_n = \\sum_{k=1}^n a_k$ 称为级数 $\\displaystyle \\sum_{n=1} a_n$ 的前 $n$ 项**部分和**\n- $\\displaystyle\\sum_{k=n+1}^\\infty a_k$ 称为级数 $\\displaystyle \\sum_{n=1} a_n$ 的**余项级数**\n\n**定义：**\n\n- 若级数 $\\displaystyle\\sum_{n=1}^\\infty a_n$ 的部分和数列 $\\{S_n\\}$ 收敛，且 $\\displaystyle \\lim_{n\\to\\infty}S_n = S$，则称级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$ **收敛**，$S$ 称为级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 的**和**，记作 $\\displaystyle \\sum_{n=1}^\\infty a_n = S$\n- 若部分和数列 $\\{S_n\\}$ 发散，则称级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$ **发散**\n\n> 常用结论：\n>\n> **等比数列** $\\displaystyle \\sum_{n=1}^\\infty aq^{n-1}\\begin{cases}\\text{收敛于}\\frac{a}{1-q} & ,\\vert q \\vert < 1\\newline \\text{发散} & ,\\vert q \\vert \\geq 1\\end{cases}$\n\n#### 数项级数的基本性质\n\n##### 基本性质\n\n1. 若常数 $\\alpha \\neq 0$，则级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 与级数 $\\displaystyle \\sum_{n=1}^\\infty \\alpha a_n$ 有相同敛散性\n2. **线性性：** 若级数 $\\displaystyle \\sum_{n=1}^\\infty a_n = S$，$\\displaystyle \\sum_{n=1}^\\infty b_n = T$，则 $\\forall \\alpha , \\beta\\in \\mathbb{R}$，有 $\\displaystyle \\sum_{n=1}^\\infty (\\alpha a_n + \\beta b_n) = \\alpha S + \\beta T$\n3. **可加性：** 将级数增加、删减或改换**有限项**，不改变级数的**敛散性**\n4. **结合律：** 若级数收敛于 $S$，则将相邻若干项添加括号所成新级数仍收敛于 $S$\n   - 其本质是部分和数列收敛于 $S$，则子列均收敛于 $S$\n   - 加括号后级数收敛 $\\nRightarrow$ 原级数收敛\n   - 加括号后级数发散 $\\Rightarrow$ 原级数发散\n\n##### 级数收敛的必要条件\n\n**定理：**\n\n若 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 收敛，则 $\\displaystyle \\lim_{n\\to\\infty} a_n = 0$\n\n- 若 $\\displaystyle \\lim_{n\\to\\infty} a_n \\neq 0 \\nRightarrow \\displaystyle \\sum_{n=1}^\\infty a_n$ 发散\n- 若 $\\displaystyle \\lim_{n\\to\\infty} a_n = 0 \\nRightarrow \\displaystyle \\sum_{n=1}^\\infty a_n$ 收敛，比如调和级数\n\n### 正项级数敛散性\n\n#### 正项级数\n\n**定义：**\n\n若级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 满足 $a_n >0 \\quad \\left(n\\in\\mathbb{N}^+\\right)$，则称此级数为**正项级数**\n\n**定理：（收敛原理）**\n\n正项级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 收敛 $\\Leftrightarrow$ 是其部分和数列 $\\{S_n\\}$ 有上界，即 $\\exists M\\in\\mathbb{R},\\forall n \\in \\mathbb{N}^+:S_n \\leq M$\n\n> $p$ 级数\n>\n> $\\displaystyle \\sum_{n=1}^\\infty \\frac{1}{n^p} \\begin{cases}\\text{收敛} & ,p>1\\newline \\text{发散} & ,p\\leq 1\\end{cases}$\n\n#### 正项级数敛散性判别法\n\n##### 比较判别法\n\n**定理：**\n\n设正项级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$，$\\displaystyle \\sum_{n=1}^\\infty b_n$ 满足 $a_n \\leq b_n \\quad (\\forall n \\in \\mathbb{N}^+)$ ，则 $\\displaystyle \\sum_{n=1}^\\infty b_n$ 收敛 $\\Rightarrow \\displaystyle \\sum_{n=1}^\\infty a_n$ 收敛，$\\displaystyle \\sum_{n=1}^\\infty a_n$ 发散 $\\Rightarrow \\displaystyle \\sum_{n=1}^\\infty b_n$ 发散\n\n- 条件 $\\forall n \\in \\mathbb{N}^+，a_n \\leq b_n$ 可改为 $\\exists N,C >0  ,\\forall n\\in \\mathbb{N}^+，\\forall n \\geq N，a_n \\leq Cb_n$\n- 使用该判别法时需要有参照级数，常选**等比级数**或 **$p$ 级数**作参照\n\n##### 比较判别法（极限形式）\n\n**定理：**\n\n正项级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$，$\\displaystyle \\sum_{n=1}^\\infty b_n$ 满足 $\\displaystyle \\lim_{n\\to\\infty} \\frac{a_n}{b_n} = l$\n\n- 当 $0 <l<+\\infty$ 时，$\\displaystyle \\sum_{n=1}^\\infty a_n$ 与 $\\displaystyle \\sum_{n=1}^\\infty b_n$ 同敛散\n- 当 $l=0$ 时，$\\displaystyle \\sum_{n=1}^\\infty b_n$ 收敛 $\\Rightarrow \\displaystyle \\sum_{n=1}^\\infty a_n$ 收敛\n- 当 $l=+\\infty$ 时，$\\displaystyle \\sum_{n=1}^\\infty b_n$ 发散 $\\Rightarrow \\displaystyle \\sum_{n=1}^\\infty a_n$ 发散\n\n> 通常使用 $b_n = \\frac{1}{n^p}$ 作为参照物，因为我们此时在分析无穷小 $a_n$ 的阶\n\n##### 比值判别法（d'Alembert 判别法）\n\n**定理：**\n\n若**正项级数** $\\displaystyle \\sum_{n=1}^\\infty a_n$ 满足 $\\displaystyle \\lim_{n\\to\\infty} \\frac{a_{n+1}}{a_n} = l$，则\n\n- 当 $0\\leq l<1$ 时，$\\displaystyle \\sum_{n=1}^\\infty a_n$ 收敛\n- 当 $l>1$ 时，$\\displaystyle \\sum_{n=1}^\\infty a_n$ 发散\n- 当 $l=1$ 时，判别法失效\n\n> Stirling 公式： $n! \\sim \\left(\\frac{n}{e}\\right)^n \\sqrt{2n\\pi} \\quad (n\\to\\infty)$\n\n> 当 $a_n$ 是一些乘积构成或含 $n!$ 时，可以考虑比值法\n\n##### 根值判别法（Cauchy 判别法）\n\n**定理：**\n\n若正项级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 满足 $\\displaystyle \\lim_{n\\to\\infty} \\sqrt[n]{a_n} = l$，则\n\n1. 当 $0\\leq l<1$ 时，$\\displaystyle \\sum_{n=1}^\\infty a_n$ 收敛\n2. 当 $1 < l \\leq +\\infty$ 时，$\\displaystyle \\sum_{n=1}^\\infty a_n$ 发散\n3. 当 $l=1$ 时，判别法失效\n\n> 当 $a_n$ 中含有 $n$ 次方时，可以考虑使用根值法\n\n> 比值法和根值法实际上可看作是在将级数与等比级数作比较，均智能判断收敛速度不满与等比级数的级数.当所求级数存在时，可称级数为**拟等比级数**\n\n> 根值法优于比值法\n>\n> - $\\displaystyle\\lim_{n\\to\\infty}\\frac{a_{n+1}}{a_n} =  l \\Rightarrow \\displaystyle \\sqrt[n]{a_n} = l$\n> - $\\displaystyle \\sqrt[n]{a_n} =l \\nRightarrow \\displaystyle\\lim_{n\\to\\infty}\\frac{a_{n+1}}{a_n} =  l$\n\n##### 积分判别法\n\n**定理：**\n\n设 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 为**正项级数**，若非负函数 $f(X)$ 在 $[1,+\\infty)$ 上**单调递减**，且 $a_n = f(n)\\quad \\left(\\forall n \\in \\mathbb{N}^+\\right)$，则级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 与反常积分 $\\displaystyle \\int_1^{+\\infty} f(x)\\,\\mathrm{d}x$ 有相同的敛散性\n\n- 条件 $\\left[1,+\\infty\\right)$ 可改为 $\\left[a,+\\infty\\right)，(a>1)$\n\n### 任意项级数的敛散性\n\n**任意项级数**\n\n正负项分布是任意的级数\n\n#### 交错级数敛散性的判别法\n\n##### 交错级数\n\n**定义：**\n\n各项正负相间的级数称为**交错级数**，其形式为\n\n$$\n\\pm\\sum_{n=1}^\\infty {-1}^{n-1}a_n \\quad \\left(\\text{其中}a_n > 0\\right)\n$$\n\n##### Leibniz 判别法\n\n**定理：**\n\n若交错级数 $\\displaystyle \\sum_{n=1}^\\infty (-1)^{n-1}a_n \\,\\left(a_n>0\\right)$ 满足:\n\n1. $a_{n+1} \\leq a_n \\quad \\left(n = 1 ,2 ,\\ldots\\right)$\n2. $\\displaystyle\\lim_{n\\to\\infty}a_n =0$\n\n则级数 $\\displaystyle \\sum_{n=1}^\\infty (-1)^{n-1}a_n$ 收敛，且其余项级数满足\n\n$$\n\\left\\vert \\sum_{k=n+1}^\\infty a_k \\right\\vert \\leq a_{n+1}\n$$\n\n> 我们称满足定理条件的级数为 **leibniz 型级数**\n\n#### Abel 判别法和 Dirichlet 判别法\n\n**定理：（Abel 判别法）**\n\n若 $\\{a_n\\}$ 单调且有界，$\\displaystyle\\sum_{n=1}^\\infty b_n$ 收敛，则 $\\displaystyle \\sum_{n=1}^\\infty a_nb_n$ 收敛\n\n**定理：（Dirichlet 判别法）**\n\n若 $\\{a_n\\}$ 单调趋于 $0$，$\\displaystyle \\sum_{n=1}^\\infty b_n$ 的部分和数列有界，则 $\\displaystyle \\sum_{n=1}^\\infty a_nb_n$ 收敛\n\n#### 绝对收敛与条件收敛\n\n**定义：**\n\n设 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 为任意项级数\n\n1. 若级数 $\\displaystyle \\sum_{n=1}^\\infty \\vert a_n \\vert$ 收敛，则称级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 为**绝对收敛**\n2. 若 $\\displaystyle \\sum_{n=1}^\\infty \\vert a_n \\vert$ 发散，而 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 收敛，但 ，则称 $\\displaystyle \\sum_{n=1}^\\infty a_n$ **条件收敛**\n\n**定理：**\n\n若 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 绝对收敛，则 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 收敛\n\n> **常用结论：**\n>\n> $$\n> \\displaystyle \\sum_{n=1}^\\infty \\frac{(-1)^{n}}{n^p}\\begin{cases}\\text{绝对收敛} & ,p>1\\\\ \\text{条件收敛} & , 0 < p\\leq 1 \\end{cases}\n> $$\n\n**定理：（绝对收敛与条件收敛的本质）**\n\n1. 绝对收敛的级数，可以改变任意项的顺序，其收敛性与和均不变（即满足加法交换律）\n2. 条件收敛的级数，总可以适当改变项的顺序，使其按照任意预定的方式收敛或者发散\n\n### 函数项级数\n\n**定义：**\n\n设函数列 $\\{u_n{x}\\} (n=1,2,\\ldots)$ 在数集 $X$ 上有定义，则称形式和\n\n$$\n\\sum_{n=1}^\\infty u_n(x)= u_1(x) + u_2(x) + \\cdots + u_n(x) + \\cdots\n$$\n\n为**函数项级数**，其中 $u_n(x)$ 称为**通项**\n\n**定义：**\n\n若数项级数 $\\displaystyle \\sum_{n=1}^\\infty u_n(x_0)$ 收敛，则 $x_0$ 为函数项级数 $\\displaystyle \\sum_{n=1}^\\infty u_n(x)$ 的一个**收敛点**，否则称为**发散点**，全体收敛点所组成的集合 $I$ 称为**收敛域**\n\n**定义**\n\n记 $\\displaystyle S_n(x) =\\sum_{k=1}^\\infty u_k(x)$,为 $\\displaystyle \\sum_{n=1}^\\infty u_n(x)$ 的前 $n$ 项**部分和(函数)**，记 $\\displaystyle r_n(x) = \\sum_{k=n+1}^\\infty u_k(x)$ 为**余和**\n\n**定义：**\n\n对于收敛域 $I$ 中的任意一点 $x$，记 $\\displaystyle \\sum_{n=1}^\\infty u_n(x)$ 的和为 $S(x)$，称此函数 $S(x)$ 为 $\\displaystyle \\sum_{n=1}^\\infty u_n(x)$ 的**和函数**\n\n显然，$\\forall x\\in I$，$\\displaystyle \\lim_{n\\to +\\infty}S_n(x) =S(x)$，$\\displaystyle \\lim_{n\\to +\\infty}r_n(x)=0$\n\n### 幂级数\n\n#### 幂级数及其收敛半径\n\n在函数项级数中，最简单及最重要的级数形如\n\n$$\n\\sum_{n=0}^\\infty a_n(x-x_0)^n = a_0 +a_1x + a_2(x-x_0)^2 + \\ldots + a_n(x-x_0)^n + \\ldots\n$$\n\n称为**幂级数**，其中常数项 $a_0,a_1,\\ldots,a_n,\\ldots$ 称为幂级数的**系数**\n\n幂级数更加一半的形式为 $\\displaystyle \\sum_{n=0}^\\infty a_n(x-x_0)^n$\n\n##### **Abel 定理**\n\n1. 若幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_n(x-x_0)^n$ 在 $x=x_0(x\\neq 0)$ 收敛，则当 $\\vert x \\vert <\\vert x_0\\vert$，时，幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_n(x-x_0)^n$ 绝对收敛\n2. 若幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nx^n$ 在 $x=x_1$ 发散，则当 $\\vert x \\vert >\\vert x_1\\vert$ 时，幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nx^n$ 发散\n\n###### 推论（幂级数收敛域的情况）\n\n幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_n(x-x_0)^n$ 的收敛域 $I$ 仅有以下几种情况：\n\n1. 仅在 $x=0$ 的情况收敛（$R=0$）\n2. 在区间 $(-R,R)(R>0)$ 内绝对收敛，在 $(-\\infty ,-R)\\bigcup(R,+\\infty)$ 发散\n3. 在区间 $(-R,R)$ 内绝对收敛（$R=+\\infty$）\n\n### 幂级数收敛半径的求法\n\n#### 系数模比值法\n\n**定理：**\n\n对幂级数 $\\displaystyle \\sum_{n=1}^\\infty a_nx^n$，若 $\\displaystyle \\lim_{n\\to+\\infty}\\left\\vert\\frac{a_{n+1}}{a_n}\\right\\vert = \\rho$，则收敛半径 $\\displaystyle R=\\begin{cases}&0,&&\\rho=+\\infty\\newline & \\frac{1}{\\rho},&& 0<\\rho<+\\infty\\newline &+\\infty ,&&\\rho=0\\end{cases}$\n\n#### 系数模根值法\n\n**定理：**\n\n对幂级数 $\\displaystyle \\sum_{n=1}^\\infty a_nx^n$，若 $\\displaystyle \\lim_{n\\to+\\infty}\\sqrt[n]{\\left\\vert a_n\\right\\vert} = \\rho$，则收敛半径 $\\displaystyle R=\\begin{cases}&0,&&\\rho=+\\infty\\newline & \\frac{1}{\\rho},&& 0<\\rho<+\\infty\\newline &+\\infty ,&&\\rho=0\\end{cases}$\n\n### 幂级数的性质\n\n1. 设幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nx^n$ 和 $\\displaystyle \\sum_{n=0}^\\infty b_nx^n$ 的收敛半径分别为 $R_1$ 和 $R_2$，则 $\\displaystyle \\sum_{n=0}^\\infty (a_n+b_n)x^n$ 的收敛半径为 $R=\\min\\{R_1,R_2\\}$\n2. 若幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nx^n$ 的收敛半径 $R>0$，在收敛区间 $(-R,R)$ 内的和函数为 $S(n)$，则 $S(n)$ 在 $(-R,R)$ 上连续；若 $\\displaystyle\\sum_{n=0}^\\infty a_nx^n$ 在 $x=R$ 或 $x=-R$ 收敛，则和函数 $S(n)$ 在 $x=R$ 左连续或 $x=-R$ 处右连续，即 $\\displaystyle \\lim_{x\\to R^-}S(x)=S(R)=\\sum_{n=0}^\\infty a_nR^n$\n3. 若幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nx^n$ 的收敛半径 $R>0$，在收敛区间 $(-R,R)$ 内的和函数为 $S(n)$，则 $S(n)$ 在 $(-R,R)$ 上可导，且有**逐项求导公式**\n\n$$\n  \\begin{aligned}\n  S'(x) = &\\left(\\sum_{n=0}^\\infty a_nx^n\\right)'\\\\\n    = &\\sum_{n=0}^\\infty \\left(a_nx^n\\right)'\\\\\n    = &\\sum_{n=0}^\\infty na_nx^{n-1}\\\\\n  \\end{aligned}\n$$\n\n且幂级数 $\\displaystyle \\sum_{n=0}^\\infty na_nx^{n-1}$ 的收敛半径仍为 $R$\n\n4. 若幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nx^n$ 的收敛半径 $R>0$，在收敛区间 $(-R,R)$ 内的和函数为 $S(n)$，则 $S(n)$ 在 $(-R,R)$ 上可导，且有**逐项求积公式**\n\n$$\n  \\begin{aligned}\n  \\int_0^xS(t)\\,\\mathrm{d}t = &\\int_0^x\\left(\\sum_{n=0}^\\infty a_nt^n\\right)\\,\\mathrm{d}t\\\\\n    = &\\sum_{n=0}^\\infty \\int_0^x a_nt^n\\,\\mathrm{d}t\\\\\n    = &\\sum_{n=0}^\\infty \\frac{a_n}{n+1}x^{n+1}\\\\\n  \\end{aligned}\n$$\n\n且幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nt^n$ 的收敛半径仍为 $R$\n\n#### 幂级数的分析性质\n\n**性质：**\n\n若幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nx^n$ 的收敛半径为 $R>0$，在收敛区间 $(-R,R)$ 上连续；若 $\\displaystyle\\sum_{n=0}^\\infty a_nx^n$ 在 $x=R$ 或 $x=-R$ 收敛，则和函数 $S(n)$ 在 $x=R$ 左连续或 $x=-R$ 处右连续，即\n\n$$\n\\displaystyle \\lim_{x\\to R^-}S(x)=S(R)=\\sum_{n=0}^\\infty a_nR^n\n$$\n\n**性质：**\n\n若幂函数 $\\displaystyle \\sum_{n=0}^\\infty a_nx^n$ 的收敛半径为 $R>0$，在收敛区间 $(-R,R)$ 上的和函数为 $S(n)$，则 $S(n)$ 在 $(-R,R)$ 上可导，且有**逐项求导公式**\n\n$$\n\\begin{aligned}\nS'(x) = &\\left(\\sum_{n=0}^\\infty a_nx^n\\right)'\\\\\n  = &\\sum_{n=0}^\\infty \\left(a_nx^n\\right)'\\\\\n  = &\\sum_{n=0}^\\infty na_nx^{n-1}\\\\\n\\end{aligned}\n$$\n\n且幂级数 $\\displaystyle \\sum_{n=0}^\\infty na_nx^{n-1}$ 的收敛半径仍为 $R$\n\n**性质：**\n\n若幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nx^n$ 的收敛半径为 $R>0$，在收敛区间 $(-R,R)$ 上的和函数为 $S(n)$，则 $S(n)$ 在 $(-R,R)$ 上可导，且有**逐项求积公式**\n\n$$\n\\begin{aligned}\n\\int_0^xS(t)\\,\\mathrm{d}t = &\\int_0^x\\left(\\sum_{n=0}^\\infty a_nt^n\\right)\\,\\mathrm{d}t\\\\\n  = &\\sum_{n=0}^\\infty \\int_0^x a_nt^n\\,\\mathrm{d}t\\\\\n  = &\\sum_{n=0}^\\infty \\frac{a_n}{n+1}x^{n+1}\\\\\n\\end{aligned}\n$$\n\n且幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nt^n$ 的收敛半径仍为 $R$\n\n> 1. 幂函数逐项求导，逐项积分后，收敛半径不变，但是收敛域可能改变\n> 2. 幂函数在收敛区间内具有任意阶导数\n\n#### Taylor 级数\n\n**定义：**\n\n设函数 $f(x)$ 在 $x_0$ 的某领域内有任意阶导数，称幂级数\n\n$$\n\\sum_{n=0}^\\infty \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\n$$\n\n为 $f(x)$ 在 $x_0$ 处的 **Taylor** 级数，记为\n\n$$\nf(x) = \\sum_{n=0}^\\infty \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\n$$\n\n$x_0=0$ 是，称为 **Maclaurin 级数**\n\n**定理（唯一性）**\n\n若 $f(x)$ 在 $x_0$ 可展开为幂级数，则展开式唯一，且恰为 Taylor 级数\n\n**定理**\n\n设 $f(x)$ 在 $x_0$ 的某领域 $I$ 内任意阶可导，则在 $I$ 内\n\n$$\nf(x) = \\sum_{n=0}^\\infty \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n \\Leftrightarrow \\lim_{n\\to\\infty}R_n(x) =0\n$$\n\n#### 常用的初等函数的幂级数展开式\n\n1. $\\displaystyle e^x = \\sum_{n=0}^\\infty \\frac{x^n}{n!} \\quad (x\\in\\mathbb{R})$\n2. $\\displaystyle \\sin x = \\sum_{n=0}^\\infty \\frac{(-1)^nx^{2n+1}}{(2n+1)!} \\quad (x\\in\\mathbb{R})$\n3. $\\displaystyle \\cos x = \\sum_{n=0}^\\infty \\frac{(-1)^nx^{2n}}{(2n)!} \\quad (x\\in\\mathbb{R})$\n4. $\\displaystyle \\ln(1+x) = \\sum_{n=1}^\\infty \\frac{(-1)^{n-1}x^n}{n} \\quad (\\left\\vert x \\right\\vert<1)$\n5. $\\displaystyle (1+x)^\\alpha = \\sum_{n=0}^\\infty \\frac{\\alpha(\\alpha-1)\\cdots(\\alpha-n+1)}{n!}x^n \\quad (\\left\\vert x\\right\\vert<1)$\n6. $\\displaystyle \\frac{1}{1-x} = \\sum_{n=0}^\\infty x^n \\quad (\\left\\vert x\\right\\vert<1)$\n7. $\\displaystyle \\frac{1}{1+x} = \\sum_{n=0}^\\infty (-1)^nx^n \\quad (\\left\\vert x\\right\\vert<1)$\n8. $\\displaystyle \\arctan{x} = \\sum_{n=0}^\\infty \\frac{(-1)^n x^{2n+1}}{2n+1} \\quad (\\left\\vert x\\right\\vert\\leq 1)$\n\n#### 正弦级数和余弦级数\n\n若周期为 $2\\pi$ 的函数 $f(x)$ 是奇函数时，其 Fourier 系数 $a_n=0$，从而\n\n$$\nf(x) \\sim \\sum_{n=1}^{+\\infty}b_n\\sin(nx)\\quad\\text{正弦级数}\n$$\n\n其中 $\\displaystyle b_n =\\frac{2}{\\pi}\\int_0^\\pi f(x)\\sin(nx) \\,\\mathrm{d}x$\n\n若周期为 $2\\pi$ 的函数 $f(x)$ 是偶函数，其 Fourier 系数 $b_n=0$，从而\n\n$$\nf(x) \\sim \\frac{a_0}{2}+\\sum_{n=0}^{+\\infty}a_n\\cos(nx)\\quad\\text{余弦级数}\n$$\n\n其中 $\\displaystyle a_n =\\frac{1}{\\pi}\\int_0^\\pi f(x)\\cos(nx) \\,\\mathrm{d}x$\n\n若函数 $f(x)$ 定义在 $[0,\\pi]$ 上，可作奇延拓\n\n$$\nF(x)=\n\\begin{cases}\n  f(x), & 0< x< \\pi\\\\\n  -f(-x), & -\\pi < x < 0\\\\\n  0, & x=0,\\pm\\pi\\\\\n\\end{cases}\n$$\n\n使得 $F(x)$ 为 $[-\\pi,\\pi]$ 上的奇函数\n\n也可作偶延拓\n\n$$\nG(x)=\n\\begin{cases}\n  f(x), & 0< x< \\pi\\\\\n  f(-x), & -\\pi < x < 0\\\\\n  0, & x=0,\\pm\\pi\\\\\n\\end{cases}\n$$\n\n使得函数 $G(x)$ 为 $[-\\pi,\\pi]$ 上的偶函数\n\n对于一定义在 $[0,\\pi]$ 上的函数 $f(x)$，可以对其先做奇延拓或者偶延拓，再将其展开为 正弦级数或者余弦级数\n\n#### 周期为 $2l$ 的 Fourier 级数\n\n设函数 $f(x)$ 在区间 $[-l,l]$ 上可积，作代换 $x =\\frac{l}{\\pi}t$，使得 $F(t) = f\\left(\\frac{l}{\\pi}t\\right)$ 为 $[-\\pi,\\pi]$ 上的可积函数，从而\n\n$$\nF(t) \\sim \\frac{a_0}{2}+\\sum_{n=1}^{+\\infty}a_n\\cos(nt)+\\sum_{n=1}^{+\\infty}b_n\\sin(nt)\n$$\n\n其中\n\n$$\n\\begin{aligned}\na_n &= \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}F(t)\\cos(nt)\\,\\mathrm{d}t = \\frac{1}{l}\\int_{-l}^{l}f(x)\\cos\\left(\\frac{\\pi n}{l}x\\right)\\,\\mathrm{d}x\\\\\nb_n &= \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}F(t)\\sin(nt)\\,\\mathrm{d}t = \\frac{1}{l}\\int_{-l}^{l}f(x)\\sin\\left(\\frac{\\pi n}{l}x\\right)\\,\\mathrm{d}x\n\\end{aligned}\n$$\n\n故\n\n$$\nf(x) \\sim \\frac{a_0}{2}+\\sum_{n=1}^{+\\infty}\\left(a_n\\cos\\left(\\frac{\\pi n}{l}x\\right)+b_n\\sin\\left(\\frac{\\pi n}{l}x\\right)\\right)\n$$\n\n其中\n\n$$\n\\begin{aligned}\na_n &= \\frac{1}{l}\\int_{-l}^{l}f(x)\\cos\\left(\\frac{\\pi n}{l}x\\right)\\,\\mathrm{d}x\\\\\nb_n &= \\frac{1}{l}\\int_{-l}^{l}f(x)\\sin\\left(\\frac{\\pi n}{l}x\\right)\\,\\mathrm{d}x\n\\end{aligned}\n$$\n\n**定理：**\n\n若 $f(x)$ 在 $[-l,l]$ 上满足 Dirichlet 条件，则 Fourier 级数\n\n$$\n\\frac{a_0}{2}+\\sum_{n=1}^{+\\infty}\\left(a_n\\cos\\left(\\frac{\\pi n}{l}x\\right)+b_n\\sin\\left(\\frac{\\pi n}{l}x\\right)\\right)\n$$\n\n收敛到\n\n$$\nS(n) =\n\\begin{cases}\n  f(x), & x \\text{为} f(x) \\text{的连续点}\\\\\n  \\frac{f(x^+)+f(x^-)}{2}, & x \\text{为} f(x) \\text{的间断点}\\\\\n  \\frac{f(l^-)+f(-l^+)}{2} ,& x=\\pm l\n\\end{cases}\n$$\n","source":"_posts/高数2笔记.md","raw":"---\ntitle: 高数2笔记\nmath: true\n---\n\n## 重积分\n\n### 重积分的概念和性质\n\n#### 二重积分的概念\n\n**定义：**\n\n设 $D$ 是平面上的有界闭区域，$f(x,y)$ 为 $D$ 上的有界函数，$I$ 为实数.若对 $D$ 的任意分割 $\\Delta D_1 , \\Delta D_2 , \\cdots , \\Delta D_n$ ，任取 $(\\xi_i , \\eta_i)\\in\\Delta D_i(i=1,\\ldots,n)$，作和 $\\displaystyle\\sum_{i=1}^nf(\\xi_i,\\eta_i)\\Delta \\sigma_i$ （$\\Delta \\sigma_i$ 为 $D_i$ 的面积），总有\n\n$$\n\\lim_{\\lambda\\to 0}\\sum_{i=1}^nf(\\xi_i,\\eta_i)\\Delta \\sigma_i = I\n$$\n\n其中 $\\displaystyle\\lambda = \\max_{1\\leq i\\leq d} \\{d_i\\}$，$d_i$ 是小区域 $\\Delta D_i$ 的直径，则称函数 $f(x,y)$ 在 $D$ 上**可积**，记为 $f\\in R(D)$；极限值 $I$ 称为 $f(x,y)$ 在 $D$ 上的**二重积分**，记作\n\n$$\n\\iint_D f(x,y)\\,\\mathrm{d}\\sigma.\n$$\n\n- $\\displaystyle \\iint$ 积分号\n- $D$ 积分区域\n- $f(x,y)$ 被积函数\n- $\\mathrm{d}\\sigma$ 面积元素（微元）\n\n- 二重积分的几何意义\n\n  - 当被积函数大于 $0$ 时，二重积分是柱体体积\n  - 当被积函数小于 $0$ 时，二重积分是柱体体积的负值\n  - 一般的，为曲顶柱体体积的代数和\n\n- 可积的充分条件\n\n  - **定理：** 若函数 $f(x,y)$ 在区域 $D$ 上连续，则 $f(x,y)\\in D$.\n\n- $f(x,y)$ 在 $D$ 上的可积性及积分值与其在 $D$ 内**有限条光滑曲线**上的定义无关\n\n### 二重积分的性质\n\n1. $\\displaystyle\\iint_D\\,\\mathrm{d}\\sigma = \\iint_D 1\\,\\mathrm{d}\\sigma = A_D \\quad\\left(\\text{D 的面积}\\right)$.\n2. **线性性：** 设 $f,g\\in R(D)$，$\\alpha , \\beta$，是任意常数，则 $\\alpha f +\\beta g \\in R(D)$，且\n\n   $$\n   \\iint_D (\\alpha f +\\beta g)\\,\\mathrm{d}\\sigma = \\alpha \\iint_D f\\,\\mathrm{d}\\sigma + \\beta \\iint_D g\\,\\mathrm{d}\\sigma\n   $$\n\n3. **区域可加性：** 若 $f\\in R(D)$ 且积分区域 $D$ 分为内部不相交的子区域 $D_1 , D_2$，则\n\n   $$\n   \\iint_D f(x,y) \\,\\mathrm{d}\\sigma = \\iint_{D_1} f(x,y)\\,\\mathrm{d}\\sigma + \\iint_{D_2} f(x,y)\\,\\mathrm{d}\\sigma\n   $$\n\n4. **保序性：** 若 $f,g\\in R(D)$，且当 $(x,y)\\in D$ 时，$f(x,y)\\leq g(x,y)$，则\n\n   $$\n   \\iint_D f(x,y)\\,\\mathrm{d}\\sigma \\leq \\iint_D g(x,y)\\,\\mathrm{d}\\sigma\n   $$\n\n   - **推论 1：** 若 $f\\in R(D)$ ,则 $\\vert f(x,y) \\vert \\in R(D)$，且\n\n   $$\n    \\left\\vert \\iint_D f(x,y)\\,\\mathrm{d}\\sigma \\right\\vert \\leq \\iint_D \\vert f(x,y) \\vert \\,\\mathrm{d}\\sigma\n   $$\n\n   - **推论 2：** 若 $f\\in R(D)$，且当 $(x,y)\\in D$ 时， $m\\leq f(x,y) \\leq M$，则\n\n   $$\n    mA_D \\leq \\iint_D f(x,y)\\,\\mathrm{d}\\sigma \\leq MA_D\n   $$\n\n   - **推论 3：** 若 $f\\in R(D)$，且当 $(x,y)\\in D$ 时，$f(x,y) \\geq 0$，则\n\n   $$\n    \\iint_D f(x,y)\\,\\mathrm{d}\\sigma \\geq 0\n   $$\n\n5. **积分中值定理：** 若 $f(x,y)\\in C(D)$ ，$g(x,y)\\in R(D)$，且 $g$ 在 $D$ 上不变号，则 $\\exists \\xi , \\eta \\in D$，使得\n\n   $$\n   \\iint_D f(x,y)g(x,y)\\,\\mathrm{d}\\sigma = f(\\xi ,\\eta )\\iint_D g(x,y)\\,\\mathrm{d}\\sigma\n   $$\n\n   - **推论：** 若 $f(x,y)\\in C(D)$，则存在 $(\\xi , \\eta )\\in D$，使得\n\n   $$\n    \\iint_D f(x,y)\\,\\mathrm{d}\\sigma = f(\\xi ,\\eta )A_D\n   $$\n\n   称 $f(\\xi,\\eta) = \\frac{\\iint_D f\\,\\mathrm{d}\\sigma}{A_D}$ 为函数 $f(x,y)$ 在有界闭区域 $D$ 上的**平均值**\n\n### 二重积分的计算\n\n#### 直角坐标系下的计算\n\n当二重积分存在时，可利用平行于坐标轴的直线来划分积分区域 $D$，此时，面积元素\n\n$$\n\\mathrm{d}\\sigma = \\mathrm{d}x\\mathrm{d}y\n$$\n\n故二重积分在直角坐标系下可表示为\n\n$$\n\\iint_D f(x,y)\\,\\mathrm{d}\\sigma = \\iint_D f(x,y)\\,\\mathrm{d}x\\mathrm{d}y\n$$\n\n##### $x$ 型正则区域\n\n$$\nD = \\left\\{(x,y)\\bigg| \\varphi_1(x)\\leq y\\leq \\varphi_2(x),a\\leq x\\leq b\\right\\}\n$$\n\n化为先 $y$ 后 $x$ 的二次积分\n\n$$\n\\begin{aligned}\n    \\iint_D f(x,y)\\,\\mathrm{d}x\\mathrm{d}y &= \\int_a^b\\left[\\int_{\\varphi_1(x)}^{\\varphi_2(x)} f(x,y)\\,\\mathrm{d}y\\right]\\mathrm{d}x \\\\\n    &\\equiv \\int_a^b f(x,y)\\,\\mathrm{d}x\\mathrm{d}y\n\\end{aligned}\n$$\n\n##### $y$ 型正则区域\n\n$$\nD = \\left\\{(x,y)\\bigg| \\varphi_1(y)\\leq x\\leq \\varphi_2(y),c\\leq y\\leq d\\right\\}\n$$\n\n化为先 $x$ 后 $y$ 的二次积分\n\n$$\n\\begin{aligned}\n    \\iint_D f(x,y)\\,\\mathrm{d}x\\mathrm{d}y &= \\int_c^d\\left[\\int_{\\varphi_1(y)}^{\\varphi_2(y)} f(x,y)\\,\\mathrm{d}x\\right]\\mathrm{d}y \\\\\n    &\\equiv \\int_c^d f(x,y)\\,\\mathrm{d}x\\mathrm{d}y\n\\end{aligned}\n$$\n\n##### 一般区域的二重积分\n\n分割成若干个正则子区域，利用积分区域可加性，分别在子区域上积分后求和\n\n> 直角坐标计算二重积分的步骤\n>\n> 1. **画出积分区域** $D$ 的草图，并**确定类型**\n> 2. 按照所确定的类型**表示区域** $D$\n> 3. **化二重积分为二次积分**（注意上下限）\n> 4. **计算**二重积分\n\n#### 极坐标系下的计算\n\n当积分区域的边界曲线或被积函数用极坐标表示较为简单时，可用极坐标来计算二重积分.\n\n面积元素 $\\Delta \\sigma$ 在极坐标下为\n\n$$\n\\boxed{\\Delta\\sigma= r\\mathrm{d}r\\mathrm{d}\\theta}\n$$\n\n从直角坐标到极坐标时的二重积分变换公式为\n\n$$\n\\iint_D f(x,y)\\,\\mathrm{d}\\sigma = \\iint_D f(r\\cos\\theta,r\\sin\\theta)r\\,\\mathrm{d}r\\mathrm{d}\\theta\n$$\n\n$$\n\\left\\{\\left(r,\\theta\\right)\\left \\vert r_1(\\theta)\\leq r \\leq r_2(\\theta) , \\alpha \\leq \\theta \\leq \\beta \\right.\\right\\}\n$$\n\n则\n\n$$\n\\iint_D f(x,y)\\,\\mathrm{d}\\sigma = \\int_\\alpha^\\beta\\, \\mathrm{d}\\theta\\int_{r_1(\\theta)}^{r_2(\\theta)} f(r\\cos\\theta,r\\sin\\theta)r\\,\\mathrm{d}r\n$$\n\n#### 二重积分的变量代换\n\n**定理：**\n\n设变换 $\\displaystyle T :\\begin{cases}x=x(u,v)\\\\y=y(u,v)\\end{cases}$ 有连续偏导数，且满足 $\\displaystyle J = \\frac{\\partial (x,y)}{\\partial (u,v)}\\coloneqq \\begin{vmatrix}x_u ,x_v\\newline y_u,y_v\\end{vmatrix} \\left(\\text{Jacobi 行列式}\\right)\\neq 0$，而 $f(x,y)\\in C(D)$，则\n\n$$\n\\iint_D f(x,y)\\,\\mathrm{d}\\sigma = \\iint_{D^*} f(x(u,v),y(u,v))\\left\\vert J \\right\\vert \\,\\mathrm{d}u\\mathrm{d}v\n$$\n\n- 在定理条件下，变换 $T$ 一定存在逆变换 $T^{-1}:\\begin{cases}u=u(x,y)\\\\v=v(x,y)\\end{cases}$，且 $\\frac{\\partial (u,v)}{\\partial (x,y)}\\cdot \\frac{\\partial (x,y)}{\\partial (u,v)} = 1$\n\n  有时，借助此式求 $J$ 较为简单\n\n- 当 Jacobi 行列式仅在区域 $D^*$ 内个别点上或个别曲线上为 $0$ 时，定理结论仍成立\n- 在广义极坐标 $\\begin{cases}x=ar\\cos\\theta\\\\y=br\\sin\\theta\\end{cases}$ 下，$J = abr$\n\n### 三重积分\n\n#### 三重积分的定义\n\n**定义：**\n\n设 $\\Omega$ 是 $\\mathbb{R}^3$ 中的有界闭区域，三元函数 $f(x,y,z)$ 在 $\\Omega$ 上有界，$I$ 为实数. 若将 $\\Omega$ 任意分割成 $n$ 个小区域 $\\Delta \\Omega_1,\\Delta\\Omega_2,\\ldots,\\Delta\\Omega_n$，任取 $\\left(\\varepsilon_i,\\eta_i,\\xi_i \\right)\\in\\Delta\\Omega_i\\left(i=1,2,\\ldotp,n\\right)$，作和 $\\displaystyle\\sum_{i=1}^nf\\left(\\varepsilon_i,\\eta_i,\\xi_i \\right)\\Delta V_i$，（$\\Delta V_i$ 是 $\\Delta\\Omega_i$ 的体积），总有\n\n$$\n\\lim_{\\lambda\\to 0}\\sum_{i=1}^nf\\left(\\varepsilon_i,\\eta_i,\\xi_i \\right)\\Delta V_i = I\n$$\n\n其中 $\\lambda = \\max_{1\\leq i\\leq n}\\{d_i\\}$，$d_i$ 是 $\\Delta\\Omega_i$ 的直径，则称函数 $f(x,y,z)$ 在 $\\Omega$ 上**可积**，记为 $f\\in R(\\Omega)$； $I$ 称为 $f(x,y,z)$ 在 $\\Omega$ 上的**三重积分**，记作\n\n$$\n\\iiint_\\Omega f(x,y,z)\\,\\mathrm{d}V\n$$\n\n其中 $V_\\Omega$ 是区域 $\\Omega$ 的体积\n\n- 若 $f(x,y,z)$ 表示占有三维空间区域 $\\Omega$ 的物体的体密度函数，则 $\\displaystyle\\iiint_\\Omega f(x,y,z)\\,\\mathrm{d}V$ 给出了物体的**质量**\n- 类似二重积分，三重积分具有线性性，区域可加性，保序性以及推论和积分中值定理，并且有 $\\displaystyle\\iiint_\\Omega \\,\\mathrm{d}V = V_\\Omega$\n\n#### 直角坐标系下的计算\n\n直角坐标系下，由于 $\\mathrm{d}V=\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z$，故\n\n$$\n\\iiint_\\Omega f(x,y,z)\\,\\mathrm{d}V = \\iiint_\\Omega f(x,y,z)\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z\n$$\n\n##### 柱线法（坐标面投影法）\n\n设 $\\Omega$ 是以曲面 $z=z_1(x,y)$ 为底，曲面 $x=x_2(x,y)$，而侧面是母线平行于 $z$ 轴的柱体所围成的区域\n\n设 $\\Omega$ 在 $xOy$ 面上的投影区域为 $D_1$ ，则 $\\Omega$ 可表示为\n\n$$\n\\Omega = \\left\\{(x,y,z)\\bigg| (x,y)\\in D_1 , z_1(x,y)\\leq z\\leq z_2(x,y)(x,y)\\in D\\right\\}\n$$\n\n则物体总质量为\n\n$$\n\\iint_D\\left(\\int_{z_1(x,y)}^{z_2(x,y)}f(x,y,z)\\,\\mathrm{d}z\\right) \\,\\mathrm{d}x\\mathrm{d}y\n$$\n\n故有\n\n$$\n\\iiint_\\Omega f(x,y,z)\\,\\mathrm{d}V = \\iint_{D_1} \\,\\mathrm{d}x\\mathrm{d}y\\int_{z_1(x,y)}^{z_2(x,y)} f(x,y,z)\\,\\mathrm{d}z\n$$\n\n##### 截面法（坐标轴投影法）\n\n设区域 $\\Omega$ 在 $z$ 轴上的投影区间为 $[h_1,h_2]$，即 $\\Omega$ 介于平面 $z=h_1$ 和 $z=h_2$ 之间，过 $z$ 处且垂直于 $z$ 轴的平面截 $\\Omega$ 得截面区域 $D_z$，则 $\\Omega$ 可表示为\n\n$$\n\\Omega = \\left\\{(x,y,z)\\bigg| h_1\\leq z\\leq h_2 , (x,y)\\in D_z\\right\\}\n$$\n\n物体总质量为\n\n$$\n\\int_{h_1}^{h_2}\\left(\\iint_{D_z} f(x,y,z)\\,\\mathrm{d}x\\mathrm{d}y\\right) \\,\\mathrm{d}z\n$$\n\n故有\n\n$$\n\\iiint_\\Omega f(x,y,z)\\,\\mathrm{d}V = \\int_{h_1}^{h_2}\\,\\mathrm{d}z\\iint_{D_z} f(x,y,z)\\,\\mathrm{d}x\\mathrm{d}y\n$$\n\n#### 三重积分的变量代换\n\n**定理：**\n\n设变换 $T:\\begin{cases}x=x(u,v,w)\\\\y=y(u,v,w)\\\\z=z(u,v,w)\\end{cases}$ 有连续偏导数，且满足 $J=\\frac{\\partial (x,y,z)}{\\partial (u,v,w)}\\neq 0$，而 $f(x,y,z)\\in C(\\Omega)$，则\n\n$$\n  \\iiint_\\Omega f(x,y,z)\\,\\mathrm{d}V = \\iiint_{\\Omega^*} f(x(u,v,w),y(u,v,w),z(u,v,w))\\left\\vert J \\right\\vert \\,\\mathrm{d}u\\mathrm{d}v\\mathrm{d}w\n$$\n\n##### 柱面坐标系下的计算\n\n柱面坐标系，实际上就是将 $x,y$ 坐标转换为极坐标\n\n$$\n\\begin{cases}\nx = r\\cos\\theta\\\\\ny = r\\sin\\theta\\\\\nz = z\n\\end{cases}\n$$\n\n其 Jacobi 行列式为\n\n$$\nJ = \\frac{\\partial (x,y,z)}{\\partial (r,\\theta,z)} = \\begin{vmatrix}\n\\cos\\theta & -r\\sin\\theta & 0\\\\\n\\sin\\theta & r\\cos\\theta & 0\\\\\n0 & 0 & 1\n\\end{vmatrix} = r\n$$\n\n则柱面积分积分公式为\n\n$$\n\\iiint_\\Omega f(x,y,z)\\,\\mathrm{d}V = \\iiint_{\\Omega^*} f(r\\cos\\theta,r\\sin\\theta,z)r\\,\\mathrm{d}r\\mathrm{d}\\theta\\mathrm{d}z\n$$\n\n##### 球面坐标系下的计算\n\n球面坐标系，实际上就是将 $x,y,z$ 坐标转换为球坐标\n\n$$\n\\begin{cases}\nx = \\rho\\sin\\varphi\\cos\\theta\\\\\ny = \\rho\\sin\\varphi\\sin\\theta\\\\\nz = \\rho\\cos\\varphi\n\\end{cases}\n$$\n\n其 Jacobi 行列式为\n\n$$\nJ = \\frac{\\partial (x,y,z)}{\\partial (\\rho,\\varphi,\\theta)} = \\begin{vmatrix}\n\\sin\\varphi\\cos\\theta & \\rho\\cos\\varphi\\cos\\theta & -\\rho\\sin\\varphi\\sin\\theta\\\\\n\\sin\\varphi\\sin\\theta & \\rho\\cos\\varphi\\sin\\theta & \\rho\\sin\\varphi\\cos\\theta\\\\\n\\cos\\varphi & -\\rho\\sin\\varphi & 0\n\\end{vmatrix} = \\rho^2\\sin\\varphi\n$$\n\n则球面积分积分公式为\n\n$$\n\\iiint_\\Omega f(x,y,z)\\,\\mathrm{d}V = \\iiint_{\\Omega^*} f(\\rho\\sin\\varphi\\cos\\theta,\\rho\\sin\\varphi\\sin\\theta,\\rho\\cos\\varphi)\\rho^2\\sin\\varphi\\,\\mathrm{d}\\rho\\mathrm{d}\\varphi\\mathrm{d}\\theta\n$$\n\n### 重积分的应用\n\n#### 重积分的几何应用\n\n##### 平面图形的面积\n\n$$\nA(D) = \\iint_D \\,\\mathrm{d}\\sigma = \\iint_D \\,\\mathrm{d}x\\mathrm{d}y\n$$\n\n##### 立体的体积\n\n$$\nV(\\Omega) = \\iiint_\\Omega \\,\\mathrm{d}V = \\iiint_\\Omega \\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z\n$$\n\n##### 曲面的面积\n\n设空间曲面 $S:z=f(x,y),(x,y)\\in D$.\n\n则曲面 $S$ 的面积为\n\n$$\nA(S) = \\iint_D \\sqrt{1+z_x^2+z_y^2}\\,\\mathrm{d}x\\mathrm{d}y\n$$\n\n#### 重积分的物理应用\n\n###### 质心\n\n体密度为 $\\rho(x, y)$ 的物体占据空间 $\\Omega$，其质心坐标为\n\n$$\n\\begin{cases}\n  \\displaystyle\\bar{x} = \\frac{\\iiint_\\Omega x\\rho(x,y,z)\\,\\mathrm{d}V}{\\iiint_\\Omega\\mu(x,y,z)\\,\\mathrm{d}V} \\\\\n  \\displaystyle\\bar{y} = \\frac{\\iiint_\\Omega y\\rho(x,y,z)\\,\\mathrm{d}V}{\\iiint_\\Omega\\mu(x,y,z)\\,\\mathrm{d}V}\\\\\n  \\displaystyle\\bar{z} = \\frac{\\iiint_\\Omega z\\rho(x,y,z)\\,\\mathrm{d}V}{\\iiint_\\Omega\\mu(x,y,z)\\,\\mathrm{d}V}\n\\end{cases}\n$$\n\n##### 转动惯量\n\n设物体的密度为 $\\rho(x,y,z)$，则物体分别关于 $x$，$y$，$z$ 轴的转动惯量为\n\n$$\n\\begin{cases}\n  I_x = \\iiint_\\Omega \\rho(x,y,z)(y^2+z^2)\\,\\mathrm{d}V\\\\\n  I_y = \\iiint_\\Omega \\rho(x,y,z)(x^2+z^2)\\,\\mathrm{d}V\\\\\n  I_z = \\iiint_\\Omega \\rho(x,y,z)(x^2+y^2)\\,\\mathrm{d}V\n\\end{cases}\n$$\n\n##### 引力\n\n$$\n\\begin{aligned}\n  &\\mathrm{d}\\vec{F} = G\\frac{m_0\\mathrm{d}m}{r^3}\\vec{r}\\\\\n  =& G\\frac{m_0\\rho(x,y,z)\\mathrm{d}V}{r^3}\\cdot\\left(x-x_0,y-y_0,z-z_0\\right)\\\\\n  =&\\left(\\mathrm{d}F_x,\\mathrm{d}F_y,\\mathrm{d}F_z\\right)\n\\end{aligned}\n$$\n\n## 曲线积分和曲面积分\n\n### 第一类曲线积分和曲面积分\n\n#### 第一类曲线积分的概念\n\n**定义：**\n\n设 $C$ 是 $xOy$ 面上的一条光滑曲线弧，函数 $f(x,y)$ 是定义在 $C$ 上的有界函数，在 $C$ 上任意插入分点 $A = A_0,A_1,\\ldots,A_{n-1},A_n=B$，将其分成 $n$ 个小弧段，记第 $i$ 个小弧段的弧长为 $\\Delta s_i$，在第 $i$ 个小段上任取点 $(\\epsilon_i,\\eta_i)$，和式 $\\displaystyle\\sum_{i=1}^{+\\infty}f(\\epsilon_i,\\eta_i)\\Delta s_i$，当 $\\displaystyle\\lambda=\\max_{1\\leq i\\leq n}\\{\\Delta s_i\\}\\to 0$ 时，有确定的极限值 $I$，即\n\n$$\n\\lim_{\\lambda\\to 0}\\sum_{i=1}^nf(\\epsilon_i,\\eta_i)\\Delta s_i = I\n$$\n\n则称函数 $f(x,y)$ 在曲线 $C$ 上**可积**，并将此极限值 $I$ 称为函数 $f(x,y)$ 在曲线 $C$ 上的**第一类曲线积分**，记作 $\\displaystyle\\int_Cf(x,y)\\,\\mathrm{d}s$，即\n\n$$\nI = \\int_C f(x,y)\\,\\mathrm{d}s = \\lim_{\\lambda\\to 0}\\sum_{i=1}^nf(\\epsilon_i,\\eta_i)\\Delta s_i\n$$\n\n- 第一类曲线积分的几何含义为柱面的面积\n- $\\displaystyle\\int_C\\,\\mathrm{d}s = \\displaystyle\\int_c1\\,\\mathrm{d}s=s_C$\n- 若 $C$ 是封闭曲线，即 $C$ 的二端点重合，则记第一类曲线积分为 $\\displaystyle\\oint_Cf(x,y)\\,\\mathrm{d}s$\n\n#### 第一类曲线积分的性质\n\n##### 与曲线方向无关\n\n若曲线 $C$ 的端点为 $A$ 和 $B$，$f(x,y)$ 在曲线 $C$ 上可积，则\n\n$$\n\\int_{\\widehat{AB}} f(x,y)\\,\\mathrm{d}s=\\oint_{\\widehat{BA}} f(x,y)\\,\\mathrm{d}s\n$$\n\n##### 线性性\n\n若 $f,g$ 在曲线 $C$ 上可积，$\\alpha , \\beta$ 是任意常数，则 $\\alpha f + \\beta g$ 在曲线 $C$ 上可积，且\n\n$$\n\\int_C (\\alpha f + \\beta g)\\,\\mathrm{d}s = \\alpha \\int_C f(x,y)\\,\\mathrm{d}s + \\beta \\int_C g(x,y)\\,\\mathrm{d}s\n$$\n\n##### 路径可加性\n\n若曲线 $C$ 由两段光滑曲线 $C_1$ 和 $C_2$ 首尾连接而成，则 $f(x,y)$ 在曲线 $C$ 上可积，等价于 $f(x,y)$ 在曲线 $C_1$ 和 $C_2$ 上均可积，且\n\n$$\n\\int_C f(x,y)\\,\\mathrm{d}s = \\int_{C_1} f(x,y)\\,\\mathrm{d}s + \\int_{C_2} f(x,y)\\,\\mathrm{d}s\n$$\n\n##### 中值定理\n\n设函数 $f$ 在光滑曲线 $C$ 上连续，则 $\\exists (\\epsilon,\\eta)\\in C$，使得\n\n$$\n\\int_C f(x,y)\\,\\mathrm{d}s = f(\\epsilon,\\eta)\\cdot s_C\n$$\n\n其中 $s_C$ 是曲线段 $C$ 的长度\n\n#### 第一类曲线积分的计算\n\n设函数 $f(x,y)$ 在光滑曲线 $C$ 上连续，$C$ 的参数方程为 $\\begin{cases}x=x(t)\\\\y=y(t)\\end{cases}$，$t\\in [a,b]$，满足 $x'(t)$，$y'(t)$ 连续，且 $x'(t)^2 + y'(t)^2 \\neq 0$，则\n\n$$\n\\int_C f(x,y)\\,\\mathrm{d}s = \\int_\\alpha^\\beta f(x(t),y(t))\\sqrt{x'(t)^2 + y'(t)^2}\\,\\mathrm{d}t\n$$\n\n- 右端积分限应 $\\alpha < \\beta$\n- 当曲线 $C$ 形式为 $y=y(x)$，$x\\in [a,b]$ 时，则 $\\displaystyle\\int_Cf(x,y)\\,\\mathrm{d}s =\\int_a^bf(x,y(x))\\sqrt{1+y'^2(x)}\\,\\mathrm{d}x$\n- 当曲线 $C$ 为极坐标 $r=r(\\theta)$，$\\theta\\in [\\alpha,\\beta]$ 时，则 $\\displaystyle\\int_Cf(x,y)\\,\\mathrm{d}s = \\int_\\alpha^\\beta f(r(\\theta)\\cos\\theta,r(\\theta)\\sin\\theta)\\sqrt{r(\\theta)^2+r'^2(\\theta)}\\,\\mathrm{d}\\theta$\n\n### 第二类曲线积分与曲面积分\n\n#### 第二类曲线积分的概念\n\n**定义：**\n\n设 $C$ 为平面光滑定向曲线($A\\rightarrow B$)，且向量值函数 $\\vec{F}(x,y) = R(x,y)\\vec{i}+Q(x,y)\\vec{j}$ 在 $C$ 上有界，$\\vec{e}_\\tau$ 为 $C$ 上点 $(x,y)$ 处于定向一致的单位切向量，若\n\n$$\n\\int_C \\vec{F}(x,y) \\cdot \\vec{e}_\\tau \\,\\mathrm{d}s\n$$\n\n存在，则称为**向量值函数 $\\vec{F}$ 在定向曲线 $C$ 上的曲线积分或第二类曲线积分**\n\n若 $\\vec{e}_\\tau(x,y) = (\\cos\\alpha,\\cos\\beta)$，则\n\n$$\n\\begin{aligned}\n  \\int_C \\vec{F}(x,y) \\cdot \\vec{e}_\\tau \\,\\mathrm{d}s &= \\int_C P(x,y)\\cos\\alpha + Q(x,y)\\cos\\beta \\,\\mathrm{d}s \\\\\n  &= \\int_C P(x,y)\\cos\\alpha \\,\\mathrm{d}s + \\int_C Q(x,y)\\cos\\beta \\,\\mathrm{d}s \\\\\n  &= \\int_C P(x,y)\\,\\mathrm{d}x +  Q(x,y)\\,\\mathrm{d}y\n\\end{aligned}\n$$\n\n这是对坐标的曲线积分\n\n记 $\\vec{r} = (x,y)$，则 $\\mathrm{d}\\vec{e} = \\vec{e}_\\tau \\,\\mathrm{d}s$ 称为**定向弧微分**\n\n从而有向量形式的第一类曲线积分\n\n$$\n\\int_C \\vec{F}(x,y) \\cdot \\mathrm{d}\\vec{e} = \\int_C \\vec{F}\\cdot \\mathrm{d}\\vec{r}\n$$\n\n##### 第二类曲线积分的性质\n\n第二类曲线积分与**曲线方向有关**，即\n\n$$\n\\int_{\\widehat{AB}} \\vec{F}(x,y) \\cdot \\mathrm{d}\\vec{r} = -\\oint_{\\widehat{BA}} \\vec{F}(x,y) \\cdot \\mathrm{d}\\vec{r}\n$$\n\n此外线性性与对定向积分路径的可加性等仍然成立\n\n##### 第二类曲线积分的计算\n\n若曲线 $C$ 为 $\\begin{cases}x=x(t)\\\\y=y(t)\\end{cases}$，$t:\\alpha\\rightarrow \\beta$\n\n起点 $A$ 对应 $\\alpha$，终点 $B$ 对应 $\\beta$\n\n考察 $\\displaystyle\\int_C P\\,\\mathrm{d}x + Q\\,\\mathrm{d}y = \\int_C \\vec{F}\\cdot\\vec{e}_\\tau \\,\\mathrm{d}s$，沿曲线 $C$ 有 $\\vec{F} = \\left(P\\left(x(t),y(t)\\right),Q\\left(x(t),y(t)\\right)\\right)$，则\n\n$$\n\\int_C P\\,\\mathrm{d}x + Q\\,\\mathrm{d}y = \\int_\\alpha^\\beta P\\left(x(t),y(t)\\right)\\,\\mathrm{d}x(t) + Q\\left(x(t),y(t)\\right)\\,\\mathrm{d}y(t)\n$$\n\n#### 第二类曲面积分的概念\n\n##### 双侧曲面\n\n**定义：**\n\n若点 $P$ 沿曲面 $S$ 上任何不越过曲面边界的连续闭曲线移动后回到起始位置时，法向量 $\\vec{n}$ 保持原来的指向，则称 $S$ 为**双侧曲面**\n\n典型的，Mobius 面不是双侧曲面\n\n选定双侧曲面 $S$ 一侧为正向，称为**正侧**，记为 $S^+$ ，其相反测记作 $S^-$\n\n##### 双侧曲面定侧\n\n若 $S:z=z(x,y)$，$(x,y)\\in D_{xy}$，$\\vec{n}_0=\\left(\\cos\\alpha,\\cos\\beta,\\cos\\gamma\\right)=\\pm\\frac{\\left(-z_x,-z_y,1\\right)}{\\sqrt{1+z_x^2+z_y^2}}$\n\n若选取 $\\vec{n}_0=\\left(\\cos\\alpha,\\cos\\beta,\\cos\\gamma\\right)=\\frac{\\left(-z_x,-z_y,1\\right)}{\\sqrt{1+z_x^2+z_y^2}}$，则说明 $\\cos\\gamma > 0$，选取了曲面的上侧\n\n一般的\n\n$$\n\\begin{cases}\n  \\cos\\alpha >0 \\Leftrightarrow \\text{前侧}，\\cos\\alpha < 0 \\Leftrightarrow \\text{后侧}\\\\\n  \\cos\\beta >0 \\Leftrightarrow \\text{右侧}，\\cos\\beta < 0 \\Leftrightarrow \\text{左侧}\\\\\n  \\cos\\gamma >0 \\Leftrightarrow \\text{上侧}，\\cos\\gamma < 0 \\Leftrightarrow \\text{下侧}\n\\end{cases}\n$$\n\n习惯上选取曲面片的上侧为 $S^+$；对于封闭曲面，选取外侧为 $S^+$\n\n对于向量值函数 $\\vec{F} = (P,Q,R)$\n\n$$\n\\int_C \\vec{F}\\cdot\\,\\mathrm{d}S = \\int_c P\\,\\mathrm{d}x\\mathrm{d}y + Q\\,\\mathrm{d}y\\mathrm{d}z + R\\,\\mathrm{d}z\\mathrm{d}x\n$$\n\n##### 第二类曲面积分的性质\n\n第二类曲面积分与在曲面的哪一侧积分有关\n\n$$\n\\iint_{S^+}P\\,\\mathrm{d}x\\mathrm{d}y + Q\\,\\mathrm{d}y\\mathrm{d}z + R\\,\\mathrm{d}z\\mathrm{d}x = -\\iint_{S^-}P\\,\\mathrm{d}x\\mathrm{d}y + Q\\,\\mathrm{d}y\\mathrm{d}z + R\\,\\mathrm{d}z\\mathrm{d}x\n$$\n\n此外第二类曲面积分也具有线性性和可加性等性质\n\n#### 第二类曲面积分的计算\n\n##### 合一投影法\n\n$$\n\\iint_{S^+}P\\,\\mathrm{d}x\\mathrm{d}y + Q\\,\\mathrm{d}y\\mathrm{d}z + R\\,\\mathrm{d}z\\mathrm{d}x = \\iint_{D_{xy}} \\left(-Pz_x-Qz_y+R\\right)\\,\\mathrm{d}x\\mathrm{d}y\n$$\n\n##### 分面投影法\n\n分 $P\\,\\mathrm{d}x\\mathrm{d}y$，$Q\\,\\mathrm{d}y\\mathrm{d}z$，$R\\,\\mathrm{d}z\\mathrm{d}x$ 三个部分进行积分\n\n常在部分曲面垂直坐标轴时进行\n\n##### 公式法\n\n常用于参数方程确定的曲面\n\n设 $S:\\vec{r} = \\left(x(u,v),y(u,v),z(u,v)\\right)$，其中 $(u,v)\\in D_{xy}$，则\n\n$$\n\\iint_{S^+}\\vec{F}\\cdot\\,\\mathrm{d}\\vec{S} = \\iint_{D_{uv}}\\vec{F}\\cdot\\left(\\vec{r}_u\\times\\vec{r_v}\\right)\\,\\mathrm{d}u\\mathrm{d}v\n$$\n\n### Green 公式及其应用\n\n#### Green 公式\n\n##### 连通区域及其边界方向\n\n设 $D$ 为平面区域, 若 $D$ 内的任意一条闭曲线所围的区域都落在 $D$ 内, 则称 $D$ 是单连通的, 否则称 $D$ 为复连通的\n\n当点沿区域边界朝一个方向前进时, 区域总在它的左侧, 则将此方向规定为边界曲线 $C$ 的正向,记为 $C^+$, 与 $C^+$ 相反方向为 $C^−$\n\n##### Green 公式\n\n**定理：**\n\n设有界闭区域 $D$ 由分段光滑曲线 $C$ 围成，函数 $P(x, y)$, $Q(x, y)$ 在 $D$ 上有一阶连续偏导数, 则\n\n$$\n\\oint_{C^+} P\\,\\mathrm{d}x + Q\\,\\mathrm{d}y = \\iint_D \\left(\\frac{\\partial Q}{\\partial x} - \\frac{\\partial P}{\\partial y}\\right)\\,\\mathrm{d}x\\mathrm{d}y\n$$\n\n- 对于复连通区域 $D$，Green 公式仍然成立，但需将 $C$ 分成若干个单连通区域 $D_i$，并对每个区域应用 Green 公式\n- 公式也可以记为 $\\displaystyle\\oint_{C^+} P\\,\\mathrm{d}x + Q\\,\\mathrm{d}y = \\iint_D \\begin{vmatrix}\\frac{\\partial}{\\partial x}&\\frac{\\partial}{\\partial y}\\newline P&Q\\end{vmatrix}\\,\\mathrm{d}x\\mathrm{d}y$\n\n##### Green 公式的向量形式\n\n$$\n\\oint_{C^+} \\vec{F}\\cdot\\,\\mathrm{d}\\vec{r} = \\iint_D \\nabla\\times\\vec{F}\\,\\mathrm{d}x\\mathrm{d}y\n$$\n\n#### 曲线积分与路径无关的条件\n\n**定义：**\n\n设 $P(x,y)$，$Q(x,y)$ 在区域 $D$ 内连续，若对 $D$ 内任意两点 $A$，$B$ 以及 $D$ 内连接 $A,B$ 的任意二分段光滑曲线 $C_1$，$C_2$，均有\n\n$$\n\\int_{C_1} P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y = \\int_{C_2} P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y\n$$\n\n则称曲线积分 $\\displaystyle\\int_C P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y$ 在 $D$ 内**与路径无关**\n\n**定理：**\n\n设函数 $P$，$Q$ 在**单连通**区域 $D$ 上有连续偏导数，则下述四命题等价\n\n1. 在 $D$ 内的任一条分段光滑闭曲线 $C$ 上，有 $\\displaystyle \\int_C P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y = 0$\n2. 曲线积分 $\\displaystyle \\int_C P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y$ 在 $D$ 内与路径无关\n3. 存在 $D$ 上的可微函数 $u(x,y)$ 使得 $\\displaystyle \\mathrm{d}u = P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y$，此时称 $u(x,y)$ 为 $\\displaystyle P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y$ 的一个**原函数**\n4. $\\displaystyle \\frac{\\partial Q}{\\partial x} = \\frac{\\partial P}{\\partial y}$ 在 $D$ 内恒成立\n\n#### 全微分求积与全微分方程\n\n设函数 $P$，$Q$ 在单连通区域 $D$ 上有连续偏导数，且 $\\displaystyle \\frac{\\partial Q}{\\partial x} = \\frac{\\partial P}{\\partial y}$ ，则 $\\displaystyle P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y$ 为某函数 $u$ 的全微分，且取定 $(x_0,y_0)\\in D$\n\n$$\nu(x,y) = u(x_0,y_0) + \\int_{(x_0,y_0)}^{(x,y)} P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y,\\quad (x,y)\\in D\n$$\n\n从而全体函数为 $u(x,y) + C$\n\n称求 $P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y$ 的原函数的过程为**全微分求积**\n\n若 $P\\,\\mathrm{d}x +Q\\,\\mathrm{d}y$ 是某二元函数的全微分，称方程\n\n$$\nP(x,y)\\,\\mathrm{d}x +Q(x,y)\\,\\mathrm{d}y = 0\n$$\n\n为**全微分方程**\n\n求出一个原函数 $u(x,y)$，则方程的通解为 $u(x,y) = C$，其中 $C$ 是任意常数\n\n### Gauss 公式和 Strokes 公式\n\n#### Gauss 公式\n\n**定理：**\n\n设函数 $P(x,y,z)$，$Q(x,y,z)$，$R(x,y,z)$ 在空间有界闭区域 $\\Omega$ 上有连续偏导数，$\\Omega$ 的边界时光滑或分片光滑的闭曲面 $\\Sigma$，则\n\n$$\n\\oiint_{\\Sigma^+} P\\,\\mathrm{d}x\\mathrm{d}y + Q\\,\\mathrm{d}y\\mathrm{d}z + R\\,\\mathrm{d}z\\mathrm{d}x = \\iiint_\\Omega \\left(\\frac{\\partial P}{\\partial x} + \\frac{\\partial Q}{\\partial y} + \\frac{\\partial R}{\\partial z}\\right)\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z\n$$\n\n- 令 $P=\\frac{x}{3}$，$Q=\\frac{y}{3}$，$R=\\frac{z}{3}$，则可导出 $\\displaystyle V_\\Omega = \\frac{1}{3}\\oiint_{\\Sigma^+} x\\,\\mathrm{d}y\\mathrm{d}z + y\\,\\mathrm{d}z\\mathrm{d}x + z\\,\\mathrm{d}x\\mathrm{d}y$，即体积公式\n- 使用 Gauss 公式时，注意 $\\Sigma^+$ 的方向应与 $\\Omega$ 的外侧一致\n\n##### 向量形式的 Gauss 公式\n\n$$\n\\oiint_{\\Sigma^+} \\vec{F}\\cdot\\,\\mathrm{d}\\vec{S} = \\iiint_\\Omega \\nabla\\cdot\\vec{F}\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z\n$$\n\n#### 通量和散度\n\n##### 通量\n\n若给定向量场\n\n$$\n\\vec{F} = \\left(P(x,y,z),Q(x,y,z),R(x,y,z)\\right)\n$$\n\n则称曲面积分\n\n$$\n\\Phi = \\oiint_{\\Sigma^+} \\vec{F}\\cdot\\,\\mathrm{d}\\vec{S} = \\oiint_{\\Sigma^+} P\\,\\mathrm{d}x\\mathrm{d}y + Q\\,\\mathrm{d}y\\mathrm{d}z + R\\,\\mathrm{d}z\\mathrm{d}x\n$$\n\n为向量场 $\\vec{F}$ 在通过定侧曲面 $\\Sigma^+$ 的**通量**\n\n##### 散度\n\n称\n\n$$\n\\mathrm{div}\\vec{F} = \\nabla\\cdot\\vec{F}=\\frac{\\partial P}{\\partial x} + \\frac{\\partial Q}{\\partial y} + \\frac{\\partial R}{\\partial z}\n$$\n\n为向量场 $\\vec{F}$ 的**散度**\n\n则 Gauss 公式可写为\n\n$$\n\\Phi =\\oiint_{\\Sigma^+} \\vec{F}\\cdot\\,\\mathrm{d}\\vec{S} = \\iiint_\\Omega \\mathrm{div}\\vec{F}\\,\\mathrm{d}V\n$$\n\n## 级数\n\n### 数项级数\n\n#### 数项级数的概念\n\n**定义：**\n\n给定数列 $\\{a_n\\}$ ，和式\n\n$$\n\\sum_{n=1}^{\\infty} a_n = a_1 + a_2 + \\cdots + a_n + \\cdots\n$$\n\n称为 **（无穷）极数** ，$a_n$ 称为级数的**通项**（或**一般项**）\n\n- $\\displaystyle S_n = \\sum_{k=1}^n a_k$ 称为级数 $\\displaystyle \\sum_{n=1} a_n$ 的前 $n$ 项**部分和**\n- $\\displaystyle\\sum_{k=n+1}^\\infty a_k$ 称为级数 $\\displaystyle \\sum_{n=1} a_n$ 的**余项级数**\n\n**定义：**\n\n- 若级数 $\\displaystyle\\sum_{n=1}^\\infty a_n$ 的部分和数列 $\\{S_n\\}$ 收敛，且 $\\displaystyle \\lim_{n\\to\\infty}S_n = S$，则称级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$ **收敛**，$S$ 称为级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 的**和**，记作 $\\displaystyle \\sum_{n=1}^\\infty a_n = S$\n- 若部分和数列 $\\{S_n\\}$ 发散，则称级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$ **发散**\n\n> 常用结论：\n>\n> **等比数列** $\\displaystyle \\sum_{n=1}^\\infty aq^{n-1}\\begin{cases}\\text{收敛于}\\frac{a}{1-q} & ,\\vert q \\vert < 1\\newline \\text{发散} & ,\\vert q \\vert \\geq 1\\end{cases}$\n\n#### 数项级数的基本性质\n\n##### 基本性质\n\n1. 若常数 $\\alpha \\neq 0$，则级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 与级数 $\\displaystyle \\sum_{n=1}^\\infty \\alpha a_n$ 有相同敛散性\n2. **线性性：** 若级数 $\\displaystyle \\sum_{n=1}^\\infty a_n = S$，$\\displaystyle \\sum_{n=1}^\\infty b_n = T$，则 $\\forall \\alpha , \\beta\\in \\mathbb{R}$，有 $\\displaystyle \\sum_{n=1}^\\infty (\\alpha a_n + \\beta b_n) = \\alpha S + \\beta T$\n3. **可加性：** 将级数增加、删减或改换**有限项**，不改变级数的**敛散性**\n4. **结合律：** 若级数收敛于 $S$，则将相邻若干项添加括号所成新级数仍收敛于 $S$\n   - 其本质是部分和数列收敛于 $S$，则子列均收敛于 $S$\n   - 加括号后级数收敛 $\\nRightarrow$ 原级数收敛\n   - 加括号后级数发散 $\\Rightarrow$ 原级数发散\n\n##### 级数收敛的必要条件\n\n**定理：**\n\n若 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 收敛，则 $\\displaystyle \\lim_{n\\to\\infty} a_n = 0$\n\n- 若 $\\displaystyle \\lim_{n\\to\\infty} a_n \\neq 0 \\nRightarrow \\displaystyle \\sum_{n=1}^\\infty a_n$ 发散\n- 若 $\\displaystyle \\lim_{n\\to\\infty} a_n = 0 \\nRightarrow \\displaystyle \\sum_{n=1}^\\infty a_n$ 收敛，比如调和级数\n\n### 正项级数敛散性\n\n#### 正项级数\n\n**定义：**\n\n若级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 满足 $a_n >0 \\quad \\left(n\\in\\mathbb{N}^+\\right)$，则称此级数为**正项级数**\n\n**定理：（收敛原理）**\n\n正项级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 收敛 $\\Leftrightarrow$ 是其部分和数列 $\\{S_n\\}$ 有上界，即 $\\exists M\\in\\mathbb{R},\\forall n \\in \\mathbb{N}^+:S_n \\leq M$\n\n> $p$ 级数\n>\n> $\\displaystyle \\sum_{n=1}^\\infty \\frac{1}{n^p} \\begin{cases}\\text{收敛} & ,p>1\\newline \\text{发散} & ,p\\leq 1\\end{cases}$\n\n#### 正项级数敛散性判别法\n\n##### 比较判别法\n\n**定理：**\n\n设正项级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$，$\\displaystyle \\sum_{n=1}^\\infty b_n$ 满足 $a_n \\leq b_n \\quad (\\forall n \\in \\mathbb{N}^+)$ ，则 $\\displaystyle \\sum_{n=1}^\\infty b_n$ 收敛 $\\Rightarrow \\displaystyle \\sum_{n=1}^\\infty a_n$ 收敛，$\\displaystyle \\sum_{n=1}^\\infty a_n$ 发散 $\\Rightarrow \\displaystyle \\sum_{n=1}^\\infty b_n$ 发散\n\n- 条件 $\\forall n \\in \\mathbb{N}^+，a_n \\leq b_n$ 可改为 $\\exists N,C >0  ,\\forall n\\in \\mathbb{N}^+，\\forall n \\geq N，a_n \\leq Cb_n$\n- 使用该判别法时需要有参照级数，常选**等比级数**或 **$p$ 级数**作参照\n\n##### 比较判别法（极限形式）\n\n**定理：**\n\n正项级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$，$\\displaystyle \\sum_{n=1}^\\infty b_n$ 满足 $\\displaystyle \\lim_{n\\to\\infty} \\frac{a_n}{b_n} = l$\n\n- 当 $0 <l<+\\infty$ 时，$\\displaystyle \\sum_{n=1}^\\infty a_n$ 与 $\\displaystyle \\sum_{n=1}^\\infty b_n$ 同敛散\n- 当 $l=0$ 时，$\\displaystyle \\sum_{n=1}^\\infty b_n$ 收敛 $\\Rightarrow \\displaystyle \\sum_{n=1}^\\infty a_n$ 收敛\n- 当 $l=+\\infty$ 时，$\\displaystyle \\sum_{n=1}^\\infty b_n$ 发散 $\\Rightarrow \\displaystyle \\sum_{n=1}^\\infty a_n$ 发散\n\n> 通常使用 $b_n = \\frac{1}{n^p}$ 作为参照物，因为我们此时在分析无穷小 $a_n$ 的阶\n\n##### 比值判别法（d'Alembert 判别法）\n\n**定理：**\n\n若**正项级数** $\\displaystyle \\sum_{n=1}^\\infty a_n$ 满足 $\\displaystyle \\lim_{n\\to\\infty} \\frac{a_{n+1}}{a_n} = l$，则\n\n- 当 $0\\leq l<1$ 时，$\\displaystyle \\sum_{n=1}^\\infty a_n$ 收敛\n- 当 $l>1$ 时，$\\displaystyle \\sum_{n=1}^\\infty a_n$ 发散\n- 当 $l=1$ 时，判别法失效\n\n> Stirling 公式： $n! \\sim \\left(\\frac{n}{e}\\right)^n \\sqrt{2n\\pi} \\quad (n\\to\\infty)$\n\n> 当 $a_n$ 是一些乘积构成或含 $n!$ 时，可以考虑比值法\n\n##### 根值判别法（Cauchy 判别法）\n\n**定理：**\n\n若正项级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 满足 $\\displaystyle \\lim_{n\\to\\infty} \\sqrt[n]{a_n} = l$，则\n\n1. 当 $0\\leq l<1$ 时，$\\displaystyle \\sum_{n=1}^\\infty a_n$ 收敛\n2. 当 $1 < l \\leq +\\infty$ 时，$\\displaystyle \\sum_{n=1}^\\infty a_n$ 发散\n3. 当 $l=1$ 时，判别法失效\n\n> 当 $a_n$ 中含有 $n$ 次方时，可以考虑使用根值法\n\n> 比值法和根值法实际上可看作是在将级数与等比级数作比较，均智能判断收敛速度不满与等比级数的级数.当所求级数存在时，可称级数为**拟等比级数**\n\n> 根值法优于比值法\n>\n> - $\\displaystyle\\lim_{n\\to\\infty}\\frac{a_{n+1}}{a_n} =  l \\Rightarrow \\displaystyle \\sqrt[n]{a_n} = l$\n> - $\\displaystyle \\sqrt[n]{a_n} =l \\nRightarrow \\displaystyle\\lim_{n\\to\\infty}\\frac{a_{n+1}}{a_n} =  l$\n\n##### 积分判别法\n\n**定理：**\n\n设 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 为**正项级数**，若非负函数 $f(X)$ 在 $[1,+\\infty)$ 上**单调递减**，且 $a_n = f(n)\\quad \\left(\\forall n \\in \\mathbb{N}^+\\right)$，则级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 与反常积分 $\\displaystyle \\int_1^{+\\infty} f(x)\\,\\mathrm{d}x$ 有相同的敛散性\n\n- 条件 $\\left[1,+\\infty\\right)$ 可改为 $\\left[a,+\\infty\\right)，(a>1)$\n\n### 任意项级数的敛散性\n\n**任意项级数**\n\n正负项分布是任意的级数\n\n#### 交错级数敛散性的判别法\n\n##### 交错级数\n\n**定义：**\n\n各项正负相间的级数称为**交错级数**，其形式为\n\n$$\n\\pm\\sum_{n=1}^\\infty {-1}^{n-1}a_n \\quad \\left(\\text{其中}a_n > 0\\right)\n$$\n\n##### Leibniz 判别法\n\n**定理：**\n\n若交错级数 $\\displaystyle \\sum_{n=1}^\\infty (-1)^{n-1}a_n \\,\\left(a_n>0\\right)$ 满足:\n\n1. $a_{n+1} \\leq a_n \\quad \\left(n = 1 ,2 ,\\ldots\\right)$\n2. $\\displaystyle\\lim_{n\\to\\infty}a_n =0$\n\n则级数 $\\displaystyle \\sum_{n=1}^\\infty (-1)^{n-1}a_n$ 收敛，且其余项级数满足\n\n$$\n\\left\\vert \\sum_{k=n+1}^\\infty a_k \\right\\vert \\leq a_{n+1}\n$$\n\n> 我们称满足定理条件的级数为 **leibniz 型级数**\n\n#### Abel 判别法和 Dirichlet 判别法\n\n**定理：（Abel 判别法）**\n\n若 $\\{a_n\\}$ 单调且有界，$\\displaystyle\\sum_{n=1}^\\infty b_n$ 收敛，则 $\\displaystyle \\sum_{n=1}^\\infty a_nb_n$ 收敛\n\n**定理：（Dirichlet 判别法）**\n\n若 $\\{a_n\\}$ 单调趋于 $0$，$\\displaystyle \\sum_{n=1}^\\infty b_n$ 的部分和数列有界，则 $\\displaystyle \\sum_{n=1}^\\infty a_nb_n$ 收敛\n\n#### 绝对收敛与条件收敛\n\n**定义：**\n\n设 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 为任意项级数\n\n1. 若级数 $\\displaystyle \\sum_{n=1}^\\infty \\vert a_n \\vert$ 收敛，则称级数 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 为**绝对收敛**\n2. 若 $\\displaystyle \\sum_{n=1}^\\infty \\vert a_n \\vert$ 发散，而 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 收敛，但 ，则称 $\\displaystyle \\sum_{n=1}^\\infty a_n$ **条件收敛**\n\n**定理：**\n\n若 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 绝对收敛，则 $\\displaystyle \\sum_{n=1}^\\infty a_n$ 收敛\n\n> **常用结论：**\n>\n> $$\n> \\displaystyle \\sum_{n=1}^\\infty \\frac{(-1)^{n}}{n^p}\\begin{cases}\\text{绝对收敛} & ,p>1\\\\ \\text{条件收敛} & , 0 < p\\leq 1 \\end{cases}\n> $$\n\n**定理：（绝对收敛与条件收敛的本质）**\n\n1. 绝对收敛的级数，可以改变任意项的顺序，其收敛性与和均不变（即满足加法交换律）\n2. 条件收敛的级数，总可以适当改变项的顺序，使其按照任意预定的方式收敛或者发散\n\n### 函数项级数\n\n**定义：**\n\n设函数列 $\\{u_n{x}\\} (n=1,2,\\ldots)$ 在数集 $X$ 上有定义，则称形式和\n\n$$\n\\sum_{n=1}^\\infty u_n(x)= u_1(x) + u_2(x) + \\cdots + u_n(x) + \\cdots\n$$\n\n为**函数项级数**，其中 $u_n(x)$ 称为**通项**\n\n**定义：**\n\n若数项级数 $\\displaystyle \\sum_{n=1}^\\infty u_n(x_0)$ 收敛，则 $x_0$ 为函数项级数 $\\displaystyle \\sum_{n=1}^\\infty u_n(x)$ 的一个**收敛点**，否则称为**发散点**，全体收敛点所组成的集合 $I$ 称为**收敛域**\n\n**定义**\n\n记 $\\displaystyle S_n(x) =\\sum_{k=1}^\\infty u_k(x)$,为 $\\displaystyle \\sum_{n=1}^\\infty u_n(x)$ 的前 $n$ 项**部分和(函数)**，记 $\\displaystyle r_n(x) = \\sum_{k=n+1}^\\infty u_k(x)$ 为**余和**\n\n**定义：**\n\n对于收敛域 $I$ 中的任意一点 $x$，记 $\\displaystyle \\sum_{n=1}^\\infty u_n(x)$ 的和为 $S(x)$，称此函数 $S(x)$ 为 $\\displaystyle \\sum_{n=1}^\\infty u_n(x)$ 的**和函数**\n\n显然，$\\forall x\\in I$，$\\displaystyle \\lim_{n\\to +\\infty}S_n(x) =S(x)$，$\\displaystyle \\lim_{n\\to +\\infty}r_n(x)=0$\n\n### 幂级数\n\n#### 幂级数及其收敛半径\n\n在函数项级数中，最简单及最重要的级数形如\n\n$$\n\\sum_{n=0}^\\infty a_n(x-x_0)^n = a_0 +a_1x + a_2(x-x_0)^2 + \\ldots + a_n(x-x_0)^n + \\ldots\n$$\n\n称为**幂级数**，其中常数项 $a_0,a_1,\\ldots,a_n,\\ldots$ 称为幂级数的**系数**\n\n幂级数更加一半的形式为 $\\displaystyle \\sum_{n=0}^\\infty a_n(x-x_0)^n$\n\n##### **Abel 定理**\n\n1. 若幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_n(x-x_0)^n$ 在 $x=x_0(x\\neq 0)$ 收敛，则当 $\\vert x \\vert <\\vert x_0\\vert$，时，幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_n(x-x_0)^n$ 绝对收敛\n2. 若幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nx^n$ 在 $x=x_1$ 发散，则当 $\\vert x \\vert >\\vert x_1\\vert$ 时，幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nx^n$ 发散\n\n###### 推论（幂级数收敛域的情况）\n\n幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_n(x-x_0)^n$ 的收敛域 $I$ 仅有以下几种情况：\n\n1. 仅在 $x=0$ 的情况收敛（$R=0$）\n2. 在区间 $(-R,R)(R>0)$ 内绝对收敛，在 $(-\\infty ,-R)\\bigcup(R,+\\infty)$ 发散\n3. 在区间 $(-R,R)$ 内绝对收敛（$R=+\\infty$）\n\n### 幂级数收敛半径的求法\n\n#### 系数模比值法\n\n**定理：**\n\n对幂级数 $\\displaystyle \\sum_{n=1}^\\infty a_nx^n$，若 $\\displaystyle \\lim_{n\\to+\\infty}\\left\\vert\\frac{a_{n+1}}{a_n}\\right\\vert = \\rho$，则收敛半径 $\\displaystyle R=\\begin{cases}&0,&&\\rho=+\\infty\\newline & \\frac{1}{\\rho},&& 0<\\rho<+\\infty\\newline &+\\infty ,&&\\rho=0\\end{cases}$\n\n#### 系数模根值法\n\n**定理：**\n\n对幂级数 $\\displaystyle \\sum_{n=1}^\\infty a_nx^n$，若 $\\displaystyle \\lim_{n\\to+\\infty}\\sqrt[n]{\\left\\vert a_n\\right\\vert} = \\rho$，则收敛半径 $\\displaystyle R=\\begin{cases}&0,&&\\rho=+\\infty\\newline & \\frac{1}{\\rho},&& 0<\\rho<+\\infty\\newline &+\\infty ,&&\\rho=0\\end{cases}$\n\n### 幂级数的性质\n\n1. 设幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nx^n$ 和 $\\displaystyle \\sum_{n=0}^\\infty b_nx^n$ 的收敛半径分别为 $R_1$ 和 $R_2$，则 $\\displaystyle \\sum_{n=0}^\\infty (a_n+b_n)x^n$ 的收敛半径为 $R=\\min\\{R_1,R_2\\}$\n2. 若幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nx^n$ 的收敛半径 $R>0$，在收敛区间 $(-R,R)$ 内的和函数为 $S(n)$，则 $S(n)$ 在 $(-R,R)$ 上连续；若 $\\displaystyle\\sum_{n=0}^\\infty a_nx^n$ 在 $x=R$ 或 $x=-R$ 收敛，则和函数 $S(n)$ 在 $x=R$ 左连续或 $x=-R$ 处右连续，即 $\\displaystyle \\lim_{x\\to R^-}S(x)=S(R)=\\sum_{n=0}^\\infty a_nR^n$\n3. 若幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nx^n$ 的收敛半径 $R>0$，在收敛区间 $(-R,R)$ 内的和函数为 $S(n)$，则 $S(n)$ 在 $(-R,R)$ 上可导，且有**逐项求导公式**\n\n$$\n  \\begin{aligned}\n  S'(x) = &\\left(\\sum_{n=0}^\\infty a_nx^n\\right)'\\\\\n    = &\\sum_{n=0}^\\infty \\left(a_nx^n\\right)'\\\\\n    = &\\sum_{n=0}^\\infty na_nx^{n-1}\\\\\n  \\end{aligned}\n$$\n\n且幂级数 $\\displaystyle \\sum_{n=0}^\\infty na_nx^{n-1}$ 的收敛半径仍为 $R$\n\n4. 若幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nx^n$ 的收敛半径 $R>0$，在收敛区间 $(-R,R)$ 内的和函数为 $S(n)$，则 $S(n)$ 在 $(-R,R)$ 上可导，且有**逐项求积公式**\n\n$$\n  \\begin{aligned}\n  \\int_0^xS(t)\\,\\mathrm{d}t = &\\int_0^x\\left(\\sum_{n=0}^\\infty a_nt^n\\right)\\,\\mathrm{d}t\\\\\n    = &\\sum_{n=0}^\\infty \\int_0^x a_nt^n\\,\\mathrm{d}t\\\\\n    = &\\sum_{n=0}^\\infty \\frac{a_n}{n+1}x^{n+1}\\\\\n  \\end{aligned}\n$$\n\n且幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nt^n$ 的收敛半径仍为 $R$\n\n#### 幂级数的分析性质\n\n**性质：**\n\n若幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nx^n$ 的收敛半径为 $R>0$，在收敛区间 $(-R,R)$ 上连续；若 $\\displaystyle\\sum_{n=0}^\\infty a_nx^n$ 在 $x=R$ 或 $x=-R$ 收敛，则和函数 $S(n)$ 在 $x=R$ 左连续或 $x=-R$ 处右连续，即\n\n$$\n\\displaystyle \\lim_{x\\to R^-}S(x)=S(R)=\\sum_{n=0}^\\infty a_nR^n\n$$\n\n**性质：**\n\n若幂函数 $\\displaystyle \\sum_{n=0}^\\infty a_nx^n$ 的收敛半径为 $R>0$，在收敛区间 $(-R,R)$ 上的和函数为 $S(n)$，则 $S(n)$ 在 $(-R,R)$ 上可导，且有**逐项求导公式**\n\n$$\n\\begin{aligned}\nS'(x) = &\\left(\\sum_{n=0}^\\infty a_nx^n\\right)'\\\\\n  = &\\sum_{n=0}^\\infty \\left(a_nx^n\\right)'\\\\\n  = &\\sum_{n=0}^\\infty na_nx^{n-1}\\\\\n\\end{aligned}\n$$\n\n且幂级数 $\\displaystyle \\sum_{n=0}^\\infty na_nx^{n-1}$ 的收敛半径仍为 $R$\n\n**性质：**\n\n若幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nx^n$ 的收敛半径为 $R>0$，在收敛区间 $(-R,R)$ 上的和函数为 $S(n)$，则 $S(n)$ 在 $(-R,R)$ 上可导，且有**逐项求积公式**\n\n$$\n\\begin{aligned}\n\\int_0^xS(t)\\,\\mathrm{d}t = &\\int_0^x\\left(\\sum_{n=0}^\\infty a_nt^n\\right)\\,\\mathrm{d}t\\\\\n  = &\\sum_{n=0}^\\infty \\int_0^x a_nt^n\\,\\mathrm{d}t\\\\\n  = &\\sum_{n=0}^\\infty \\frac{a_n}{n+1}x^{n+1}\\\\\n\\end{aligned}\n$$\n\n且幂级数 $\\displaystyle \\sum_{n=0}^\\infty a_nt^n$ 的收敛半径仍为 $R$\n\n> 1. 幂函数逐项求导，逐项积分后，收敛半径不变，但是收敛域可能改变\n> 2. 幂函数在收敛区间内具有任意阶导数\n\n#### Taylor 级数\n\n**定义：**\n\n设函数 $f(x)$ 在 $x_0$ 的某领域内有任意阶导数，称幂级数\n\n$$\n\\sum_{n=0}^\\infty \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\n$$\n\n为 $f(x)$ 在 $x_0$ 处的 **Taylor** 级数，记为\n\n$$\nf(x) = \\sum_{n=0}^\\infty \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\n$$\n\n$x_0=0$ 是，称为 **Maclaurin 级数**\n\n**定理（唯一性）**\n\n若 $f(x)$ 在 $x_0$ 可展开为幂级数，则展开式唯一，且恰为 Taylor 级数\n\n**定理**\n\n设 $f(x)$ 在 $x_0$ 的某领域 $I$ 内任意阶可导，则在 $I$ 内\n\n$$\nf(x) = \\sum_{n=0}^\\infty \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n \\Leftrightarrow \\lim_{n\\to\\infty}R_n(x) =0\n$$\n\n#### 常用的初等函数的幂级数展开式\n\n1. $\\displaystyle e^x = \\sum_{n=0}^\\infty \\frac{x^n}{n!} \\quad (x\\in\\mathbb{R})$\n2. $\\displaystyle \\sin x = \\sum_{n=0}^\\infty \\frac{(-1)^nx^{2n+1}}{(2n+1)!} \\quad (x\\in\\mathbb{R})$\n3. $\\displaystyle \\cos x = \\sum_{n=0}^\\infty \\frac{(-1)^nx^{2n}}{(2n)!} \\quad (x\\in\\mathbb{R})$\n4. $\\displaystyle \\ln(1+x) = \\sum_{n=1}^\\infty \\frac{(-1)^{n-1}x^n}{n} \\quad (\\left\\vert x \\right\\vert<1)$\n5. $\\displaystyle (1+x)^\\alpha = \\sum_{n=0}^\\infty \\frac{\\alpha(\\alpha-1)\\cdots(\\alpha-n+1)}{n!}x^n \\quad (\\left\\vert x\\right\\vert<1)$\n6. $\\displaystyle \\frac{1}{1-x} = \\sum_{n=0}^\\infty x^n \\quad (\\left\\vert x\\right\\vert<1)$\n7. $\\displaystyle \\frac{1}{1+x} = \\sum_{n=0}^\\infty (-1)^nx^n \\quad (\\left\\vert x\\right\\vert<1)$\n8. $\\displaystyle \\arctan{x} = \\sum_{n=0}^\\infty \\frac{(-1)^n x^{2n+1}}{2n+1} \\quad (\\left\\vert x\\right\\vert\\leq 1)$\n\n#### 正弦级数和余弦级数\n\n若周期为 $2\\pi$ 的函数 $f(x)$ 是奇函数时，其 Fourier 系数 $a_n=0$，从而\n\n$$\nf(x) \\sim \\sum_{n=1}^{+\\infty}b_n\\sin(nx)\\quad\\text{正弦级数}\n$$\n\n其中 $\\displaystyle b_n =\\frac{2}{\\pi}\\int_0^\\pi f(x)\\sin(nx) \\,\\mathrm{d}x$\n\n若周期为 $2\\pi$ 的函数 $f(x)$ 是偶函数，其 Fourier 系数 $b_n=0$，从而\n\n$$\nf(x) \\sim \\frac{a_0}{2}+\\sum_{n=0}^{+\\infty}a_n\\cos(nx)\\quad\\text{余弦级数}\n$$\n\n其中 $\\displaystyle a_n =\\frac{1}{\\pi}\\int_0^\\pi f(x)\\cos(nx) \\,\\mathrm{d}x$\n\n若函数 $f(x)$ 定义在 $[0,\\pi]$ 上，可作奇延拓\n\n$$\nF(x)=\n\\begin{cases}\n  f(x), & 0< x< \\pi\\\\\n  -f(-x), & -\\pi < x < 0\\\\\n  0, & x=0,\\pm\\pi\\\\\n\\end{cases}\n$$\n\n使得 $F(x)$ 为 $[-\\pi,\\pi]$ 上的奇函数\n\n也可作偶延拓\n\n$$\nG(x)=\n\\begin{cases}\n  f(x), & 0< x< \\pi\\\\\n  f(-x), & -\\pi < x < 0\\\\\n  0, & x=0,\\pm\\pi\\\\\n\\end{cases}\n$$\n\n使得函数 $G(x)$ 为 $[-\\pi,\\pi]$ 上的偶函数\n\n对于一定义在 $[0,\\pi]$ 上的函数 $f(x)$，可以对其先做奇延拓或者偶延拓，再将其展开为 正弦级数或者余弦级数\n\n#### 周期为 $2l$ 的 Fourier 级数\n\n设函数 $f(x)$ 在区间 $[-l,l]$ 上可积，作代换 $x =\\frac{l}{\\pi}t$，使得 $F(t) = f\\left(\\frac{l}{\\pi}t\\right)$ 为 $[-\\pi,\\pi]$ 上的可积函数，从而\n\n$$\nF(t) \\sim \\frac{a_0}{2}+\\sum_{n=1}^{+\\infty}a_n\\cos(nt)+\\sum_{n=1}^{+\\infty}b_n\\sin(nt)\n$$\n\n其中\n\n$$\n\\begin{aligned}\na_n &= \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}F(t)\\cos(nt)\\,\\mathrm{d}t = \\frac{1}{l}\\int_{-l}^{l}f(x)\\cos\\left(\\frac{\\pi n}{l}x\\right)\\,\\mathrm{d}x\\\\\nb_n &= \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}F(t)\\sin(nt)\\,\\mathrm{d}t = \\frac{1}{l}\\int_{-l}^{l}f(x)\\sin\\left(\\frac{\\pi n}{l}x\\right)\\,\\mathrm{d}x\n\\end{aligned}\n$$\n\n故\n\n$$\nf(x) \\sim \\frac{a_0}{2}+\\sum_{n=1}^{+\\infty}\\left(a_n\\cos\\left(\\frac{\\pi n}{l}x\\right)+b_n\\sin\\left(\\frac{\\pi n}{l}x\\right)\\right)\n$$\n\n其中\n\n$$\n\\begin{aligned}\na_n &= \\frac{1}{l}\\int_{-l}^{l}f(x)\\cos\\left(\\frac{\\pi n}{l}x\\right)\\,\\mathrm{d}x\\\\\nb_n &= \\frac{1}{l}\\int_{-l}^{l}f(x)\\sin\\left(\\frac{\\pi n}{l}x\\right)\\,\\mathrm{d}x\n\\end{aligned}\n$$\n\n**定理：**\n\n若 $f(x)$ 在 $[-l,l]$ 上满足 Dirichlet 条件，则 Fourier 级数\n\n$$\n\\frac{a_0}{2}+\\sum_{n=1}^{+\\infty}\\left(a_n\\cos\\left(\\frac{\\pi n}{l}x\\right)+b_n\\sin\\left(\\frac{\\pi n}{l}x\\right)\\right)\n$$\n\n收敛到\n\n$$\nS(n) =\n\\begin{cases}\n  f(x), & x \\text{为} f(x) \\text{的连续点}\\\\\n  \\frac{f(x^+)+f(x^-)}{2}, & x \\text{为} f(x) \\text{的间断点}\\\\\n  \\frac{f(l^-)+f(-l^+)}{2} ,& x=\\pm l\n\\end{cases}\n$$\n","slug":"高数2笔记","published":1,"date":"2025-09-11T11:36:20.597Z","updated":"2025-09-11T16:16:00.928Z","comments":1,"layout":"post","photos":[],"_id":"cmffo52nu000e6xzd6j29aa0m","content":"<h2 id=\"重积分\">重积分</h2>\n<h3 id=\"重积分的概念和性质\">重积分的概念和性质</h3>\n<h4 id=\"二重积分的概念\">二重积分的概念</h4>\n<p><strong>定义：</strong></p>\n<p>设 <span class=\"math inline\"><em>D</em></span>\n是平面上的有界闭区域，<span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 为 <span\nclass=\"math inline\"><em>D</em></span> 上的有界函数，<span\nclass=\"math inline\"><em>I</em></span> 为实数.若对 <span\nclass=\"math inline\"><em>D</em></span> 的任意分割 <span\nclass=\"math inline\"><em>Δ</em><em>D</em><sub>1</sub>, <em>Δ</em><em>D</em><sub>2</sub>, ⋯, <em>Δ</em><em>D</em><sub><em>n</em></sub></span>\n，任取 <span\nclass=\"math inline\">(<em>ξ</em><sub><em>i</em></sub>, <em>η</em><sub><em>i</em></sub>) ∈ <em>Δ</em><em>D</em><sub><em>i</em></sub>(<em>i</em> = 1, …, <em>n</em>)</span>，作和\n<span\nclass=\"math inline\">$\\displaystyle\\sum_{i=1}^nf(\\xi_i,\\eta_i)\\Delta\n\\sigma_i$</span> （<span\nclass=\"math inline\"><em>Δ</em><em>σ</em><sub><em>i</em></sub></span> 为\n<span class=\"math inline\"><em>D</em><sub><em>i</em></sub></span>\n的面积），总有</p>\n<p><span class=\"math display\">$$\n\\lim_{\\lambda\\to 0}\\sum_{i=1}^nf(\\xi_i,\\eta_i)\\Delta \\sigma_i = I\n$$</span></p>\n<p>其中 <span\nclass=\"math inline\"><em>λ</em> = max<sub>1 ≤ <em>i</em> ≤ <em>d</em></sub>{<em>d</em><sub><em>i</em></sub>}</span>，<span\nclass=\"math inline\"><em>d</em><sub><em>i</em></sub></span> 是小区域\n<span\nclass=\"math inline\"><em>Δ</em><em>D</em><sub><em>i</em></sub></span>\n的直径，则称函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在 <span\nclass=\"math inline\"><em>D</em></span> 上<strong>可积</strong>，记为\n<span\nclass=\"math inline\"><em>f</em> ∈ <em>R</em>(<em>D</em>)</span>；极限值\n<span class=\"math inline\"><em>I</em></span> 称为 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在 <span\nclass=\"math inline\"><em>D</em></span>\n上的<strong>二重积分</strong>，记作</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em>.</span></p>\n<ul>\n<li><p><span class=\"math inline\">∬</span> 积分号</p></li>\n<li><p><span class=\"math inline\"><em>D</em></span> 积分区域</p></li>\n<li><p><span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span>\n被积函数</p></li>\n<li><p><span class=\"math inline\">d<em>σ</em></span>\n面积元素（微元）</p></li>\n<li><p>二重积分的几何意义</p>\n<ul>\n<li>当被积函数大于 <span class=\"math inline\">0</span>\n时，二重积分是柱体体积</li>\n<li>当被积函数小于 <span class=\"math inline\">0</span>\n时，二重积分是柱体体积的负值</li>\n<li>一般的，为曲顶柱体体积的代数和</li>\n</ul></li>\n<li><p>可积的充分条件</p>\n<ul>\n<li><strong>定理：</strong> 若函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在区域\n<span class=\"math inline\"><em>D</em></span> 上连续，则 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>) ∈ <em>D</em></span>.</li>\n</ul></li>\n<li><p><span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在 <span\nclass=\"math inline\"><em>D</em></span> 上的可积性及积分值与其在 <span\nclass=\"math inline\"><em>D</em></span>\n内<strong>有限条光滑曲线</strong>上的定义无关</p></li>\n</ul>\n<h3 id=\"二重积分的性质\">二重积分的性质</h3>\n<ol type=\"1\">\n<li><p><span\nclass=\"math inline\">∬<sub><em>D</em></sub> d<em>σ</em> = ∬<sub><em>D</em></sub>1 d<em>σ</em> = <em>A</em><sub><em>D</em></sub>  (D\n的面积)</span>.</p></li>\n<li><p><strong>线性性：</strong> 设 <span\nclass=\"math inline\"><em>f</em>, <em>g</em> ∈ <em>R</em>(<em>D</em>)</span>，<span\nclass=\"math inline\"><em>α</em>, <em>β</em></span>，是任意常数，则 <span\nclass=\"math inline\"><em>α</em><em>f</em> + <em>β</em><em>g</em> ∈ <em>R</em>(<em>D</em>)</span>，且</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub>(<em>α</em><em>f</em> + <em>β</em><em>g</em>) d<em>σ</em> = <em>α</em>∬<sub><em>D</em></sub><em>f</em> d<em>σ</em> + <em>β</em>∬<sub><em>D</em></sub><em>g</em> d<em>σ</em></span></p></li>\n<li><p><strong>区域可加性：</strong> 若 <span\nclass=\"math inline\"><em>f</em> ∈ <em>R</em>(<em>D</em>)</span>\n且积分区域 <span class=\"math inline\"><em>D</em></span>\n分为内部不相交的子区域 <span\nclass=\"math inline\"><em>D</em><sub>1</sub>, <em>D</em><sub>2</sub></span>，则</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> = ∬<sub><em>D</em><sub>1</sub></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> + ∬<sub><em>D</em><sub>2</sub></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em></span></p></li>\n<li><p><strong>保序性：</strong> 若 <span\nclass=\"math inline\"><em>f</em>, <em>g</em> ∈ <em>R</em>(<em>D</em>)</span>，且当\n<span class=\"math inline\">(<em>x</em>, <em>y</em>) ∈ <em>D</em></span>\n时，<span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>) ≤ <em>g</em>(<em>x</em>, <em>y</em>)</span>，则</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> ≤ ∬<sub><em>D</em></sub><em>g</em>(<em>x</em>, <em>y</em>) d<em>σ</em></span></p>\n<ul>\n<li><strong>推论 1：</strong> 若 <span\nclass=\"math inline\"><em>f</em> ∈ <em>R</em>(<em>D</em>)</span> ,则 <span\nclass=\"math inline\">|<em>f</em>(<em>x</em>, <em>y</em>)| ∈ <em>R</em>(<em>D</em>)</span>，且</li>\n</ul>\n<p><span\nclass=\"math display\">|∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em>| ≤ ∬<sub><em>D</em></sub>|<em>f</em>(<em>x</em>, <em>y</em>)| d<em>σ</em></span></p>\n<ul>\n<li><strong>推论 2：</strong> 若 <span\nclass=\"math inline\"><em>f</em> ∈ <em>R</em>(<em>D</em>)</span>，且当\n<span class=\"math inline\">(<em>x</em>, <em>y</em>) ∈ <em>D</em></span>\n时， <span\nclass=\"math inline\"><em>m</em> ≤ <em>f</em>(<em>x</em>, <em>y</em>) ≤ <em>M</em></span>，则</li>\n</ul>\n<p><span\nclass=\"math display\"><em>m</em><em>A</em><sub><em>D</em></sub> ≤ ∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> ≤ <em>M</em><em>A</em><sub><em>D</em></sub></span></p>\n<ul>\n<li><strong>推论 3：</strong> 若 <span\nclass=\"math inline\"><em>f</em> ∈ <em>R</em>(<em>D</em>)</span>，且当\n<span class=\"math inline\">(<em>x</em>, <em>y</em>) ∈ <em>D</em></span>\n时，<span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>) ≥ 0</span>，则</li>\n</ul>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> ≥ 0</span></p></li>\n<li><p><strong>积分中值定理：</strong> 若 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>) ∈ <em>C</em>(<em>D</em>)</span>\n，<span\nclass=\"math inline\"><em>g</em>(<em>x</em>, <em>y</em>) ∈ <em>R</em>(<em>D</em>)</span>，且\n<span class=\"math inline\"><em>g</em></span> 在 <span\nclass=\"math inline\"><em>D</em></span> 上不变号，则 <span\nclass=\"math inline\">∃<em>ξ</em>, <em>η</em> ∈ <em>D</em></span>，使得</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>)<em>g</em>(<em>x</em>, <em>y</em>) d<em>σ</em> = <em>f</em>(<em>ξ</em>, <em>η</em>)∬<sub><em>D</em></sub><em>g</em>(<em>x</em>, <em>y</em>) d<em>σ</em></span></p>\n<ul>\n<li><strong>推论：</strong> 若 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>) ∈ <em>C</em>(<em>D</em>)</span>，则存在\n<span\nclass=\"math inline\">(<em>ξ</em>, <em>η</em>) ∈ <em>D</em></span>，使得</li>\n</ul>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> = <em>f</em>(<em>ξ</em>, <em>η</em>)<em>A</em><sub><em>D</em></sub></span></p>\n<p>称 <span class=\"math inline\">$f(\\xi,\\eta) = \\frac{\\iint_D\nf\\,\\mathrm{d}\\sigma}{A_D}$</span> 为函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span>\n在有界闭区域 <span class=\"math inline\"><em>D</em></span>\n上的<strong>平均值</strong></p></li>\n</ol>\n<h3 id=\"二重积分的计算\">二重积分的计算</h3>\n<h4 id=\"直角坐标系下的计算\">直角坐标系下的计算</h4>\n<p>当二重积分存在时，可利用平行于坐标轴的直线来划分积分区域 <span\nclass=\"math inline\"><em>D</em></span>，此时，面积元素</p>\n<p><span\nclass=\"math display\">d<em>σ</em> = d<em>x</em>d<em>y</em></span></p>\n<p>故二重积分在直角坐标系下可表示为</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> = ∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>x</em>d<em>y</em></span></p>\n<h5 id=\"x-型正则区域\"><span class=\"math inline\"><em>x</em></span>\n型正则区域</h5>\n<p><span\nclass=\"math display\"><em>D</em> = {(<em>x</em>, <em>y</em>)|<em>φ</em><sub>1</sub>(<em>x</em>) ≤ <em>y</em> ≤ <em>φ</em><sub>2</sub>(<em>x</em>), <em>a</em> ≤ <em>x</em> ≤ <em>b</em>}</span></p>\n<p>化为先 <span class=\"math inline\"><em>y</em></span> 后 <span\nclass=\"math inline\"><em>x</em></span> 的二次积分</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n    \\iint_D f(x,y)\\,\\mathrm{d}x\\mathrm{d}y &amp;=\n\\int_a^b\\left[\\int_{\\varphi_1(x)}^{\\varphi_2(x)}\nf(x,y)\\,\\mathrm{d}y\\right]\\mathrm{d}x \\\\\n    &amp;\\equiv \\int_a^b f(x,y)\\,\\mathrm{d}x\\mathrm{d}y\n\\end{aligned}\n$$</span></p>\n<h5 id=\"y-型正则区域\"><span class=\"math inline\"><em>y</em></span>\n型正则区域</h5>\n<p><span\nclass=\"math display\"><em>D</em> = {(<em>x</em>, <em>y</em>)|<em>φ</em><sub>1</sub>(<em>y</em>) ≤ <em>x</em> ≤ <em>φ</em><sub>2</sub>(<em>y</em>), <em>c</em> ≤ <em>y</em> ≤ <em>d</em>}</span></p>\n<p>化为先 <span class=\"math inline\"><em>x</em></span> 后 <span\nclass=\"math inline\"><em>y</em></span> 的二次积分</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n    \\iint_D f(x,y)\\,\\mathrm{d}x\\mathrm{d}y &amp;=\n\\int_c^d\\left[\\int_{\\varphi_1(y)}^{\\varphi_2(y)}\nf(x,y)\\,\\mathrm{d}x\\right]\\mathrm{d}y \\\\\n    &amp;\\equiv \\int_c^d f(x,y)\\,\\mathrm{d}x\\mathrm{d}y\n\\end{aligned}\n$$</span></p>\n<h5 id=\"一般区域的二重积分\">一般区域的二重积分</h5>\n<p>分割成若干个正则子区域，利用积分区域可加性，分别在子区域上积分后求和</p>\n<blockquote>\n<p>直角坐标计算二重积分的步骤</p>\n<ol type=\"1\">\n<li><strong>画出积分区域</strong> <span\nclass=\"math inline\"><em>D</em></span>\n的草图，并<strong>确定类型</strong></li>\n<li>按照所确定的类型<strong>表示区域</strong> <span\nclass=\"math inline\"><em>D</em></span></li>\n<li><strong>化二重积分为二次积分</strong>（注意上下限）</li>\n<li><strong>计算</strong>二重积分</li>\n</ol>\n</blockquote>\n<h4 id=\"极坐标系下的计算\">极坐标系下的计算</h4>\n<p>当积分区域的边界曲线或被积函数用极坐标表示较为简单时，可用极坐标来计算二重积分.</p>\n<p>面积元素 <span class=\"math inline\"><em>Δ</em><em>σ</em></span>\n在极坐标下为</p>\n<p><span class=\"math display\">$$\n\\boxed{\\Delta\\sigma= r\\mathrm{d}r\\mathrm{d}\\theta}\n$$</span></p>\n<p>从直角坐标到极坐标时的二重积分变换公式为</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> = ∬<sub><em>D</em></sub><em>f</em>(<em>r</em>cos <em>θ</em>, <em>r</em>sin <em>θ</em>)<em>r</em> d<em>r</em>d<em>θ</em></span></p>\n<p><span\nclass=\"math display\">{(<em>r</em>, <em>θ</em>)|<em>r</em><sub>1</sub>(<em>θ</em>) ≤ <em>r</em> ≤ <em>r</em><sub>2</sub>(<em>θ</em>), <em>α</em> ≤ <em>θ</em> ≤ <em>β</em>}</span></p>\n<p>则</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> = ∫<sub><em>α</em></sub><sup><em>β</em></sup> d<em>θ</em>∫<sub><em>r</em><sub>1</sub>(<em>θ</em>)</sub><sup><em>r</em><sub>2</sub>(<em>θ</em>)</sup><em>f</em>(<em>r</em>cos <em>θ</em>, <em>r</em>sin <em>θ</em>)<em>r</em> d<em>r</em></span></p>\n<h4 id=\"二重积分的变量代换\">二重积分的变量代换</h4>\n<p><strong>定理：</strong></p>\n<p>设变换 <span class=\"math inline\">$\\displaystyle T\n:\\begin{cases}x=x(u,v)\\\\y=y(u,v)\\end{cases}$</span> 有连续偏导数，且满足\n<span class=\"math inline\">$\\displaystyle J = \\frac{\\partial\n(x,y)}{\\partial (u,v)}\\coloneqq \\begin{vmatrix}x_u ,x_v\\newline\ny_u,y_v\\end{vmatrix} \\left(\\text{Jacobi 行列式}\\right)\\neq 0$</span>，而\n<span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>) ∈ <em>C</em>(<em>D</em>)</span>，则</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> = ∬<sub><em>D</em><sup>*</sup></sub><em>f</em>(<em>x</em>(<em>u</em>, <em>v</em>), <em>y</em>(<em>u</em>, <em>v</em>))|<em>J</em>| d<em>u</em>d<em>v</em></span></p>\n<ul>\n<li><p>在定理条件下，变换 <span class=\"math inline\"><em>T</em></span>\n一定存在逆变换 <span\nclass=\"math inline\">$T^{-1}:\\begin{cases}u=u(x,y)\\\\v=v(x,y)\\end{cases}$</span>，且\n<span class=\"math inline\">$\\frac{\\partial (u,v)}{\\partial (x,y)}\\cdot\n\\frac{\\partial (x,y)}{\\partial (u,v)} = 1$</span></p>\n<p>有时，借助此式求 <span class=\"math inline\"><em>J</em></span>\n较为简单</p></li>\n<li><p>当 Jacobi 行列式仅在区域 <span\nclass=\"math inline\"><em>D</em><sup>*</sup></span>\n内个别点上或个别曲线上为 <span class=\"math inline\">0</span>\n时，定理结论仍成立</p></li>\n<li><p>在广义极坐标 <span\nclass=\"math inline\">$\\begin{cases}x=ar\\cos\\theta\\\\y=br\\sin\\theta\\end{cases}$</span>\n下，<span\nclass=\"math inline\"><em>J</em> = <em>a</em><em>b</em><em>r</em></span></p></li>\n</ul>\n<h3 id=\"三重积分\">三重积分</h3>\n<h4 id=\"三重积分的定义\">三重积分的定义</h4>\n<p><strong>定义：</strong></p>\n<p>设 <span class=\"math inline\"><em>Ω</em></span> 是 <span\nclass=\"math inline\">ℝ<sup>3</sup></span> 中的有界闭区域，三元函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>\n在 <span class=\"math inline\"><em>Ω</em></span> 上有界，<span\nclass=\"math inline\"><em>I</em></span> 为实数. 若将 <span\nclass=\"math inline\"><em>Ω</em></span> 任意分割成 <span\nclass=\"math inline\"><em>n</em></span> 个小区域 <span\nclass=\"math inline\"><em>Δ</em><em>Ω</em><sub>1</sub>, <em>Δ</em><em>Ω</em><sub>2</sub>, …, <em>Δ</em><em>Ω</em><sub><em>n</em></sub></span>，任取\n<span class=\"math inline\">$\\left(\\varepsilon_i,\\eta_i,\\xi_i\n\\right)\\in\\Delta\\Omega_i\\left(i=1,2,\\ldotp,n\\right)$</span>，作和 <span\nclass=\"math inline\">$\\displaystyle\\sum_{i=1}^nf\\left(\\varepsilon_i,\\eta_i,\\xi_i\n\\right)\\Delta V_i$</span>，（<span\nclass=\"math inline\"><em>Δ</em><em>V</em><sub><em>i</em></sub></span> 是\n<span\nclass=\"math inline\"><em>Δ</em><em>Ω</em><sub><em>i</em></sub></span>\n的体积），总有</p>\n<p><span class=\"math display\">$$\n\\lim_{\\lambda\\to 0}\\sum_{i=1}^nf\\left(\\varepsilon_i,\\eta_i,\\xi_i\n\\right)\\Delta V_i = I\n$$</span></p>\n<p>其中 <span\nclass=\"math inline\"><em>λ</em> = max<sub>1 ≤ <em>i</em> ≤ <em>n</em></sub>{<em>d</em><sub><em>i</em></sub>}</span>，<span\nclass=\"math inline\"><em>d</em><sub><em>i</em></sub></span> 是 <span\nclass=\"math inline\"><em>Δ</em><em>Ω</em><sub><em>i</em></sub></span>\n的直径，则称函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>\n在 <span class=\"math inline\"><em>Ω</em></span>\n上<strong>可积</strong>，记为 <span\nclass=\"math inline\"><em>f</em> ∈ <em>R</em>(<em>Ω</em>)</span>； <span\nclass=\"math inline\"><em>I</em></span> 称为 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>\n在 <span class=\"math inline\"><em>Ω</em></span>\n上的<strong>三重积分</strong>，记作</p>\n<p><span\nclass=\"math display\">∭<sub><em>Ω</em></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>V</em></span></p>\n<p>其中 <span class=\"math inline\"><em>V</em><sub><em>Ω</em></sub></span>\n是区域 <span class=\"math inline\"><em>Ω</em></span> 的体积</p>\n<ul>\n<li>若 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>\n表示占有三维空间区域 <span class=\"math inline\"><em>Ω</em></span>\n的物体的体密度函数，则 <span\nclass=\"math inline\">∭<sub><em>Ω</em></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>V</em></span>\n给出了物体的<strong>质量</strong></li>\n<li>类似二重积分，三重积分具有线性性，区域可加性，保序性以及推论和积分中值定理，并且有\n<span\nclass=\"math inline\">∭<sub><em>Ω</em></sub> d<em>V</em> = <em>V</em><sub><em>Ω</em></sub></span></li>\n</ul>\n<h4 id=\"直角坐标系下的计算-1\">直角坐标系下的计算</h4>\n<p>直角坐标系下，由于 <span\nclass=\"math inline\">d<em>V</em> = d<em>x</em>d<em>y</em>d<em>z</em></span>，故</p>\n<p><span\nclass=\"math display\">∭<sub><em>Ω</em></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>V</em> = ∭<sub><em>Ω</em></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>x</em>d<em>y</em>d<em>z</em></span></p>\n<h5 id=\"柱线法坐标面投影法\">柱线法（坐标面投影法）</h5>\n<p>设 <span class=\"math inline\"><em>Ω</em></span> 是以曲面 <span\nclass=\"math inline\"><em>z</em> = <em>z</em><sub>1</sub>(<em>x</em>, <em>y</em>)</span>\n为底，曲面 <span\nclass=\"math inline\"><em>x</em> = <em>x</em><sub>2</sub>(<em>x</em>, <em>y</em>)</span>，而侧面是母线平行于\n<span class=\"math inline\"><em>z</em></span> 轴的柱体所围成的区域</p>\n<p>设 <span class=\"math inline\"><em>Ω</em></span> 在 <span\nclass=\"math inline\"><em>x</em><em>O</em><em>y</em></span>\n面上的投影区域为 <span class=\"math inline\"><em>D</em><sub>1</sub></span>\n，则 <span class=\"math inline\"><em>Ω</em></span> 可表示为</p>\n<p><span\nclass=\"math display\"><em>Ω</em> = {(<em>x</em>, <em>y</em>, <em>z</em>)|(<em>x</em>, <em>y</em>) ∈ <em>D</em><sub>1</sub>, <em>z</em><sub>1</sub>(<em>x</em>, <em>y</em>) ≤ <em>z</em> ≤ <em>z</em><sub>2</sub>(<em>x</em>, <em>y</em>)(<em>x</em>, <em>y</em>) ∈ <em>D</em>}</span></p>\n<p>则物体总质量为</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub>(∫<sub><em>z</em><sub>1</sub>(<em>x</em>, <em>y</em>)</sub><sup><em>z</em><sub>2</sub>(<em>x</em>, <em>y</em>)</sup><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>z</em>) d<em>x</em>d<em>y</em></span></p>\n<p>故有</p>\n<p><span\nclass=\"math display\">∭<sub><em>Ω</em></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>V</em> = ∬<sub><em>D</em><sub>1</sub></sub> d<em>x</em>d<em>y</em>∫<sub><em>z</em><sub>1</sub>(<em>x</em>, <em>y</em>)</sub><sup><em>z</em><sub>2</sub>(<em>x</em>, <em>y</em>)</sup><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>z</em></span></p>\n<h5 id=\"截面法坐标轴投影法\">截面法（坐标轴投影法）</h5>\n<p>设区域 <span class=\"math inline\"><em>Ω</em></span> 在 <span\nclass=\"math inline\"><em>z</em></span> 轴上的投影区间为 <span\nclass=\"math inline\">[<em>h</em><sub>1</sub>, <em>h</em><sub>2</sub>]</span>，即\n<span class=\"math inline\"><em>Ω</em></span> 介于平面 <span\nclass=\"math inline\"><em>z</em> = <em>h</em><sub>1</sub></span> 和 <span\nclass=\"math inline\"><em>z</em> = <em>h</em><sub>2</sub></span> 之间，过\n<span class=\"math inline\"><em>z</em></span> 处且垂直于 <span\nclass=\"math inline\"><em>z</em></span> 轴的平面截 <span\nclass=\"math inline\"><em>Ω</em></span> 得截面区域 <span\nclass=\"math inline\"><em>D</em><sub><em>z</em></sub></span>，则 <span\nclass=\"math inline\"><em>Ω</em></span> 可表示为</p>\n<p><span\nclass=\"math display\"><em>Ω</em> = {(<em>x</em>, <em>y</em>, <em>z</em>)|<em>h</em><sub>1</sub> ≤ <em>z</em> ≤ <em>h</em><sub>2</sub>, (<em>x</em>, <em>y</em>) ∈ <em>D</em><sub><em>z</em></sub>}</span></p>\n<p>物体总质量为</p>\n<p><span\nclass=\"math display\">∫<sub><em>h</em><sub>1</sub></sub><sup><em>h</em><sub>2</sub></sup>(∬<sub><em>D</em><sub><em>z</em></sub></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>x</em>d<em>y</em>) d<em>z</em></span></p>\n<p>故有</p>\n<p><span\nclass=\"math display\">∭<sub><em>Ω</em></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>V</em> = ∫<sub><em>h</em><sub>1</sub></sub><sup><em>h</em><sub>2</sub></sup> d<em>z</em>∬<sub><em>D</em><sub><em>z</em></sub></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>x</em>d<em>y</em></span></p>\n<h4 id=\"三重积分的变量代换\">三重积分的变量代换</h4>\n<p><strong>定理：</strong></p>\n<p>设变换 <span\nclass=\"math inline\">$T:\\begin{cases}x=x(u,v,w)\\\\y=y(u,v,w)\\\\z=z(u,v,w)\\end{cases}$</span>\n有连续偏导数，且满足 <span class=\"math inline\">$J=\\frac{\\partial\n(x,y,z)}{\\partial (u,v,w)}\\neq 0$</span>，而 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) ∈ <em>C</em>(<em>Ω</em>)</span>，则</p>\n<p><span\nclass=\"math display\">∭<sub><em>Ω</em></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>V</em> = ∭<sub><em>Ω</em><sup>*</sup></sub><em>f</em>(<em>x</em>(<em>u</em>, <em>v</em>, <em>w</em>), <em>y</em>(<em>u</em>, <em>v</em>, <em>w</em>), <em>z</em>(<em>u</em>, <em>v</em>, <em>w</em>))|<em>J</em>| d<em>u</em>d<em>v</em>d<em>w</em></span></p>\n<h5 id=\"柱面坐标系下的计算\">柱面坐标系下的计算</h5>\n<p>柱面坐标系，实际上就是将 <span\nclass=\"math inline\"><em>x</em>, <em>y</em></span> 坐标转换为极坐标</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\nx = r\\cos\\theta\\\\\ny = r\\sin\\theta\\\\\nz = z\n\\end{cases}\n$$</span></p>\n<p>其 Jacobi 行列式为</p>\n<p><span class=\"math display\">$$\nJ = \\frac{\\partial (x,y,z)}{\\partial (r,\\theta,z)} = \\begin{vmatrix}\n\\cos\\theta &amp; -r\\sin\\theta &amp; 0\\\\\n\\sin\\theta &amp; r\\cos\\theta &amp; 0\\\\\n0 &amp; 0 &amp; 1\n\\end{vmatrix} = r\n$$</span></p>\n<p>则柱面积分积分公式为</p>\n<p><span\nclass=\"math display\">∭<sub><em>Ω</em></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>V</em> = ∭<sub><em>Ω</em><sup>*</sup></sub><em>f</em>(<em>r</em>cos <em>θ</em>, <em>r</em>sin <em>θ</em>, <em>z</em>)<em>r</em> d<em>r</em>d<em>θ</em>d<em>z</em></span></p>\n<h5 id=\"球面坐标系下的计算\">球面坐标系下的计算</h5>\n<p>球面坐标系，实际上就是将 <span\nclass=\"math inline\"><em>x</em>, <em>y</em>, <em>z</em></span>\n坐标转换为球坐标</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\nx = \\rho\\sin\\varphi\\cos\\theta\\\\\ny = \\rho\\sin\\varphi\\sin\\theta\\\\\nz = \\rho\\cos\\varphi\n\\end{cases}\n$$</span></p>\n<p>其 Jacobi 行列式为</p>\n<p><span class=\"math display\">$$\nJ = \\frac{\\partial (x,y,z)}{\\partial (\\rho,\\varphi,\\theta)} =\n\\begin{vmatrix}\n\\sin\\varphi\\cos\\theta &amp; \\rho\\cos\\varphi\\cos\\theta &amp;\n-\\rho\\sin\\varphi\\sin\\theta\\\\\n\\sin\\varphi\\sin\\theta &amp; \\rho\\cos\\varphi\\sin\\theta &amp;\n\\rho\\sin\\varphi\\cos\\theta\\\\\n\\cos\\varphi &amp; -\\rho\\sin\\varphi &amp; 0\n\\end{vmatrix} = \\rho^2\\sin\\varphi\n$$</span></p>\n<p>则球面积分积分公式为</p>\n<p><span\nclass=\"math display\">∭<sub><em>Ω</em></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>V</em> = ∭<sub><em>Ω</em><sup>*</sup></sub><em>f</em>(<em>ρ</em>sin <em>φ</em>cos <em>θ</em>, <em>ρ</em>sin <em>φ</em>sin <em>θ</em>, <em>ρ</em>cos <em>φ</em>)<em>ρ</em><sup>2</sup>sin <em>φ</em> d<em>ρ</em>d<em>φ</em>d<em>θ</em></span></p>\n<h3 id=\"重积分的应用\">重积分的应用</h3>\n<h4 id=\"重积分的几何应用\">重积分的几何应用</h4>\n<h5 id=\"平面图形的面积\">平面图形的面积</h5>\n<p><span\nclass=\"math display\"><em>A</em>(<em>D</em>) = ∬<sub><em>D</em></sub> d<em>σ</em> = ∬<sub><em>D</em></sub> d<em>x</em>d<em>y</em></span></p>\n<h5 id=\"立体的体积\">立体的体积</h5>\n<p><span\nclass=\"math display\"><em>V</em>(<em>Ω</em>) = ∭<sub><em>Ω</em></sub> d<em>V</em> = ∭<sub><em>Ω</em></sub> d<em>x</em>d<em>y</em>d<em>z</em></span></p>\n<h5 id=\"曲面的面积\">曲面的面积</h5>\n<p>设空间曲面 <span\nclass=\"math inline\"><em>S</em> : <em>z</em> = <em>f</em>(<em>x</em>, <em>y</em>), (<em>x</em>, <em>y</em>) ∈ <em>D</em></span>.</p>\n<p>则曲面 <span class=\"math inline\"><em>S</em></span> 的面积为</p>\n<p><span class=\"math display\">$$\nA(S) = \\iint_D \\sqrt{1+z_x^2+z_y^2}\\,\\mathrm{d}x\\mathrm{d}y\n$$</span></p>\n<h4 id=\"重积分的物理应用\">重积分的物理应用</h4>\n<h6 id=\"质心\">质心</h6>\n<p>体密度为 <span\nclass=\"math inline\"><em>ρ</em>(<em>x</em>, <em>y</em>)</span>\n的物体占据空间 <span\nclass=\"math inline\"><em>Ω</em></span>，其质心坐标为</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\displaystyle\\bar{x} = \\frac{\\iiint_\\Omega\nx\\rho(x,y,z)\\,\\mathrm{d}V}{\\iiint_\\Omega\\mu(x,y,z)\\,\\mathrm{d}V} \\\\\n  \\displaystyle\\bar{y} = \\frac{\\iiint_\\Omega\ny\\rho(x,y,z)\\,\\mathrm{d}V}{\\iiint_\\Omega\\mu(x,y,z)\\,\\mathrm{d}V}\\\\\n  \\displaystyle\\bar{z} = \\frac{\\iiint_\\Omega\nz\\rho(x,y,z)\\,\\mathrm{d}V}{\\iiint_\\Omega\\mu(x,y,z)\\,\\mathrm{d}V}\n\\end{cases}\n$$</span></p>\n<h5 id=\"转动惯量\">转动惯量</h5>\n<p>设物体的密度为 <span\nclass=\"math inline\"><em>ρ</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>，则物体分别关于\n<span class=\"math inline\"><em>x</em></span>，<span\nclass=\"math inline\"><em>y</em></span>，<span\nclass=\"math inline\"><em>z</em></span> 轴的转动惯量为</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  I_x = \\iiint_\\Omega \\rho(x,y,z)(y^2+z^2)\\,\\mathrm{d}V\\\\\n  I_y = \\iiint_\\Omega \\rho(x,y,z)(x^2+z^2)\\,\\mathrm{d}V\\\\\n  I_z = \\iiint_\\Omega \\rho(x,y,z)(x^2+y^2)\\,\\mathrm{d}V\n\\end{cases}\n$$</span></p>\n<h5 id=\"引力\">引力</h5>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  &amp;\\mathrm{d}\\vec{F} = G\\frac{m_0\\mathrm{d}m}{r^3}\\vec{r}\\\\\n  =&amp;\nG\\frac{m_0\\rho(x,y,z)\\mathrm{d}V}{r^3}\\cdot\\left(x-x_0,y-y_0,z-z_0\\right)\\\\\n  =&amp;\\left(\\mathrm{d}F_x,\\mathrm{d}F_y,\\mathrm{d}F_z\\right)\n\\end{aligned}\n$$</span></p>\n<h2 id=\"曲线积分和曲面积分\">曲线积分和曲面积分</h2>\n<h3 id=\"第一类曲线积分和曲面积分\">第一类曲线积分和曲面积分</h3>\n<h4 id=\"第一类曲线积分的概念\">第一类曲线积分的概念</h4>\n<p><strong>定义：</strong></p>\n<p>设 <span class=\"math inline\"><em>C</em></span> 是 <span\nclass=\"math inline\"><em>x</em><em>O</em><em>y</em></span>\n面上的一条光滑曲线弧，函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 是定义在\n<span class=\"math inline\"><em>C</em></span> 上的有界函数，在 <span\nclass=\"math inline\"><em>C</em></span> 上任意插入分点 <span\nclass=\"math inline\"><em>A</em> = <em>A</em><sub>0</sub>, <em>A</em><sub>1</sub>, …, <em>A</em><sub><em>n</em> − 1</sub>, <em>A</em><sub><em>n</em></sub> = <em>B</em></span>，将其分成\n<span class=\"math inline\"><em>n</em></span> 个小弧段，记第 <span\nclass=\"math inline\"><em>i</em></span> 个小弧段的弧长为 <span\nclass=\"math inline\"><em>Δ</em><em>s</em><sub><em>i</em></sub></span>，在第\n<span class=\"math inline\"><em>i</em></span> 个小段上任取点 <span\nclass=\"math inline\">(<em>ϵ</em><sub><em>i</em></sub>, <em>η</em><sub><em>i</em></sub>)</span>，和式\n<span\nclass=\"math inline\">$\\displaystyle\\sum_{i=1}^{+\\infty}f(\\epsilon_i,\\eta_i)\\Delta\ns_i$</span>，当 <span\nclass=\"math inline\"><em>λ</em> = max<sub>1 ≤ <em>i</em> ≤ <em>n</em></sub>{<em>Δ</em><em>s</em><sub><em>i</em></sub>} → 0</span>\n时，有确定的极限值 <span class=\"math inline\"><em>I</em></span>，即</p>\n<p><span class=\"math display\">$$\n\\lim_{\\lambda\\to 0}\\sum_{i=1}^nf(\\epsilon_i,\\eta_i)\\Delta s_i = I\n$$</span></p>\n<p>则称函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在曲线\n<span class=\"math inline\"><em>C</em></span>\n上<strong>可积</strong>，并将此极限值 <span\nclass=\"math inline\"><em>I</em></span> 称为函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在曲线\n<span class=\"math inline\"><em>C</em></span>\n上的<strong>第一类曲线积分</strong>，记作 <span\nclass=\"math inline\">∫<sub><em>C</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>s</em></span>，即</p>\n<p><span class=\"math display\">$$\nI = \\int_C f(x,y)\\,\\mathrm{d}s = \\lim_{\\lambda\\to\n0}\\sum_{i=1}^nf(\\epsilon_i,\\eta_i)\\Delta s_i\n$$</span></p>\n<ul>\n<li>第一类曲线积分的几何含义为柱面的面积</li>\n<li><span\nclass=\"math inline\">∫<sub><em>C</em></sub> d<em>s</em> = ∫<sub><em>c</em></sub>1 d<em>s</em> = <em>s</em><sub><em>C</em></sub></span></li>\n<li>若 <span class=\"math inline\"><em>C</em></span> 是封闭曲线，即 <span\nclass=\"math inline\"><em>C</em></span> 的二端点重合，则记第一类曲线积分为\n<span\nclass=\"math inline\">∮<sub><em>C</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>s</em></span></li>\n</ul>\n<h4 id=\"第一类曲线积分的性质\">第一类曲线积分的性质</h4>\n<h5 id=\"与曲线方向无关\">与曲线方向无关</h5>\n<p>若曲线 <span class=\"math inline\"><em>C</em></span> 的端点为 <span\nclass=\"math inline\"><em>A</em></span> 和 <span\nclass=\"math inline\"><em>B</em></span>，<span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在曲线\n<span class=\"math inline\"><em>C</em></span> 上可积，则</p>\n<p><span class=\"math display\">$$\n\\int_{\\widehat{AB}} f(x,y)\\,\\mathrm{d}s=\\oint_{\\widehat{BA}}\nf(x,y)\\,\\mathrm{d}s\n$$</span></p>\n<h5 id=\"线性性\">线性性</h5>\n<p>若 <span class=\"math inline\"><em>f</em>, <em>g</em></span> 在曲线\n<span class=\"math inline\"><em>C</em></span> 上可积，<span\nclass=\"math inline\"><em>α</em>, <em>β</em></span> 是任意常数，则 <span\nclass=\"math inline\"><em>α</em><em>f</em> + <em>β</em><em>g</em></span>\n在曲线 <span class=\"math inline\"><em>C</em></span> 上可积，且</p>\n<p><span\nclass=\"math display\">∫<sub><em>C</em></sub>(<em>α</em><em>f</em> + <em>β</em><em>g</em>) d<em>s</em> = <em>α</em>∫<sub><em>C</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>s</em> + <em>β</em>∫<sub><em>C</em></sub><em>g</em>(<em>x</em>, <em>y</em>) d<em>s</em></span></p>\n<h5 id=\"路径可加性\">路径可加性</h5>\n<p>若曲线 <span class=\"math inline\"><em>C</em></span> 由两段光滑曲线\n<span class=\"math inline\"><em>C</em><sub>1</sub></span> 和 <span\nclass=\"math inline\"><em>C</em><sub>2</sub></span> 首尾连接而成，则 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在曲线\n<span class=\"math inline\"><em>C</em></span> 上可积，等价于 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在曲线\n<span class=\"math inline\"><em>C</em><sub>1</sub></span> 和 <span\nclass=\"math inline\"><em>C</em><sub>2</sub></span> 上均可积，且</p>\n<p><span\nclass=\"math display\">∫<sub><em>C</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>s</em> = ∫<sub><em>C</em><sub>1</sub></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>s</em> + ∫<sub><em>C</em><sub>2</sub></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>s</em></span></p>\n<h5 id=\"中值定理\">中值定理</h5>\n<p>设函数 <span class=\"math inline\"><em>f</em></span> 在光滑曲线 <span\nclass=\"math inline\"><em>C</em></span> 上连续，则 <span\nclass=\"math inline\">∃(<em>ϵ</em>, <em>η</em>) ∈ <em>C</em></span>，使得</p>\n<p><span\nclass=\"math display\">∫<sub><em>C</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>s</em> = <em>f</em>(<em>ϵ</em>, <em>η</em>) ⋅ <em>s</em><sub><em>C</em></sub></span></p>\n<p>其中 <span class=\"math inline\"><em>s</em><sub><em>C</em></sub></span>\n是曲线段 <span class=\"math inline\"><em>C</em></span> 的长度</p>\n<h4 id=\"第一类曲线积分的计算\">第一类曲线积分的计算</h4>\n<p>设函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在光滑曲线\n<span class=\"math inline\"><em>C</em></span> 上连续，<span\nclass=\"math inline\"><em>C</em></span> 的参数方程为 <span\nclass=\"math inline\">$\\begin{cases}x=x(t)\\\\y=y(t)\\end{cases}$</span>，<span\nclass=\"math inline\"><em>t</em> ∈ [<em>a</em>, <em>b</em>]</span>，满足\n<span\nclass=\"math inline\"><em>x</em><sup>′</sup>(<em>t</em>)</span>，<span\nclass=\"math inline\"><em>y</em><sup>′</sup>(<em>t</em>)</span> 连续，且\n<span\nclass=\"math inline\"><em>x</em><sup>′</sup>(<em>t</em>)<sup>2</sup> + <em>y</em><sup>′</sup>(<em>t</em>)<sup>2</sup> ≠ 0</span>，则</p>\n<p><span class=\"math display\">$$\n\\int_C f(x,y)\\,\\mathrm{d}s = \\int_\\alpha^\\beta f(x(t),y(t))\\sqrt{x'(t)^2\n+ y'(t)^2}\\,\\mathrm{d}t\n$$</span></p>\n<ul>\n<li>右端积分限应 <span\nclass=\"math inline\"><em>α</em> &lt; <em>β</em></span></li>\n<li>当曲线 <span class=\"math inline\"><em>C</em></span> 形式为 <span\nclass=\"math inline\"><em>y</em> = <em>y</em>(<em>x</em>)</span>，<span\nclass=\"math inline\"><em>x</em> ∈ [<em>a</em>, <em>b</em>]</span> 时，则\n<span class=\"math inline\">$\\displaystyle\\int_Cf(x,y)\\,\\mathrm{d}s\n=\\int_a^bf(x,y(x))\\sqrt{1+y'^2(x)}\\,\\mathrm{d}x$</span></li>\n<li>当曲线 <span class=\"math inline\"><em>C</em></span> 为极坐标 <span\nclass=\"math inline\"><em>r</em> = <em>r</em>(<em>θ</em>)</span>，<span\nclass=\"math inline\"><em>θ</em> ∈ [<em>α</em>, <em>β</em>]</span> 时，则\n<span class=\"math inline\">$\\displaystyle\\int_Cf(x,y)\\,\\mathrm{d}s =\n\\int_\\alpha^\\beta\nf(r(\\theta)\\cos\\theta,r(\\theta)\\sin\\theta)\\sqrt{r(\\theta)^2+r'^2(\\theta)}\\,\\mathrm{d}\\theta$</span></li>\n</ul>\n<h3 id=\"第二类曲线积分与曲面积分\">第二类曲线积分与曲面积分</h3>\n<h4 id=\"第二类曲线积分的概念\">第二类曲线积分的概念</h4>\n<p><strong>定义：</strong></p>\n<p>设 <span class=\"math inline\"><em>C</em></span>\n为平面光滑定向曲线(<span\nclass=\"math inline\"><em>A</em> → <em>B</em></span>)，且向量值函数 <span\nclass=\"math inline\"><em>F⃗</em>(<em>x</em>, <em>y</em>) = <em>R</em>(<em>x</em>, <em>y</em>)<em>i⃗</em> + <em>Q</em>(<em>x</em>, <em>y</em>)<em>j⃗</em></span>\n在 <span class=\"math inline\"><em>C</em></span> 上有界，<span\nclass=\"math inline\"><em>e⃗</em><sub><em>τ</em></sub></span> 为 <span\nclass=\"math inline\"><em>C</em></span> 上点 <span\nclass=\"math inline\">(<em>x</em>, <em>y</em>)</span>\n处于定向一致的单位切向量，若</p>\n<p><span\nclass=\"math display\">∫<sub><em>C</em></sub><em>F⃗</em>(<em>x</em>, <em>y</em>) ⋅ <em>e⃗</em><sub><em>τ</em></sub> d<em>s</em></span></p>\n<p>存在，则称为<strong>向量值函数 <span\nclass=\"math inline\"><em>F⃗</em></span> 在定向曲线 <span\nclass=\"math inline\"><em>C</em></span>\n上的曲线积分或第二类曲线积分</strong></p>\n<p>若 <span\nclass=\"math inline\"><em>e⃗</em><sub><em>τ</em></sub>(<em>x</em>, <em>y</em>) = (cos <em>α</em>, cos <em>β</em>)</span>，则</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  \\int_C \\vec{F}(x,y) \\cdot \\vec{e}_\\tau \\,\\mathrm{d}s &amp;= \\int_C\nP(x,y)\\cos\\alpha + Q(x,y)\\cos\\beta \\,\\mathrm{d}s \\\\\n  &amp;= \\int_C P(x,y)\\cos\\alpha \\,\\mathrm{d}s + \\int_C Q(x,y)\\cos\\beta\n\\,\\mathrm{d}s \\\\\n  &amp;= \\int_C P(x,y)\\,\\mathrm{d}x +  Q(x,y)\\,\\mathrm{d}y\n\\end{aligned}\n$$</span></p>\n<p>这是对坐标的曲线积分</p>\n<p>记 <span\nclass=\"math inline\"><em>r⃗</em> = (<em>x</em>, <em>y</em>)</span>，则\n<span\nclass=\"math inline\">d<em>e⃗</em> = <em>e⃗</em><sub><em>τ</em></sub> d<em>s</em></span>\n称为<strong>定向弧微分</strong></p>\n<p>从而有向量形式的第一类曲线积分</p>\n<p><span\nclass=\"math display\">∫<sub><em>C</em></sub><em>F⃗</em>(<em>x</em>, <em>y</em>) ⋅ d<em>e⃗</em> = ∫<sub><em>C</em></sub><em>F⃗</em> ⋅ d<em>r⃗</em></span></p>\n<h5 id=\"第二类曲线积分的性质\">第二类曲线积分的性质</h5>\n<p>第二类曲线积分与<strong>曲线方向有关</strong>，即</p>\n<p><span class=\"math display\">$$\n\\int_{\\widehat{AB}} \\vec{F}(x,y) \\cdot \\mathrm{d}\\vec{r} =\n-\\oint_{\\widehat{BA}} \\vec{F}(x,y) \\cdot \\mathrm{d}\\vec{r}\n$$</span></p>\n<p>此外线性性与对定向积分路径的可加性等仍然成立</p>\n<h5 id=\"第二类曲线积分的计算\">第二类曲线积分的计算</h5>\n<p>若曲线 <span class=\"math inline\"><em>C</em></span> 为 <span\nclass=\"math inline\">$\\begin{cases}x=x(t)\\\\y=y(t)\\end{cases}$</span>，<span\nclass=\"math inline\"><em>t</em> : <em>α</em> → <em>β</em></span></p>\n<p>起点 <span class=\"math inline\"><em>A</em></span> 对应 <span\nclass=\"math inline\"><em>α</em></span>，终点 <span\nclass=\"math inline\"><em>B</em></span> 对应 <span\nclass=\"math inline\"><em>β</em></span></p>\n<p>考察 <span\nclass=\"math inline\">∫<sub><em>C</em></sub><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em> = ∫<sub><em>C</em></sub><em>F⃗</em> ⋅ <em>e⃗</em><sub><em>τ</em></sub> d<em>s</em></span>，沿曲线\n<span class=\"math inline\"><em>C</em></span> 有 <span\nclass=\"math inline\"><em>F⃗</em> = (<em>P</em>(<em>x</em>(<em>t</em>), <em>y</em>(<em>t</em>)), <em>Q</em>(<em>x</em>(<em>t</em>), <em>y</em>(<em>t</em>)))</span>，则</p>\n<p><span\nclass=\"math display\">∫<sub><em>C</em></sub><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em> = ∫<sub><em>α</em></sub><sup><em>β</em></sup><em>P</em>(<em>x</em>(<em>t</em>), <em>y</em>(<em>t</em>)) d<em>x</em>(<em>t</em>) + <em>Q</em>(<em>x</em>(<em>t</em>), <em>y</em>(<em>t</em>)) d<em>y</em>(<em>t</em>)</span></p>\n<h4 id=\"第二类曲面积分的概念\">第二类曲面积分的概念</h4>\n<h5 id=\"双侧曲面\">双侧曲面</h5>\n<p><strong>定义：</strong></p>\n<p>若点 <span class=\"math inline\"><em>P</em></span> 沿曲面 <span\nclass=\"math inline\"><em>S</em></span>\n上任何不越过曲面边界的连续闭曲线移动后回到起始位置时，法向量 <span\nclass=\"math inline\"><em>n⃗</em></span> 保持原来的指向，则称 <span\nclass=\"math inline\"><em>S</em></span> 为<strong>双侧曲面</strong></p>\n<p>典型的，Mobius 面不是双侧曲面</p>\n<p>选定双侧曲面 <span class=\"math inline\"><em>S</em></span>\n一侧为正向，称为<strong>正侧</strong>，记为 <span\nclass=\"math inline\"><em>S</em><sup>+</sup></span> ，其相反测记作 <span\nclass=\"math inline\"><em>S</em><sup>−</sup></span></p>\n<h5 id=\"双侧曲面定侧\">双侧曲面定侧</h5>\n<p>若 <span\nclass=\"math inline\"><em>S</em> : <em>z</em> = <em>z</em>(<em>x</em>, <em>y</em>)</span>，<span\nclass=\"math inline\">(<em>x</em>, <em>y</em>) ∈ <em>D</em><sub><em>x</em><em>y</em></sub></span>，<span\nclass=\"math inline\">$\\vec{n}_0=\\left(\\cos\\alpha,\\cos\\beta,\\cos\\gamma\\right)=\\pm\\frac{\\left(-z_x,-z_y,1\\right)}{\\sqrt{1+z_x^2+z_y^2}}$</span></p>\n<p>若选取 <span\nclass=\"math inline\">$\\vec{n}_0=\\left(\\cos\\alpha,\\cos\\beta,\\cos\\gamma\\right)=\\frac{\\left(-z_x,-z_y,1\\right)}{\\sqrt{1+z_x^2+z_y^2}}$</span>，则说明\n<span\nclass=\"math inline\">cos <em>γ</em> &gt; 0</span>，选取了曲面的上侧</p>\n<p>一般的</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\cos\\alpha &gt;0 \\Leftrightarrow \\text{前侧}，\\cos\\alpha &lt; 0\n\\Leftrightarrow \\text{后侧}\\\\\n  \\cos\\beta &gt;0 \\Leftrightarrow \\text{右侧}，\\cos\\beta &lt; 0\n\\Leftrightarrow \\text{左侧}\\\\\n  \\cos\\gamma &gt;0 \\Leftrightarrow \\text{上侧}，\\cos\\gamma &lt; 0\n\\Leftrightarrow \\text{下侧}\n\\end{cases}\n$$</span></p>\n<p>习惯上选取曲面片的上侧为 <span\nclass=\"math inline\"><em>S</em><sup>+</sup></span>；对于封闭曲面，选取外侧为\n<span class=\"math inline\"><em>S</em><sup>+</sup></span></p>\n<p>对于向量值函数 <span\nclass=\"math inline\"><em>F⃗</em> = (<em>P</em>, <em>Q</em>, <em>R</em>)</span></p>\n<p><span\nclass=\"math display\">∫<sub><em>C</em></sub><em>F⃗</em>⋅ d<em>S</em> = ∫<sub><em>c</em></sub><em>P</em> d<em>x</em>d<em>y</em> + <em>Q</em> d<em>y</em>d<em>z</em> + <em>R</em> d<em>z</em>d<em>x</em></span></p>\n<h5 id=\"第二类曲面积分的性质\">第二类曲面积分的性质</h5>\n<p>第二类曲面积分与在曲面的哪一侧积分有关</p>\n<p><span\nclass=\"math display\">∬<sub><em>S</em><sup>+</sup></sub><em>P</em> d<em>x</em>d<em>y</em> + <em>Q</em> d<em>y</em>d<em>z</em> + <em>R</em> d<em>z</em>d<em>x</em> = −∬<sub><em>S</em><sup>−</sup></sub><em>P</em> d<em>x</em>d<em>y</em> + <em>Q</em> d<em>y</em>d<em>z</em> + <em>R</em> d<em>z</em>d<em>x</em></span></p>\n<p>此外第二类曲面积分也具有线性性和可加性等性质</p>\n<h4 id=\"第二类曲面积分的计算\">第二类曲面积分的计算</h4>\n<h5 id=\"合一投影法\">合一投影法</h5>\n<p><span\nclass=\"math display\">∬<sub><em>S</em><sup>+</sup></sub><em>P</em> d<em>x</em>d<em>y</em> + <em>Q</em> d<em>y</em>d<em>z</em> + <em>R</em> d<em>z</em>d<em>x</em> = ∬<sub><em>D</em><sub><em>x</em><em>y</em></sub></sub>(−<em>P</em><em>z</em><sub><em>x</em></sub> − <em>Q</em><em>z</em><sub><em>y</em></sub> + <em>R</em>) d<em>x</em>d<em>y</em></span></p>\n<h5 id=\"分面投影法\">分面投影法</h5>\n<p>分 <span\nclass=\"math inline\"><em>P</em> d<em>x</em>d<em>y</em></span>，<span\nclass=\"math inline\"><em>Q</em> d<em>y</em>d<em>z</em></span>，<span\nclass=\"math inline\"><em>R</em> d<em>z</em>d<em>x</em></span>\n三个部分进行积分</p>\n<p>常在部分曲面垂直坐标轴时进行</p>\n<h5 id=\"公式法\">公式法</h5>\n<p>常用于参数方程确定的曲面</p>\n<p>设 <span\nclass=\"math inline\"><em>S</em> : <em>r⃗</em> = (<em>x</em>(<em>u</em>, <em>v</em>), <em>y</em>(<em>u</em>, <em>v</em>), <em>z</em>(<em>u</em>, <em>v</em>))</span>，其中\n<span\nclass=\"math inline\">(<em>u</em>, <em>v</em>) ∈ <em>D</em><sub><em>x</em><em>y</em></sub></span>，则</p>\n<p><span class=\"math display\">$$\n\\iint_{S^+}\\vec{F}\\cdot\\,\\mathrm{d}\\vec{S} =\n\\iint_{D_{uv}}\\vec{F}\\cdot\\left(\\vec{r}_u\\times\\vec{r_v}\\right)\\,\\mathrm{d}u\\mathrm{d}v\n$$</span></p>\n<h3 id=\"green-公式及其应用\">Green 公式及其应用</h3>\n<h4 id=\"green-公式\">Green 公式</h4>\n<h5 id=\"连通区域及其边界方向\">连通区域及其边界方向</h5>\n<p>设 <span class=\"math inline\"><em>D</em></span> 为平面区域, 若 <span\nclass=\"math inline\"><em>D</em></span> 内的任意一条闭曲线所围的区域都落在\n<span class=\"math inline\"><em>D</em></span> 内, 则称 <span\nclass=\"math inline\"><em>D</em></span> 是单连通的, 否则称 <span\nclass=\"math inline\"><em>D</em></span> 为复连通的</p>\n<p>当点沿区域边界朝一个方向前进时, 区域总在它的左侧,\n则将此方向规定为边界曲线 <span class=\"math inline\"><em>C</em></span>\n的正向,记为 <span class=\"math inline\"><em>C</em><sup>+</sup></span>, 与\n<span class=\"math inline\"><em>C</em><sup>+</sup></span> 相反方向为 <span\nclass=\"math inline\"><em>C</em><sup>−</sup></span></p>\n<h5 id=\"green-公式-1\">Green 公式</h5>\n<p><strong>定理：</strong></p>\n<p>设有界闭区域 <span class=\"math inline\"><em>D</em></span>\n由分段光滑曲线 <span class=\"math inline\"><em>C</em></span> 围成，函数\n<span class=\"math inline\"><em>P</em>(<em>x</em>, <em>y</em>)</span>,\n<span class=\"math inline\"><em>Q</em>(<em>x</em>, <em>y</em>)</span> 在\n<span class=\"math inline\"><em>D</em></span> 上有一阶连续偏导数, 则</p>\n<p><span class=\"math display\">$$\n\\oint_{C^+} P\\,\\mathrm{d}x + Q\\,\\mathrm{d}y = \\iint_D\n\\left(\\frac{\\partial Q}{\\partial x} - \\frac{\\partial P}{\\partial\ny}\\right)\\,\\mathrm{d}x\\mathrm{d}y\n$$</span></p>\n<ul>\n<li>对于复连通区域 <span class=\"math inline\"><em>D</em></span>，Green\n公式仍然成立，但需将 <span class=\"math inline\"><em>C</em></span>\n分成若干个单连通区域 <span\nclass=\"math inline\"><em>D</em><sub><em>i</em></sub></span>，并对每个区域应用\nGreen 公式</li>\n<li>公式也可以记为 <span class=\"math inline\">$\\displaystyle\\oint_{C^+}\nP\\,\\mathrm{d}x + Q\\,\\mathrm{d}y = \\iint_D\n\\begin{vmatrix}\\frac{\\partial}{\\partial x}&amp;\\frac{\\partial}{\\partial\ny}\\newline P&amp;Q\\end{vmatrix}\\,\\mathrm{d}x\\mathrm{d}y$</span></li>\n</ul>\n<h5 id=\"green-公式的向量形式\">Green 公式的向量形式</h5>\n<p><span\nclass=\"math display\">∮<sub><em>C</em><sup>+</sup></sub><em>F⃗</em>⋅ d<em>r⃗</em> = ∬<sub><em>D</em></sub>∇ × <em>F⃗</em> d<em>x</em>d<em>y</em></span></p>\n<h4 id=\"曲线积分与路径无关的条件\">曲线积分与路径无关的条件</h4>\n<p><strong>定义：</strong></p>\n<p>设 <span\nclass=\"math inline\"><em>P</em>(<em>x</em>, <em>y</em>)</span>，<span\nclass=\"math inline\"><em>Q</em>(<em>x</em>, <em>y</em>)</span> 在区域\n<span class=\"math inline\"><em>D</em></span> 内连续，若对 <span\nclass=\"math inline\"><em>D</em></span> 内任意两点 <span\nclass=\"math inline\"><em>A</em></span>，<span\nclass=\"math inline\"><em>B</em></span> 以及 <span\nclass=\"math inline\"><em>D</em></span> 内连接 <span\nclass=\"math inline\"><em>A</em>, <em>B</em></span> 的任意二分段光滑曲线\n<span class=\"math inline\"><em>C</em><sub>1</sub></span>，<span\nclass=\"math inline\"><em>C</em><sub>2</sub></span>，均有</p>\n<p><span\nclass=\"math display\">∫<sub><em>C</em><sub>1</sub></sub><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em> = ∫<sub><em>C</em><sub>2</sub></sub><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em></span></p>\n<p>则称曲线积分 <span\nclass=\"math inline\">∫<sub><em>C</em></sub><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em></span>\n在 <span class=\"math inline\"><em>D</em></span>\n内<strong>与路径无关</strong></p>\n<p><strong>定理：</strong></p>\n<p>设函数 <span class=\"math inline\"><em>P</em></span>，<span\nclass=\"math inline\"><em>Q</em></span> 在<strong>单连通</strong>区域\n<span class=\"math inline\"><em>D</em></span>\n上有连续偏导数，则下述四命题等价</p>\n<ol type=\"1\">\n<li>在 <span class=\"math inline\"><em>D</em></span>\n内的任一条分段光滑闭曲线 <span class=\"math inline\"><em>C</em></span>\n上，有 <span\nclass=\"math inline\">∫<sub><em>C</em></sub><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em> = 0</span></li>\n<li>曲线积分 <span\nclass=\"math inline\">∫<sub><em>C</em></sub><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em></span>\n在 <span class=\"math inline\"><em>D</em></span> 内与路径无关</li>\n<li>存在 <span class=\"math inline\"><em>D</em></span> 上的可微函数 <span\nclass=\"math inline\"><em>u</em>(<em>x</em>, <em>y</em>)</span> 使得 <span\nclass=\"math inline\">d<em>u</em> = <em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em></span>，此时称\n<span class=\"math inline\"><em>u</em>(<em>x</em>, <em>y</em>)</span> 为\n<span\nclass=\"math inline\"><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em></span>\n的一个<strong>原函数</strong></li>\n<li><span class=\"math inline\">$\\displaystyle \\frac{\\partial Q}{\\partial\nx} = \\frac{\\partial P}{\\partial y}$</span> 在 <span\nclass=\"math inline\"><em>D</em></span> 内恒成立</li>\n</ol>\n<h4 id=\"全微分求积与全微分方程\">全微分求积与全微分方程</h4>\n<p>设函数 <span class=\"math inline\"><em>P</em></span>，<span\nclass=\"math inline\"><em>Q</em></span> 在单连通区域 <span\nclass=\"math inline\"><em>D</em></span> 上有连续偏导数，且 <span\nclass=\"math inline\">$\\displaystyle \\frac{\\partial Q}{\\partial x} =\n\\frac{\\partial P}{\\partial y}$</span> ，则 <span\nclass=\"math inline\"><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em></span>\n为某函数 <span class=\"math inline\"><em>u</em></span> 的全微分，且取定\n<span\nclass=\"math inline\">(<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>) ∈ <em>D</em></span></p>\n<p><span\nclass=\"math display\"><em>u</em>(<em>x</em>, <em>y</em>) = <em>u</em>(<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>) + ∫<sub>(<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>)</sub><sup>(<em>x</em>, <em>y</em>)</sup><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em>,  (<em>x</em>, <em>y</em>) ∈ <em>D</em></span></p>\n<p>从而全体函数为 <span\nclass=\"math inline\"><em>u</em>(<em>x</em>, <em>y</em>) + <em>C</em></span></p>\n<p>称求 <span\nclass=\"math inline\"><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em></span>\n的原函数的过程为<strong>全微分求积</strong></p>\n<p>若 <span\nclass=\"math inline\"><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em></span>\n是某二元函数的全微分，称方程</p>\n<p><span\nclass=\"math display\"><em>P</em>(<em>x</em>, <em>y</em>) d<em>x</em> + <em>Q</em>(<em>x</em>, <em>y</em>) d<em>y</em> = 0</span></p>\n<p>为<strong>全微分方程</strong></p>\n<p>求出一个原函数 <span\nclass=\"math inline\"><em>u</em>(<em>x</em>, <em>y</em>)</span>，则方程的通解为\n<span\nclass=\"math inline\"><em>u</em>(<em>x</em>, <em>y</em>) = <em>C</em></span>，其中\n<span class=\"math inline\"><em>C</em></span> 是任意常数</p>\n<h3 id=\"gauss-公式和-strokes-公式\">Gauss 公式和 Strokes 公式</h3>\n<h4 id=\"gauss-公式\">Gauss 公式</h4>\n<p><strong>定理：</strong></p>\n<p>设函数 <span\nclass=\"math inline\"><em>P</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>，<span\nclass=\"math inline\"><em>Q</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>，<span\nclass=\"math inline\"><em>R</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>\n在空间有界闭区域 <span class=\"math inline\"><em>Ω</em></span>\n上有连续偏导数，<span class=\"math inline\"><em>Ω</em></span>\n的边界时光滑或分片光滑的闭曲面 <span\nclass=\"math inline\"><em>Σ</em></span>，则</p>\n<p><span class=\"math display\">$$\n\\oiint_{\\Sigma^+} P\\,\\mathrm{d}x\\mathrm{d}y + Q\\,\\mathrm{d}y\\mathrm{d}z\n+ R\\,\\mathrm{d}z\\mathrm{d}x = \\iiint_\\Omega \\left(\\frac{\\partial\nP}{\\partial x} + \\frac{\\partial Q}{\\partial y} + \\frac{\\partial\nR}{\\partial z}\\right)\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z\n$$</span></p>\n<ul>\n<li>令 <span class=\"math inline\">$P=\\frac{x}{3}$</span>，<span\nclass=\"math inline\">$Q=\\frac{y}{3}$</span>，<span\nclass=\"math inline\">$R=\\frac{z}{3}$</span>，则可导出 <span\nclass=\"math inline\">$\\displaystyle V_\\Omega =\n\\frac{1}{3}\\oiint_{\\Sigma^+} x\\,\\mathrm{d}y\\mathrm{d}z +\ny\\,\\mathrm{d}z\\mathrm{d}x +\nz\\,\\mathrm{d}x\\mathrm{d}y$</span>，即体积公式</li>\n<li>使用 Gauss 公式时，注意 <span\nclass=\"math inline\"><em>Σ</em><sup>+</sup></span> 的方向应与 <span\nclass=\"math inline\"><em>Ω</em></span> 的外侧一致</li>\n</ul>\n<h5 id=\"向量形式的-gauss-公式\">向量形式的 Gauss 公式</h5>\n<p><span\nclass=\"math display\">∯<sub><em>Σ</em><sup>+</sup></sub><em>F⃗</em>⋅ d<em>S⃗</em> = ∭<sub><em>Ω</em></sub>∇ ⋅ <em>F⃗</em> d<em>x</em>d<em>y</em>d<em>z</em></span></p>\n<h4 id=\"通量和散度\">通量和散度</h4>\n<h5 id=\"通量\">通量</h5>\n<p>若给定向量场</p>\n<p><span\nclass=\"math display\"><em>F⃗</em> = (<em>P</em>(<em>x</em>, <em>y</em>, <em>z</em>), <em>Q</em>(<em>x</em>, <em>y</em>, <em>z</em>), <em>R</em>(<em>x</em>, <em>y</em>, <em>z</em>))</span></p>\n<p>则称曲面积分</p>\n<p><span\nclass=\"math display\"><em>Φ</em> = ∯<sub><em>Σ</em><sup>+</sup></sub><em>F⃗</em>⋅ d<em>S⃗</em> = ∯<sub><em>Σ</em><sup>+</sup></sub><em>P</em> d<em>x</em>d<em>y</em> + <em>Q</em> d<em>y</em>d<em>z</em> + <em>R</em> d<em>z</em>d<em>x</em></span></p>\n<p>为向量场 <span class=\"math inline\"><em>F⃗</em></span> 在通过定侧曲面\n<span class=\"math inline\"><em>Σ</em><sup>+</sup></span>\n的<strong>通量</strong></p>\n<h5 id=\"散度\">散度</h5>\n<p>称</p>\n<p><span class=\"math display\">$$\n\\mathrm{div}\\vec{F} = \\nabla\\cdot\\vec{F}=\\frac{\\partial P}{\\partial x} +\n\\frac{\\partial Q}{\\partial y} + \\frac{\\partial R}{\\partial z}\n$$</span></p>\n<p>为向量场 <span class=\"math inline\"><em>F⃗</em></span>\n的<strong>散度</strong></p>\n<p>则 Gauss 公式可写为</p>\n<p><span\nclass=\"math display\"><em>Φ</em> = ∯<sub><em>Σ</em><sup>+</sup></sub><em>F⃗</em>⋅ d<em>S⃗</em> = ∭<sub><em>Ω</em></sub>div<em>F⃗</em> d<em>V</em></span></p>\n<h2 id=\"级数\">级数</h2>\n<h3 id=\"数项级数\">数项级数</h3>\n<h4 id=\"数项级数的概念\">数项级数的概念</h4>\n<p><strong>定义：</strong></p>\n<p>给定数列 <span\nclass=\"math inline\">{<em>a</em><sub><em>n</em></sub>}</span> ，和式</p>\n<p><span class=\"math display\">$$\n\\sum_{n=1}^{\\infty} a_n = a_1 + a_2 + \\cdots + a_n + \\cdots\n$$</span></p>\n<p>称为 <strong>（无穷）极数</strong> ，<span\nclass=\"math inline\"><em>a</em><sub><em>n</em></sub></span>\n称为级数的<strong>通项</strong>（或<strong>一般项</strong>）</p>\n<ul>\n<li><span class=\"math inline\">$\\displaystyle S_n = \\sum_{k=1}^n\na_k$</span> 称为级数 <span\nclass=\"math inline\">∑<sub><em>n</em> = 1</sub><em>a</em><sub><em>n</em></sub></span>\n的前 <span class=\"math inline\"><em>n</em></span>\n项<strong>部分和</strong></li>\n<li><span class=\"math inline\">$\\displaystyle\\sum_{k=n+1}^\\infty\na_k$</span> 称为级数 <span\nclass=\"math inline\">∑<sub><em>n</em> = 1</sub><em>a</em><sub><em>n</em></sub></span>\n的<strong>余项级数</strong></li>\n</ul>\n<p><strong>定义：</strong></p>\n<ul>\n<li>若级数 <span class=\"math inline\">$\\displaystyle\\sum_{n=1}^\\infty\na_n$</span> 的部分和数列 <span\nclass=\"math inline\">{<em>S</em><sub><em>n</em></sub>}</span> 收敛，且\n<span\nclass=\"math inline\">lim<sub><em>n</em> → ∞</sub><em>S</em><sub><em>n</em></sub> = <em>S</em></span>，则称级数\n<span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n<strong>收敛</strong>，<span class=\"math inline\"><em>S</em></span>\n称为级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 的<strong>和</strong>，记作 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n =\nS$</span></li>\n<li>若部分和数列 <span\nclass=\"math inline\">{<em>S</em><sub><em>n</em></sub>}</span>\n发散，则称级数 <span class=\"math inline\">$\\displaystyle\n\\sum_{n=1}^\\infty a_n$</span> <strong>发散</strong></li>\n</ul>\n<blockquote>\n<p>常用结论：</p>\n<p><strong>等比数列</strong> <span class=\"math inline\">$\\displaystyle\n\\sum_{n=1}^\\infty aq^{n-1}\\begin{cases}\\text{收敛于}\\frac{a}{1-q} &amp;\n,\\vert q \\vert &lt; 1\\newline \\text{发散} &amp; ,\\vert q \\vert \\geq\n1\\end{cases}$</span></p>\n</blockquote>\n<h4 id=\"数项级数的基本性质\">数项级数的基本性质</h4>\n<h5 id=\"基本性质\">基本性质</h5>\n<ol type=\"1\">\n<li>若常数 <span class=\"math inline\"><em>α</em> ≠ 0</span>，则级数 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span> 与级数\n<span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty \\alpha\na_n$</span> 有相同敛散性</li>\n<li><strong>线性性：</strong> 若级数 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n =\nS$</span>，<span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\nb_n = T$</span>，则 <span\nclass=\"math inline\">∀<em>α</em>, <em>β</em> ∈ ℝ</span>，有 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty (\\alpha a_n + \\beta\nb_n) = \\alpha S + \\beta T$</span></li>\n<li><strong>可加性：</strong>\n将级数增加、删减或改换<strong>有限项</strong>，不改变级数的<strong>敛散性</strong></li>\n<li><strong>结合律：</strong> 若级数收敛于 <span\nclass=\"math inline\"><em>S</em></span>，则将相邻若干项添加括号所成新级数仍收敛于\n<span class=\"math inline\"><em>S</em></span>\n<ul>\n<li>其本质是部分和数列收敛于 <span\nclass=\"math inline\"><em>S</em></span>，则子列均收敛于 <span\nclass=\"math inline\"><em>S</em></span></li>\n<li>加括号后级数收敛 <span class=\"math inline\">⇏</span> 原级数收敛</li>\n<li>加括号后级数发散 <span class=\"math inline\">⇒</span> 原级数发散</li>\n</ul></li>\n</ol>\n<h5 id=\"级数收敛的必要条件\">级数收敛的必要条件</h5>\n<p><strong>定理：</strong></p>\n<p>若 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 收敛，则 <span\nclass=\"math inline\">lim<sub><em>n</em> → ∞</sub><em>a</em><sub><em>n</em></sub> = 0</span></p>\n<ul>\n<li>若 <span class=\"math inline\">$\\displaystyle \\lim_{n\\to\\infty} a_n\n\\neq 0 \\nRightarrow \\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n发散</li>\n<li>若 <span class=\"math inline\">$\\displaystyle \\lim_{n\\to\\infty} a_n =\n0 \\nRightarrow \\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n收敛，比如调和级数</li>\n</ul>\n<h3 id=\"正项级数敛散性\">正项级数敛散性</h3>\n<h4 id=\"正项级数\">正项级数</h4>\n<p><strong>定义：</strong></p>\n<p>若级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 满足 <span\nclass=\"math inline\"><em>a</em><sub><em>n</em></sub> &gt; 0  (<em>n</em> ∈ ℕ<sup>+</sup>)</span>，则称此级数为<strong>正项级数</strong></p>\n<p><strong>定理：（收敛原理）</strong></p>\n<p>正项级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 收敛 <span class=\"math inline\">⇔</span> 是其部分和数列 <span\nclass=\"math inline\">{<em>S</em><sub><em>n</em></sub>}</span> 有上界，即\n<span\nclass=\"math inline\">∃<em>M</em> ∈ ℝ, ∀<em>n</em> ∈ ℕ<sup>+</sup> : <em>S</em><sub><em>n</em></sub> ≤ <em>M</em></span></p>\n<blockquote>\n<p><span class=\"math inline\"><em>p</em></span> 级数</p>\n<p><span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\n\\frac{1}{n^p} \\begin{cases}\\text{收敛} &amp; ,p&gt;1\\newline \\text{发散}\n&amp; ,p\\leq 1\\end{cases}$</span></p>\n</blockquote>\n<h4 id=\"正项级数敛散性判别法\">正项级数敛散性判别法</h4>\n<h5 id=\"比较判别法\">比较判别法</h5>\n<p><strong>定理：</strong></p>\n<p>设正项级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span>，<span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\nb_n$</span> 满足 <span\nclass=\"math inline\"><em>a</em><sub><em>n</em></sub> ≤ <em>b</em><sub><em>n</em></sub>  (∀<em>n</em> ∈ ℕ<sup>+</sup>)</span>\n，则 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\nb_n$</span> 收敛 <span class=\"math inline\">$\\Rightarrow \\displaystyle\n\\sum_{n=1}^\\infty a_n$</span> 收敛，<span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span> 发散\n<span class=\"math inline\">$\\Rightarrow \\displaystyle \\sum_{n=1}^\\infty\nb_n$</span> 发散</p>\n<ul>\n<li>条件 <span\nclass=\"math inline\">∀<em>n</em> ∈ ℕ<sup>+</sup>，<em>a</em><sub><em>n</em></sub> ≤ <em>b</em><sub><em>n</em></sub></span>\n可改为 <span\nclass=\"math inline\">∃<em>N</em>, <em>C</em> &gt; 0, ∀<em>n</em> ∈ ℕ<sup>+</sup>，∀<em>n</em> ≥ <em>N</em>，<em>a</em><sub><em>n</em></sub> ≤ <em>C</em><em>b</em><sub><em>n</em></sub></span></li>\n<li>使用该判别法时需要有参照级数，常选<strong>等比级数</strong>或\n<strong><span class=\"math inline\"><em>p</em></span>\n级数</strong>作参照</li>\n</ul>\n<h5 id=\"比较判别法极限形式\">比较判别法（极限形式）</h5>\n<p><strong>定理：</strong></p>\n<p>正项级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span>，<span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\nb_n$</span> 满足 <span class=\"math inline\">$\\displaystyle\n\\lim_{n\\to\\infty} \\frac{a_n}{b_n} = l$</span></p>\n<ul>\n<li>当 <span class=\"math inline\">0 &lt; <em>l</em> &lt; +∞</span>\n时，<span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 与 <span class=\"math inline\">$\\displaystyle\n\\sum_{n=1}^\\infty b_n$</span> 同敛散</li>\n<li>当 <span class=\"math inline\"><em>l</em> = 0</span> 时，<span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty b_n$</span> 收敛\n<span class=\"math inline\">$\\Rightarrow \\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 收敛</li>\n<li>当 <span class=\"math inline\"><em>l</em> = +∞</span> 时，<span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty b_n$</span> 发散\n<span class=\"math inline\">$\\Rightarrow \\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 发散</li>\n</ul>\n<blockquote>\n<p>通常使用 <span class=\"math inline\">$b_n = \\frac{1}{n^p}$</span>\n作为参照物，因为我们此时在分析无穷小 <span\nclass=\"math inline\"><em>a</em><sub><em>n</em></sub></span> 的阶</p>\n</blockquote>\n<h5 id=\"比值判别法dalembert-判别法\">比值判别法（d’Alembert 判别法）</h5>\n<p><strong>定理：</strong></p>\n<p>若<strong>正项级数</strong> <span class=\"math inline\">$\\displaystyle\n\\sum_{n=1}^\\infty a_n$</span> 满足 <span\nclass=\"math inline\">$\\displaystyle \\lim_{n\\to\\infty} \\frac{a_{n+1}}{a_n}\n= l$</span>，则</p>\n<ul>\n<li>当 <span class=\"math inline\">0 ≤ <em>l</em> &lt; 1</span> 时，<span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n收敛</li>\n<li>当 <span class=\"math inline\"><em>l</em> &gt; 1</span> 时，<span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n发散</li>\n<li>当 <span class=\"math inline\"><em>l</em> = 1</span>\n时，判别法失效</li>\n</ul>\n<blockquote>\n<p>Stirling 公式： <span class=\"math inline\">$n! \\sim\n\\left(\\frac{n}{e}\\right)^n \\sqrt{2n\\pi} \\quad (n\\to\\infty)$</span></p>\n</blockquote>\n<blockquote>\n<p>当 <span class=\"math inline\"><em>a</em><sub><em>n</em></sub></span>\n是一些乘积构成或含 <span class=\"math inline\"><em>n</em>!</span>\n时，可以考虑比值法</p>\n</blockquote>\n<h5 id=\"根值判别法cauchy-判别法\">根值判别法（Cauchy 判别法）</h5>\n<p><strong>定理：</strong></p>\n<p>若正项级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 满足 <span class=\"math inline\">$\\displaystyle\n\\lim_{n\\to\\infty} \\sqrt[n]{a_n} = l$</span>，则</p>\n<ol type=\"1\">\n<li>当 <span class=\"math inline\">0 ≤ <em>l</em> &lt; 1</span> 时，<span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n收敛</li>\n<li>当 <span class=\"math inline\">1 &lt; <em>l</em> ≤ +∞</span> 时，<span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n发散</li>\n<li>当 <span class=\"math inline\"><em>l</em> = 1</span>\n时，判别法失效</li>\n</ol>\n<blockquote>\n<p>当 <span class=\"math inline\"><em>a</em><sub><em>n</em></sub></span>\n中含有 <span class=\"math inline\"><em>n</em></span>\n次方时，可以考虑使用根值法</p>\n</blockquote>\n<blockquote>\n<p>比值法和根值法实际上可看作是在将级数与等比级数作比较，均智能判断收敛速度不满与等比级数的级数.当所求级数存在时，可称级数为<strong>拟等比级数</strong></p>\n</blockquote>\n<blockquote>\n<p>根值法优于比值法</p>\n<ul>\n<li><span\nclass=\"math inline\">$\\displaystyle\\lim_{n\\to\\infty}\\frac{a_{n+1}}{a_n}\n=  l \\Rightarrow \\displaystyle \\sqrt[n]{a_n} = l$</span></li>\n<li><span class=\"math inline\">$\\displaystyle \\sqrt[n]{a_n} =l\n\\nRightarrow \\displaystyle\\lim_{n\\to\\infty}\\frac{a_{n+1}}{a_n}\n=  l$</span></li>\n</ul>\n</blockquote>\n<h5 id=\"积分判别法\">积分判别法</h5>\n<p><strong>定理：</strong></p>\n<p>设 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 为<strong>正项级数</strong>，若非负函数 <span\nclass=\"math inline\"><em>f</em>(<em>X</em>)</span> 在 <span\nclass=\"math inline\">[1, +∞)</span> 上<strong>单调递减</strong>，且 <span\nclass=\"math inline\"><em>a</em><sub><em>n</em></sub> = <em>f</em>(<em>n</em>)  (∀<em>n</em> ∈ ℕ<sup>+</sup>)</span>，则级数\n<span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n与反常积分 <span\nclass=\"math inline\">∫<sub>1</sub><sup>+∞</sup><em>f</em>(<em>x</em>) d<em>x</em></span>\n有相同的敛散性</p>\n<ul>\n<li>条件 <span class=\"math inline\">[1, +∞)</span> 可改为 <span\nclass=\"math inline\">[<em>a</em>, +∞)，(<em>a</em> &gt; 1)</span></li>\n</ul>\n<h3 id=\"任意项级数的敛散性\">任意项级数的敛散性</h3>\n<p><strong>任意项级数</strong></p>\n<p>正负项分布是任意的级数</p>\n<h4 id=\"交错级数敛散性的判别法\">交错级数敛散性的判别法</h4>\n<h5 id=\"交错级数\">交错级数</h5>\n<p><strong>定义：</strong></p>\n<p>各项正负相间的级数称为<strong>交错级数</strong>，其形式为</p>\n<p><span class=\"math display\">$$\n\\pm\\sum_{n=1}^\\infty {-1}^{n-1}a_n \\quad \\left(\\text{其中}a_n &gt;\n0\\right)\n$$</span></p>\n<h5 id=\"leibniz-判别法\">Leibniz 判别法</h5>\n<p><strong>定理：</strong></p>\n<p>若交错级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\n(-1)^{n-1}a_n \\,\\left(a_n&gt;0\\right)$</span> 满足:</p>\n<ol type=\"1\">\n<li><span\nclass=\"math inline\"><em>a</em><sub><em>n</em> + 1</sub> ≤ <em>a</em><sub><em>n</em></sub>  (<em>n</em> = 1, 2, …)</span></li>\n<li><span\nclass=\"math inline\">lim<sub><em>n</em> → ∞</sub><em>a</em><sub><em>n</em></sub> = 0</span></li>\n</ol>\n<p>则级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\n(-1)^{n-1}a_n$</span> 收敛，且其余项级数满足</p>\n<p><span class=\"math display\">$$\n\\left\\vert \\sum_{k=n+1}^\\infty a_k \\right\\vert \\leq a_{n+1}\n$$</span></p>\n<blockquote>\n<p>我们称满足定理条件的级数为 <strong>leibniz 型级数</strong></p>\n</blockquote>\n<h4 id=\"abel-判别法和-dirichlet-判别法\">Abel 判别法和 Dirichlet\n判别法</h4>\n<p><strong>定理：（Abel 判别法）</strong></p>\n<p>若 <span class=\"math inline\">{<em>a</em><sub><em>n</em></sub>}</span>\n单调且有界，<span class=\"math inline\">$\\displaystyle\\sum_{n=1}^\\infty\nb_n$</span> 收敛，则 <span class=\"math inline\">$\\displaystyle\n\\sum_{n=1}^\\infty a_nb_n$</span> 收敛</p>\n<p><strong>定理：（Dirichlet 判别法）</strong></p>\n<p>若 <span class=\"math inline\">{<em>a</em><sub><em>n</em></sub>}</span>\n单调趋于 <span class=\"math inline\">0</span>，<span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty b_n$</span>\n的部分和数列有界，则 <span class=\"math inline\">$\\displaystyle\n\\sum_{n=1}^\\infty a_nb_n$</span> 收敛</p>\n<h4 id=\"绝对收敛与条件收敛\">绝对收敛与条件收敛</h4>\n<p><strong>定义：</strong></p>\n<p>设 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 为任意项级数</p>\n<ol type=\"1\">\n<li>若级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\n\\vert a_n \\vert$</span> 收敛，则称级数 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n为<strong>绝对收敛</strong></li>\n<li>若 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty \\vert\na_n \\vert$</span> 发散，而 <span class=\"math inline\">$\\displaystyle\n\\sum_{n=1}^\\infty a_n$</span> 收敛，但 ，则称 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n<strong>条件收敛</strong></li>\n</ol>\n<p><strong>定理：</strong></p>\n<p>若 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 绝对收敛，则 <span class=\"math inline\">$\\displaystyle\n\\sum_{n=1}^\\infty a_n$</span> 收敛</p>\n<blockquote>\n<p><strong>常用结论：</strong></p>\n<p><span class=\"math display\">$$\n\\displaystyle \\sum_{n=1}^\\infty\n\\frac{(-1)^{n}}{n^p}\\begin{cases}\\text{绝对收敛} &amp; ,p&gt;1\\\\\n\\text{条件收敛} &amp; , 0 &lt; p\\leq 1 \\end{cases}\n$$</span></p>\n</blockquote>\n<p><strong>定理：（绝对收敛与条件收敛的本质）</strong></p>\n<ol type=\"1\">\n<li>绝对收敛的级数，可以改变任意项的顺序，其收敛性与和均不变（即满足加法交换律）</li>\n<li>条件收敛的级数，总可以适当改变项的顺序，使其按照任意预定的方式收敛或者发散</li>\n</ol>\n<h3 id=\"函数项级数\">函数项级数</h3>\n<p><strong>定义：</strong></p>\n<p>设函数列 <span\nclass=\"math inline\">{<em>u</em><sub><em>n</em></sub><em>x</em>}(<em>n</em> = 1, 2, …)</span>\n在数集 <span class=\"math inline\"><em>X</em></span>\n上有定义，则称形式和</p>\n<p><span class=\"math display\">$$\n\\sum_{n=1}^\\infty u_n(x)= u_1(x) + u_2(x) + \\cdots + u_n(x) + \\cdots\n$$</span></p>\n<p>为<strong>函数项级数</strong>，其中 <span\nclass=\"math inline\"><em>u</em><sub><em>n</em></sub>(<em>x</em>)</span>\n称为<strong>通项</strong></p>\n<p><strong>定义：</strong></p>\n<p>若数项级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\nu_n(x_0)$</span> 收敛，则 <span\nclass=\"math inline\"><em>x</em><sub>0</sub></span> 为函数项级数 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty u_n(x)$</span>\n的一个<strong>收敛点</strong>，否则称为<strong>发散点</strong>，全体收敛点所组成的集合\n<span class=\"math inline\"><em>I</em></span>\n称为<strong>收敛域</strong></p>\n<p><strong>定义</strong></p>\n<p>记 <span class=\"math inline\">$\\displaystyle S_n(x) =\\sum_{k=1}^\\infty\nu_k(x)$</span>,为 <span class=\"math inline\">$\\displaystyle\n\\sum_{n=1}^\\infty u_n(x)$</span> 的前 <span\nclass=\"math inline\"><em>n</em></span>\n项<strong>部分和(函数)</strong>，记 <span\nclass=\"math inline\">$\\displaystyle r_n(x) = \\sum_{k=n+1}^\\infty\nu_k(x)$</span> 为<strong>余和</strong></p>\n<p><strong>定义：</strong></p>\n<p>对于收敛域 <span class=\"math inline\"><em>I</em></span> 中的任意一点\n<span class=\"math inline\"><em>x</em></span>，记 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty u_n(x)$</span>\n的和为 <span class=\"math inline\"><em>S</em>(<em>x</em>)</span>，称此函数\n<span class=\"math inline\"><em>S</em>(<em>x</em>)</span> 为 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty u_n(x)$</span>\n的<strong>和函数</strong></p>\n<p>显然，<span\nclass=\"math inline\">∀<em>x</em> ∈ <em>I</em></span>，<span\nclass=\"math inline\">lim<sub><em>n</em> → +∞</sub><em>S</em><sub><em>n</em></sub>(<em>x</em>) = <em>S</em>(<em>x</em>)</span>，<span\nclass=\"math inline\">lim<sub><em>n</em> → +∞</sub><em>r</em><sub><em>n</em></sub>(<em>x</em>) = 0</span></p>\n<h3 id=\"幂级数\">幂级数</h3>\n<h4 id=\"幂级数及其收敛半径\">幂级数及其收敛半径</h4>\n<p>在函数项级数中，最简单及最重要的级数形如</p>\n<p><span class=\"math display\">$$\n\\sum_{n=0}^\\infty a_n(x-x_0)^n = a_0 +a_1x + a_2(x-x_0)^2 + \\ldots +\na_n(x-x_0)^n + \\ldots\n$$</span></p>\n<p>称为<strong>幂级数</strong>，其中常数项 <span\nclass=\"math inline\"><em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, …, <em>a</em><sub><em>n</em></sub>, …</span>\n称为幂级数的<strong>系数</strong></p>\n<p>幂级数更加一半的形式为 <span class=\"math inline\">$\\displaystyle\n\\sum_{n=0}^\\infty a_n(x-x_0)^n$</span></p>\n<h5 id=\"abel-定理\"><strong>Abel 定理</strong></h5>\n<ol type=\"1\">\n<li>若幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_n(x-x_0)^n$</span> 在 <span\nclass=\"math inline\"><em>x</em> = <em>x</em><sub>0</sub>(<em>x</em> ≠ 0)</span>\n收敛，则当 <span\nclass=\"math inline\">|<em>x</em>| &lt; |<em>x</em><sub>0</sub>|</span>，时，幂级数\n<span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_n(x-x_0)^n$</span> 绝对收敛</li>\n<li>若幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nx^n$</span> 在 <span\nclass=\"math inline\"><em>x</em> = <em>x</em><sub>1</sub></span>\n发散，则当 <span\nclass=\"math inline\">|<em>x</em>| &gt; |<em>x</em><sub>1</sub>|</span>\n时，幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nx^n$</span> 发散</li>\n</ol>\n<h6 id=\"推论幂级数收敛域的情况\">推论（幂级数收敛域的情况）</h6>\n<p>幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_n(x-x_0)^n$</span> 的收敛域 <span\nclass=\"math inline\"><em>I</em></span> 仅有以下几种情况：</p>\n<ol type=\"1\">\n<li>仅在 <span class=\"math inline\"><em>x</em> = 0</span>\n的情况收敛（<span class=\"math inline\"><em>R</em> = 0</span>）</li>\n<li>在区间 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)(<em>R</em> &gt; 0)</span>\n内绝对收敛，在 <span\nclass=\"math inline\">(−∞, −<em>R</em>)⋃(<em>R</em>, +∞)</span> 发散</li>\n<li>在区间 <span class=\"math inline\">(−<em>R</em>, <em>R</em>)</span>\n内绝对收敛（<span class=\"math inline\"><em>R</em> = +∞</span>）</li>\n</ol>\n<h3 id=\"幂级数收敛半径的求法\">幂级数收敛半径的求法</h3>\n<h4 id=\"系数模比值法\">系数模比值法</h4>\n<p><strong>定理：</strong></p>\n<p>对幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_nx^n$</span>，若 <span class=\"math inline\">$\\displaystyle\n\\lim_{n\\to+\\infty}\\left\\vert\\frac{a_{n+1}}{a_n}\\right\\vert =\n\\rho$</span>，则收敛半径 <span class=\"math inline\">$\\displaystyle\nR=\\begin{cases}&amp;0,&amp;&amp;\\rho=+\\infty\\newline &amp;\n\\frac{1}{\\rho},&amp;&amp; 0&lt;\\rho&lt;+\\infty\\newline &amp;+\\infty\n,&amp;&amp;\\rho=0\\end{cases}$</span></p>\n<h4 id=\"系数模根值法\">系数模根值法</h4>\n<p><strong>定理：</strong></p>\n<p>对幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_nx^n$</span>，若 <span class=\"math inline\">$\\displaystyle\n\\lim_{n\\to+\\infty}\\sqrt[n]{\\left\\vert a_n\\right\\vert} =\n\\rho$</span>，则收敛半径 <span class=\"math inline\">$\\displaystyle\nR=\\begin{cases}&amp;0,&amp;&amp;\\rho=+\\infty\\newline &amp;\n\\frac{1}{\\rho},&amp;&amp; 0&lt;\\rho&lt;+\\infty\\newline &amp;+\\infty\n,&amp;&amp;\\rho=0\\end{cases}$</span></p>\n<h3 id=\"幂级数的性质\">幂级数的性质</h3>\n<ol type=\"1\">\n<li>设幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nx^n$</span> 和 <span class=\"math inline\">$\\displaystyle\n\\sum_{n=0}^\\infty b_nx^n$</span> 的收敛半径分别为 <span\nclass=\"math inline\"><em>R</em><sub>1</sub></span> 和 <span\nclass=\"math inline\"><em>R</em><sub>2</sub></span>，则 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\n(a_n+b_n)x^n$</span> 的收敛半径为 <span\nclass=\"math inline\"><em>R</em> = min {<em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>}</span></li>\n<li>若幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nx^n$</span> 的收敛半径 <span\nclass=\"math inline\"><em>R</em> &gt; 0</span>，在收敛区间 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span> 内的和函数为 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span>，则 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span> 在 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span> 上连续；若 <span\nclass=\"math inline\">$\\displaystyle\\sum_{n=0}^\\infty a_nx^n$</span> 在\n<span class=\"math inline\"><em>x</em> = <em>R</em></span> 或 <span\nclass=\"math inline\"><em>x</em> = −<em>R</em></span> 收敛，则和函数 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span> 在 <span\nclass=\"math inline\"><em>x</em> = <em>R</em></span> 左连续或 <span\nclass=\"math inline\"><em>x</em> = −<em>R</em></span> 处右连续，即 <span\nclass=\"math inline\">$\\displaystyle \\lim_{x\\to\nR^-}S(x)=S(R)=\\sum_{n=0}^\\infty a_nR^n$</span></li>\n<li>若幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nx^n$</span> 的收敛半径 <span\nclass=\"math inline\"><em>R</em> &gt; 0</span>，在收敛区间 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span> 内的和函数为 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span>，则 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span> 在 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span>\n上可导，且有<strong>逐项求导公式</strong></li>\n</ol>\n<p><span class=\"math display\">$$\n  \\begin{aligned}\n  S'(x) = &amp;\\left(\\sum_{n=0}^\\infty a_nx^n\\right)'\\\\\n    = &amp;\\sum_{n=0}^\\infty \\left(a_nx^n\\right)'\\\\\n    = &amp;\\sum_{n=0}^\\infty na_nx^{n-1}\\\\\n  \\end{aligned}\n$$</span></p>\n<p>且幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\nna_nx^{n-1}$</span> 的收敛半径仍为 <span\nclass=\"math inline\"><em>R</em></span></p>\n<ol start=\"4\" type=\"1\">\n<li>若幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nx^n$</span> 的收敛半径 <span\nclass=\"math inline\"><em>R</em> &gt; 0</span>，在收敛区间 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span> 内的和函数为 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span>，则 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span> 在 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span>\n上可导，且有<strong>逐项求积公式</strong></li>\n</ol>\n<p><span class=\"math display\">$$\n  \\begin{aligned}\n  \\int_0^xS(t)\\,\\mathrm{d}t = &amp;\\int_0^x\\left(\\sum_{n=0}^\\infty\na_nt^n\\right)\\,\\mathrm{d}t\\\\\n    = &amp;\\sum_{n=0}^\\infty \\int_0^x a_nt^n\\,\\mathrm{d}t\\\\\n    = &amp;\\sum_{n=0}^\\infty \\frac{a_n}{n+1}x^{n+1}\\\\\n  \\end{aligned}\n$$</span></p>\n<p>且幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nt^n$</span> 的收敛半径仍为 <span\nclass=\"math inline\"><em>R</em></span></p>\n<h4 id=\"幂级数的分析性质\">幂级数的分析性质</h4>\n<p><strong>性质：</strong></p>\n<p>若幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nx^n$</span> 的收敛半径为 <span\nclass=\"math inline\"><em>R</em> &gt; 0</span>，在收敛区间 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span> 上连续；若 <span\nclass=\"math inline\">$\\displaystyle\\sum_{n=0}^\\infty a_nx^n$</span> 在\n<span class=\"math inline\"><em>x</em> = <em>R</em></span> 或 <span\nclass=\"math inline\"><em>x</em> = −<em>R</em></span> 收敛，则和函数 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span> 在 <span\nclass=\"math inline\"><em>x</em> = <em>R</em></span> 左连续或 <span\nclass=\"math inline\"><em>x</em> = −<em>R</em></span> 处右连续，即</p>\n<p><span class=\"math display\">$$\n\\displaystyle \\lim_{x\\to R^-}S(x)=S(R)=\\sum_{n=0}^\\infty a_nR^n\n$$</span></p>\n<p><strong>性质：</strong></p>\n<p>若幂函数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nx^n$</span> 的收敛半径为 <span\nclass=\"math inline\"><em>R</em> &gt; 0</span>，在收敛区间 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span> 上的和函数为 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span>，则 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span> 在 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span>\n上可导，且有<strong>逐项求导公式</strong></p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\nS'(x) = &amp;\\left(\\sum_{n=0}^\\infty a_nx^n\\right)'\\\\\n  = &amp;\\sum_{n=0}^\\infty \\left(a_nx^n\\right)'\\\\\n  = &amp;\\sum_{n=0}^\\infty na_nx^{n-1}\\\\\n\\end{aligned}\n$$</span></p>\n<p>且幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\nna_nx^{n-1}$</span> 的收敛半径仍为 <span\nclass=\"math inline\"><em>R</em></span></p>\n<p><strong>性质：</strong></p>\n<p>若幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nx^n$</span> 的收敛半径为 <span\nclass=\"math inline\"><em>R</em> &gt; 0</span>，在收敛区间 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span> 上的和函数为 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span>，则 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span> 在 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span>\n上可导，且有<strong>逐项求积公式</strong></p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n\\int_0^xS(t)\\,\\mathrm{d}t = &amp;\\int_0^x\\left(\\sum_{n=0}^\\infty\na_nt^n\\right)\\,\\mathrm{d}t\\\\\n  = &amp;\\sum_{n=0}^\\infty \\int_0^x a_nt^n\\,\\mathrm{d}t\\\\\n  = &amp;\\sum_{n=0}^\\infty \\frac{a_n}{n+1}x^{n+1}\\\\\n\\end{aligned}\n$$</span></p>\n<p>且幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nt^n$</span> 的收敛半径仍为 <span\nclass=\"math inline\"><em>R</em></span></p>\n<blockquote>\n<ol type=\"1\">\n<li>幂函数逐项求导，逐项积分后，收敛半径不变，但是收敛域可能改变</li>\n<li>幂函数在收敛区间内具有任意阶导数</li>\n</ol>\n</blockquote>\n<h4 id=\"taylor-级数\">Taylor 级数</h4>\n<p><strong>定义：</strong></p>\n<p>设函数 <span class=\"math inline\"><em>f</em>(<em>x</em>)</span> 在\n<span class=\"math inline\"><em>x</em><sub>0</sub></span>\n的某领域内有任意阶导数，称幂级数</p>\n<p><span class=\"math display\">$$\n\\sum_{n=0}^\\infty \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\n$$</span></p>\n<p>为 <span class=\"math inline\"><em>f</em>(<em>x</em>)</span> 在 <span\nclass=\"math inline\"><em>x</em><sub>0</sub></span> 处的\n<strong>Taylor</strong> 级数，记为</p>\n<p><span class=\"math display\">$$\nf(x) = \\sum_{n=0}^\\infty \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\n$$</span></p>\n<p><span class=\"math inline\"><em>x</em><sub>0</sub> = 0</span> 是，称为\n<strong>Maclaurin 级数</strong></p>\n<p><strong>定理（唯一性）</strong></p>\n<p>若 <span class=\"math inline\"><em>f</em>(<em>x</em>)</span> 在 <span\nclass=\"math inline\"><em>x</em><sub>0</sub></span>\n可展开为幂级数，则展开式唯一，且恰为 Taylor 级数</p>\n<p><strong>定理</strong></p>\n<p>设 <span class=\"math inline\"><em>f</em>(<em>x</em>)</span> 在 <span\nclass=\"math inline\"><em>x</em><sub>0</sub></span> 的某领域 <span\nclass=\"math inline\"><em>I</em></span> 内任意阶可导，则在 <span\nclass=\"math inline\"><em>I</em></span> 内</p>\n<p><span class=\"math display\">$$\nf(x) = \\sum_{n=0}^\\infty \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\n\\Leftrightarrow \\lim_{n\\to\\infty}R_n(x) =0\n$$</span></p>\n<h4 id=\"常用的初等函数的幂级数展开式\">常用的初等函数的幂级数展开式</h4>\n<ol type=\"1\">\n<li><span class=\"math inline\">$\\displaystyle e^x = \\sum_{n=0}^\\infty\n\\frac{x^n}{n!} \\quad (x\\in\\mathbb{R})$</span></li>\n<li><span class=\"math inline\">$\\displaystyle \\sin x = \\sum_{n=0}^\\infty\n\\frac{(-1)^nx^{2n+1}}{(2n+1)!} \\quad (x\\in\\mathbb{R})$</span></li>\n<li><span class=\"math inline\">$\\displaystyle \\cos x = \\sum_{n=0}^\\infty\n\\frac{(-1)^nx^{2n}}{(2n)!} \\quad (x\\in\\mathbb{R})$</span></li>\n<li><span class=\"math inline\">$\\displaystyle \\ln(1+x) =\n\\sum_{n=1}^\\infty \\frac{(-1)^{n-1}x^n}{n} \\quad (\\left\\vert x\n\\right\\vert&lt;1)$</span></li>\n<li><span class=\"math inline\">$\\displaystyle (1+x)^\\alpha =\n\\sum_{n=0}^\\infty \\frac{\\alpha(\\alpha-1)\\cdots(\\alpha-n+1)}{n!}x^n \\quad\n(\\left\\vert x\\right\\vert&lt;1)$</span></li>\n<li><span class=\"math inline\">$\\displaystyle \\frac{1}{1-x} =\n\\sum_{n=0}^\\infty x^n \\quad (\\left\\vert x\\right\\vert&lt;1)$</span></li>\n<li><span class=\"math inline\">$\\displaystyle \\frac{1}{1+x} =\n\\sum_{n=0}^\\infty (-1)^nx^n \\quad (\\left\\vert\nx\\right\\vert&lt;1)$</span></li>\n<li><span class=\"math inline\">$\\displaystyle \\arctan{x} =\n\\sum_{n=0}^\\infty \\frac{(-1)^n x^{2n+1}}{2n+1} \\quad (\\left\\vert\nx\\right\\vert\\leq 1)$</span></li>\n</ol>\n<h4 id=\"正弦级数和余弦级数\">正弦级数和余弦级数</h4>\n<p>若周期为 <span class=\"math inline\">2<em>π</em></span> 的函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>)</span> 是奇函数时，其 Fourier\n系数 <span\nclass=\"math inline\"><em>a</em><sub><em>n</em></sub> = 0</span>，从而</p>\n<p><span class=\"math display\">$$\nf(x) \\sim \\sum_{n=1}^{+\\infty}b_n\\sin(nx)\\quad\\text{正弦级数}\n$$</span></p>\n<p>其中 <span class=\"math inline\">$\\displaystyle b_n\n=\\frac{2}{\\pi}\\int_0^\\pi f(x)\\sin(nx) \\,\\mathrm{d}x$</span></p>\n<p>若周期为 <span class=\"math inline\">2<em>π</em></span> 的函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>)</span> 是偶函数，其 Fourier\n系数 <span\nclass=\"math inline\"><em>b</em><sub><em>n</em></sub> = 0</span>，从而</p>\n<p><span class=\"math display\">$$\nf(x) \\sim\n\\frac{a_0}{2}+\\sum_{n=0}^{+\\infty}a_n\\cos(nx)\\quad\\text{余弦级数}\n$$</span></p>\n<p>其中 <span class=\"math inline\">$\\displaystyle a_n\n=\\frac{1}{\\pi}\\int_0^\\pi f(x)\\cos(nx) \\,\\mathrm{d}x$</span></p>\n<p>若函数 <span class=\"math inline\"><em>f</em>(<em>x</em>)</span> 定义在\n<span class=\"math inline\">[0, <em>π</em>]</span> 上，可作奇延拓</p>\n<p><span class=\"math display\">$$\nF(x)=\n\\begin{cases}\n  f(x), &amp; 0&lt; x&lt; \\pi\\\\\n  -f(-x), &amp; -\\pi &lt; x &lt; 0\\\\\n  0, &amp; x=0,\\pm\\pi\\\\\n\\end{cases}\n$$</span></p>\n<p>使得 <span class=\"math inline\"><em>F</em>(<em>x</em>)</span> 为 <span\nclass=\"math inline\">[−<em>π</em>, <em>π</em>]</span> 上的奇函数</p>\n<p>也可作偶延拓</p>\n<p><span class=\"math display\">$$\nG(x)=\n\\begin{cases}\n  f(x), &amp; 0&lt; x&lt; \\pi\\\\\n  f(-x), &amp; -\\pi &lt; x &lt; 0\\\\\n  0, &amp; x=0,\\pm\\pi\\\\\n\\end{cases}\n$$</span></p>\n<p>使得函数 <span class=\"math inline\"><em>G</em>(<em>x</em>)</span> 为\n<span class=\"math inline\">[−<em>π</em>, <em>π</em>]</span>\n上的偶函数</p>\n<p>对于一定义在 <span class=\"math inline\">[0, <em>π</em>]</span>\n上的函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>)</span>，可以对其先做奇延拓或者偶延拓，再将其展开为\n正弦级数或者余弦级数</p>\n<h4 id=\"周期为-2l-的-fourier-级数\">周期为 <span\nclass=\"math inline\">2<em>l</em></span> 的 Fourier 级数</h4>\n<p>设函数 <span class=\"math inline\"><em>f</em>(<em>x</em>)</span> 在区间\n<span class=\"math inline\">[−<em>l</em>, <em>l</em>]</span>\n上可积，作代换 <span class=\"math inline\">$x\n=\\frac{l}{\\pi}t$</span>，使得 <span class=\"math inline\">$F(t) =\nf\\left(\\frac{l}{\\pi}t\\right)$</span> 为 <span\nclass=\"math inline\">[−<em>π</em>, <em>π</em>]</span>\n上的可积函数，从而</p>\n<p><span class=\"math display\">$$\nF(t) \\sim\n\\frac{a_0}{2}+\\sum_{n=1}^{+\\infty}a_n\\cos(nt)+\\sum_{n=1}^{+\\infty}b_n\\sin(nt)\n$$</span></p>\n<p>其中</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\na_n &amp;= \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}F(t)\\cos(nt)\\,\\mathrm{d}t =\n\\frac{1}{l}\\int_{-l}^{l}f(x)\\cos\\left(\\frac{\\pi\nn}{l}x\\right)\\,\\mathrm{d}x\\\\\nb_n &amp;= \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}F(t)\\sin(nt)\\,\\mathrm{d}t =\n\\frac{1}{l}\\int_{-l}^{l}f(x)\\sin\\left(\\frac{\\pi\nn}{l}x\\right)\\,\\mathrm{d}x\n\\end{aligned}\n$$</span></p>\n<p>故</p>\n<p><span class=\"math display\">$$\nf(x) \\sim \\frac{a_0}{2}+\\sum_{n=1}^{+\\infty}\\left(a_n\\cos\\left(\\frac{\\pi\nn}{l}x\\right)+b_n\\sin\\left(\\frac{\\pi n}{l}x\\right)\\right)\n$$</span></p>\n<p>其中</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\na_n &amp;= \\frac{1}{l}\\int_{-l}^{l}f(x)\\cos\\left(\\frac{\\pi\nn}{l}x\\right)\\,\\mathrm{d}x\\\\\nb_n &amp;= \\frac{1}{l}\\int_{-l}^{l}f(x)\\sin\\left(\\frac{\\pi\nn}{l}x\\right)\\,\\mathrm{d}x\n\\end{aligned}\n$$</span></p>\n<p><strong>定理：</strong></p>\n<p>若 <span class=\"math inline\"><em>f</em>(<em>x</em>)</span> 在 <span\nclass=\"math inline\">[−<em>l</em>, <em>l</em>]</span> 上满足 Dirichlet\n条件，则 Fourier 级数</p>\n<p><span class=\"math display\">$$\n\\frac{a_0}{2}+\\sum_{n=1}^{+\\infty}\\left(a_n\\cos\\left(\\frac{\\pi\nn}{l}x\\right)+b_n\\sin\\left(\\frac{\\pi n}{l}x\\right)\\right)\n$$</span></p>\n<p>收敛到</p>\n<p><span class=\"math display\">$$\nS(n) =\n\\begin{cases}\n  f(x), &amp; x \\text{为} f(x) \\text{的连续点}\\\\\n  \\frac{f(x^+)+f(x^-)}{2}, &amp; x \\text{为} f(x) \\text{的间断点}\\\\\n  \\frac{f(l^-)+f(-l^+)}{2} ,&amp; x=\\pm l\n\\end{cases}\n$$</span></p>\n","excerpt":"","more":"<h2 id=\"重积分\">重积分</h2>\n<h3 id=\"重积分的概念和性质\">重积分的概念和性质</h3>\n<h4 id=\"二重积分的概念\">二重积分的概念</h4>\n<p><strong>定义：</strong></p>\n<p>设 <span class=\"math inline\"><em>D</em></span>\n是平面上的有界闭区域，<span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 为 <span\nclass=\"math inline\"><em>D</em></span> 上的有界函数，<span\nclass=\"math inline\"><em>I</em></span> 为实数.若对 <span\nclass=\"math inline\"><em>D</em></span> 的任意分割 <span\nclass=\"math inline\"><em>Δ</em><em>D</em><sub>1</sub>, <em>Δ</em><em>D</em><sub>2</sub>, ⋯, <em>Δ</em><em>D</em><sub><em>n</em></sub></span>\n，任取 <span\nclass=\"math inline\">(<em>ξ</em><sub><em>i</em></sub>, <em>η</em><sub><em>i</em></sub>) ∈ <em>Δ</em><em>D</em><sub><em>i</em></sub>(<em>i</em> = 1, …, <em>n</em>)</span>，作和\n<span\nclass=\"math inline\">$\\displaystyle\\sum_{i=1}^nf(\\xi_i,\\eta_i)\\Delta\n\\sigma_i$</span> （<span\nclass=\"math inline\"><em>Δ</em><em>σ</em><sub><em>i</em></sub></span> 为\n<span class=\"math inline\"><em>D</em><sub><em>i</em></sub></span>\n的面积），总有</p>\n<p><span class=\"math display\">$$\n\\lim_{\\lambda\\to 0}\\sum_{i=1}^nf(\\xi_i,\\eta_i)\\Delta \\sigma_i = I\n$$</span></p>\n<p>其中 <span\nclass=\"math inline\"><em>λ</em> = max<sub>1 ≤ <em>i</em> ≤ <em>d</em></sub>{<em>d</em><sub><em>i</em></sub>}</span>，<span\nclass=\"math inline\"><em>d</em><sub><em>i</em></sub></span> 是小区域\n<span\nclass=\"math inline\"><em>Δ</em><em>D</em><sub><em>i</em></sub></span>\n的直径，则称函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在 <span\nclass=\"math inline\"><em>D</em></span> 上<strong>可积</strong>，记为\n<span\nclass=\"math inline\"><em>f</em> ∈ <em>R</em>(<em>D</em>)</span>；极限值\n<span class=\"math inline\"><em>I</em></span> 称为 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在 <span\nclass=\"math inline\"><em>D</em></span>\n上的<strong>二重积分</strong>，记作</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em>.</span></p>\n<ul>\n<li><p><span class=\"math inline\">∬</span> 积分号</p></li>\n<li><p><span class=\"math inline\"><em>D</em></span> 积分区域</p></li>\n<li><p><span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span>\n被积函数</p></li>\n<li><p><span class=\"math inline\">d<em>σ</em></span>\n面积元素（微元）</p></li>\n<li><p>二重积分的几何意义</p>\n<ul>\n<li>当被积函数大于 <span class=\"math inline\">0</span>\n时，二重积分是柱体体积</li>\n<li>当被积函数小于 <span class=\"math inline\">0</span>\n时，二重积分是柱体体积的负值</li>\n<li>一般的，为曲顶柱体体积的代数和</li>\n</ul></li>\n<li><p>可积的充分条件</p>\n<ul>\n<li><strong>定理：</strong> 若函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在区域\n<span class=\"math inline\"><em>D</em></span> 上连续，则 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>) ∈ <em>D</em></span>.</li>\n</ul></li>\n<li><p><span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在 <span\nclass=\"math inline\"><em>D</em></span> 上的可积性及积分值与其在 <span\nclass=\"math inline\"><em>D</em></span>\n内<strong>有限条光滑曲线</strong>上的定义无关</p></li>\n</ul>\n<h3 id=\"二重积分的性质\">二重积分的性质</h3>\n<ol type=\"1\">\n<li><p><span\nclass=\"math inline\">∬<sub><em>D</em></sub> d<em>σ</em> = ∬<sub><em>D</em></sub>1 d<em>σ</em> = <em>A</em><sub><em>D</em></sub>  (D\n的面积)</span>.</p></li>\n<li><p><strong>线性性：</strong> 设 <span\nclass=\"math inline\"><em>f</em>, <em>g</em> ∈ <em>R</em>(<em>D</em>)</span>，<span\nclass=\"math inline\"><em>α</em>, <em>β</em></span>，是任意常数，则 <span\nclass=\"math inline\"><em>α</em><em>f</em> + <em>β</em><em>g</em> ∈ <em>R</em>(<em>D</em>)</span>，且</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub>(<em>α</em><em>f</em> + <em>β</em><em>g</em>) d<em>σ</em> = <em>α</em>∬<sub><em>D</em></sub><em>f</em> d<em>σ</em> + <em>β</em>∬<sub><em>D</em></sub><em>g</em> d<em>σ</em></span></p></li>\n<li><p><strong>区域可加性：</strong> 若 <span\nclass=\"math inline\"><em>f</em> ∈ <em>R</em>(<em>D</em>)</span>\n且积分区域 <span class=\"math inline\"><em>D</em></span>\n分为内部不相交的子区域 <span\nclass=\"math inline\"><em>D</em><sub>1</sub>, <em>D</em><sub>2</sub></span>，则</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> = ∬<sub><em>D</em><sub>1</sub></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> + ∬<sub><em>D</em><sub>2</sub></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em></span></p></li>\n<li><p><strong>保序性：</strong> 若 <span\nclass=\"math inline\"><em>f</em>, <em>g</em> ∈ <em>R</em>(<em>D</em>)</span>，且当\n<span class=\"math inline\">(<em>x</em>, <em>y</em>) ∈ <em>D</em></span>\n时，<span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>) ≤ <em>g</em>(<em>x</em>, <em>y</em>)</span>，则</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> ≤ ∬<sub><em>D</em></sub><em>g</em>(<em>x</em>, <em>y</em>) d<em>σ</em></span></p>\n<ul>\n<li><strong>推论 1：</strong> 若 <span\nclass=\"math inline\"><em>f</em> ∈ <em>R</em>(<em>D</em>)</span> ,则 <span\nclass=\"math inline\">|<em>f</em>(<em>x</em>, <em>y</em>)| ∈ <em>R</em>(<em>D</em>)</span>，且</li>\n</ul>\n<p><span\nclass=\"math display\">|∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em>| ≤ ∬<sub><em>D</em></sub>|<em>f</em>(<em>x</em>, <em>y</em>)| d<em>σ</em></span></p>\n<ul>\n<li><strong>推论 2：</strong> 若 <span\nclass=\"math inline\"><em>f</em> ∈ <em>R</em>(<em>D</em>)</span>，且当\n<span class=\"math inline\">(<em>x</em>, <em>y</em>) ∈ <em>D</em></span>\n时， <span\nclass=\"math inline\"><em>m</em> ≤ <em>f</em>(<em>x</em>, <em>y</em>) ≤ <em>M</em></span>，则</li>\n</ul>\n<p><span\nclass=\"math display\"><em>m</em><em>A</em><sub><em>D</em></sub> ≤ ∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> ≤ <em>M</em><em>A</em><sub><em>D</em></sub></span></p>\n<ul>\n<li><strong>推论 3：</strong> 若 <span\nclass=\"math inline\"><em>f</em> ∈ <em>R</em>(<em>D</em>)</span>，且当\n<span class=\"math inline\">(<em>x</em>, <em>y</em>) ∈ <em>D</em></span>\n时，<span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>) ≥ 0</span>，则</li>\n</ul>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> ≥ 0</span></p></li>\n<li><p><strong>积分中值定理：</strong> 若 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>) ∈ <em>C</em>(<em>D</em>)</span>\n，<span\nclass=\"math inline\"><em>g</em>(<em>x</em>, <em>y</em>) ∈ <em>R</em>(<em>D</em>)</span>，且\n<span class=\"math inline\"><em>g</em></span> 在 <span\nclass=\"math inline\"><em>D</em></span> 上不变号，则 <span\nclass=\"math inline\">∃<em>ξ</em>, <em>η</em> ∈ <em>D</em></span>，使得</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>)<em>g</em>(<em>x</em>, <em>y</em>) d<em>σ</em> = <em>f</em>(<em>ξ</em>, <em>η</em>)∬<sub><em>D</em></sub><em>g</em>(<em>x</em>, <em>y</em>) d<em>σ</em></span></p>\n<ul>\n<li><strong>推论：</strong> 若 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>) ∈ <em>C</em>(<em>D</em>)</span>，则存在\n<span\nclass=\"math inline\">(<em>ξ</em>, <em>η</em>) ∈ <em>D</em></span>，使得</li>\n</ul>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> = <em>f</em>(<em>ξ</em>, <em>η</em>)<em>A</em><sub><em>D</em></sub></span></p>\n<p>称 <span class=\"math inline\">$f(\\xi,\\eta) = \\frac{\\iint_D\nf\\,\\mathrm{d}\\sigma}{A_D}$</span> 为函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span>\n在有界闭区域 <span class=\"math inline\"><em>D</em></span>\n上的<strong>平均值</strong></p></li>\n</ol>\n<h3 id=\"二重积分的计算\">二重积分的计算</h3>\n<h4 id=\"直角坐标系下的计算\">直角坐标系下的计算</h4>\n<p>当二重积分存在时，可利用平行于坐标轴的直线来划分积分区域 <span\nclass=\"math inline\"><em>D</em></span>，此时，面积元素</p>\n<p><span\nclass=\"math display\">d<em>σ</em> = d<em>x</em>d<em>y</em></span></p>\n<p>故二重积分在直角坐标系下可表示为</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> = ∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>x</em>d<em>y</em></span></p>\n<h5 id=\"x-型正则区域\"><span class=\"math inline\"><em>x</em></span>\n型正则区域</h5>\n<p><span\nclass=\"math display\"><em>D</em> = {(<em>x</em>, <em>y</em>)|<em>φ</em><sub>1</sub>(<em>x</em>) ≤ <em>y</em> ≤ <em>φ</em><sub>2</sub>(<em>x</em>), <em>a</em> ≤ <em>x</em> ≤ <em>b</em>}</span></p>\n<p>化为先 <span class=\"math inline\"><em>y</em></span> 后 <span\nclass=\"math inline\"><em>x</em></span> 的二次积分</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n    \\iint_D f(x,y)\\,\\mathrm{d}x\\mathrm{d}y &amp;=\n\\int_a^b\\left[\\int_{\\varphi_1(x)}^{\\varphi_2(x)}\nf(x,y)\\,\\mathrm{d}y\\right]\\mathrm{d}x \\\\\n    &amp;\\equiv \\int_a^b f(x,y)\\,\\mathrm{d}x\\mathrm{d}y\n\\end{aligned}\n$$</span></p>\n<h5 id=\"y-型正则区域\"><span class=\"math inline\"><em>y</em></span>\n型正则区域</h5>\n<p><span\nclass=\"math display\"><em>D</em> = {(<em>x</em>, <em>y</em>)|<em>φ</em><sub>1</sub>(<em>y</em>) ≤ <em>x</em> ≤ <em>φ</em><sub>2</sub>(<em>y</em>), <em>c</em> ≤ <em>y</em> ≤ <em>d</em>}</span></p>\n<p>化为先 <span class=\"math inline\"><em>x</em></span> 后 <span\nclass=\"math inline\"><em>y</em></span> 的二次积分</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n    \\iint_D f(x,y)\\,\\mathrm{d}x\\mathrm{d}y &amp;=\n\\int_c^d\\left[\\int_{\\varphi_1(y)}^{\\varphi_2(y)}\nf(x,y)\\,\\mathrm{d}x\\right]\\mathrm{d}y \\\\\n    &amp;\\equiv \\int_c^d f(x,y)\\,\\mathrm{d}x\\mathrm{d}y\n\\end{aligned}\n$$</span></p>\n<h5 id=\"一般区域的二重积分\">一般区域的二重积分</h5>\n<p>分割成若干个正则子区域，利用积分区域可加性，分别在子区域上积分后求和</p>\n<blockquote>\n<p>直角坐标计算二重积分的步骤</p>\n<ol type=\"1\">\n<li><strong>画出积分区域</strong> <span\nclass=\"math inline\"><em>D</em></span>\n的草图，并<strong>确定类型</strong></li>\n<li>按照所确定的类型<strong>表示区域</strong> <span\nclass=\"math inline\"><em>D</em></span></li>\n<li><strong>化二重积分为二次积分</strong>（注意上下限）</li>\n<li><strong>计算</strong>二重积分</li>\n</ol>\n</blockquote>\n<h4 id=\"极坐标系下的计算\">极坐标系下的计算</h4>\n<p>当积分区域的边界曲线或被积函数用极坐标表示较为简单时，可用极坐标来计算二重积分.</p>\n<p>面积元素 <span class=\"math inline\"><em>Δ</em><em>σ</em></span>\n在极坐标下为</p>\n<p><span class=\"math display\">$$\n\\boxed{\\Delta\\sigma= r\\mathrm{d}r\\mathrm{d}\\theta}\n$$</span></p>\n<p>从直角坐标到极坐标时的二重积分变换公式为</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> = ∬<sub><em>D</em></sub><em>f</em>(<em>r</em>cos <em>θ</em>, <em>r</em>sin <em>θ</em>)<em>r</em> d<em>r</em>d<em>θ</em></span></p>\n<p><span\nclass=\"math display\">{(<em>r</em>, <em>θ</em>)|<em>r</em><sub>1</sub>(<em>θ</em>) ≤ <em>r</em> ≤ <em>r</em><sub>2</sub>(<em>θ</em>), <em>α</em> ≤ <em>θ</em> ≤ <em>β</em>}</span></p>\n<p>则</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> = ∫<sub><em>α</em></sub><sup><em>β</em></sup> d<em>θ</em>∫<sub><em>r</em><sub>1</sub>(<em>θ</em>)</sub><sup><em>r</em><sub>2</sub>(<em>θ</em>)</sup><em>f</em>(<em>r</em>cos <em>θ</em>, <em>r</em>sin <em>θ</em>)<em>r</em> d<em>r</em></span></p>\n<h4 id=\"二重积分的变量代换\">二重积分的变量代换</h4>\n<p><strong>定理：</strong></p>\n<p>设变换 <span class=\"math inline\">$\\displaystyle T\n:\\begin{cases}x=x(u,v)\\\\y=y(u,v)\\end{cases}$</span> 有连续偏导数，且满足\n<span class=\"math inline\">$\\displaystyle J = \\frac{\\partial\n(x,y)}{\\partial (u,v)}\\coloneqq \\begin{vmatrix}x_u ,x_v\\newline\ny_u,y_v\\end{vmatrix} \\left(\\text{Jacobi 行列式}\\right)\\neq 0$</span>，而\n<span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>) ∈ <em>C</em>(<em>D</em>)</span>，则</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>σ</em> = ∬<sub><em>D</em><sup>*</sup></sub><em>f</em>(<em>x</em>(<em>u</em>, <em>v</em>), <em>y</em>(<em>u</em>, <em>v</em>))|<em>J</em>| d<em>u</em>d<em>v</em></span></p>\n<ul>\n<li><p>在定理条件下，变换 <span class=\"math inline\"><em>T</em></span>\n一定存在逆变换 <span\nclass=\"math inline\">$T^{-1}:\\begin{cases}u=u(x,y)\\\\v=v(x,y)\\end{cases}$</span>，且\n<span class=\"math inline\">$\\frac{\\partial (u,v)}{\\partial (x,y)}\\cdot\n\\frac{\\partial (x,y)}{\\partial (u,v)} = 1$</span></p>\n<p>有时，借助此式求 <span class=\"math inline\"><em>J</em></span>\n较为简单</p></li>\n<li><p>当 Jacobi 行列式仅在区域 <span\nclass=\"math inline\"><em>D</em><sup>*</sup></span>\n内个别点上或个别曲线上为 <span class=\"math inline\">0</span>\n时，定理结论仍成立</p></li>\n<li><p>在广义极坐标 <span\nclass=\"math inline\">$\\begin{cases}x=ar\\cos\\theta\\\\y=br\\sin\\theta\\end{cases}$</span>\n下，<span\nclass=\"math inline\"><em>J</em> = <em>a</em><em>b</em><em>r</em></span></p></li>\n</ul>\n<h3 id=\"三重积分\">三重积分</h3>\n<h4 id=\"三重积分的定义\">三重积分的定义</h4>\n<p><strong>定义：</strong></p>\n<p>设 <span class=\"math inline\"><em>Ω</em></span> 是 <span\nclass=\"math inline\">ℝ<sup>3</sup></span> 中的有界闭区域，三元函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>\n在 <span class=\"math inline\"><em>Ω</em></span> 上有界，<span\nclass=\"math inline\"><em>I</em></span> 为实数. 若将 <span\nclass=\"math inline\"><em>Ω</em></span> 任意分割成 <span\nclass=\"math inline\"><em>n</em></span> 个小区域 <span\nclass=\"math inline\"><em>Δ</em><em>Ω</em><sub>1</sub>, <em>Δ</em><em>Ω</em><sub>2</sub>, …, <em>Δ</em><em>Ω</em><sub><em>n</em></sub></span>，任取\n<span class=\"math inline\">$\\left(\\varepsilon_i,\\eta_i,\\xi_i\n\\right)\\in\\Delta\\Omega_i\\left(i=1,2,\\ldotp,n\\right)$</span>，作和 <span\nclass=\"math inline\">$\\displaystyle\\sum_{i=1}^nf\\left(\\varepsilon_i,\\eta_i,\\xi_i\n\\right)\\Delta V_i$</span>，（<span\nclass=\"math inline\"><em>Δ</em><em>V</em><sub><em>i</em></sub></span> 是\n<span\nclass=\"math inline\"><em>Δ</em><em>Ω</em><sub><em>i</em></sub></span>\n的体积），总有</p>\n<p><span class=\"math display\">$$\n\\lim_{\\lambda\\to 0}\\sum_{i=1}^nf\\left(\\varepsilon_i,\\eta_i,\\xi_i\n\\right)\\Delta V_i = I\n$$</span></p>\n<p>其中 <span\nclass=\"math inline\"><em>λ</em> = max<sub>1 ≤ <em>i</em> ≤ <em>n</em></sub>{<em>d</em><sub><em>i</em></sub>}</span>，<span\nclass=\"math inline\"><em>d</em><sub><em>i</em></sub></span> 是 <span\nclass=\"math inline\"><em>Δ</em><em>Ω</em><sub><em>i</em></sub></span>\n的直径，则称函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>\n在 <span class=\"math inline\"><em>Ω</em></span>\n上<strong>可积</strong>，记为 <span\nclass=\"math inline\"><em>f</em> ∈ <em>R</em>(<em>Ω</em>)</span>； <span\nclass=\"math inline\"><em>I</em></span> 称为 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>\n在 <span class=\"math inline\"><em>Ω</em></span>\n上的<strong>三重积分</strong>，记作</p>\n<p><span\nclass=\"math display\">∭<sub><em>Ω</em></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>V</em></span></p>\n<p>其中 <span class=\"math inline\"><em>V</em><sub><em>Ω</em></sub></span>\n是区域 <span class=\"math inline\"><em>Ω</em></span> 的体积</p>\n<ul>\n<li>若 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>\n表示占有三维空间区域 <span class=\"math inline\"><em>Ω</em></span>\n的物体的体密度函数，则 <span\nclass=\"math inline\">∭<sub><em>Ω</em></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>V</em></span>\n给出了物体的<strong>质量</strong></li>\n<li>类似二重积分，三重积分具有线性性，区域可加性，保序性以及推论和积分中值定理，并且有\n<span\nclass=\"math inline\">∭<sub><em>Ω</em></sub> d<em>V</em> = <em>V</em><sub><em>Ω</em></sub></span></li>\n</ul>\n<h4 id=\"直角坐标系下的计算-1\">直角坐标系下的计算</h4>\n<p>直角坐标系下，由于 <span\nclass=\"math inline\">d<em>V</em> = d<em>x</em>d<em>y</em>d<em>z</em></span>，故</p>\n<p><span\nclass=\"math display\">∭<sub><em>Ω</em></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>V</em> = ∭<sub><em>Ω</em></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>x</em>d<em>y</em>d<em>z</em></span></p>\n<h5 id=\"柱线法坐标面投影法\">柱线法（坐标面投影法）</h5>\n<p>设 <span class=\"math inline\"><em>Ω</em></span> 是以曲面 <span\nclass=\"math inline\"><em>z</em> = <em>z</em><sub>1</sub>(<em>x</em>, <em>y</em>)</span>\n为底，曲面 <span\nclass=\"math inline\"><em>x</em> = <em>x</em><sub>2</sub>(<em>x</em>, <em>y</em>)</span>，而侧面是母线平行于\n<span class=\"math inline\"><em>z</em></span> 轴的柱体所围成的区域</p>\n<p>设 <span class=\"math inline\"><em>Ω</em></span> 在 <span\nclass=\"math inline\"><em>x</em><em>O</em><em>y</em></span>\n面上的投影区域为 <span class=\"math inline\"><em>D</em><sub>1</sub></span>\n，则 <span class=\"math inline\"><em>Ω</em></span> 可表示为</p>\n<p><span\nclass=\"math display\"><em>Ω</em> = {(<em>x</em>, <em>y</em>, <em>z</em>)|(<em>x</em>, <em>y</em>) ∈ <em>D</em><sub>1</sub>, <em>z</em><sub>1</sub>(<em>x</em>, <em>y</em>) ≤ <em>z</em> ≤ <em>z</em><sub>2</sub>(<em>x</em>, <em>y</em>)(<em>x</em>, <em>y</em>) ∈ <em>D</em>}</span></p>\n<p>则物体总质量为</p>\n<p><span\nclass=\"math display\">∬<sub><em>D</em></sub>(∫<sub><em>z</em><sub>1</sub>(<em>x</em>, <em>y</em>)</sub><sup><em>z</em><sub>2</sub>(<em>x</em>, <em>y</em>)</sup><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>z</em>) d<em>x</em>d<em>y</em></span></p>\n<p>故有</p>\n<p><span\nclass=\"math display\">∭<sub><em>Ω</em></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>V</em> = ∬<sub><em>D</em><sub>1</sub></sub> d<em>x</em>d<em>y</em>∫<sub><em>z</em><sub>1</sub>(<em>x</em>, <em>y</em>)</sub><sup><em>z</em><sub>2</sub>(<em>x</em>, <em>y</em>)</sup><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>z</em></span></p>\n<h5 id=\"截面法坐标轴投影法\">截面法（坐标轴投影法）</h5>\n<p>设区域 <span class=\"math inline\"><em>Ω</em></span> 在 <span\nclass=\"math inline\"><em>z</em></span> 轴上的投影区间为 <span\nclass=\"math inline\">[<em>h</em><sub>1</sub>, <em>h</em><sub>2</sub>]</span>，即\n<span class=\"math inline\"><em>Ω</em></span> 介于平面 <span\nclass=\"math inline\"><em>z</em> = <em>h</em><sub>1</sub></span> 和 <span\nclass=\"math inline\"><em>z</em> = <em>h</em><sub>2</sub></span> 之间，过\n<span class=\"math inline\"><em>z</em></span> 处且垂直于 <span\nclass=\"math inline\"><em>z</em></span> 轴的平面截 <span\nclass=\"math inline\"><em>Ω</em></span> 得截面区域 <span\nclass=\"math inline\"><em>D</em><sub><em>z</em></sub></span>，则 <span\nclass=\"math inline\"><em>Ω</em></span> 可表示为</p>\n<p><span\nclass=\"math display\"><em>Ω</em> = {(<em>x</em>, <em>y</em>, <em>z</em>)|<em>h</em><sub>1</sub> ≤ <em>z</em> ≤ <em>h</em><sub>2</sub>, (<em>x</em>, <em>y</em>) ∈ <em>D</em><sub><em>z</em></sub>}</span></p>\n<p>物体总质量为</p>\n<p><span\nclass=\"math display\">∫<sub><em>h</em><sub>1</sub></sub><sup><em>h</em><sub>2</sub></sup>(∬<sub><em>D</em><sub><em>z</em></sub></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>x</em>d<em>y</em>) d<em>z</em></span></p>\n<p>故有</p>\n<p><span\nclass=\"math display\">∭<sub><em>Ω</em></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>V</em> = ∫<sub><em>h</em><sub>1</sub></sub><sup><em>h</em><sub>2</sub></sup> d<em>z</em>∬<sub><em>D</em><sub><em>z</em></sub></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>x</em>d<em>y</em></span></p>\n<h4 id=\"三重积分的变量代换\">三重积分的变量代换</h4>\n<p><strong>定理：</strong></p>\n<p>设变换 <span\nclass=\"math inline\">$T:\\begin{cases}x=x(u,v,w)\\\\y=y(u,v,w)\\\\z=z(u,v,w)\\end{cases}$</span>\n有连续偏导数，且满足 <span class=\"math inline\">$J=\\frac{\\partial\n(x,y,z)}{\\partial (u,v,w)}\\neq 0$</span>，而 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) ∈ <em>C</em>(<em>Ω</em>)</span>，则</p>\n<p><span\nclass=\"math display\">∭<sub><em>Ω</em></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>V</em> = ∭<sub><em>Ω</em><sup>*</sup></sub><em>f</em>(<em>x</em>(<em>u</em>, <em>v</em>, <em>w</em>), <em>y</em>(<em>u</em>, <em>v</em>, <em>w</em>), <em>z</em>(<em>u</em>, <em>v</em>, <em>w</em>))|<em>J</em>| d<em>u</em>d<em>v</em>d<em>w</em></span></p>\n<h5 id=\"柱面坐标系下的计算\">柱面坐标系下的计算</h5>\n<p>柱面坐标系，实际上就是将 <span\nclass=\"math inline\"><em>x</em>, <em>y</em></span> 坐标转换为极坐标</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\nx = r\\cos\\theta\\\\\ny = r\\sin\\theta\\\\\nz = z\n\\end{cases}\n$$</span></p>\n<p>其 Jacobi 行列式为</p>\n<p><span class=\"math display\">$$\nJ = \\frac{\\partial (x,y,z)}{\\partial (r,\\theta,z)} = \\begin{vmatrix}\n\\cos\\theta &amp; -r\\sin\\theta &amp; 0\\\\\n\\sin\\theta &amp; r\\cos\\theta &amp; 0\\\\\n0 &amp; 0 &amp; 1\n\\end{vmatrix} = r\n$$</span></p>\n<p>则柱面积分积分公式为</p>\n<p><span\nclass=\"math display\">∭<sub><em>Ω</em></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>V</em> = ∭<sub><em>Ω</em><sup>*</sup></sub><em>f</em>(<em>r</em>cos <em>θ</em>, <em>r</em>sin <em>θ</em>, <em>z</em>)<em>r</em> d<em>r</em>d<em>θ</em>d<em>z</em></span></p>\n<h5 id=\"球面坐标系下的计算\">球面坐标系下的计算</h5>\n<p>球面坐标系，实际上就是将 <span\nclass=\"math inline\"><em>x</em>, <em>y</em>, <em>z</em></span>\n坐标转换为球坐标</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\nx = \\rho\\sin\\varphi\\cos\\theta\\\\\ny = \\rho\\sin\\varphi\\sin\\theta\\\\\nz = \\rho\\cos\\varphi\n\\end{cases}\n$$</span></p>\n<p>其 Jacobi 行列式为</p>\n<p><span class=\"math display\">$$\nJ = \\frac{\\partial (x,y,z)}{\\partial (\\rho,\\varphi,\\theta)} =\n\\begin{vmatrix}\n\\sin\\varphi\\cos\\theta &amp; \\rho\\cos\\varphi\\cos\\theta &amp;\n-\\rho\\sin\\varphi\\sin\\theta\\\\\n\\sin\\varphi\\sin\\theta &amp; \\rho\\cos\\varphi\\sin\\theta &amp;\n\\rho\\sin\\varphi\\cos\\theta\\\\\n\\cos\\varphi &amp; -\\rho\\sin\\varphi &amp; 0\n\\end{vmatrix} = \\rho^2\\sin\\varphi\n$$</span></p>\n<p>则球面积分积分公式为</p>\n<p><span\nclass=\"math display\">∭<sub><em>Ω</em></sub><em>f</em>(<em>x</em>, <em>y</em>, <em>z</em>) d<em>V</em> = ∭<sub><em>Ω</em><sup>*</sup></sub><em>f</em>(<em>ρ</em>sin <em>φ</em>cos <em>θ</em>, <em>ρ</em>sin <em>φ</em>sin <em>θ</em>, <em>ρ</em>cos <em>φ</em>)<em>ρ</em><sup>2</sup>sin <em>φ</em> d<em>ρ</em>d<em>φ</em>d<em>θ</em></span></p>\n<h3 id=\"重积分的应用\">重积分的应用</h3>\n<h4 id=\"重积分的几何应用\">重积分的几何应用</h4>\n<h5 id=\"平面图形的面积\">平面图形的面积</h5>\n<p><span\nclass=\"math display\"><em>A</em>(<em>D</em>) = ∬<sub><em>D</em></sub> d<em>σ</em> = ∬<sub><em>D</em></sub> d<em>x</em>d<em>y</em></span></p>\n<h5 id=\"立体的体积\">立体的体积</h5>\n<p><span\nclass=\"math display\"><em>V</em>(<em>Ω</em>) = ∭<sub><em>Ω</em></sub> d<em>V</em> = ∭<sub><em>Ω</em></sub> d<em>x</em>d<em>y</em>d<em>z</em></span></p>\n<h5 id=\"曲面的面积\">曲面的面积</h5>\n<p>设空间曲面 <span\nclass=\"math inline\"><em>S</em> : <em>z</em> = <em>f</em>(<em>x</em>, <em>y</em>), (<em>x</em>, <em>y</em>) ∈ <em>D</em></span>.</p>\n<p>则曲面 <span class=\"math inline\"><em>S</em></span> 的面积为</p>\n<p><span class=\"math display\">$$\nA(S) = \\iint_D \\sqrt{1+z_x^2+z_y^2}\\,\\mathrm{d}x\\mathrm{d}y\n$$</span></p>\n<h4 id=\"重积分的物理应用\">重积分的物理应用</h4>\n<h6 id=\"质心\">质心</h6>\n<p>体密度为 <span\nclass=\"math inline\"><em>ρ</em>(<em>x</em>, <em>y</em>)</span>\n的物体占据空间 <span\nclass=\"math inline\"><em>Ω</em></span>，其质心坐标为</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\displaystyle\\bar{x} = \\frac{\\iiint_\\Omega\nx\\rho(x,y,z)\\,\\mathrm{d}V}{\\iiint_\\Omega\\mu(x,y,z)\\,\\mathrm{d}V} \\\\\n  \\displaystyle\\bar{y} = \\frac{\\iiint_\\Omega\ny\\rho(x,y,z)\\,\\mathrm{d}V}{\\iiint_\\Omega\\mu(x,y,z)\\,\\mathrm{d}V}\\\\\n  \\displaystyle\\bar{z} = \\frac{\\iiint_\\Omega\nz\\rho(x,y,z)\\,\\mathrm{d}V}{\\iiint_\\Omega\\mu(x,y,z)\\,\\mathrm{d}V}\n\\end{cases}\n$$</span></p>\n<h5 id=\"转动惯量\">转动惯量</h5>\n<p>设物体的密度为 <span\nclass=\"math inline\"><em>ρ</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>，则物体分别关于\n<span class=\"math inline\"><em>x</em></span>，<span\nclass=\"math inline\"><em>y</em></span>，<span\nclass=\"math inline\"><em>z</em></span> 轴的转动惯量为</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  I_x = \\iiint_\\Omega \\rho(x,y,z)(y^2+z^2)\\,\\mathrm{d}V\\\\\n  I_y = \\iiint_\\Omega \\rho(x,y,z)(x^2+z^2)\\,\\mathrm{d}V\\\\\n  I_z = \\iiint_\\Omega \\rho(x,y,z)(x^2+y^2)\\,\\mathrm{d}V\n\\end{cases}\n$$</span></p>\n<h5 id=\"引力\">引力</h5>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  &amp;\\mathrm{d}\\vec{F} = G\\frac{m_0\\mathrm{d}m}{r^3}\\vec{r}\\\\\n  =&amp;\nG\\frac{m_0\\rho(x,y,z)\\mathrm{d}V}{r^3}\\cdot\\left(x-x_0,y-y_0,z-z_0\\right)\\\\\n  =&amp;\\left(\\mathrm{d}F_x,\\mathrm{d}F_y,\\mathrm{d}F_z\\right)\n\\end{aligned}\n$$</span></p>\n<h2 id=\"曲线积分和曲面积分\">曲线积分和曲面积分</h2>\n<h3 id=\"第一类曲线积分和曲面积分\">第一类曲线积分和曲面积分</h3>\n<h4 id=\"第一类曲线积分的概念\">第一类曲线积分的概念</h4>\n<p><strong>定义：</strong></p>\n<p>设 <span class=\"math inline\"><em>C</em></span> 是 <span\nclass=\"math inline\"><em>x</em><em>O</em><em>y</em></span>\n面上的一条光滑曲线弧，函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 是定义在\n<span class=\"math inline\"><em>C</em></span> 上的有界函数，在 <span\nclass=\"math inline\"><em>C</em></span> 上任意插入分点 <span\nclass=\"math inline\"><em>A</em> = <em>A</em><sub>0</sub>, <em>A</em><sub>1</sub>, …, <em>A</em><sub><em>n</em> − 1</sub>, <em>A</em><sub><em>n</em></sub> = <em>B</em></span>，将其分成\n<span class=\"math inline\"><em>n</em></span> 个小弧段，记第 <span\nclass=\"math inline\"><em>i</em></span> 个小弧段的弧长为 <span\nclass=\"math inline\"><em>Δ</em><em>s</em><sub><em>i</em></sub></span>，在第\n<span class=\"math inline\"><em>i</em></span> 个小段上任取点 <span\nclass=\"math inline\">(<em>ϵ</em><sub><em>i</em></sub>, <em>η</em><sub><em>i</em></sub>)</span>，和式\n<span\nclass=\"math inline\">$\\displaystyle\\sum_{i=1}^{+\\infty}f(\\epsilon_i,\\eta_i)\\Delta\ns_i$</span>，当 <span\nclass=\"math inline\"><em>λ</em> = max<sub>1 ≤ <em>i</em> ≤ <em>n</em></sub>{<em>Δ</em><em>s</em><sub><em>i</em></sub>} → 0</span>\n时，有确定的极限值 <span class=\"math inline\"><em>I</em></span>，即</p>\n<p><span class=\"math display\">$$\n\\lim_{\\lambda\\to 0}\\sum_{i=1}^nf(\\epsilon_i,\\eta_i)\\Delta s_i = I\n$$</span></p>\n<p>则称函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在曲线\n<span class=\"math inline\"><em>C</em></span>\n上<strong>可积</strong>，并将此极限值 <span\nclass=\"math inline\"><em>I</em></span> 称为函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在曲线\n<span class=\"math inline\"><em>C</em></span>\n上的<strong>第一类曲线积分</strong>，记作 <span\nclass=\"math inline\">∫<sub><em>C</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>s</em></span>，即</p>\n<p><span class=\"math display\">$$\nI = \\int_C f(x,y)\\,\\mathrm{d}s = \\lim_{\\lambda\\to\n0}\\sum_{i=1}^nf(\\epsilon_i,\\eta_i)\\Delta s_i\n$$</span></p>\n<ul>\n<li>第一类曲线积分的几何含义为柱面的面积</li>\n<li><span\nclass=\"math inline\">∫<sub><em>C</em></sub> d<em>s</em> = ∫<sub><em>c</em></sub>1 d<em>s</em> = <em>s</em><sub><em>C</em></sub></span></li>\n<li>若 <span class=\"math inline\"><em>C</em></span> 是封闭曲线，即 <span\nclass=\"math inline\"><em>C</em></span> 的二端点重合，则记第一类曲线积分为\n<span\nclass=\"math inline\">∮<sub><em>C</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>s</em></span></li>\n</ul>\n<h4 id=\"第一类曲线积分的性质\">第一类曲线积分的性质</h4>\n<h5 id=\"与曲线方向无关\">与曲线方向无关</h5>\n<p>若曲线 <span class=\"math inline\"><em>C</em></span> 的端点为 <span\nclass=\"math inline\"><em>A</em></span> 和 <span\nclass=\"math inline\"><em>B</em></span>，<span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在曲线\n<span class=\"math inline\"><em>C</em></span> 上可积，则</p>\n<p><span class=\"math display\">$$\n\\int_{\\widehat{AB}} f(x,y)\\,\\mathrm{d}s=\\oint_{\\widehat{BA}}\nf(x,y)\\,\\mathrm{d}s\n$$</span></p>\n<h5 id=\"线性性\">线性性</h5>\n<p>若 <span class=\"math inline\"><em>f</em>, <em>g</em></span> 在曲线\n<span class=\"math inline\"><em>C</em></span> 上可积，<span\nclass=\"math inline\"><em>α</em>, <em>β</em></span> 是任意常数，则 <span\nclass=\"math inline\"><em>α</em><em>f</em> + <em>β</em><em>g</em></span>\n在曲线 <span class=\"math inline\"><em>C</em></span> 上可积，且</p>\n<p><span\nclass=\"math display\">∫<sub><em>C</em></sub>(<em>α</em><em>f</em> + <em>β</em><em>g</em>) d<em>s</em> = <em>α</em>∫<sub><em>C</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>s</em> + <em>β</em>∫<sub><em>C</em></sub><em>g</em>(<em>x</em>, <em>y</em>) d<em>s</em></span></p>\n<h5 id=\"路径可加性\">路径可加性</h5>\n<p>若曲线 <span class=\"math inline\"><em>C</em></span> 由两段光滑曲线\n<span class=\"math inline\"><em>C</em><sub>1</sub></span> 和 <span\nclass=\"math inline\"><em>C</em><sub>2</sub></span> 首尾连接而成，则 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在曲线\n<span class=\"math inline\"><em>C</em></span> 上可积，等价于 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在曲线\n<span class=\"math inline\"><em>C</em><sub>1</sub></span> 和 <span\nclass=\"math inline\"><em>C</em><sub>2</sub></span> 上均可积，且</p>\n<p><span\nclass=\"math display\">∫<sub><em>C</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>s</em> = ∫<sub><em>C</em><sub>1</sub></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>s</em> + ∫<sub><em>C</em><sub>2</sub></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>s</em></span></p>\n<h5 id=\"中值定理\">中值定理</h5>\n<p>设函数 <span class=\"math inline\"><em>f</em></span> 在光滑曲线 <span\nclass=\"math inline\"><em>C</em></span> 上连续，则 <span\nclass=\"math inline\">∃(<em>ϵ</em>, <em>η</em>) ∈ <em>C</em></span>，使得</p>\n<p><span\nclass=\"math display\">∫<sub><em>C</em></sub><em>f</em>(<em>x</em>, <em>y</em>) d<em>s</em> = <em>f</em>(<em>ϵ</em>, <em>η</em>) ⋅ <em>s</em><sub><em>C</em></sub></span></p>\n<p>其中 <span class=\"math inline\"><em>s</em><sub><em>C</em></sub></span>\n是曲线段 <span class=\"math inline\"><em>C</em></span> 的长度</p>\n<h4 id=\"第一类曲线积分的计算\">第一类曲线积分的计算</h4>\n<p>设函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>, <em>y</em>)</span> 在光滑曲线\n<span class=\"math inline\"><em>C</em></span> 上连续，<span\nclass=\"math inline\"><em>C</em></span> 的参数方程为 <span\nclass=\"math inline\">$\\begin{cases}x=x(t)\\\\y=y(t)\\end{cases}$</span>，<span\nclass=\"math inline\"><em>t</em> ∈ [<em>a</em>, <em>b</em>]</span>，满足\n<span\nclass=\"math inline\"><em>x</em><sup>′</sup>(<em>t</em>)</span>，<span\nclass=\"math inline\"><em>y</em><sup>′</sup>(<em>t</em>)</span> 连续，且\n<span\nclass=\"math inline\"><em>x</em><sup>′</sup>(<em>t</em>)<sup>2</sup> + <em>y</em><sup>′</sup>(<em>t</em>)<sup>2</sup> ≠ 0</span>，则</p>\n<p><span class=\"math display\">$$\n\\int_C f(x,y)\\,\\mathrm{d}s = \\int_\\alpha^\\beta f(x(t),y(t))\\sqrt{x'(t)^2\n+ y'(t)^2}\\,\\mathrm{d}t\n$$</span></p>\n<ul>\n<li>右端积分限应 <span\nclass=\"math inline\"><em>α</em> &lt; <em>β</em></span></li>\n<li>当曲线 <span class=\"math inline\"><em>C</em></span> 形式为 <span\nclass=\"math inline\"><em>y</em> = <em>y</em>(<em>x</em>)</span>，<span\nclass=\"math inline\"><em>x</em> ∈ [<em>a</em>, <em>b</em>]</span> 时，则\n<span class=\"math inline\">$\\displaystyle\\int_Cf(x,y)\\,\\mathrm{d}s\n=\\int_a^bf(x,y(x))\\sqrt{1+y'^2(x)}\\,\\mathrm{d}x$</span></li>\n<li>当曲线 <span class=\"math inline\"><em>C</em></span> 为极坐标 <span\nclass=\"math inline\"><em>r</em> = <em>r</em>(<em>θ</em>)</span>，<span\nclass=\"math inline\"><em>θ</em> ∈ [<em>α</em>, <em>β</em>]</span> 时，则\n<span class=\"math inline\">$\\displaystyle\\int_Cf(x,y)\\,\\mathrm{d}s =\n\\int_\\alpha^\\beta\nf(r(\\theta)\\cos\\theta,r(\\theta)\\sin\\theta)\\sqrt{r(\\theta)^2+r'^2(\\theta)}\\,\\mathrm{d}\\theta$</span></li>\n</ul>\n<h3 id=\"第二类曲线积分与曲面积分\">第二类曲线积分与曲面积分</h3>\n<h4 id=\"第二类曲线积分的概念\">第二类曲线积分的概念</h4>\n<p><strong>定义：</strong></p>\n<p>设 <span class=\"math inline\"><em>C</em></span>\n为平面光滑定向曲线(<span\nclass=\"math inline\"><em>A</em> → <em>B</em></span>)，且向量值函数 <span\nclass=\"math inline\"><em>F⃗</em>(<em>x</em>, <em>y</em>) = <em>R</em>(<em>x</em>, <em>y</em>)<em>i⃗</em> + <em>Q</em>(<em>x</em>, <em>y</em>)<em>j⃗</em></span>\n在 <span class=\"math inline\"><em>C</em></span> 上有界，<span\nclass=\"math inline\"><em>e⃗</em><sub><em>τ</em></sub></span> 为 <span\nclass=\"math inline\"><em>C</em></span> 上点 <span\nclass=\"math inline\">(<em>x</em>, <em>y</em>)</span>\n处于定向一致的单位切向量，若</p>\n<p><span\nclass=\"math display\">∫<sub><em>C</em></sub><em>F⃗</em>(<em>x</em>, <em>y</em>) ⋅ <em>e⃗</em><sub><em>τ</em></sub> d<em>s</em></span></p>\n<p>存在，则称为<strong>向量值函数 <span\nclass=\"math inline\"><em>F⃗</em></span> 在定向曲线 <span\nclass=\"math inline\"><em>C</em></span>\n上的曲线积分或第二类曲线积分</strong></p>\n<p>若 <span\nclass=\"math inline\"><em>e⃗</em><sub><em>τ</em></sub>(<em>x</em>, <em>y</em>) = (cos <em>α</em>, cos <em>β</em>)</span>，则</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  \\int_C \\vec{F}(x,y) \\cdot \\vec{e}_\\tau \\,\\mathrm{d}s &amp;= \\int_C\nP(x,y)\\cos\\alpha + Q(x,y)\\cos\\beta \\,\\mathrm{d}s \\\\\n  &amp;= \\int_C P(x,y)\\cos\\alpha \\,\\mathrm{d}s + \\int_C Q(x,y)\\cos\\beta\n\\,\\mathrm{d}s \\\\\n  &amp;= \\int_C P(x,y)\\,\\mathrm{d}x +  Q(x,y)\\,\\mathrm{d}y\n\\end{aligned}\n$$</span></p>\n<p>这是对坐标的曲线积分</p>\n<p>记 <span\nclass=\"math inline\"><em>r⃗</em> = (<em>x</em>, <em>y</em>)</span>，则\n<span\nclass=\"math inline\">d<em>e⃗</em> = <em>e⃗</em><sub><em>τ</em></sub> d<em>s</em></span>\n称为<strong>定向弧微分</strong></p>\n<p>从而有向量形式的第一类曲线积分</p>\n<p><span\nclass=\"math display\">∫<sub><em>C</em></sub><em>F⃗</em>(<em>x</em>, <em>y</em>) ⋅ d<em>e⃗</em> = ∫<sub><em>C</em></sub><em>F⃗</em> ⋅ d<em>r⃗</em></span></p>\n<h5 id=\"第二类曲线积分的性质\">第二类曲线积分的性质</h5>\n<p>第二类曲线积分与<strong>曲线方向有关</strong>，即</p>\n<p><span class=\"math display\">$$\n\\int_{\\widehat{AB}} \\vec{F}(x,y) \\cdot \\mathrm{d}\\vec{r} =\n-\\oint_{\\widehat{BA}} \\vec{F}(x,y) \\cdot \\mathrm{d}\\vec{r}\n$$</span></p>\n<p>此外线性性与对定向积分路径的可加性等仍然成立</p>\n<h5 id=\"第二类曲线积分的计算\">第二类曲线积分的计算</h5>\n<p>若曲线 <span class=\"math inline\"><em>C</em></span> 为 <span\nclass=\"math inline\">$\\begin{cases}x=x(t)\\\\y=y(t)\\end{cases}$</span>，<span\nclass=\"math inline\"><em>t</em> : <em>α</em> → <em>β</em></span></p>\n<p>起点 <span class=\"math inline\"><em>A</em></span> 对应 <span\nclass=\"math inline\"><em>α</em></span>，终点 <span\nclass=\"math inline\"><em>B</em></span> 对应 <span\nclass=\"math inline\"><em>β</em></span></p>\n<p>考察 <span\nclass=\"math inline\">∫<sub><em>C</em></sub><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em> = ∫<sub><em>C</em></sub><em>F⃗</em> ⋅ <em>e⃗</em><sub><em>τ</em></sub> d<em>s</em></span>，沿曲线\n<span class=\"math inline\"><em>C</em></span> 有 <span\nclass=\"math inline\"><em>F⃗</em> = (<em>P</em>(<em>x</em>(<em>t</em>), <em>y</em>(<em>t</em>)), <em>Q</em>(<em>x</em>(<em>t</em>), <em>y</em>(<em>t</em>)))</span>，则</p>\n<p><span\nclass=\"math display\">∫<sub><em>C</em></sub><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em> = ∫<sub><em>α</em></sub><sup><em>β</em></sup><em>P</em>(<em>x</em>(<em>t</em>), <em>y</em>(<em>t</em>)) d<em>x</em>(<em>t</em>) + <em>Q</em>(<em>x</em>(<em>t</em>), <em>y</em>(<em>t</em>)) d<em>y</em>(<em>t</em>)</span></p>\n<h4 id=\"第二类曲面积分的概念\">第二类曲面积分的概念</h4>\n<h5 id=\"双侧曲面\">双侧曲面</h5>\n<p><strong>定义：</strong></p>\n<p>若点 <span class=\"math inline\"><em>P</em></span> 沿曲面 <span\nclass=\"math inline\"><em>S</em></span>\n上任何不越过曲面边界的连续闭曲线移动后回到起始位置时，法向量 <span\nclass=\"math inline\"><em>n⃗</em></span> 保持原来的指向，则称 <span\nclass=\"math inline\"><em>S</em></span> 为<strong>双侧曲面</strong></p>\n<p>典型的，Mobius 面不是双侧曲面</p>\n<p>选定双侧曲面 <span class=\"math inline\"><em>S</em></span>\n一侧为正向，称为<strong>正侧</strong>，记为 <span\nclass=\"math inline\"><em>S</em><sup>+</sup></span> ，其相反测记作 <span\nclass=\"math inline\"><em>S</em><sup>−</sup></span></p>\n<h5 id=\"双侧曲面定侧\">双侧曲面定侧</h5>\n<p>若 <span\nclass=\"math inline\"><em>S</em> : <em>z</em> = <em>z</em>(<em>x</em>, <em>y</em>)</span>，<span\nclass=\"math inline\">(<em>x</em>, <em>y</em>) ∈ <em>D</em><sub><em>x</em><em>y</em></sub></span>，<span\nclass=\"math inline\">$\\vec{n}_0=\\left(\\cos\\alpha,\\cos\\beta,\\cos\\gamma\\right)=\\pm\\frac{\\left(-z_x,-z_y,1\\right)}{\\sqrt{1+z_x^2+z_y^2}}$</span></p>\n<p>若选取 <span\nclass=\"math inline\">$\\vec{n}_0=\\left(\\cos\\alpha,\\cos\\beta,\\cos\\gamma\\right)=\\frac{\\left(-z_x,-z_y,1\\right)}{\\sqrt{1+z_x^2+z_y^2}}$</span>，则说明\n<span\nclass=\"math inline\">cos <em>γ</em> &gt; 0</span>，选取了曲面的上侧</p>\n<p>一般的</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\n  \\cos\\alpha &gt;0 \\Leftrightarrow \\text{前侧}，\\cos\\alpha &lt; 0\n\\Leftrightarrow \\text{后侧}\\\\\n  \\cos\\beta &gt;0 \\Leftrightarrow \\text{右侧}，\\cos\\beta &lt; 0\n\\Leftrightarrow \\text{左侧}\\\\\n  \\cos\\gamma &gt;0 \\Leftrightarrow \\text{上侧}，\\cos\\gamma &lt; 0\n\\Leftrightarrow \\text{下侧}\n\\end{cases}\n$$</span></p>\n<p>习惯上选取曲面片的上侧为 <span\nclass=\"math inline\"><em>S</em><sup>+</sup></span>；对于封闭曲面，选取外侧为\n<span class=\"math inline\"><em>S</em><sup>+</sup></span></p>\n<p>对于向量值函数 <span\nclass=\"math inline\"><em>F⃗</em> = (<em>P</em>, <em>Q</em>, <em>R</em>)</span></p>\n<p><span\nclass=\"math display\">∫<sub><em>C</em></sub><em>F⃗</em>⋅ d<em>S</em> = ∫<sub><em>c</em></sub><em>P</em> d<em>x</em>d<em>y</em> + <em>Q</em> d<em>y</em>d<em>z</em> + <em>R</em> d<em>z</em>d<em>x</em></span></p>\n<h5 id=\"第二类曲面积分的性质\">第二类曲面积分的性质</h5>\n<p>第二类曲面积分与在曲面的哪一侧积分有关</p>\n<p><span\nclass=\"math display\">∬<sub><em>S</em><sup>+</sup></sub><em>P</em> d<em>x</em>d<em>y</em> + <em>Q</em> d<em>y</em>d<em>z</em> + <em>R</em> d<em>z</em>d<em>x</em> = −∬<sub><em>S</em><sup>−</sup></sub><em>P</em> d<em>x</em>d<em>y</em> + <em>Q</em> d<em>y</em>d<em>z</em> + <em>R</em> d<em>z</em>d<em>x</em></span></p>\n<p>此外第二类曲面积分也具有线性性和可加性等性质</p>\n<h4 id=\"第二类曲面积分的计算\">第二类曲面积分的计算</h4>\n<h5 id=\"合一投影法\">合一投影法</h5>\n<p><span\nclass=\"math display\">∬<sub><em>S</em><sup>+</sup></sub><em>P</em> d<em>x</em>d<em>y</em> + <em>Q</em> d<em>y</em>d<em>z</em> + <em>R</em> d<em>z</em>d<em>x</em> = ∬<sub><em>D</em><sub><em>x</em><em>y</em></sub></sub>(−<em>P</em><em>z</em><sub><em>x</em></sub> − <em>Q</em><em>z</em><sub><em>y</em></sub> + <em>R</em>) d<em>x</em>d<em>y</em></span></p>\n<h5 id=\"分面投影法\">分面投影法</h5>\n<p>分 <span\nclass=\"math inline\"><em>P</em> d<em>x</em>d<em>y</em></span>，<span\nclass=\"math inline\"><em>Q</em> d<em>y</em>d<em>z</em></span>，<span\nclass=\"math inline\"><em>R</em> d<em>z</em>d<em>x</em></span>\n三个部分进行积分</p>\n<p>常在部分曲面垂直坐标轴时进行</p>\n<h5 id=\"公式法\">公式法</h5>\n<p>常用于参数方程确定的曲面</p>\n<p>设 <span\nclass=\"math inline\"><em>S</em> : <em>r⃗</em> = (<em>x</em>(<em>u</em>, <em>v</em>), <em>y</em>(<em>u</em>, <em>v</em>), <em>z</em>(<em>u</em>, <em>v</em>))</span>，其中\n<span\nclass=\"math inline\">(<em>u</em>, <em>v</em>) ∈ <em>D</em><sub><em>x</em><em>y</em></sub></span>，则</p>\n<p><span class=\"math display\">$$\n\\iint_{S^+}\\vec{F}\\cdot\\,\\mathrm{d}\\vec{S} =\n\\iint_{D_{uv}}\\vec{F}\\cdot\\left(\\vec{r}_u\\times\\vec{r_v}\\right)\\,\\mathrm{d}u\\mathrm{d}v\n$$</span></p>\n<h3 id=\"green-公式及其应用\">Green 公式及其应用</h3>\n<h4 id=\"green-公式\">Green 公式</h4>\n<h5 id=\"连通区域及其边界方向\">连通区域及其边界方向</h5>\n<p>设 <span class=\"math inline\"><em>D</em></span> 为平面区域, 若 <span\nclass=\"math inline\"><em>D</em></span> 内的任意一条闭曲线所围的区域都落在\n<span class=\"math inline\"><em>D</em></span> 内, 则称 <span\nclass=\"math inline\"><em>D</em></span> 是单连通的, 否则称 <span\nclass=\"math inline\"><em>D</em></span> 为复连通的</p>\n<p>当点沿区域边界朝一个方向前进时, 区域总在它的左侧,\n则将此方向规定为边界曲线 <span class=\"math inline\"><em>C</em></span>\n的正向,记为 <span class=\"math inline\"><em>C</em><sup>+</sup></span>, 与\n<span class=\"math inline\"><em>C</em><sup>+</sup></span> 相反方向为 <span\nclass=\"math inline\"><em>C</em><sup>−</sup></span></p>\n<h5 id=\"green-公式-1\">Green 公式</h5>\n<p><strong>定理：</strong></p>\n<p>设有界闭区域 <span class=\"math inline\"><em>D</em></span>\n由分段光滑曲线 <span class=\"math inline\"><em>C</em></span> 围成，函数\n<span class=\"math inline\"><em>P</em>(<em>x</em>, <em>y</em>)</span>,\n<span class=\"math inline\"><em>Q</em>(<em>x</em>, <em>y</em>)</span> 在\n<span class=\"math inline\"><em>D</em></span> 上有一阶连续偏导数, 则</p>\n<p><span class=\"math display\">$$\n\\oint_{C^+} P\\,\\mathrm{d}x + Q\\,\\mathrm{d}y = \\iint_D\n\\left(\\frac{\\partial Q}{\\partial x} - \\frac{\\partial P}{\\partial\ny}\\right)\\,\\mathrm{d}x\\mathrm{d}y\n$$</span></p>\n<ul>\n<li>对于复连通区域 <span class=\"math inline\"><em>D</em></span>，Green\n公式仍然成立，但需将 <span class=\"math inline\"><em>C</em></span>\n分成若干个单连通区域 <span\nclass=\"math inline\"><em>D</em><sub><em>i</em></sub></span>，并对每个区域应用\nGreen 公式</li>\n<li>公式也可以记为 <span class=\"math inline\">$\\displaystyle\\oint_{C^+}\nP\\,\\mathrm{d}x + Q\\,\\mathrm{d}y = \\iint_D\n\\begin{vmatrix}\\frac{\\partial}{\\partial x}&amp;\\frac{\\partial}{\\partial\ny}\\newline P&amp;Q\\end{vmatrix}\\,\\mathrm{d}x\\mathrm{d}y$</span></li>\n</ul>\n<h5 id=\"green-公式的向量形式\">Green 公式的向量形式</h5>\n<p><span\nclass=\"math display\">∮<sub><em>C</em><sup>+</sup></sub><em>F⃗</em>⋅ d<em>r⃗</em> = ∬<sub><em>D</em></sub>∇ × <em>F⃗</em> d<em>x</em>d<em>y</em></span></p>\n<h4 id=\"曲线积分与路径无关的条件\">曲线积分与路径无关的条件</h4>\n<p><strong>定义：</strong></p>\n<p>设 <span\nclass=\"math inline\"><em>P</em>(<em>x</em>, <em>y</em>)</span>，<span\nclass=\"math inline\"><em>Q</em>(<em>x</em>, <em>y</em>)</span> 在区域\n<span class=\"math inline\"><em>D</em></span> 内连续，若对 <span\nclass=\"math inline\"><em>D</em></span> 内任意两点 <span\nclass=\"math inline\"><em>A</em></span>，<span\nclass=\"math inline\"><em>B</em></span> 以及 <span\nclass=\"math inline\"><em>D</em></span> 内连接 <span\nclass=\"math inline\"><em>A</em>, <em>B</em></span> 的任意二分段光滑曲线\n<span class=\"math inline\"><em>C</em><sub>1</sub></span>，<span\nclass=\"math inline\"><em>C</em><sub>2</sub></span>，均有</p>\n<p><span\nclass=\"math display\">∫<sub><em>C</em><sub>1</sub></sub><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em> = ∫<sub><em>C</em><sub>2</sub></sub><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em></span></p>\n<p>则称曲线积分 <span\nclass=\"math inline\">∫<sub><em>C</em></sub><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em></span>\n在 <span class=\"math inline\"><em>D</em></span>\n内<strong>与路径无关</strong></p>\n<p><strong>定理：</strong></p>\n<p>设函数 <span class=\"math inline\"><em>P</em></span>，<span\nclass=\"math inline\"><em>Q</em></span> 在<strong>单连通</strong>区域\n<span class=\"math inline\"><em>D</em></span>\n上有连续偏导数，则下述四命题等价</p>\n<ol type=\"1\">\n<li>在 <span class=\"math inline\"><em>D</em></span>\n内的任一条分段光滑闭曲线 <span class=\"math inline\"><em>C</em></span>\n上，有 <span\nclass=\"math inline\">∫<sub><em>C</em></sub><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em> = 0</span></li>\n<li>曲线积分 <span\nclass=\"math inline\">∫<sub><em>C</em></sub><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em></span>\n在 <span class=\"math inline\"><em>D</em></span> 内与路径无关</li>\n<li>存在 <span class=\"math inline\"><em>D</em></span> 上的可微函数 <span\nclass=\"math inline\"><em>u</em>(<em>x</em>, <em>y</em>)</span> 使得 <span\nclass=\"math inline\">d<em>u</em> = <em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em></span>，此时称\n<span class=\"math inline\"><em>u</em>(<em>x</em>, <em>y</em>)</span> 为\n<span\nclass=\"math inline\"><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em></span>\n的一个<strong>原函数</strong></li>\n<li><span class=\"math inline\">$\\displaystyle \\frac{\\partial Q}{\\partial\nx} = \\frac{\\partial P}{\\partial y}$</span> 在 <span\nclass=\"math inline\"><em>D</em></span> 内恒成立</li>\n</ol>\n<h4 id=\"全微分求积与全微分方程\">全微分求积与全微分方程</h4>\n<p>设函数 <span class=\"math inline\"><em>P</em></span>，<span\nclass=\"math inline\"><em>Q</em></span> 在单连通区域 <span\nclass=\"math inline\"><em>D</em></span> 上有连续偏导数，且 <span\nclass=\"math inline\">$\\displaystyle \\frac{\\partial Q}{\\partial x} =\n\\frac{\\partial P}{\\partial y}$</span> ，则 <span\nclass=\"math inline\"><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em></span>\n为某函数 <span class=\"math inline\"><em>u</em></span> 的全微分，且取定\n<span\nclass=\"math inline\">(<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>) ∈ <em>D</em></span></p>\n<p><span\nclass=\"math display\"><em>u</em>(<em>x</em>, <em>y</em>) = <em>u</em>(<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>) + ∫<sub>(<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>)</sub><sup>(<em>x</em>, <em>y</em>)</sup><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em>,  (<em>x</em>, <em>y</em>) ∈ <em>D</em></span></p>\n<p>从而全体函数为 <span\nclass=\"math inline\"><em>u</em>(<em>x</em>, <em>y</em>) + <em>C</em></span></p>\n<p>称求 <span\nclass=\"math inline\"><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em></span>\n的原函数的过程为<strong>全微分求积</strong></p>\n<p>若 <span\nclass=\"math inline\"><em>P</em> d<em>x</em> + <em>Q</em> d<em>y</em></span>\n是某二元函数的全微分，称方程</p>\n<p><span\nclass=\"math display\"><em>P</em>(<em>x</em>, <em>y</em>) d<em>x</em> + <em>Q</em>(<em>x</em>, <em>y</em>) d<em>y</em> = 0</span></p>\n<p>为<strong>全微分方程</strong></p>\n<p>求出一个原函数 <span\nclass=\"math inline\"><em>u</em>(<em>x</em>, <em>y</em>)</span>，则方程的通解为\n<span\nclass=\"math inline\"><em>u</em>(<em>x</em>, <em>y</em>) = <em>C</em></span>，其中\n<span class=\"math inline\"><em>C</em></span> 是任意常数</p>\n<h3 id=\"gauss-公式和-strokes-公式\">Gauss 公式和 Strokes 公式</h3>\n<h4 id=\"gauss-公式\">Gauss 公式</h4>\n<p><strong>定理：</strong></p>\n<p>设函数 <span\nclass=\"math inline\"><em>P</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>，<span\nclass=\"math inline\"><em>Q</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>，<span\nclass=\"math inline\"><em>R</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>\n在空间有界闭区域 <span class=\"math inline\"><em>Ω</em></span>\n上有连续偏导数，<span class=\"math inline\"><em>Ω</em></span>\n的边界时光滑或分片光滑的闭曲面 <span\nclass=\"math inline\"><em>Σ</em></span>，则</p>\n<p><span class=\"math display\">$$\n\\oiint_{\\Sigma^+} P\\,\\mathrm{d}x\\mathrm{d}y + Q\\,\\mathrm{d}y\\mathrm{d}z\n+ R\\,\\mathrm{d}z\\mathrm{d}x = \\iiint_\\Omega \\left(\\frac{\\partial\nP}{\\partial x} + \\frac{\\partial Q}{\\partial y} + \\frac{\\partial\nR}{\\partial z}\\right)\\,\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z\n$$</span></p>\n<ul>\n<li>令 <span class=\"math inline\">$P=\\frac{x}{3}$</span>，<span\nclass=\"math inline\">$Q=\\frac{y}{3}$</span>，<span\nclass=\"math inline\">$R=\\frac{z}{3}$</span>，则可导出 <span\nclass=\"math inline\">$\\displaystyle V_\\Omega =\n\\frac{1}{3}\\oiint_{\\Sigma^+} x\\,\\mathrm{d}y\\mathrm{d}z +\ny\\,\\mathrm{d}z\\mathrm{d}x +\nz\\,\\mathrm{d}x\\mathrm{d}y$</span>，即体积公式</li>\n<li>使用 Gauss 公式时，注意 <span\nclass=\"math inline\"><em>Σ</em><sup>+</sup></span> 的方向应与 <span\nclass=\"math inline\"><em>Ω</em></span> 的外侧一致</li>\n</ul>\n<h5 id=\"向量形式的-gauss-公式\">向量形式的 Gauss 公式</h5>\n<p><span\nclass=\"math display\">∯<sub><em>Σ</em><sup>+</sup></sub><em>F⃗</em>⋅ d<em>S⃗</em> = ∭<sub><em>Ω</em></sub>∇ ⋅ <em>F⃗</em> d<em>x</em>d<em>y</em>d<em>z</em></span></p>\n<h4 id=\"通量和散度\">通量和散度</h4>\n<h5 id=\"通量\">通量</h5>\n<p>若给定向量场</p>\n<p><span\nclass=\"math display\"><em>F⃗</em> = (<em>P</em>(<em>x</em>, <em>y</em>, <em>z</em>), <em>Q</em>(<em>x</em>, <em>y</em>, <em>z</em>), <em>R</em>(<em>x</em>, <em>y</em>, <em>z</em>))</span></p>\n<p>则称曲面积分</p>\n<p><span\nclass=\"math display\"><em>Φ</em> = ∯<sub><em>Σ</em><sup>+</sup></sub><em>F⃗</em>⋅ d<em>S⃗</em> = ∯<sub><em>Σ</em><sup>+</sup></sub><em>P</em> d<em>x</em>d<em>y</em> + <em>Q</em> d<em>y</em>d<em>z</em> + <em>R</em> d<em>z</em>d<em>x</em></span></p>\n<p>为向量场 <span class=\"math inline\"><em>F⃗</em></span> 在通过定侧曲面\n<span class=\"math inline\"><em>Σ</em><sup>+</sup></span>\n的<strong>通量</strong></p>\n<h5 id=\"散度\">散度</h5>\n<p>称</p>\n<p><span class=\"math display\">$$\n\\mathrm{div}\\vec{F} = \\nabla\\cdot\\vec{F}=\\frac{\\partial P}{\\partial x} +\n\\frac{\\partial Q}{\\partial y} + \\frac{\\partial R}{\\partial z}\n$$</span></p>\n<p>为向量场 <span class=\"math inline\"><em>F⃗</em></span>\n的<strong>散度</strong></p>\n<p>则 Gauss 公式可写为</p>\n<p><span\nclass=\"math display\"><em>Φ</em> = ∯<sub><em>Σ</em><sup>+</sup></sub><em>F⃗</em>⋅ d<em>S⃗</em> = ∭<sub><em>Ω</em></sub>div<em>F⃗</em> d<em>V</em></span></p>\n<h2 id=\"级数\">级数</h2>\n<h3 id=\"数项级数\">数项级数</h3>\n<h4 id=\"数项级数的概念\">数项级数的概念</h4>\n<p><strong>定义：</strong></p>\n<p>给定数列 <span\nclass=\"math inline\">{<em>a</em><sub><em>n</em></sub>}</span> ，和式</p>\n<p><span class=\"math display\">$$\n\\sum_{n=1}^{\\infty} a_n = a_1 + a_2 + \\cdots + a_n + \\cdots\n$$</span></p>\n<p>称为 <strong>（无穷）极数</strong> ，<span\nclass=\"math inline\"><em>a</em><sub><em>n</em></sub></span>\n称为级数的<strong>通项</strong>（或<strong>一般项</strong>）</p>\n<ul>\n<li><span class=\"math inline\">$\\displaystyle S_n = \\sum_{k=1}^n\na_k$</span> 称为级数 <span\nclass=\"math inline\">∑<sub><em>n</em> = 1</sub><em>a</em><sub><em>n</em></sub></span>\n的前 <span class=\"math inline\"><em>n</em></span>\n项<strong>部分和</strong></li>\n<li><span class=\"math inline\">$\\displaystyle\\sum_{k=n+1}^\\infty\na_k$</span> 称为级数 <span\nclass=\"math inline\">∑<sub><em>n</em> = 1</sub><em>a</em><sub><em>n</em></sub></span>\n的<strong>余项级数</strong></li>\n</ul>\n<p><strong>定义：</strong></p>\n<ul>\n<li>若级数 <span class=\"math inline\">$\\displaystyle\\sum_{n=1}^\\infty\na_n$</span> 的部分和数列 <span\nclass=\"math inline\">{<em>S</em><sub><em>n</em></sub>}</span> 收敛，且\n<span\nclass=\"math inline\">lim<sub><em>n</em> → ∞</sub><em>S</em><sub><em>n</em></sub> = <em>S</em></span>，则称级数\n<span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n<strong>收敛</strong>，<span class=\"math inline\"><em>S</em></span>\n称为级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 的<strong>和</strong>，记作 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n =\nS$</span></li>\n<li>若部分和数列 <span\nclass=\"math inline\">{<em>S</em><sub><em>n</em></sub>}</span>\n发散，则称级数 <span class=\"math inline\">$\\displaystyle\n\\sum_{n=1}^\\infty a_n$</span> <strong>发散</strong></li>\n</ul>\n<blockquote>\n<p>常用结论：</p>\n<p><strong>等比数列</strong> <span class=\"math inline\">$\\displaystyle\n\\sum_{n=1}^\\infty aq^{n-1}\\begin{cases}\\text{收敛于}\\frac{a}{1-q} &amp;\n,\\vert q \\vert &lt; 1\\newline \\text{发散} &amp; ,\\vert q \\vert \\geq\n1\\end{cases}$</span></p>\n</blockquote>\n<h4 id=\"数项级数的基本性质\">数项级数的基本性质</h4>\n<h5 id=\"基本性质\">基本性质</h5>\n<ol type=\"1\">\n<li>若常数 <span class=\"math inline\"><em>α</em> ≠ 0</span>，则级数 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span> 与级数\n<span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty \\alpha\na_n$</span> 有相同敛散性</li>\n<li><strong>线性性：</strong> 若级数 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n =\nS$</span>，<span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\nb_n = T$</span>，则 <span\nclass=\"math inline\">∀<em>α</em>, <em>β</em> ∈ ℝ</span>，有 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty (\\alpha a_n + \\beta\nb_n) = \\alpha S + \\beta T$</span></li>\n<li><strong>可加性：</strong>\n将级数增加、删减或改换<strong>有限项</strong>，不改变级数的<strong>敛散性</strong></li>\n<li><strong>结合律：</strong> 若级数收敛于 <span\nclass=\"math inline\"><em>S</em></span>，则将相邻若干项添加括号所成新级数仍收敛于\n<span class=\"math inline\"><em>S</em></span>\n<ul>\n<li>其本质是部分和数列收敛于 <span\nclass=\"math inline\"><em>S</em></span>，则子列均收敛于 <span\nclass=\"math inline\"><em>S</em></span></li>\n<li>加括号后级数收敛 <span class=\"math inline\">⇏</span> 原级数收敛</li>\n<li>加括号后级数发散 <span class=\"math inline\">⇒</span> 原级数发散</li>\n</ul></li>\n</ol>\n<h5 id=\"级数收敛的必要条件\">级数收敛的必要条件</h5>\n<p><strong>定理：</strong></p>\n<p>若 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 收敛，则 <span\nclass=\"math inline\">lim<sub><em>n</em> → ∞</sub><em>a</em><sub><em>n</em></sub> = 0</span></p>\n<ul>\n<li>若 <span class=\"math inline\">$\\displaystyle \\lim_{n\\to\\infty} a_n\n\\neq 0 \\nRightarrow \\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n发散</li>\n<li>若 <span class=\"math inline\">$\\displaystyle \\lim_{n\\to\\infty} a_n =\n0 \\nRightarrow \\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n收敛，比如调和级数</li>\n</ul>\n<h3 id=\"正项级数敛散性\">正项级数敛散性</h3>\n<h4 id=\"正项级数\">正项级数</h4>\n<p><strong>定义：</strong></p>\n<p>若级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 满足 <span\nclass=\"math inline\"><em>a</em><sub><em>n</em></sub> &gt; 0  (<em>n</em> ∈ ℕ<sup>+</sup>)</span>，则称此级数为<strong>正项级数</strong></p>\n<p><strong>定理：（收敛原理）</strong></p>\n<p>正项级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 收敛 <span class=\"math inline\">⇔</span> 是其部分和数列 <span\nclass=\"math inline\">{<em>S</em><sub><em>n</em></sub>}</span> 有上界，即\n<span\nclass=\"math inline\">∃<em>M</em> ∈ ℝ, ∀<em>n</em> ∈ ℕ<sup>+</sup> : <em>S</em><sub><em>n</em></sub> ≤ <em>M</em></span></p>\n<blockquote>\n<p><span class=\"math inline\"><em>p</em></span> 级数</p>\n<p><span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\n\\frac{1}{n^p} \\begin{cases}\\text{收敛} &amp; ,p&gt;1\\newline \\text{发散}\n&amp; ,p\\leq 1\\end{cases}$</span></p>\n</blockquote>\n<h4 id=\"正项级数敛散性判别法\">正项级数敛散性判别法</h4>\n<h5 id=\"比较判别法\">比较判别法</h5>\n<p><strong>定理：</strong></p>\n<p>设正项级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span>，<span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\nb_n$</span> 满足 <span\nclass=\"math inline\"><em>a</em><sub><em>n</em></sub> ≤ <em>b</em><sub><em>n</em></sub>  (∀<em>n</em> ∈ ℕ<sup>+</sup>)</span>\n，则 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\nb_n$</span> 收敛 <span class=\"math inline\">$\\Rightarrow \\displaystyle\n\\sum_{n=1}^\\infty a_n$</span> 收敛，<span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span> 发散\n<span class=\"math inline\">$\\Rightarrow \\displaystyle \\sum_{n=1}^\\infty\nb_n$</span> 发散</p>\n<ul>\n<li>条件 <span\nclass=\"math inline\">∀<em>n</em> ∈ ℕ<sup>+</sup>，<em>a</em><sub><em>n</em></sub> ≤ <em>b</em><sub><em>n</em></sub></span>\n可改为 <span\nclass=\"math inline\">∃<em>N</em>, <em>C</em> &gt; 0, ∀<em>n</em> ∈ ℕ<sup>+</sup>，∀<em>n</em> ≥ <em>N</em>，<em>a</em><sub><em>n</em></sub> ≤ <em>C</em><em>b</em><sub><em>n</em></sub></span></li>\n<li>使用该判别法时需要有参照级数，常选<strong>等比级数</strong>或\n<strong><span class=\"math inline\"><em>p</em></span>\n级数</strong>作参照</li>\n</ul>\n<h5 id=\"比较判别法极限形式\">比较判别法（极限形式）</h5>\n<p><strong>定理：</strong></p>\n<p>正项级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span>，<span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\nb_n$</span> 满足 <span class=\"math inline\">$\\displaystyle\n\\lim_{n\\to\\infty} \\frac{a_n}{b_n} = l$</span></p>\n<ul>\n<li>当 <span class=\"math inline\">0 &lt; <em>l</em> &lt; +∞</span>\n时，<span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 与 <span class=\"math inline\">$\\displaystyle\n\\sum_{n=1}^\\infty b_n$</span> 同敛散</li>\n<li>当 <span class=\"math inline\"><em>l</em> = 0</span> 时，<span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty b_n$</span> 收敛\n<span class=\"math inline\">$\\Rightarrow \\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 收敛</li>\n<li>当 <span class=\"math inline\"><em>l</em> = +∞</span> 时，<span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty b_n$</span> 发散\n<span class=\"math inline\">$\\Rightarrow \\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 发散</li>\n</ul>\n<blockquote>\n<p>通常使用 <span class=\"math inline\">$b_n = \\frac{1}{n^p}$</span>\n作为参照物，因为我们此时在分析无穷小 <span\nclass=\"math inline\"><em>a</em><sub><em>n</em></sub></span> 的阶</p>\n</blockquote>\n<h5 id=\"比值判别法dalembert-判别法\">比值判别法（d’Alembert 判别法）</h5>\n<p><strong>定理：</strong></p>\n<p>若<strong>正项级数</strong> <span class=\"math inline\">$\\displaystyle\n\\sum_{n=1}^\\infty a_n$</span> 满足 <span\nclass=\"math inline\">$\\displaystyle \\lim_{n\\to\\infty} \\frac{a_{n+1}}{a_n}\n= l$</span>，则</p>\n<ul>\n<li>当 <span class=\"math inline\">0 ≤ <em>l</em> &lt; 1</span> 时，<span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n收敛</li>\n<li>当 <span class=\"math inline\"><em>l</em> &gt; 1</span> 时，<span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n发散</li>\n<li>当 <span class=\"math inline\"><em>l</em> = 1</span>\n时，判别法失效</li>\n</ul>\n<blockquote>\n<p>Stirling 公式： <span class=\"math inline\">$n! \\sim\n\\left(\\frac{n}{e}\\right)^n \\sqrt{2n\\pi} \\quad (n\\to\\infty)$</span></p>\n</blockquote>\n<blockquote>\n<p>当 <span class=\"math inline\"><em>a</em><sub><em>n</em></sub></span>\n是一些乘积构成或含 <span class=\"math inline\"><em>n</em>!</span>\n时，可以考虑比值法</p>\n</blockquote>\n<h5 id=\"根值判别法cauchy-判别法\">根值判别法（Cauchy 判别法）</h5>\n<p><strong>定理：</strong></p>\n<p>若正项级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 满足 <span class=\"math inline\">$\\displaystyle\n\\lim_{n\\to\\infty} \\sqrt[n]{a_n} = l$</span>，则</p>\n<ol type=\"1\">\n<li>当 <span class=\"math inline\">0 ≤ <em>l</em> &lt; 1</span> 时，<span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n收敛</li>\n<li>当 <span class=\"math inline\">1 &lt; <em>l</em> ≤ +∞</span> 时，<span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n发散</li>\n<li>当 <span class=\"math inline\"><em>l</em> = 1</span>\n时，判别法失效</li>\n</ol>\n<blockquote>\n<p>当 <span class=\"math inline\"><em>a</em><sub><em>n</em></sub></span>\n中含有 <span class=\"math inline\"><em>n</em></span>\n次方时，可以考虑使用根值法</p>\n</blockquote>\n<blockquote>\n<p>比值法和根值法实际上可看作是在将级数与等比级数作比较，均智能判断收敛速度不满与等比级数的级数.当所求级数存在时，可称级数为<strong>拟等比级数</strong></p>\n</blockquote>\n<blockquote>\n<p>根值法优于比值法</p>\n<ul>\n<li><span\nclass=\"math inline\">$\\displaystyle\\lim_{n\\to\\infty}\\frac{a_{n+1}}{a_n}\n=  l \\Rightarrow \\displaystyle \\sqrt[n]{a_n} = l$</span></li>\n<li><span class=\"math inline\">$\\displaystyle \\sqrt[n]{a_n} =l\n\\nRightarrow \\displaystyle\\lim_{n\\to\\infty}\\frac{a_{n+1}}{a_n}\n=  l$</span></li>\n</ul>\n</blockquote>\n<h5 id=\"积分判别法\">积分判别法</h5>\n<p><strong>定理：</strong></p>\n<p>设 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 为<strong>正项级数</strong>，若非负函数 <span\nclass=\"math inline\"><em>f</em>(<em>X</em>)</span> 在 <span\nclass=\"math inline\">[1, +∞)</span> 上<strong>单调递减</strong>，且 <span\nclass=\"math inline\"><em>a</em><sub><em>n</em></sub> = <em>f</em>(<em>n</em>)  (∀<em>n</em> ∈ ℕ<sup>+</sup>)</span>，则级数\n<span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n与反常积分 <span\nclass=\"math inline\">∫<sub>1</sub><sup>+∞</sup><em>f</em>(<em>x</em>) d<em>x</em></span>\n有相同的敛散性</p>\n<ul>\n<li>条件 <span class=\"math inline\">[1, +∞)</span> 可改为 <span\nclass=\"math inline\">[<em>a</em>, +∞)，(<em>a</em> &gt; 1)</span></li>\n</ul>\n<h3 id=\"任意项级数的敛散性\">任意项级数的敛散性</h3>\n<p><strong>任意项级数</strong></p>\n<p>正负项分布是任意的级数</p>\n<h4 id=\"交错级数敛散性的判别法\">交错级数敛散性的判别法</h4>\n<h5 id=\"交错级数\">交错级数</h5>\n<p><strong>定义：</strong></p>\n<p>各项正负相间的级数称为<strong>交错级数</strong>，其形式为</p>\n<p><span class=\"math display\">$$\n\\pm\\sum_{n=1}^\\infty {-1}^{n-1}a_n \\quad \\left(\\text{其中}a_n &gt;\n0\\right)\n$$</span></p>\n<h5 id=\"leibniz-判别法\">Leibniz 判别法</h5>\n<p><strong>定理：</strong></p>\n<p>若交错级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\n(-1)^{n-1}a_n \\,\\left(a_n&gt;0\\right)$</span> 满足:</p>\n<ol type=\"1\">\n<li><span\nclass=\"math inline\"><em>a</em><sub><em>n</em> + 1</sub> ≤ <em>a</em><sub><em>n</em></sub>  (<em>n</em> = 1, 2, …)</span></li>\n<li><span\nclass=\"math inline\">lim<sub><em>n</em> → ∞</sub><em>a</em><sub><em>n</em></sub> = 0</span></li>\n</ol>\n<p>则级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\n(-1)^{n-1}a_n$</span> 收敛，且其余项级数满足</p>\n<p><span class=\"math display\">$$\n\\left\\vert \\sum_{k=n+1}^\\infty a_k \\right\\vert \\leq a_{n+1}\n$$</span></p>\n<blockquote>\n<p>我们称满足定理条件的级数为 <strong>leibniz 型级数</strong></p>\n</blockquote>\n<h4 id=\"abel-判别法和-dirichlet-判别法\">Abel 判别法和 Dirichlet\n判别法</h4>\n<p><strong>定理：（Abel 判别法）</strong></p>\n<p>若 <span class=\"math inline\">{<em>a</em><sub><em>n</em></sub>}</span>\n单调且有界，<span class=\"math inline\">$\\displaystyle\\sum_{n=1}^\\infty\nb_n$</span> 收敛，则 <span class=\"math inline\">$\\displaystyle\n\\sum_{n=1}^\\infty a_nb_n$</span> 收敛</p>\n<p><strong>定理：（Dirichlet 判别法）</strong></p>\n<p>若 <span class=\"math inline\">{<em>a</em><sub><em>n</em></sub>}</span>\n单调趋于 <span class=\"math inline\">0</span>，<span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty b_n$</span>\n的部分和数列有界，则 <span class=\"math inline\">$\\displaystyle\n\\sum_{n=1}^\\infty a_nb_n$</span> 收敛</p>\n<h4 id=\"绝对收敛与条件收敛\">绝对收敛与条件收敛</h4>\n<p><strong>定义：</strong></p>\n<p>设 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 为任意项级数</p>\n<ol type=\"1\">\n<li>若级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\n\\vert a_n \\vert$</span> 收敛，则称级数 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n为<strong>绝对收敛</strong></li>\n<li>若 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty \\vert\na_n \\vert$</span> 发散，而 <span class=\"math inline\">$\\displaystyle\n\\sum_{n=1}^\\infty a_n$</span> 收敛，但 ，则称 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty a_n$</span>\n<strong>条件收敛</strong></li>\n</ol>\n<p><strong>定理：</strong></p>\n<p>若 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_n$</span> 绝对收敛，则 <span class=\"math inline\">$\\displaystyle\n\\sum_{n=1}^\\infty a_n$</span> 收敛</p>\n<blockquote>\n<p><strong>常用结论：</strong></p>\n<p><span class=\"math display\">$$\n\\displaystyle \\sum_{n=1}^\\infty\n\\frac{(-1)^{n}}{n^p}\\begin{cases}\\text{绝对收敛} &amp; ,p&gt;1\\\\\n\\text{条件收敛} &amp; , 0 &lt; p\\leq 1 \\end{cases}\n$$</span></p>\n</blockquote>\n<p><strong>定理：（绝对收敛与条件收敛的本质）</strong></p>\n<ol type=\"1\">\n<li>绝对收敛的级数，可以改变任意项的顺序，其收敛性与和均不变（即满足加法交换律）</li>\n<li>条件收敛的级数，总可以适当改变项的顺序，使其按照任意预定的方式收敛或者发散</li>\n</ol>\n<h3 id=\"函数项级数\">函数项级数</h3>\n<p><strong>定义：</strong></p>\n<p>设函数列 <span\nclass=\"math inline\">{<em>u</em><sub><em>n</em></sub><em>x</em>}(<em>n</em> = 1, 2, …)</span>\n在数集 <span class=\"math inline\"><em>X</em></span>\n上有定义，则称形式和</p>\n<p><span class=\"math display\">$$\n\\sum_{n=1}^\\infty u_n(x)= u_1(x) + u_2(x) + \\cdots + u_n(x) + \\cdots\n$$</span></p>\n<p>为<strong>函数项级数</strong>，其中 <span\nclass=\"math inline\"><em>u</em><sub><em>n</em></sub>(<em>x</em>)</span>\n称为<strong>通项</strong></p>\n<p><strong>定义：</strong></p>\n<p>若数项级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\nu_n(x_0)$</span> 收敛，则 <span\nclass=\"math inline\"><em>x</em><sub>0</sub></span> 为函数项级数 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty u_n(x)$</span>\n的一个<strong>收敛点</strong>，否则称为<strong>发散点</strong>，全体收敛点所组成的集合\n<span class=\"math inline\"><em>I</em></span>\n称为<strong>收敛域</strong></p>\n<p><strong>定义</strong></p>\n<p>记 <span class=\"math inline\">$\\displaystyle S_n(x) =\\sum_{k=1}^\\infty\nu_k(x)$</span>,为 <span class=\"math inline\">$\\displaystyle\n\\sum_{n=1}^\\infty u_n(x)$</span> 的前 <span\nclass=\"math inline\"><em>n</em></span>\n项<strong>部分和(函数)</strong>，记 <span\nclass=\"math inline\">$\\displaystyle r_n(x) = \\sum_{k=n+1}^\\infty\nu_k(x)$</span> 为<strong>余和</strong></p>\n<p><strong>定义：</strong></p>\n<p>对于收敛域 <span class=\"math inline\"><em>I</em></span> 中的任意一点\n<span class=\"math inline\"><em>x</em></span>，记 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty u_n(x)$</span>\n的和为 <span class=\"math inline\"><em>S</em>(<em>x</em>)</span>，称此函数\n<span class=\"math inline\"><em>S</em>(<em>x</em>)</span> 为 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty u_n(x)$</span>\n的<strong>和函数</strong></p>\n<p>显然，<span\nclass=\"math inline\">∀<em>x</em> ∈ <em>I</em></span>，<span\nclass=\"math inline\">lim<sub><em>n</em> → +∞</sub><em>S</em><sub><em>n</em></sub>(<em>x</em>) = <em>S</em>(<em>x</em>)</span>，<span\nclass=\"math inline\">lim<sub><em>n</em> → +∞</sub><em>r</em><sub><em>n</em></sub>(<em>x</em>) = 0</span></p>\n<h3 id=\"幂级数\">幂级数</h3>\n<h4 id=\"幂级数及其收敛半径\">幂级数及其收敛半径</h4>\n<p>在函数项级数中，最简单及最重要的级数形如</p>\n<p><span class=\"math display\">$$\n\\sum_{n=0}^\\infty a_n(x-x_0)^n = a_0 +a_1x + a_2(x-x_0)^2 + \\ldots +\na_n(x-x_0)^n + \\ldots\n$$</span></p>\n<p>称为<strong>幂级数</strong>，其中常数项 <span\nclass=\"math inline\"><em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, …, <em>a</em><sub><em>n</em></sub>, …</span>\n称为幂级数的<strong>系数</strong></p>\n<p>幂级数更加一半的形式为 <span class=\"math inline\">$\\displaystyle\n\\sum_{n=0}^\\infty a_n(x-x_0)^n$</span></p>\n<h5 id=\"abel-定理\"><strong>Abel 定理</strong></h5>\n<ol type=\"1\">\n<li>若幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_n(x-x_0)^n$</span> 在 <span\nclass=\"math inline\"><em>x</em> = <em>x</em><sub>0</sub>(<em>x</em> ≠ 0)</span>\n收敛，则当 <span\nclass=\"math inline\">|<em>x</em>| &lt; |<em>x</em><sub>0</sub>|</span>，时，幂级数\n<span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_n(x-x_0)^n$</span> 绝对收敛</li>\n<li>若幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nx^n$</span> 在 <span\nclass=\"math inline\"><em>x</em> = <em>x</em><sub>1</sub></span>\n发散，则当 <span\nclass=\"math inline\">|<em>x</em>| &gt; |<em>x</em><sub>1</sub>|</span>\n时，幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nx^n$</span> 发散</li>\n</ol>\n<h6 id=\"推论幂级数收敛域的情况\">推论（幂级数收敛域的情况）</h6>\n<p>幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_n(x-x_0)^n$</span> 的收敛域 <span\nclass=\"math inline\"><em>I</em></span> 仅有以下几种情况：</p>\n<ol type=\"1\">\n<li>仅在 <span class=\"math inline\"><em>x</em> = 0</span>\n的情况收敛（<span class=\"math inline\"><em>R</em> = 0</span>）</li>\n<li>在区间 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)(<em>R</em> &gt; 0)</span>\n内绝对收敛，在 <span\nclass=\"math inline\">(−∞, −<em>R</em>)⋃(<em>R</em>, +∞)</span> 发散</li>\n<li>在区间 <span class=\"math inline\">(−<em>R</em>, <em>R</em>)</span>\n内绝对收敛（<span class=\"math inline\"><em>R</em> = +∞</span>）</li>\n</ol>\n<h3 id=\"幂级数收敛半径的求法\">幂级数收敛半径的求法</h3>\n<h4 id=\"系数模比值法\">系数模比值法</h4>\n<p><strong>定理：</strong></p>\n<p>对幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_nx^n$</span>，若 <span class=\"math inline\">$\\displaystyle\n\\lim_{n\\to+\\infty}\\left\\vert\\frac{a_{n+1}}{a_n}\\right\\vert =\n\\rho$</span>，则收敛半径 <span class=\"math inline\">$\\displaystyle\nR=\\begin{cases}&amp;0,&amp;&amp;\\rho=+\\infty\\newline &amp;\n\\frac{1}{\\rho},&amp;&amp; 0&lt;\\rho&lt;+\\infty\\newline &amp;+\\infty\n,&amp;&amp;\\rho=0\\end{cases}$</span></p>\n<h4 id=\"系数模根值法\">系数模根值法</h4>\n<p><strong>定理：</strong></p>\n<p>对幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=1}^\\infty\na_nx^n$</span>，若 <span class=\"math inline\">$\\displaystyle\n\\lim_{n\\to+\\infty}\\sqrt[n]{\\left\\vert a_n\\right\\vert} =\n\\rho$</span>，则收敛半径 <span class=\"math inline\">$\\displaystyle\nR=\\begin{cases}&amp;0,&amp;&amp;\\rho=+\\infty\\newline &amp;\n\\frac{1}{\\rho},&amp;&amp; 0&lt;\\rho&lt;+\\infty\\newline &amp;+\\infty\n,&amp;&amp;\\rho=0\\end{cases}$</span></p>\n<h3 id=\"幂级数的性质\">幂级数的性质</h3>\n<ol type=\"1\">\n<li>设幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nx^n$</span> 和 <span class=\"math inline\">$\\displaystyle\n\\sum_{n=0}^\\infty b_nx^n$</span> 的收敛半径分别为 <span\nclass=\"math inline\"><em>R</em><sub>1</sub></span> 和 <span\nclass=\"math inline\"><em>R</em><sub>2</sub></span>，则 <span\nclass=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\n(a_n+b_n)x^n$</span> 的收敛半径为 <span\nclass=\"math inline\"><em>R</em> = min {<em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>}</span></li>\n<li>若幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nx^n$</span> 的收敛半径 <span\nclass=\"math inline\"><em>R</em> &gt; 0</span>，在收敛区间 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span> 内的和函数为 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span>，则 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span> 在 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span> 上连续；若 <span\nclass=\"math inline\">$\\displaystyle\\sum_{n=0}^\\infty a_nx^n$</span> 在\n<span class=\"math inline\"><em>x</em> = <em>R</em></span> 或 <span\nclass=\"math inline\"><em>x</em> = −<em>R</em></span> 收敛，则和函数 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span> 在 <span\nclass=\"math inline\"><em>x</em> = <em>R</em></span> 左连续或 <span\nclass=\"math inline\"><em>x</em> = −<em>R</em></span> 处右连续，即 <span\nclass=\"math inline\">$\\displaystyle \\lim_{x\\to\nR^-}S(x)=S(R)=\\sum_{n=0}^\\infty a_nR^n$</span></li>\n<li>若幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nx^n$</span> 的收敛半径 <span\nclass=\"math inline\"><em>R</em> &gt; 0</span>，在收敛区间 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span> 内的和函数为 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span>，则 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span> 在 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span>\n上可导，且有<strong>逐项求导公式</strong></li>\n</ol>\n<p><span class=\"math display\">$$\n  \\begin{aligned}\n  S'(x) = &amp;\\left(\\sum_{n=0}^\\infty a_nx^n\\right)'\\\\\n    = &amp;\\sum_{n=0}^\\infty \\left(a_nx^n\\right)'\\\\\n    = &amp;\\sum_{n=0}^\\infty na_nx^{n-1}\\\\\n  \\end{aligned}\n$$</span></p>\n<p>且幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\nna_nx^{n-1}$</span> 的收敛半径仍为 <span\nclass=\"math inline\"><em>R</em></span></p>\n<ol start=\"4\" type=\"1\">\n<li>若幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nx^n$</span> 的收敛半径 <span\nclass=\"math inline\"><em>R</em> &gt; 0</span>，在收敛区间 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span> 内的和函数为 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span>，则 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span> 在 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span>\n上可导，且有<strong>逐项求积公式</strong></li>\n</ol>\n<p><span class=\"math display\">$$\n  \\begin{aligned}\n  \\int_0^xS(t)\\,\\mathrm{d}t = &amp;\\int_0^x\\left(\\sum_{n=0}^\\infty\na_nt^n\\right)\\,\\mathrm{d}t\\\\\n    = &amp;\\sum_{n=0}^\\infty \\int_0^x a_nt^n\\,\\mathrm{d}t\\\\\n    = &amp;\\sum_{n=0}^\\infty \\frac{a_n}{n+1}x^{n+1}\\\\\n  \\end{aligned}\n$$</span></p>\n<p>且幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nt^n$</span> 的收敛半径仍为 <span\nclass=\"math inline\"><em>R</em></span></p>\n<h4 id=\"幂级数的分析性质\">幂级数的分析性质</h4>\n<p><strong>性质：</strong></p>\n<p>若幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nx^n$</span> 的收敛半径为 <span\nclass=\"math inline\"><em>R</em> &gt; 0</span>，在收敛区间 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span> 上连续；若 <span\nclass=\"math inline\">$\\displaystyle\\sum_{n=0}^\\infty a_nx^n$</span> 在\n<span class=\"math inline\"><em>x</em> = <em>R</em></span> 或 <span\nclass=\"math inline\"><em>x</em> = −<em>R</em></span> 收敛，则和函数 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span> 在 <span\nclass=\"math inline\"><em>x</em> = <em>R</em></span> 左连续或 <span\nclass=\"math inline\"><em>x</em> = −<em>R</em></span> 处右连续，即</p>\n<p><span class=\"math display\">$$\n\\displaystyle \\lim_{x\\to R^-}S(x)=S(R)=\\sum_{n=0}^\\infty a_nR^n\n$$</span></p>\n<p><strong>性质：</strong></p>\n<p>若幂函数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nx^n$</span> 的收敛半径为 <span\nclass=\"math inline\"><em>R</em> &gt; 0</span>，在收敛区间 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span> 上的和函数为 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span>，则 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span> 在 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span>\n上可导，且有<strong>逐项求导公式</strong></p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\nS'(x) = &amp;\\left(\\sum_{n=0}^\\infty a_nx^n\\right)'\\\\\n  = &amp;\\sum_{n=0}^\\infty \\left(a_nx^n\\right)'\\\\\n  = &amp;\\sum_{n=0}^\\infty na_nx^{n-1}\\\\\n\\end{aligned}\n$$</span></p>\n<p>且幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\nna_nx^{n-1}$</span> 的收敛半径仍为 <span\nclass=\"math inline\"><em>R</em></span></p>\n<p><strong>性质：</strong></p>\n<p>若幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nx^n$</span> 的收敛半径为 <span\nclass=\"math inline\"><em>R</em> &gt; 0</span>，在收敛区间 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span> 上的和函数为 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span>，则 <span\nclass=\"math inline\"><em>S</em>(<em>n</em>)</span> 在 <span\nclass=\"math inline\">(−<em>R</em>, <em>R</em>)</span>\n上可导，且有<strong>逐项求积公式</strong></p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n\\int_0^xS(t)\\,\\mathrm{d}t = &amp;\\int_0^x\\left(\\sum_{n=0}^\\infty\na_nt^n\\right)\\,\\mathrm{d}t\\\\\n  = &amp;\\sum_{n=0}^\\infty \\int_0^x a_nt^n\\,\\mathrm{d}t\\\\\n  = &amp;\\sum_{n=0}^\\infty \\frac{a_n}{n+1}x^{n+1}\\\\\n\\end{aligned}\n$$</span></p>\n<p>且幂级数 <span class=\"math inline\">$\\displaystyle \\sum_{n=0}^\\infty\na_nt^n$</span> 的收敛半径仍为 <span\nclass=\"math inline\"><em>R</em></span></p>\n<blockquote>\n<ol type=\"1\">\n<li>幂函数逐项求导，逐项积分后，收敛半径不变，但是收敛域可能改变</li>\n<li>幂函数在收敛区间内具有任意阶导数</li>\n</ol>\n</blockquote>\n<h4 id=\"taylor-级数\">Taylor 级数</h4>\n<p><strong>定义：</strong></p>\n<p>设函数 <span class=\"math inline\"><em>f</em>(<em>x</em>)</span> 在\n<span class=\"math inline\"><em>x</em><sub>0</sub></span>\n的某领域内有任意阶导数，称幂级数</p>\n<p><span class=\"math display\">$$\n\\sum_{n=0}^\\infty \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\n$$</span></p>\n<p>为 <span class=\"math inline\"><em>f</em>(<em>x</em>)</span> 在 <span\nclass=\"math inline\"><em>x</em><sub>0</sub></span> 处的\n<strong>Taylor</strong> 级数，记为</p>\n<p><span class=\"math display\">$$\nf(x) = \\sum_{n=0}^\\infty \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\n$$</span></p>\n<p><span class=\"math inline\"><em>x</em><sub>0</sub> = 0</span> 是，称为\n<strong>Maclaurin 级数</strong></p>\n<p><strong>定理（唯一性）</strong></p>\n<p>若 <span class=\"math inline\"><em>f</em>(<em>x</em>)</span> 在 <span\nclass=\"math inline\"><em>x</em><sub>0</sub></span>\n可展开为幂级数，则展开式唯一，且恰为 Taylor 级数</p>\n<p><strong>定理</strong></p>\n<p>设 <span class=\"math inline\"><em>f</em>(<em>x</em>)</span> 在 <span\nclass=\"math inline\"><em>x</em><sub>0</sub></span> 的某领域 <span\nclass=\"math inline\"><em>I</em></span> 内任意阶可导，则在 <span\nclass=\"math inline\"><em>I</em></span> 内</p>\n<p><span class=\"math display\">$$\nf(x) = \\sum_{n=0}^\\infty \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\n\\Leftrightarrow \\lim_{n\\to\\infty}R_n(x) =0\n$$</span></p>\n<h4 id=\"常用的初等函数的幂级数展开式\">常用的初等函数的幂级数展开式</h4>\n<ol type=\"1\">\n<li><span class=\"math inline\">$\\displaystyle e^x = \\sum_{n=0}^\\infty\n\\frac{x^n}{n!} \\quad (x\\in\\mathbb{R})$</span></li>\n<li><span class=\"math inline\">$\\displaystyle \\sin x = \\sum_{n=0}^\\infty\n\\frac{(-1)^nx^{2n+1}}{(2n+1)!} \\quad (x\\in\\mathbb{R})$</span></li>\n<li><span class=\"math inline\">$\\displaystyle \\cos x = \\sum_{n=0}^\\infty\n\\frac{(-1)^nx^{2n}}{(2n)!} \\quad (x\\in\\mathbb{R})$</span></li>\n<li><span class=\"math inline\">$\\displaystyle \\ln(1+x) =\n\\sum_{n=1}^\\infty \\frac{(-1)^{n-1}x^n}{n} \\quad (\\left\\vert x\n\\right\\vert&lt;1)$</span></li>\n<li><span class=\"math inline\">$\\displaystyle (1+x)^\\alpha =\n\\sum_{n=0}^\\infty \\frac{\\alpha(\\alpha-1)\\cdots(\\alpha-n+1)}{n!}x^n \\quad\n(\\left\\vert x\\right\\vert&lt;1)$</span></li>\n<li><span class=\"math inline\">$\\displaystyle \\frac{1}{1-x} =\n\\sum_{n=0}^\\infty x^n \\quad (\\left\\vert x\\right\\vert&lt;1)$</span></li>\n<li><span class=\"math inline\">$\\displaystyle \\frac{1}{1+x} =\n\\sum_{n=0}^\\infty (-1)^nx^n \\quad (\\left\\vert\nx\\right\\vert&lt;1)$</span></li>\n<li><span class=\"math inline\">$\\displaystyle \\arctan{x} =\n\\sum_{n=0}^\\infty \\frac{(-1)^n x^{2n+1}}{2n+1} \\quad (\\left\\vert\nx\\right\\vert\\leq 1)$</span></li>\n</ol>\n<h4 id=\"正弦级数和余弦级数\">正弦级数和余弦级数</h4>\n<p>若周期为 <span class=\"math inline\">2<em>π</em></span> 的函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>)</span> 是奇函数时，其 Fourier\n系数 <span\nclass=\"math inline\"><em>a</em><sub><em>n</em></sub> = 0</span>，从而</p>\n<p><span class=\"math display\">$$\nf(x) \\sim \\sum_{n=1}^{+\\infty}b_n\\sin(nx)\\quad\\text{正弦级数}\n$$</span></p>\n<p>其中 <span class=\"math inline\">$\\displaystyle b_n\n=\\frac{2}{\\pi}\\int_0^\\pi f(x)\\sin(nx) \\,\\mathrm{d}x$</span></p>\n<p>若周期为 <span class=\"math inline\">2<em>π</em></span> 的函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>)</span> 是偶函数，其 Fourier\n系数 <span\nclass=\"math inline\"><em>b</em><sub><em>n</em></sub> = 0</span>，从而</p>\n<p><span class=\"math display\">$$\nf(x) \\sim\n\\frac{a_0}{2}+\\sum_{n=0}^{+\\infty}a_n\\cos(nx)\\quad\\text{余弦级数}\n$$</span></p>\n<p>其中 <span class=\"math inline\">$\\displaystyle a_n\n=\\frac{1}{\\pi}\\int_0^\\pi f(x)\\cos(nx) \\,\\mathrm{d}x$</span></p>\n<p>若函数 <span class=\"math inline\"><em>f</em>(<em>x</em>)</span> 定义在\n<span class=\"math inline\">[0, <em>π</em>]</span> 上，可作奇延拓</p>\n<p><span class=\"math display\">$$\nF(x)=\n\\begin{cases}\n  f(x), &amp; 0&lt; x&lt; \\pi\\\\\n  -f(-x), &amp; -\\pi &lt; x &lt; 0\\\\\n  0, &amp; x=0,\\pm\\pi\\\\\n\\end{cases}\n$$</span></p>\n<p>使得 <span class=\"math inline\"><em>F</em>(<em>x</em>)</span> 为 <span\nclass=\"math inline\">[−<em>π</em>, <em>π</em>]</span> 上的奇函数</p>\n<p>也可作偶延拓</p>\n<p><span class=\"math display\">$$\nG(x)=\n\\begin{cases}\n  f(x), &amp; 0&lt; x&lt; \\pi\\\\\n  f(-x), &amp; -\\pi &lt; x &lt; 0\\\\\n  0, &amp; x=0,\\pm\\pi\\\\\n\\end{cases}\n$$</span></p>\n<p>使得函数 <span class=\"math inline\"><em>G</em>(<em>x</em>)</span> 为\n<span class=\"math inline\">[−<em>π</em>, <em>π</em>]</span>\n上的偶函数</p>\n<p>对于一定义在 <span class=\"math inline\">[0, <em>π</em>]</span>\n上的函数 <span\nclass=\"math inline\"><em>f</em>(<em>x</em>)</span>，可以对其先做奇延拓或者偶延拓，再将其展开为\n正弦级数或者余弦级数</p>\n<h4 id=\"周期为-2l-的-fourier-级数\">周期为 <span\nclass=\"math inline\">2<em>l</em></span> 的 Fourier 级数</h4>\n<p>设函数 <span class=\"math inline\"><em>f</em>(<em>x</em>)</span> 在区间\n<span class=\"math inline\">[−<em>l</em>, <em>l</em>]</span>\n上可积，作代换 <span class=\"math inline\">$x\n=\\frac{l}{\\pi}t$</span>，使得 <span class=\"math inline\">$F(t) =\nf\\left(\\frac{l}{\\pi}t\\right)$</span> 为 <span\nclass=\"math inline\">[−<em>π</em>, <em>π</em>]</span>\n上的可积函数，从而</p>\n<p><span class=\"math display\">$$\nF(t) \\sim\n\\frac{a_0}{2}+\\sum_{n=1}^{+\\infty}a_n\\cos(nt)+\\sum_{n=1}^{+\\infty}b_n\\sin(nt)\n$$</span></p>\n<p>其中</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\na_n &amp;= \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}F(t)\\cos(nt)\\,\\mathrm{d}t =\n\\frac{1}{l}\\int_{-l}^{l}f(x)\\cos\\left(\\frac{\\pi\nn}{l}x\\right)\\,\\mathrm{d}x\\\\\nb_n &amp;= \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}F(t)\\sin(nt)\\,\\mathrm{d}t =\n\\frac{1}{l}\\int_{-l}^{l}f(x)\\sin\\left(\\frac{\\pi\nn}{l}x\\right)\\,\\mathrm{d}x\n\\end{aligned}\n$$</span></p>\n<p>故</p>\n<p><span class=\"math display\">$$\nf(x) \\sim \\frac{a_0}{2}+\\sum_{n=1}^{+\\infty}\\left(a_n\\cos\\left(\\frac{\\pi\nn}{l}x\\right)+b_n\\sin\\left(\\frac{\\pi n}{l}x\\right)\\right)\n$$</span></p>\n<p>其中</p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\na_n &amp;= \\frac{1}{l}\\int_{-l}^{l}f(x)\\cos\\left(\\frac{\\pi\nn}{l}x\\right)\\,\\mathrm{d}x\\\\\nb_n &amp;= \\frac{1}{l}\\int_{-l}^{l}f(x)\\sin\\left(\\frac{\\pi\nn}{l}x\\right)\\,\\mathrm{d}x\n\\end{aligned}\n$$</span></p>\n<p><strong>定理：</strong></p>\n<p>若 <span class=\"math inline\"><em>f</em>(<em>x</em>)</span> 在 <span\nclass=\"math inline\">[−<em>l</em>, <em>l</em>]</span> 上满足 Dirichlet\n条件，则 Fourier 级数</p>\n<p><span class=\"math display\">$$\n\\frac{a_0}{2}+\\sum_{n=1}^{+\\infty}\\left(a_n\\cos\\left(\\frac{\\pi\nn}{l}x\\right)+b_n\\sin\\left(\\frac{\\pi n}{l}x\\right)\\right)\n$$</span></p>\n<p>收敛到</p>\n<p><span class=\"math display\">$$\nS(n) =\n\\begin{cases}\n  f(x), &amp; x \\text{为} f(x) \\text{的连续点}\\\\\n  \\frac{f(x^+)+f(x^-)}{2}, &amp; x \\text{为} f(x) \\text{的间断点}\\\\\n  \\frac{f(l^-)+f(-l^+)}{2} ,&amp; x=\\pm l\n\\end{cases}\n$$</span></p>\n"},{"title":"黑波","_content":"\n脉络根据书本，部分内容来源于书本，可对照参考\n\n## 马克思主义中国化时代化的历史进程与理论成果\n\n### 马克思主义中国化时代化的提出\n\n马克思主义中国化同时包含着马克思主义时代化的意蕴。我们党自成立以来，始终坚持把马克思主义基本原理同中国具体实际和时代特征相结合，不断进行理论创新。\n\n### 马克思主义中国化时代化的历史进程\n\n两大飞跃\n\n- 在改革开放和社会主义现代化建设新时期，中国共产党坚持以理论创新引领事业发展，（从新的实践和时代特征出发坚持和发展马克思主义，科学回答了建设中国特色社会主义的发展道路、发展阶段、根本任务、发展动力、发展战略、政治保证、祖国统一、外交和国际战略、领导力量和依靠力址等一系列基本问题，）形成中国特色社会主义理论体系，实现了马克思主义中国化时代化新的飞跃。\n\n- （党的十八大以来，中国特色社会主义进入新时代，以习近平同志为主要代表的中国共产党人，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，系统回答了新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义，建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国，建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党等重大时代课题，提出一系列原创性的治国理政新理念新思想新战略，）创立了习近平新时代中国特色社会主义思想，实现了马克思主义中国化时代化新的飞跃。\n\n### 马克思主义中国化时代化理论成果及其关系\n\n马克思主义中国化时代化的理论成果是一脉相承又与时俱进的关系。一方面，毛泽东思想所蕴含的马克思主义的立场、观点和方法，为中国特色社会主义理论体系提供了基本遵循。实事求是、群众路线、独立自主是毛泽东思想活的灵魂，这一具有中国共产党人特色的立场、观点和方法也贯穿于中国特色社会主义理论体系之中。\n\n另一方面，中国特色社会主义理论体系在新的历史条件下进一步丰富和发展了毛泽东思想。\n\n## 毛泽东思想及其历史地位\n\n### 毛泽东思想的主要内容和活的灵魂\n\n#### 毛泽东思想活的灵魂\n\n实事求是，群众路线，独立自主\n\n##### 实事求是\n\n实事求是是毛泽东思想的基本点，是毛泽东思想的精髓。实事求是,就是一切从实际出发，理论联系实际，坚持在实践中检验真理和发展真理。\n\n坚持实事求是，就要深入实际了解事物的本来面貌，把握事物内在必然联系，按照客观规律办事。\n\n坚持实事求是，就要清醒认识和正确把握我国基本国情。\n\n坚持实事求是，就要不断推进实践基础上的理论创新。\n\n##### 群众路线\n\n群众路线，就是一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动。\n\n群众路线本质上体现的是马克思主义关于人民群众是历史的创造者这一基本原理。\n\n坚持群众路线，就要坚持人民是推动历史发展的根本力量。\n\n坚持群众路线，就要坚持全心全意为人民服务的根本宗旨。\n\n坚持群众路线，就要保持党同人民群众的血肉联系。\n\n##### 独立自主\n\n独立自主，就是坚持独立思考，走自己的路，就是坚定不移地维护民族独立、捍卫国家主权，把立足点放在依靠自己力量的基础上，同时积极争取外援，开展国际经济文化交流，学习外国一切对我们有益的先进事物。\n\n不论过去、现在和将来，我们都要把国家和民族的发展放在自己力量的基点上，增强民族自尊心和自信心，坚定不移走自己的路。\n\n坚持独立自主原则，是毛泽东针对党内存在的“左”倾教条主义倾向，从中国革命遭受挫折的教训中提出的正确思想主张。\n\n坚持独立自主，就要坚持中国的事情必须由中国人民自己作主张、自己来处理。\n\n坚持独立自主，就要坚持独立自主的和平外交政策，坚定不移走和平发展道路。\n\n### 毛泽东思想的历史地位\n\n熟读小标题\n\n1. 马克思主义中国化时代化的第一个重大理论成果\n2. 中国革命和建设的科学指南\n3. 中国共产党和中国人民宝贵的精神财富\n\n## 新民主主义革命理论\n\n### 新民主主义革命理论形成的依据\n\n1. 近代中国国情\n\n   中国逐步成为半殖民地半封建社会，这是近代中国最基本的国情。\n\n2. 近代中国革命的时代特征\n\n   近代中国的社会性质和主要矛盾，决定了中国革命仍然是资产阶级民主革命。但中国资产阶级民主革命不同于一般的资产阶级民主革命，经历了从旧民主主义革命向新民主主义革命的转变，具有鲜明的时代特征。\n\n新民主主义革命和一般意义上的社会主义革命也不相同，它只推翻帝国主义、封建主义和官僚资本主义的反动统治，而不破坏参加反帝反封建的资本主义成分。这样的民主主义革命，不是旧范畴的民主主义革命,而是新民主主义革命。由此中国革命分两步走，第一步是完成反帝反封建的新民主主义革命任务，第二步是完成社会主义革命任务，这是质不同但又相互联系的两个革命过程。\n\n### 新民主主义革命理论的实践基础\n\n#### 新民主主义革命的艰辛探索奠定了革命理论形成的实践基础\n\n熟读 见书本\n\n### 新民主主义革命的总路线和基本纲领\n\n#### 新民主主义革命的总路线\n\n总路线是党和国家在某个历史阶段制定各方面具体工作路线和政策的总依据，是根本指导路线。\n\n1939 年，毛泽东在==《中国革命和中国共产党》==一文中第一次提出了==“新民主主义的革命”==的科学概念。\n\n1948 年，毛泽东在==《在晋绥干部会议上的讲话》==中完整地总结和概括了新民主主义革命总路线的内容，即==无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命==。\n\n##### 新民主主义革命的对象\n\n中国革命的对象是==帝国主义、封建主义和官僚资本主义==，它们是压在中国人民头上的三座大山。\n\n##### 新民主主义革命的动力\n\n新民主主义革命的动力包括无产阶级、农民阶级、城市小资产阶级和民族资产阶级。\n\n- 无产阶级是中国革命==最基本==的动力。\n- 农民是中国革命的==主力军==。\n- 城市小资产阶级是无产阶级的==可靠同盟者==。\n- 民族资产阶级也是中国革命的==动力之一==\n\n##### 新民主主义革命的领导力量\n\n区别新旧两种不同范畴的民主主义革命的根本标志是，革命的==领导权==是掌握在无产阶级手中还是掌握在资产阶级手中。\n\n中国无产阶级除了具有与先进的生产方式相联系、没有私人占有的生产资料、富于组织纪律性等一般无产阶级的基本优点外，还具有自身的特点和优点。\n\n1. 从诞生之日起，就身受外国资本主义、本国封建势力和资产阶级的三重压迫，而这些压迫的严重性和残酷性，是世界各民族中少见的。因此，中国无产阶级在革命斗争中比任何别的阶级都来得坚决和彻底。\n2. 集中分布在少数大城市和大企业，有利于组织和团结，有利于革命思想的传播和强大革命力量的形成。\n3. 成员中大部分出身于破产农民，和农民有着天然的联系，便于和农民结成亲密的联盟，共同团结战斗。\n\n#### 新民主主义的基本纲领\n\n##### 新民主主义的政治纲领\n\n新民主主义的政治纲领是：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国。\n\n新民主主义共和国是一定历史时期的国家形式，是过渡的形式\n\n##### 新民主主义的经济纲领\n\n新民主主义的经济纲领是：没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业。\n\n##### 新民主主义的文化纲领\n\n新民主主义文化，就是无产阶级领导的人民大众的反帝反封建的文化，即民族的科学的大众的文化。\n\n### 新民主主义革命的道路和基本经验\n\n#### 新民主主义革命的道路\n\n##### 新民主主义革命道路的提出\n\n1938 年 11 月，他在党的六届六中全会上明确指出：“共产党的任务，基本地不是经过长期合法斗争以进入起义和战争，也不是先占城市后取乡村，而是走相反的道路。”从而确立了经过长期武装斗争，先占乡村，后取城市，最后夺取全国胜利的革命道路。\n\n二、新民主主义革命的三大法宝\n\n1. 统一战线\n2. 武装斗争\n3. 党的建设\n\n第一，必须把思想建设始终放在党的建设的首位。加强党的思想建设，关键是要以无产阶级思想克服和改造各种非无产阶级思想。第二，必须在任何时候都重视党的组织建设。加强党的组织建设，根本的是要贯彻民主集中制这一根本组织原则，坚持在民主基础上的集中和在集中指导下的民主相结合，个人服从组织，少数服从多数，下级服从上级，全党服从中央。第三，必须重视党的作风建设。\n\n革命时期，思想建设首位\n\n现在，政治建设首位\n\n三大法宝与毛泽东思想活的灵魂区分\n\n## 社会主义改造理论\n\n### 从新民主主义到社会主义的转变\n\n#### 新民主主义社会是一个过渡性的社会\n\n从中华人民共和国成立到社会主义改造基本完成，是我国从新民主主义到社会主义的过渡时期。这一时期，我国社会的性质是新民主主义社会。新民主主义社会不是一个独立的社会形态，而是由新民主主义向社会主义转变的过渡性社会形态\n\n辨析：新民主主义社会是社会主义社会吗？不是，过渡\n\n主要的经济成分是三种：社会主义经济、个体经济和资本主义经济。\n\n新民主主义社会要继续向前发展，就要不断扩大国营经济.同时逐步将资本主义经济和个体经济改变为社会主义经济，使社会主义经济逐步成为我国的经济基础。\n\n一化三改\n\n1953 年 6 月，毛泽东在中央政治局会议上正式提出过渡时期的总路线和总任务，同年 12 月形成了关于总路线的完整表述：“从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期。党在这个过渡时期的总路线和总任务，是要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业.对手工业和对资本主义工商业的社会主义改造。\n\n##### 党在过渡时期的总路线的现实依据\n\n经过 1949 年到 1952 年三年的努力，我国已经有了相对强大和迅速发展的社会主义国营经济。\n\n土地改革完成后，为发展生产、抵御自然灾害，广大农民具有走互助合作道路的要求。\n\n新中国成立初期，党和国家在合理调整工商业的过程中，出现了加工订货、经销代销、统购包销、公私合营等一系列从低级到高级的国家资本主义形式。\n\n当时的国际形势也有利于中国向社会主义过渡。\n\n### 社会主义改造道路和历史经验\n\n#### 适合中国特点的社会主义改造道路\n\n##### 农业、手工业的社会主义改造\n\n1. 积极引导农民组织起来，走互助合作道路。\n2. 遵循自愿互利、典型示范和国家帮助的原则，以互助合作的优越性吸引农民走互助合作道路。\n3. 正确分析农村的阶级和阶层状况，制定正确的阶级政策。\n4. 坚持积极领导、稳步前进的方针，采取循序渐进的步骤。\n\n手工业一二三略\n\n##### 资本主义工商业的社会主义改造\n\n1. 用和平赎买的方法改造资本主义工商业。\n2. 采取从低级到高级的国家资本主义的过渡形式。\n   四马分肥：企业的利润，按国家所得税、企业公积金、工人福利费、资方红利这四个方面进行分配，即当时所说的“四马分肥”。\n3. 把资本主义工商业者改造成为自食其力的社会主义劳动者。\n\n#### 社会主义改造的历史经验\n\n1. 坚持社会主义工业化建设与社会主义改造同时并举。\n2. 采取积极引导、逐步过渡的方式。\n3. 用和平方法进行改造。\n\n## 社会主义建设道路\n\n初步探索的理论成果\n\n第一节初步探索的重要理论成果\n\n### 调动一切积极因素为社会主义事业服务\n\n特别是在社会主义改造基本完成以后怎样建设社会主义的道路问题上，仍然需要把马克思列宁主义基本原理同中国具体实际进行“第二次结合”，努力找到适合中国特点的社会主义建设道路。\n\n《论十大关系》标志着党探索中国社会主义建设道路的良好开端。\n\n《论十大关系》确定了一个基本方针，就是“努力把党内党外、国内国外的一切积极的因素，直接的、间接的积极因素，全部调动起来”③，为社会主义建设服务。\n\n### 正确认识和处理社会主义社会矛盾的思想\n\n党在八大前后，特别是毛泽东在 1957 年 2 月所作的《关于正确处理人民内部矛盾的问题》的报告，系统论述了社会主义社会矛盾的理论。\n\n#### 走中国工业化道路的思想\n\n毛泽东还主张企业要建立合理的规章制度和严格的责任制，要实行民主管理，实行干部参加劳动，工人参加管理，改革不合理的规章制度，工人群众、领导干部和技术人员三结合，即“两参一改三结合”。\n\n#### 初步探索的其他理论成果\n\n毛泽东提出：“社会主义这个阶段，又可能分为两个阶段，第一个阶段是不发达的社会主义，第二个阶段是比较发达的社会主义。后一阶段可能比前一阶段需要更长的时间。经过后一阶段，到了物质产品、精神财富都极为丰富和人们的共产主义觉悟极大提高的时候，就可以进入共产主义社会了。”\n\n“一纲四目”\n\n- \"一纲\"是：只要台湾归回祖国，其他一切问题悉尊重台湾领导人意见妥善处理。\n- “四目”是：\n\n  1.  台湾归回祖国后，除外交必须统一于中央外，所有军政大权人事安排等悉由台湾领导人全权处理；\n  2.  所有军政及建设费用，不足之数，悉由中央拨付；\n  3.  台湾之社会改革，可以从缓，必俟条件成熟，并尊重台湾领导人意见协商决定，然后进行；\n  4.  双方互约不派人进行破坏对方团结之事。\n\n### 初步探索的意义和经验教训\n\n#### 初步探索的意义\n\n1. 巩固和发展了我国的社会主义制度。\n2. 为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础。\n3. 丰富了科学社会主义的理论和实践。\n\n#### 初步探索的经验教训\n\n1. 必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路。\n2. 必须正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力。\n3. 必须从实际出发进行社会主义建设，建设规模和速度要与国力相适应，不能急于求成。\n4. 必须发展社会主义民主，健全社会主义法制。\n5. 必须坚持党的民主集中制和集体领导制度，加强执政党建设。\n6. 必须坚持对外开放，借鉴和吸收人类文明成果建设社会主义，不能关起门来搞建设。\n\n<!--第五章跳过-->\n\n## 邓小平理论\n\n### 邓小平理论首要的基本的理论问题\n\n在中国这样一个经济文化比较落后的国家==建设什么样的社会主义、怎样建设社会主义==是一个首要的基本的理论问题。\n\n“什么是社会主义，怎样建设社会主义”\n\n1992 年初，邓小平在南方谈话中对社会主义本质作出了总结性的理论概括，他指出：“社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕。”\n\n### 邓小平理论的精髓\n\n==解放思想、实事求是==\n\n与毛泽东三大法宝区分\n\n实事求是，群众路线，独立自主\n\n### 邓小平理论的主要内容\n\n#### 社会主义初级阶段理论和党的基本路线\n\n##### 社会主义初级阶段理论\n\n党的十三大系统地阐述了社会主义初级阶段的科学内涵。首先，阐明了社会主义初级阶段这个论断包括两层含义：\n\n1. 我国社会已经是社会主义社会。我们必须坚持而不能离开社会主义。\n2. 我国的社会主义社会还处在初级阶段。\n\n其次，强调了社会主义初级阶段的长期性。\n最后，阐述了社会主义初级阶段的基本特征。\n\n##### 党在社会主义初级阶段的基本路线\n\n熟读\n\n党的十三大从我国社会主义初级阶段的基本国情出发，在科学认识我国社会主要矛盾的基础上，提出了党在社会主义初级阶段的基本路线：“领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强、民主、文明的社会主义现代化国家而奋斗。”\n\n记\n\n1. 坚持社会主义道路、\n2. 坚持无产阶级专政（后表述为人民民主专政）、\n3. 坚持共产党的领导、\n4. 坚持马列主义毛泽东思想\n\n这四项基本原则\n\n#### 社会主义根本任务和发展战略理论\n\n##### 社会主义根本任务的理论\n\n社会主义的根本任务是发展生产力\n\n##### 分三步走基本实现现代化的发展战略\n\n了解\n\n#### 社会主义改革开放和社会主义市场经济理论\n\n##### 社会主义改革开放理论\n\n党的十一届三中全会作出把党和国家工作中心转移到经济建设上来、实行改革开放的历史性决策，实现了新中国成立以来党的历史上具有深远意义的伟大转折，开启了改革开放和社会主义现代化的伟大征程。\n\n改革是一场深刻的社会变革，是中国的第二次革命，是实现中国现代化的必由之路。\n\n归根到底，主要看是否有利于发展社会主义社会的生产力，是否有利于增强社会主义国家的综合国力，是否有利于提高人民生活水平，即“三个有利于”标准。\n\n##### 社会主义市场经济理论\n\n辨析：计划经济就是社会主义，市场经济就是资本主义。\n\n1992 年，邓小平在南方谈话中明确指出：“计划多一点还是市场多一点，不是社会主义与资本主义的本质区别。计划经济不等于社会主义，资本主义也有计划；市场经济不等于资本主义，社会主义也有市场。计划和市场都是经济手段。”\n\n邓小平的社会主义市场经济理论具有丰富的内涵：\n\n1. 计划经济和市场经济不是划分社会制度的标志，计划经济不等于社会主义，市场经济也不等于资本主义；\n2. 计划和市场都是经济手段，对经济活动的调节各有优劣，社会主义实行市场经济是要把两者优势结合起来；\n3. 市场经济作为资源配置手段本身不具有制度属性，可以和不同的社会制度结合，从而表现出不同的性质。\n\n#### 中国特色社会主义外交和国际战略\n\n邓小平对时代主题的判断，其基本点是：\n\n1. 世界大战在一个相当长的时期内可以避免.我们有可能争取较长时期的和平环境；\n2. 从经济角度来说，和平与发展是当今世界两大带有全球性的战略问题，是东西方之间、发达国家与发展中国家之间矛盾全局的集中体现；\n3. 和平与发展是相辅相成的，世界和平是促进各国共同发展的前提条件，各国的共同发展则是保持世界和平的重要基础；\n4. 和平与发展成为时代主题，并不意味着这两个问题已经解决。\n\n判断：现在世界只需努力发展（取得和平）\n\n- 错误，都没有解决，要一起解决，要清醒地看到，当今世界和平与发展这两大问题一个都没有得到解决，还需要各国人民长期不懈地共同努力。\n\n### 邓小平理论的历史地位\n\n熟读小标题即可\n\n1. 马克思列宁主义、毛泽东思想的继承和发展\n2. 中国特色社会主义理论体系的开篇之作\n3. 改革开放和社会主义现代化建设的科学指南\n\n## “三个代表”重要思想\n\n### “三个代表”重要思想的核心观点\n\n1. 始终代表中国先进生产力的发展要求\n2. 始终代表中国先进文化的前进方向\n\n### “三个代表”重要思想的主要内容\n\n1. 发展是党执政兴国的第一要务\n2. 建立社会主义市场经济体制\n\n   在建立什么样的经济体制问题上，江泽民根据邓小平南方谈话精神，明确提出使用“社会主义市场经济体制”这个提法。党的十四大正式把建立社会主义市场经济体制确立为我国经济体制改革的目标。\n\n3. 实施“引进来”和“走出去”相结合的对外开放战略\n\n   对外开放是一项长期的基本国策。\n\n### “三个代表”重要思想的历史地位\n\n#### 中国特色社会主义理论体系的丰富发展\n\n#### 加强和改进党的建设、推进中国特色社会主义事业的强大理论武器\n\n## 科学发展观\n\n### 科学发展观的科学内涵\n\n熟读小标题\n\n1. 推动经济社会发展是科学发展观的第一要义\n2. 以人为本是科学发展观的核心立场\n3. 全面协调可持续是科学发展观的基本要求\n4. 统筹兼顾是科学发展观的根本方法\n\n### 科学发展观的主要内容\n\n#### 加快转变经济发展方式\n\n推动经济持续健康发展，必须坚持以科学发展为主题，以加快转变经济发展方式为主线。\n\n主题和主线\n\n#### 发展社会主义民主政治\n\n社会主义民主政治的本质和核心是==人民当家作主==。\n\n#### 构建社会主义和谐社会\n\n胡锦涛明确指出：“社会和谐是中国特色社会主义的本质属性。”\n\n#### 全面提高党的建设科学化水平\n\n党的建设是党领导的伟大事业不断取得胜利的重要法宝。\n\n#### 科学发展观的历史地位\n\n熟读小标题\n\n1. 中国特色社会主义理论体系在新世纪新阶段的接续发展\n2. 全面建设小康社会、加快推进社会主义现代化的根本指针\n","source":"_posts/黑波.md","raw":"---\ntitle: 黑波\n---\n\n脉络根据书本，部分内容来源于书本，可对照参考\n\n## 马克思主义中国化时代化的历史进程与理论成果\n\n### 马克思主义中国化时代化的提出\n\n马克思主义中国化同时包含着马克思主义时代化的意蕴。我们党自成立以来，始终坚持把马克思主义基本原理同中国具体实际和时代特征相结合，不断进行理论创新。\n\n### 马克思主义中国化时代化的历史进程\n\n两大飞跃\n\n- 在改革开放和社会主义现代化建设新时期，中国共产党坚持以理论创新引领事业发展，（从新的实践和时代特征出发坚持和发展马克思主义，科学回答了建设中国特色社会主义的发展道路、发展阶段、根本任务、发展动力、发展战略、政治保证、祖国统一、外交和国际战略、领导力量和依靠力址等一系列基本问题，）形成中国特色社会主义理论体系，实现了马克思主义中国化时代化新的飞跃。\n\n- （党的十八大以来，中国特色社会主义进入新时代，以习近平同志为主要代表的中国共产党人，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，系统回答了新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义，建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国，建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党等重大时代课题，提出一系列原创性的治国理政新理念新思想新战略，）创立了习近平新时代中国特色社会主义思想，实现了马克思主义中国化时代化新的飞跃。\n\n### 马克思主义中国化时代化理论成果及其关系\n\n马克思主义中国化时代化的理论成果是一脉相承又与时俱进的关系。一方面，毛泽东思想所蕴含的马克思主义的立场、观点和方法，为中国特色社会主义理论体系提供了基本遵循。实事求是、群众路线、独立自主是毛泽东思想活的灵魂，这一具有中国共产党人特色的立场、观点和方法也贯穿于中国特色社会主义理论体系之中。\n\n另一方面，中国特色社会主义理论体系在新的历史条件下进一步丰富和发展了毛泽东思想。\n\n## 毛泽东思想及其历史地位\n\n### 毛泽东思想的主要内容和活的灵魂\n\n#### 毛泽东思想活的灵魂\n\n实事求是，群众路线，独立自主\n\n##### 实事求是\n\n实事求是是毛泽东思想的基本点，是毛泽东思想的精髓。实事求是,就是一切从实际出发，理论联系实际，坚持在实践中检验真理和发展真理。\n\n坚持实事求是，就要深入实际了解事物的本来面貌，把握事物内在必然联系，按照客观规律办事。\n\n坚持实事求是，就要清醒认识和正确把握我国基本国情。\n\n坚持实事求是，就要不断推进实践基础上的理论创新。\n\n##### 群众路线\n\n群众路线，就是一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动。\n\n群众路线本质上体现的是马克思主义关于人民群众是历史的创造者这一基本原理。\n\n坚持群众路线，就要坚持人民是推动历史发展的根本力量。\n\n坚持群众路线，就要坚持全心全意为人民服务的根本宗旨。\n\n坚持群众路线，就要保持党同人民群众的血肉联系。\n\n##### 独立自主\n\n独立自主，就是坚持独立思考，走自己的路，就是坚定不移地维护民族独立、捍卫国家主权，把立足点放在依靠自己力量的基础上，同时积极争取外援，开展国际经济文化交流，学习外国一切对我们有益的先进事物。\n\n不论过去、现在和将来，我们都要把国家和民族的发展放在自己力量的基点上，增强民族自尊心和自信心，坚定不移走自己的路。\n\n坚持独立自主原则，是毛泽东针对党内存在的“左”倾教条主义倾向，从中国革命遭受挫折的教训中提出的正确思想主张。\n\n坚持独立自主，就要坚持中国的事情必须由中国人民自己作主张、自己来处理。\n\n坚持独立自主，就要坚持独立自主的和平外交政策，坚定不移走和平发展道路。\n\n### 毛泽东思想的历史地位\n\n熟读小标题\n\n1. 马克思主义中国化时代化的第一个重大理论成果\n2. 中国革命和建设的科学指南\n3. 中国共产党和中国人民宝贵的精神财富\n\n## 新民主主义革命理论\n\n### 新民主主义革命理论形成的依据\n\n1. 近代中国国情\n\n   中国逐步成为半殖民地半封建社会，这是近代中国最基本的国情。\n\n2. 近代中国革命的时代特征\n\n   近代中国的社会性质和主要矛盾，决定了中国革命仍然是资产阶级民主革命。但中国资产阶级民主革命不同于一般的资产阶级民主革命，经历了从旧民主主义革命向新民主主义革命的转变，具有鲜明的时代特征。\n\n新民主主义革命和一般意义上的社会主义革命也不相同，它只推翻帝国主义、封建主义和官僚资本主义的反动统治，而不破坏参加反帝反封建的资本主义成分。这样的民主主义革命，不是旧范畴的民主主义革命,而是新民主主义革命。由此中国革命分两步走，第一步是完成反帝反封建的新民主主义革命任务，第二步是完成社会主义革命任务，这是质不同但又相互联系的两个革命过程。\n\n### 新民主主义革命理论的实践基础\n\n#### 新民主主义革命的艰辛探索奠定了革命理论形成的实践基础\n\n熟读 见书本\n\n### 新民主主义革命的总路线和基本纲领\n\n#### 新民主主义革命的总路线\n\n总路线是党和国家在某个历史阶段制定各方面具体工作路线和政策的总依据，是根本指导路线。\n\n1939 年，毛泽东在==《中国革命和中国共产党》==一文中第一次提出了==“新民主主义的革命”==的科学概念。\n\n1948 年，毛泽东在==《在晋绥干部会议上的讲话》==中完整地总结和概括了新民主主义革命总路线的内容，即==无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命==。\n\n##### 新民主主义革命的对象\n\n中国革命的对象是==帝国主义、封建主义和官僚资本主义==，它们是压在中国人民头上的三座大山。\n\n##### 新民主主义革命的动力\n\n新民主主义革命的动力包括无产阶级、农民阶级、城市小资产阶级和民族资产阶级。\n\n- 无产阶级是中国革命==最基本==的动力。\n- 农民是中国革命的==主力军==。\n- 城市小资产阶级是无产阶级的==可靠同盟者==。\n- 民族资产阶级也是中国革命的==动力之一==\n\n##### 新民主主义革命的领导力量\n\n区别新旧两种不同范畴的民主主义革命的根本标志是，革命的==领导权==是掌握在无产阶级手中还是掌握在资产阶级手中。\n\n中国无产阶级除了具有与先进的生产方式相联系、没有私人占有的生产资料、富于组织纪律性等一般无产阶级的基本优点外，还具有自身的特点和优点。\n\n1. 从诞生之日起，就身受外国资本主义、本国封建势力和资产阶级的三重压迫，而这些压迫的严重性和残酷性，是世界各民族中少见的。因此，中国无产阶级在革命斗争中比任何别的阶级都来得坚决和彻底。\n2. 集中分布在少数大城市和大企业，有利于组织和团结，有利于革命思想的传播和强大革命力量的形成。\n3. 成员中大部分出身于破产农民，和农民有着天然的联系，便于和农民结成亲密的联盟，共同团结战斗。\n\n#### 新民主主义的基本纲领\n\n##### 新民主主义的政治纲领\n\n新民主主义的政治纲领是：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国。\n\n新民主主义共和国是一定历史时期的国家形式，是过渡的形式\n\n##### 新民主主义的经济纲领\n\n新民主主义的经济纲领是：没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业。\n\n##### 新民主主义的文化纲领\n\n新民主主义文化，就是无产阶级领导的人民大众的反帝反封建的文化，即民族的科学的大众的文化。\n\n### 新民主主义革命的道路和基本经验\n\n#### 新民主主义革命的道路\n\n##### 新民主主义革命道路的提出\n\n1938 年 11 月，他在党的六届六中全会上明确指出：“共产党的任务，基本地不是经过长期合法斗争以进入起义和战争，也不是先占城市后取乡村，而是走相反的道路。”从而确立了经过长期武装斗争，先占乡村，后取城市，最后夺取全国胜利的革命道路。\n\n二、新民主主义革命的三大法宝\n\n1. 统一战线\n2. 武装斗争\n3. 党的建设\n\n第一，必须把思想建设始终放在党的建设的首位。加强党的思想建设，关键是要以无产阶级思想克服和改造各种非无产阶级思想。第二，必须在任何时候都重视党的组织建设。加强党的组织建设，根本的是要贯彻民主集中制这一根本组织原则，坚持在民主基础上的集中和在集中指导下的民主相结合，个人服从组织，少数服从多数，下级服从上级，全党服从中央。第三，必须重视党的作风建设。\n\n革命时期，思想建设首位\n\n现在，政治建设首位\n\n三大法宝与毛泽东思想活的灵魂区分\n\n## 社会主义改造理论\n\n### 从新民主主义到社会主义的转变\n\n#### 新民主主义社会是一个过渡性的社会\n\n从中华人民共和国成立到社会主义改造基本完成，是我国从新民主主义到社会主义的过渡时期。这一时期，我国社会的性质是新民主主义社会。新民主主义社会不是一个独立的社会形态，而是由新民主主义向社会主义转变的过渡性社会形态\n\n辨析：新民主主义社会是社会主义社会吗？不是，过渡\n\n主要的经济成分是三种：社会主义经济、个体经济和资本主义经济。\n\n新民主主义社会要继续向前发展，就要不断扩大国营经济.同时逐步将资本主义经济和个体经济改变为社会主义经济，使社会主义经济逐步成为我国的经济基础。\n\n一化三改\n\n1953 年 6 月，毛泽东在中央政治局会议上正式提出过渡时期的总路线和总任务，同年 12 月形成了关于总路线的完整表述：“从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期。党在这个过渡时期的总路线和总任务，是要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业.对手工业和对资本主义工商业的社会主义改造。\n\n##### 党在过渡时期的总路线的现实依据\n\n经过 1949 年到 1952 年三年的努力，我国已经有了相对强大和迅速发展的社会主义国营经济。\n\n土地改革完成后，为发展生产、抵御自然灾害，广大农民具有走互助合作道路的要求。\n\n新中国成立初期，党和国家在合理调整工商业的过程中，出现了加工订货、经销代销、统购包销、公私合营等一系列从低级到高级的国家资本主义形式。\n\n当时的国际形势也有利于中国向社会主义过渡。\n\n### 社会主义改造道路和历史经验\n\n#### 适合中国特点的社会主义改造道路\n\n##### 农业、手工业的社会主义改造\n\n1. 积极引导农民组织起来，走互助合作道路。\n2. 遵循自愿互利、典型示范和国家帮助的原则，以互助合作的优越性吸引农民走互助合作道路。\n3. 正确分析农村的阶级和阶层状况，制定正确的阶级政策。\n4. 坚持积极领导、稳步前进的方针，采取循序渐进的步骤。\n\n手工业一二三略\n\n##### 资本主义工商业的社会主义改造\n\n1. 用和平赎买的方法改造资本主义工商业。\n2. 采取从低级到高级的国家资本主义的过渡形式。\n   四马分肥：企业的利润，按国家所得税、企业公积金、工人福利费、资方红利这四个方面进行分配，即当时所说的“四马分肥”。\n3. 把资本主义工商业者改造成为自食其力的社会主义劳动者。\n\n#### 社会主义改造的历史经验\n\n1. 坚持社会主义工业化建设与社会主义改造同时并举。\n2. 采取积极引导、逐步过渡的方式。\n3. 用和平方法进行改造。\n\n## 社会主义建设道路\n\n初步探索的理论成果\n\n第一节初步探索的重要理论成果\n\n### 调动一切积极因素为社会主义事业服务\n\n特别是在社会主义改造基本完成以后怎样建设社会主义的道路问题上，仍然需要把马克思列宁主义基本原理同中国具体实际进行“第二次结合”，努力找到适合中国特点的社会主义建设道路。\n\n《论十大关系》标志着党探索中国社会主义建设道路的良好开端。\n\n《论十大关系》确定了一个基本方针，就是“努力把党内党外、国内国外的一切积极的因素，直接的、间接的积极因素，全部调动起来”③，为社会主义建设服务。\n\n### 正确认识和处理社会主义社会矛盾的思想\n\n党在八大前后，特别是毛泽东在 1957 年 2 月所作的《关于正确处理人民内部矛盾的问题》的报告，系统论述了社会主义社会矛盾的理论。\n\n#### 走中国工业化道路的思想\n\n毛泽东还主张企业要建立合理的规章制度和严格的责任制，要实行民主管理，实行干部参加劳动，工人参加管理，改革不合理的规章制度，工人群众、领导干部和技术人员三结合，即“两参一改三结合”。\n\n#### 初步探索的其他理论成果\n\n毛泽东提出：“社会主义这个阶段，又可能分为两个阶段，第一个阶段是不发达的社会主义，第二个阶段是比较发达的社会主义。后一阶段可能比前一阶段需要更长的时间。经过后一阶段，到了物质产品、精神财富都极为丰富和人们的共产主义觉悟极大提高的时候，就可以进入共产主义社会了。”\n\n“一纲四目”\n\n- \"一纲\"是：只要台湾归回祖国，其他一切问题悉尊重台湾领导人意见妥善处理。\n- “四目”是：\n\n  1.  台湾归回祖国后，除外交必须统一于中央外，所有军政大权人事安排等悉由台湾领导人全权处理；\n  2.  所有军政及建设费用，不足之数，悉由中央拨付；\n  3.  台湾之社会改革，可以从缓，必俟条件成熟，并尊重台湾领导人意见协商决定，然后进行；\n  4.  双方互约不派人进行破坏对方团结之事。\n\n### 初步探索的意义和经验教训\n\n#### 初步探索的意义\n\n1. 巩固和发展了我国的社会主义制度。\n2. 为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础。\n3. 丰富了科学社会主义的理论和实践。\n\n#### 初步探索的经验教训\n\n1. 必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路。\n2. 必须正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力。\n3. 必须从实际出发进行社会主义建设，建设规模和速度要与国力相适应，不能急于求成。\n4. 必须发展社会主义民主，健全社会主义法制。\n5. 必须坚持党的民主集中制和集体领导制度，加强执政党建设。\n6. 必须坚持对外开放，借鉴和吸收人类文明成果建设社会主义，不能关起门来搞建设。\n\n<!--第五章跳过-->\n\n## 邓小平理论\n\n### 邓小平理论首要的基本的理论问题\n\n在中国这样一个经济文化比较落后的国家==建设什么样的社会主义、怎样建设社会主义==是一个首要的基本的理论问题。\n\n“什么是社会主义，怎样建设社会主义”\n\n1992 年初，邓小平在南方谈话中对社会主义本质作出了总结性的理论概括，他指出：“社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕。”\n\n### 邓小平理论的精髓\n\n==解放思想、实事求是==\n\n与毛泽东三大法宝区分\n\n实事求是，群众路线，独立自主\n\n### 邓小平理论的主要内容\n\n#### 社会主义初级阶段理论和党的基本路线\n\n##### 社会主义初级阶段理论\n\n党的十三大系统地阐述了社会主义初级阶段的科学内涵。首先，阐明了社会主义初级阶段这个论断包括两层含义：\n\n1. 我国社会已经是社会主义社会。我们必须坚持而不能离开社会主义。\n2. 我国的社会主义社会还处在初级阶段。\n\n其次，强调了社会主义初级阶段的长期性。\n最后，阐述了社会主义初级阶段的基本特征。\n\n##### 党在社会主义初级阶段的基本路线\n\n熟读\n\n党的十三大从我国社会主义初级阶段的基本国情出发，在科学认识我国社会主要矛盾的基础上，提出了党在社会主义初级阶段的基本路线：“领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强、民主、文明的社会主义现代化国家而奋斗。”\n\n记\n\n1. 坚持社会主义道路、\n2. 坚持无产阶级专政（后表述为人民民主专政）、\n3. 坚持共产党的领导、\n4. 坚持马列主义毛泽东思想\n\n这四项基本原则\n\n#### 社会主义根本任务和发展战略理论\n\n##### 社会主义根本任务的理论\n\n社会主义的根本任务是发展生产力\n\n##### 分三步走基本实现现代化的发展战略\n\n了解\n\n#### 社会主义改革开放和社会主义市场经济理论\n\n##### 社会主义改革开放理论\n\n党的十一届三中全会作出把党和国家工作中心转移到经济建设上来、实行改革开放的历史性决策，实现了新中国成立以来党的历史上具有深远意义的伟大转折，开启了改革开放和社会主义现代化的伟大征程。\n\n改革是一场深刻的社会变革，是中国的第二次革命，是实现中国现代化的必由之路。\n\n归根到底，主要看是否有利于发展社会主义社会的生产力，是否有利于增强社会主义国家的综合国力，是否有利于提高人民生活水平，即“三个有利于”标准。\n\n##### 社会主义市场经济理论\n\n辨析：计划经济就是社会主义，市场经济就是资本主义。\n\n1992 年，邓小平在南方谈话中明确指出：“计划多一点还是市场多一点，不是社会主义与资本主义的本质区别。计划经济不等于社会主义，资本主义也有计划；市场经济不等于资本主义，社会主义也有市场。计划和市场都是经济手段。”\n\n邓小平的社会主义市场经济理论具有丰富的内涵：\n\n1. 计划经济和市场经济不是划分社会制度的标志，计划经济不等于社会主义，市场经济也不等于资本主义；\n2. 计划和市场都是经济手段，对经济活动的调节各有优劣，社会主义实行市场经济是要把两者优势结合起来；\n3. 市场经济作为资源配置手段本身不具有制度属性，可以和不同的社会制度结合，从而表现出不同的性质。\n\n#### 中国特色社会主义外交和国际战略\n\n邓小平对时代主题的判断，其基本点是：\n\n1. 世界大战在一个相当长的时期内可以避免.我们有可能争取较长时期的和平环境；\n2. 从经济角度来说，和平与发展是当今世界两大带有全球性的战略问题，是东西方之间、发达国家与发展中国家之间矛盾全局的集中体现；\n3. 和平与发展是相辅相成的，世界和平是促进各国共同发展的前提条件，各国的共同发展则是保持世界和平的重要基础；\n4. 和平与发展成为时代主题，并不意味着这两个问题已经解决。\n\n判断：现在世界只需努力发展（取得和平）\n\n- 错误，都没有解决，要一起解决，要清醒地看到，当今世界和平与发展这两大问题一个都没有得到解决，还需要各国人民长期不懈地共同努力。\n\n### 邓小平理论的历史地位\n\n熟读小标题即可\n\n1. 马克思列宁主义、毛泽东思想的继承和发展\n2. 中国特色社会主义理论体系的开篇之作\n3. 改革开放和社会主义现代化建设的科学指南\n\n## “三个代表”重要思想\n\n### “三个代表”重要思想的核心观点\n\n1. 始终代表中国先进生产力的发展要求\n2. 始终代表中国先进文化的前进方向\n\n### “三个代表”重要思想的主要内容\n\n1. 发展是党执政兴国的第一要务\n2. 建立社会主义市场经济体制\n\n   在建立什么样的经济体制问题上，江泽民根据邓小平南方谈话精神，明确提出使用“社会主义市场经济体制”这个提法。党的十四大正式把建立社会主义市场经济体制确立为我国经济体制改革的目标。\n\n3. 实施“引进来”和“走出去”相结合的对外开放战略\n\n   对外开放是一项长期的基本国策。\n\n### “三个代表”重要思想的历史地位\n\n#### 中国特色社会主义理论体系的丰富发展\n\n#### 加强和改进党的建设、推进中国特色社会主义事业的强大理论武器\n\n## 科学发展观\n\n### 科学发展观的科学内涵\n\n熟读小标题\n\n1. 推动经济社会发展是科学发展观的第一要义\n2. 以人为本是科学发展观的核心立场\n3. 全面协调可持续是科学发展观的基本要求\n4. 统筹兼顾是科学发展观的根本方法\n\n### 科学发展观的主要内容\n\n#### 加快转变经济发展方式\n\n推动经济持续健康发展，必须坚持以科学发展为主题，以加快转变经济发展方式为主线。\n\n主题和主线\n\n#### 发展社会主义民主政治\n\n社会主义民主政治的本质和核心是==人民当家作主==。\n\n#### 构建社会主义和谐社会\n\n胡锦涛明确指出：“社会和谐是中国特色社会主义的本质属性。”\n\n#### 全面提高党的建设科学化水平\n\n党的建设是党领导的伟大事业不断取得胜利的重要法宝。\n\n#### 科学发展观的历史地位\n\n熟读小标题\n\n1. 中国特色社会主义理论体系在新世纪新阶段的接续发展\n2. 全面建设小康社会、加快推进社会主义现代化的根本指针\n","slug":"黑波","published":1,"date":"2025-09-11T11:36:20.597Z","updated":"2025-09-11T11:36:20.597Z","comments":1,"layout":"post","photos":[],"_id":"cmffo52nv000f6xzdeckm8nnd","content":"<p>脉络根据书本，部分内容来源于书本，可对照参考</p>\n<h2\nid=\"马克思主义中国化时代化的历史进程与理论成果\">马克思主义中国化时代化的历史进程与理论成果</h2>\n<h3 id=\"马克思主义中国化时代化的提出\">马克思主义中国化时代化的提出</h3>\n<p>马克思主义中国化同时包含着马克思主义时代化的意蕴。我们党自成立以来，始终坚持把马克思主义基本原理同中国具体实际和时代特征相结合，不断进行理论创新。</p>\n<h3\nid=\"马克思主义中国化时代化的历史进程\">马克思主义中国化时代化的历史进程</h3>\n<p>两大飞跃</p>\n<ul>\n<li><p>在改革开放和社会主义现代化建设新时期，中国共产党坚持以理论创新引领事业发展，（从新的实践和时代特征出发坚持和发展马克思主义，科学回答了建设中国特色社会主义的发展道路、发展阶段、根本任务、发展动力、发展战略、政治保证、祖国统一、外交和国际战略、领导力量和依靠力址等一系列基本问题，）形成中国特色社会主义理论体系，实现了马克思主义中国化时代化新的飞跃。</p></li>\n<li><p>（党的十八大以来，中国特色社会主义进入新时代，以习近平同志为主要代表的中国共产党人，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，系统回答了新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义，建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国，建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党等重大时代课题，提出一系列原创性的治国理政新理念新思想新战略，）创立了习近平新时代中国特色社会主义思想，实现了马克思主义中国化时代化新的飞跃。</p></li>\n</ul>\n<h3\nid=\"马克思主义中国化时代化理论成果及其关系\">马克思主义中国化时代化理论成果及其关系</h3>\n<p>马克思主义中国化时代化的理论成果是一脉相承又与时俱进的关系。一方面，毛泽东思想所蕴含的马克思主义的立场、观点和方法，为中国特色社会主义理论体系提供了基本遵循。实事求是、群众路线、独立自主是毛泽东思想活的灵魂，这一具有中国共产党人特色的立场、观点和方法也贯穿于中国特色社会主义理论体系之中。</p>\n<p>另一方面，中国特色社会主义理论体系在新的历史条件下进一步丰富和发展了毛泽东思想。</p>\n<h2 id=\"毛泽东思想及其历史地位\">毛泽东思想及其历史地位</h2>\n<h3\nid=\"毛泽东思想的主要内容和活的灵魂\">毛泽东思想的主要内容和活的灵魂</h3>\n<h4 id=\"毛泽东思想活的灵魂\">毛泽东思想活的灵魂</h4>\n<p>实事求是，群众路线，独立自主</p>\n<h5 id=\"实事求是\">实事求是</h5>\n<p>实事求是是毛泽东思想的基本点，是毛泽东思想的精髓。实事求是,就是一切从实际出发，理论联系实际，坚持在实践中检验真理和发展真理。</p>\n<p>坚持实事求是，就要深入实际了解事物的本来面貌，把握事物内在必然联系，按照客观规律办事。</p>\n<p>坚持实事求是，就要清醒认识和正确把握我国基本国情。</p>\n<p>坚持实事求是，就要不断推进实践基础上的理论创新。</p>\n<h5 id=\"群众路线\">群众路线</h5>\n<p>群众路线，就是一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动。</p>\n<p>群众路线本质上体现的是马克思主义关于人民群众是历史的创造者这一基本原理。</p>\n<p>坚持群众路线，就要坚持人民是推动历史发展的根本力量。</p>\n<p>坚持群众路线，就要坚持全心全意为人民服务的根本宗旨。</p>\n<p>坚持群众路线，就要保持党同人民群众的血肉联系。</p>\n<h5 id=\"独立自主\">独立自主</h5>\n<p>独立自主，就是坚持独立思考，走自己的路，就是坚定不移地维护民族独立、捍卫国家主权，把立足点放在依靠自己力量的基础上，同时积极争取外援，开展国际经济文化交流，学习外国一切对我们有益的先进事物。</p>\n<p>不论过去、现在和将来，我们都要把国家和民族的发展放在自己力量的基点上，增强民族自尊心和自信心，坚定不移走自己的路。</p>\n<p>坚持独立自主原则，是毛泽东针对党内存在的“左”倾教条主义倾向，从中国革命遭受挫折的教训中提出的正确思想主张。</p>\n<p>坚持独立自主，就要坚持中国的事情必须由中国人民自己作主张、自己来处理。</p>\n<p>坚持独立自主，就要坚持独立自主的和平外交政策，坚定不移走和平发展道路。</p>\n<h3 id=\"毛泽东思想的历史地位\">毛泽东思想的历史地位</h3>\n<p>熟读小标题</p>\n<ol type=\"1\">\n<li>马克思主义中国化时代化的第一个重大理论成果</li>\n<li>中国革命和建设的科学指南</li>\n<li>中国共产党和中国人民宝贵的精神财富</li>\n</ol>\n<h2 id=\"新民主主义革命理论\">新民主主义革命理论</h2>\n<h3 id=\"新民主主义革命理论形成的依据\">新民主主义革命理论形成的依据</h3>\n<ol type=\"1\">\n<li><p>近代中国国情</p>\n<p>中国逐步成为半殖民地半封建社会，这是近代中国最基本的国情。</p></li>\n<li><p>近代中国革命的时代特征</p>\n<p>近代中国的社会性质和主要矛盾，决定了中国革命仍然是资产阶级民主革命。但中国资产阶级民主革命不同于一般的资产阶级民主革命，经历了从旧民主主义革命向新民主主义革命的转变，具有鲜明的时代特征。</p></li>\n</ol>\n<p>新民主主义革命和一般意义上的社会主义革命也不相同，它只推翻帝国主义、封建主义和官僚资本主义的反动统治，而不破坏参加反帝反封建的资本主义成分。这样的民主主义革命，不是旧范畴的民主主义革命,而是新民主主义革命。由此中国革命分两步走，第一步是完成反帝反封建的新民主主义革命任务，第二步是完成社会主义革命任务，这是质不同但又相互联系的两个革命过程。</p>\n<h3 id=\"新民主主义革命理论的实践基础\">新民主主义革命理论的实践基础</h3>\n<h4\nid=\"新民主主义革命的艰辛探索奠定了革命理论形成的实践基础\">新民主主义革命的艰辛探索奠定了革命理论形成的实践基础</h4>\n<p>熟读 见书本</p>\n<h3\nid=\"新民主主义革命的总路线和基本纲领\">新民主主义革命的总路线和基本纲领</h3>\n<h4 id=\"新民主主义革命的总路线\">新民主主义革命的总路线</h4>\n<p>总路线是党和国家在某个历史阶段制定各方面具体工作路线和政策的总依据，是根本指导路线。</p>\n<p>1939\n年，毛泽东在==《中国革命和中国共产党》==一文中第一次提出了==“新民主主义的革命”==的科学概念。</p>\n<p>1948\n年，毛泽东在==《在晋绥干部会议上的讲话》==中完整地总结和概括了新民主主义革命总路线的内容，即==无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命==。</p>\n<h5 id=\"新民主主义革命的对象\">新民主主义革命的对象</h5>\n<p>中国革命的对象是==帝国主义、封建主义和官僚资本主义==，它们是压在中国人民头上的三座大山。</p>\n<h5 id=\"新民主主义革命的动力\">新民主主义革命的动力</h5>\n<p>新民主主义革命的动力包括无产阶级、农民阶级、城市小资产阶级和民族资产阶级。</p>\n<ul>\n<li>无产阶级是中国革命==最基本==的动力。</li>\n<li>农民是中国革命的==主力军==。</li>\n<li>城市小资产阶级是无产阶级的==可靠同盟者==。</li>\n<li>民族资产阶级也是中国革命的==动力之一==</li>\n</ul>\n<h5 id=\"新民主主义革命的领导力量\">新民主主义革命的领导力量</h5>\n<p>区别新旧两种不同范畴的民主主义革命的根本标志是，革命的==领导权==是掌握在无产阶级手中还是掌握在资产阶级手中。</p>\n<p>中国无产阶级除了具有与先进的生产方式相联系、没有私人占有的生产资料、富于组织纪律性等一般无产阶级的基本优点外，还具有自身的特点和优点。</p>\n<ol type=\"1\">\n<li>从诞生之日起，就身受外国资本主义、本国封建势力和资产阶级的三重压迫，而这些压迫的严重性和残酷性，是世界各民族中少见的。因此，中国无产阶级在革命斗争中比任何别的阶级都来得坚决和彻底。</li>\n<li>集中分布在少数大城市和大企业，有利于组织和团结，有利于革命思想的传播和强大革命力量的形成。</li>\n<li>成员中大部分出身于破产农民，和农民有着天然的联系，便于和农民结成亲密的联盟，共同团结战斗。</li>\n</ol>\n<h4 id=\"新民主主义的基本纲领\">新民主主义的基本纲领</h4>\n<h5 id=\"新民主主义的政治纲领\">新民主主义的政治纲领</h5>\n<p>新民主主义的政治纲领是：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国。</p>\n<p>新民主主义共和国是一定历史时期的国家形式，是过渡的形式</p>\n<h5 id=\"新民主主义的经济纲领\">新民主主义的经济纲领</h5>\n<p>新民主主义的经济纲领是：没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业。</p>\n<h5 id=\"新民主主义的文化纲领\">新民主主义的文化纲领</h5>\n<p>新民主主义文化，就是无产阶级领导的人民大众的反帝反封建的文化，即民族的科学的大众的文化。</p>\n<h3\nid=\"新民主主义革命的道路和基本经验\">新民主主义革命的道路和基本经验</h3>\n<h4 id=\"新民主主义革命的道路\">新民主主义革命的道路</h4>\n<h5 id=\"新民主主义革命道路的提出\">新民主主义革命道路的提出</h5>\n<p>1938 年 11\n月，他在党的六届六中全会上明确指出：“共产党的任务，基本地不是经过长期合法斗争以进入起义和战争，也不是先占城市后取乡村，而是走相反的道路。”从而确立了经过长期武装斗争，先占乡村，后取城市，最后夺取全国胜利的革命道路。</p>\n<p>二、新民主主义革命的三大法宝</p>\n<ol type=\"1\">\n<li>统一战线</li>\n<li>武装斗争</li>\n<li>党的建设</li>\n</ol>\n<p>第一，必须把思想建设始终放在党的建设的首位。加强党的思想建设，关键是要以无产阶级思想克服和改造各种非无产阶级思想。第二，必须在任何时候都重视党的组织建设。加强党的组织建设，根本的是要贯彻民主集中制这一根本组织原则，坚持在民主基础上的集中和在集中指导下的民主相结合，个人服从组织，少数服从多数，下级服从上级，全党服从中央。第三，必须重视党的作风建设。</p>\n<p>革命时期，思想建设首位</p>\n<p>现在，政治建设首位</p>\n<p>三大法宝与毛泽东思想活的灵魂区分</p>\n<h2 id=\"社会主义改造理论\">社会主义改造理论</h2>\n<h3 id=\"从新民主主义到社会主义的转变\">从新民主主义到社会主义的转变</h3>\n<h4\nid=\"新民主主义社会是一个过渡性的社会\">新民主主义社会是一个过渡性的社会</h4>\n<p>从中华人民共和国成立到社会主义改造基本完成，是我国从新民主主义到社会主义的过渡时期。这一时期，我国社会的性质是新民主主义社会。新民主主义社会不是一个独立的社会形态，而是由新民主主义向社会主义转变的过渡性社会形态</p>\n<p>辨析：新民主主义社会是社会主义社会吗？不是，过渡</p>\n<p>主要的经济成分是三种：社会主义经济、个体经济和资本主义经济。</p>\n<p>新民主主义社会要继续向前发展，就要不断扩大国营经济.同时逐步将资本主义经济和个体经济改变为社会主义经济，使社会主义经济逐步成为我国的经济基础。</p>\n<p>一化三改</p>\n<p>1953 年 6\n月，毛泽东在中央政治局会议上正式提出过渡时期的总路线和总任务，同年 12\n月形成了关于总路线的完整表述：“从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期。党在这个过渡时期的总路线和总任务，是要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业.对手工业和对资本主义工商业的社会主义改造。</p>\n<h5\nid=\"党在过渡时期的总路线的现实依据\">党在过渡时期的总路线的现实依据</h5>\n<p>经过 1949 年到 1952\n年三年的努力，我国已经有了相对强大和迅速发展的社会主义国营经济。</p>\n<p>土地改革完成后，为发展生产、抵御自然灾害，广大农民具有走互助合作道路的要求。</p>\n<p>新中国成立初期，党和国家在合理调整工商业的过程中，出现了加工订货、经销代销、统购包销、公私合营等一系列从低级到高级的国家资本主义形式。</p>\n<p>当时的国际形势也有利于中国向社会主义过渡。</p>\n<h3 id=\"社会主义改造道路和历史经验\">社会主义改造道路和历史经验</h3>\n<h4\nid=\"适合中国特点的社会主义改造道路\">适合中国特点的社会主义改造道路</h4>\n<h5 id=\"农业手工业的社会主义改造\">农业、手工业的社会主义改造</h5>\n<ol type=\"1\">\n<li>积极引导农民组织起来，走互助合作道路。</li>\n<li>遵循自愿互利、典型示范和国家帮助的原则，以互助合作的优越性吸引农民走互助合作道路。</li>\n<li>正确分析农村的阶级和阶层状况，制定正确的阶级政策。</li>\n<li>坚持积极领导、稳步前进的方针，采取循序渐进的步骤。</li>\n</ol>\n<p>手工业一二三略</p>\n<h5 id=\"资本主义工商业的社会主义改造\">资本主义工商业的社会主义改造</h5>\n<ol type=\"1\">\n<li>用和平赎买的方法改造资本主义工商业。</li>\n<li>采取从低级到高级的国家资本主义的过渡形式。\n四马分肥：企业的利润，按国家所得税、企业公积金、工人福利费、资方红利这四个方面进行分配，即当时所说的“四马分肥”。</li>\n<li>把资本主义工商业者改造成为自食其力的社会主义劳动者。</li>\n</ol>\n<h4 id=\"社会主义改造的历史经验\">社会主义改造的历史经验</h4>\n<ol type=\"1\">\n<li>坚持社会主义工业化建设与社会主义改造同时并举。</li>\n<li>采取积极引导、逐步过渡的方式。</li>\n<li>用和平方法进行改造。</li>\n</ol>\n<h2 id=\"社会主义建设道路\">社会主义建设道路</h2>\n<p>初步探索的理论成果</p>\n<p>第一节初步探索的重要理论成果</p>\n<h3\nid=\"调动一切积极因素为社会主义事业服务\">调动一切积极因素为社会主义事业服务</h3>\n<p>特别是在社会主义改造基本完成以后怎样建设社会主义的道路问题上，仍然需要把马克思列宁主义基本原理同中国具体实际进行“第二次结合”，努力找到适合中国特点的社会主义建设道路。</p>\n<p>《论十大关系》标志着党探索中国社会主义建设道路的良好开端。</p>\n<p>《论十大关系》确定了一个基本方针，就是“努力把党内党外、国内国外的一切积极的因素，直接的、间接的积极因素，全部调动起来”③，为社会主义建设服务。</p>\n<h3\nid=\"正确认识和处理社会主义社会矛盾的思想\">正确认识和处理社会主义社会矛盾的思想</h3>\n<p>党在八大前后，特别是毛泽东在 1957 年 2\n月所作的《关于正确处理人民内部矛盾的问题》的报告，系统论述了社会主义社会矛盾的理论。</p>\n<h4 id=\"走中国工业化道路的思想\">走中国工业化道路的思想</h4>\n<p>毛泽东还主张企业要建立合理的规章制度和严格的责任制，要实行民主管理，实行干部参加劳动，工人参加管理，改革不合理的规章制度，工人群众、领导干部和技术人员三结合，即“两参一改三结合”。</p>\n<h4 id=\"初步探索的其他理论成果\">初步探索的其他理论成果</h4>\n<p>毛泽东提出：“社会主义这个阶段，又可能分为两个阶段，第一个阶段是不发达的社会主义，第二个阶段是比较发达的社会主义。后一阶段可能比前一阶段需要更长的时间。经过后一阶段，到了物质产品、精神财富都极为丰富和人们的共产主义觉悟极大提高的时候，就可以进入共产主义社会了。”</p>\n<p>“一纲四目”</p>\n<ul>\n<li><p>“一纲”是：只要台湾归回祖国，其他一切问题悉尊重台湾领导人意见妥善处理。</p></li>\n<li><p>“四目”是：</p>\n<ol type=\"1\">\n<li>台湾归回祖国后，除外交必须统一于中央外，所有军政大权人事安排等悉由台湾领导人全权处理；</li>\n<li>所有军政及建设费用，不足之数，悉由中央拨付；</li>\n<li>台湾之社会改革，可以从缓，必俟条件成熟，并尊重台湾领导人意见协商决定，然后进行；</li>\n<li>双方互约不派人进行破坏对方团结之事。</li>\n</ol></li>\n</ul>\n<h3 id=\"初步探索的意义和经验教训\">初步探索的意义和经验教训</h3>\n<h4 id=\"初步探索的意义\">初步探索的意义</h4>\n<ol type=\"1\">\n<li>巩固和发展了我国的社会主义制度。</li>\n<li>为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础。</li>\n<li>丰富了科学社会主义的理论和实践。</li>\n</ol>\n<h4 id=\"初步探索的经验教训\">初步探索的经验教训</h4>\n<ol type=\"1\">\n<li>必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路。</li>\n<li>必须正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力。</li>\n<li>必须从实际出发进行社会主义建设，建设规模和速度要与国力相适应，不能急于求成。</li>\n<li>必须发展社会主义民主，健全社会主义法制。</li>\n<li>必须坚持党的民主集中制和集体领导制度，加强执政党建设。</li>\n<li>必须坚持对外开放，借鉴和吸收人类文明成果建设社会主义，不能关起门来搞建设。</li>\n</ol>\n<!--第五章跳过-->\n<h2 id=\"邓小平理论\">邓小平理论</h2>\n<h3\nid=\"邓小平理论首要的基本的理论问题\">邓小平理论首要的基本的理论问题</h3>\n<p>在中国这样一个经济文化比较落后的国家==建设什么样的社会主义、怎样建设社会主义==是一个首要的基本的理论问题。</p>\n<p>“什么是社会主义，怎样建设社会主义”</p>\n<p>1992\n年初，邓小平在南方谈话中对社会主义本质作出了总结性的理论概括，他指出：“社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕。”</p>\n<h3 id=\"邓小平理论的精髓\">邓小平理论的精髓</h3>\n<p>==解放思想、实事求是==</p>\n<p>与毛泽东三大法宝区分</p>\n<p>实事求是，群众路线，独立自主</p>\n<h3 id=\"邓小平理论的主要内容\">邓小平理论的主要内容</h3>\n<h4\nid=\"社会主义初级阶段理论和党的基本路线\">社会主义初级阶段理论和党的基本路线</h4>\n<h5 id=\"社会主义初级阶段理论\">社会主义初级阶段理论</h5>\n<p>党的十三大系统地阐述了社会主义初级阶段的科学内涵。首先，阐明了社会主义初级阶段这个论断包括两层含义：</p>\n<ol type=\"1\">\n<li>我国社会已经是社会主义社会。我们必须坚持而不能离开社会主义。</li>\n<li>我国的社会主义社会还处在初级阶段。</li>\n</ol>\n<p>其次，强调了社会主义初级阶段的长期性。\n最后，阐述了社会主义初级阶段的基本特征。</p>\n<h5\nid=\"党在社会主义初级阶段的基本路线\">党在社会主义初级阶段的基本路线</h5>\n<p>熟读</p>\n<p>党的十三大从我国社会主义初级阶段的基本国情出发，在科学认识我国社会主要矛盾的基础上，提出了党在社会主义初级阶段的基本路线：“领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强、民主、文明的社会主义现代化国家而奋斗。”</p>\n<p>记</p>\n<ol type=\"1\">\n<li>坚持社会主义道路、</li>\n<li>坚持无产阶级专政（后表述为人民民主专政）、</li>\n<li>坚持共产党的领导、</li>\n<li>坚持马列主义毛泽东思想</li>\n</ol>\n<p>这四项基本原则</p>\n<h4\nid=\"社会主义根本任务和发展战略理论\">社会主义根本任务和发展战略理论</h4>\n<h5 id=\"社会主义根本任务的理论\">社会主义根本任务的理论</h5>\n<p>社会主义的根本任务是发展生产力</p>\n<h5\nid=\"分三步走基本实现现代化的发展战略\">分三步走基本实现现代化的发展战略</h5>\n<p>了解</p>\n<h4\nid=\"社会主义改革开放和社会主义市场经济理论\">社会主义改革开放和社会主义市场经济理论</h4>\n<h5 id=\"社会主义改革开放理论\">社会主义改革开放理论</h5>\n<p>党的十一届三中全会作出把党和国家工作中心转移到经济建设上来、实行改革开放的历史性决策，实现了新中国成立以来党的历史上具有深远意义的伟大转折，开启了改革开放和社会主义现代化的伟大征程。</p>\n<p>改革是一场深刻的社会变革，是中国的第二次革命，是实现中国现代化的必由之路。</p>\n<p>归根到底，主要看是否有利于发展社会主义社会的生产力，是否有利于增强社会主义国家的综合国力，是否有利于提高人民生活水平，即“三个有利于”标准。</p>\n<h5 id=\"社会主义市场经济理论\">社会主义市场经济理论</h5>\n<p>辨析：计划经济就是社会主义，市场经济就是资本主义。</p>\n<p>1992\n年，邓小平在南方谈话中明确指出：“计划多一点还是市场多一点，不是社会主义与资本主义的本质区别。计划经济不等于社会主义，资本主义也有计划；市场经济不等于资本主义，社会主义也有市场。计划和市场都是经济手段。”</p>\n<p>邓小平的社会主义市场经济理论具有丰富的内涵：</p>\n<ol type=\"1\">\n<li>计划经济和市场经济不是划分社会制度的标志，计划经济不等于社会主义，市场经济也不等于资本主义；</li>\n<li>计划和市场都是经济手段，对经济活动的调节各有优劣，社会主义实行市场经济是要把两者优势结合起来；</li>\n<li>市场经济作为资源配置手段本身不具有制度属性，可以和不同的社会制度结合，从而表现出不同的性质。</li>\n</ol>\n<h4\nid=\"中国特色社会主义外交和国际战略\">中国特色社会主义外交和国际战略</h4>\n<p>邓小平对时代主题的判断，其基本点是：</p>\n<ol type=\"1\">\n<li>世界大战在一个相当长的时期内可以避免.我们有可能争取较长时期的和平环境；</li>\n<li>从经济角度来说，和平与发展是当今世界两大带有全球性的战略问题，是东西方之间、发达国家与发展中国家之间矛盾全局的集中体现；</li>\n<li>和平与发展是相辅相成的，世界和平是促进各国共同发展的前提条件，各国的共同发展则是保持世界和平的重要基础；</li>\n<li>和平与发展成为时代主题，并不意味着这两个问题已经解决。</li>\n</ol>\n<p>判断：现在世界只需努力发展（取得和平）</p>\n<ul>\n<li>错误，都没有解决，要一起解决，要清醒地看到，当今世界和平与发展这两大问题一个都没有得到解决，还需要各国人民长期不懈地共同努力。</li>\n</ul>\n<h3 id=\"邓小平理论的历史地位\">邓小平理论的历史地位</h3>\n<p>熟读小标题即可</p>\n<ol type=\"1\">\n<li>马克思列宁主义、毛泽东思想的继承和发展</li>\n<li>中国特色社会主义理论体系的开篇之作</li>\n<li>改革开放和社会主义现代化建设的科学指南</li>\n</ol>\n<h2 id=\"三个代表重要思想\">“三个代表”重要思想</h2>\n<h3 id=\"三个代表重要思想的核心观点\">“三个代表”重要思想的核心观点</h3>\n<ol type=\"1\">\n<li>始终代表中国先进生产力的发展要求</li>\n<li>始终代表中国先进文化的前进方向</li>\n</ol>\n<h3 id=\"三个代表重要思想的主要内容\">“三个代表”重要思想的主要内容</h3>\n<ol type=\"1\">\n<li><p>发展是党执政兴国的第一要务</p></li>\n<li><p>建立社会主义市场经济体制</p>\n<p>在建立什么样的经济体制问题上，江泽民根据邓小平南方谈话精神，明确提出使用“社会主义市场经济体制”这个提法。党的十四大正式把建立社会主义市场经济体制确立为我国经济体制改革的目标。</p></li>\n<li><p>实施“引进来”和“走出去”相结合的对外开放战略</p>\n<p>对外开放是一项长期的基本国策。</p></li>\n</ol>\n<h3 id=\"三个代表重要思想的历史地位\">“三个代表”重要思想的历史地位</h3>\n<h4\nid=\"中国特色社会主义理论体系的丰富发展\">中国特色社会主义理论体系的丰富发展</h4>\n<h4\nid=\"加强和改进党的建设推进中国特色社会主义事业的强大理论武器\">加强和改进党的建设、推进中国特色社会主义事业的强大理论武器</h4>\n<h2 id=\"科学发展观\">科学发展观</h2>\n<h3 id=\"科学发展观的科学内涵\">科学发展观的科学内涵</h3>\n<p>熟读小标题</p>\n<ol type=\"1\">\n<li>推动经济社会发展是科学发展观的第一要义</li>\n<li>以人为本是科学发展观的核心立场</li>\n<li>全面协调可持续是科学发展观的基本要求</li>\n<li>统筹兼顾是科学发展观的根本方法</li>\n</ol>\n<h3 id=\"科学发展观的主要内容\">科学发展观的主要内容</h3>\n<h4 id=\"加快转变经济发展方式\">加快转变经济发展方式</h4>\n<p>推动经济持续健康发展，必须坚持以科学发展为主题，以加快转变经济发展方式为主线。</p>\n<p>主题和主线</p>\n<h4 id=\"发展社会主义民主政治\">发展社会主义民主政治</h4>\n<p>社会主义民主政治的本质和核心是==人民当家作主==。</p>\n<h4 id=\"构建社会主义和谐社会\">构建社会主义和谐社会</h4>\n<p>胡锦涛明确指出：“社会和谐是中国特色社会主义的本质属性。”</p>\n<h4 id=\"全面提高党的建设科学化水平\">全面提高党的建设科学化水平</h4>\n<p>党的建设是党领导的伟大事业不断取得胜利的重要法宝。</p>\n<h4 id=\"科学发展观的历史地位\">科学发展观的历史地位</h4>\n<p>熟读小标题</p>\n<ol type=\"1\">\n<li>中国特色社会主义理论体系在新世纪新阶段的接续发展</li>\n<li>全面建设小康社会、加快推进社会主义现代化的根本指针</li>\n</ol>\n","excerpt":"","more":"<p>脉络根据书本，部分内容来源于书本，可对照参考</p>\n<h2\nid=\"马克思主义中国化时代化的历史进程与理论成果\">马克思主义中国化时代化的历史进程与理论成果</h2>\n<h3 id=\"马克思主义中国化时代化的提出\">马克思主义中国化时代化的提出</h3>\n<p>马克思主义中国化同时包含着马克思主义时代化的意蕴。我们党自成立以来，始终坚持把马克思主义基本原理同中国具体实际和时代特征相结合，不断进行理论创新。</p>\n<h3\nid=\"马克思主义中国化时代化的历史进程\">马克思主义中国化时代化的历史进程</h3>\n<p>两大飞跃</p>\n<ul>\n<li><p>在改革开放和社会主义现代化建设新时期，中国共产党坚持以理论创新引领事业发展，（从新的实践和时代特征出发坚持和发展马克思主义，科学回答了建设中国特色社会主义的发展道路、发展阶段、根本任务、发展动力、发展战略、政治保证、祖国统一、外交和国际战略、领导力量和依靠力址等一系列基本问题，）形成中国特色社会主义理论体系，实现了马克思主义中国化时代化新的飞跃。</p></li>\n<li><p>（党的十八大以来，中国特色社会主义进入新时代，以习近平同志为主要代表的中国共产党人，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，系统回答了新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义，建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国，建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党等重大时代课题，提出一系列原创性的治国理政新理念新思想新战略，）创立了习近平新时代中国特色社会主义思想，实现了马克思主义中国化时代化新的飞跃。</p></li>\n</ul>\n<h3\nid=\"马克思主义中国化时代化理论成果及其关系\">马克思主义中国化时代化理论成果及其关系</h3>\n<p>马克思主义中国化时代化的理论成果是一脉相承又与时俱进的关系。一方面，毛泽东思想所蕴含的马克思主义的立场、观点和方法，为中国特色社会主义理论体系提供了基本遵循。实事求是、群众路线、独立自主是毛泽东思想活的灵魂，这一具有中国共产党人特色的立场、观点和方法也贯穿于中国特色社会主义理论体系之中。</p>\n<p>另一方面，中国特色社会主义理论体系在新的历史条件下进一步丰富和发展了毛泽东思想。</p>\n<h2 id=\"毛泽东思想及其历史地位\">毛泽东思想及其历史地位</h2>\n<h3\nid=\"毛泽东思想的主要内容和活的灵魂\">毛泽东思想的主要内容和活的灵魂</h3>\n<h4 id=\"毛泽东思想活的灵魂\">毛泽东思想活的灵魂</h4>\n<p>实事求是，群众路线，独立自主</p>\n<h5 id=\"实事求是\">实事求是</h5>\n<p>实事求是是毛泽东思想的基本点，是毛泽东思想的精髓。实事求是,就是一切从实际出发，理论联系实际，坚持在实践中检验真理和发展真理。</p>\n<p>坚持实事求是，就要深入实际了解事物的本来面貌，把握事物内在必然联系，按照客观规律办事。</p>\n<p>坚持实事求是，就要清醒认识和正确把握我国基本国情。</p>\n<p>坚持实事求是，就要不断推进实践基础上的理论创新。</p>\n<h5 id=\"群众路线\">群众路线</h5>\n<p>群众路线，就是一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动。</p>\n<p>群众路线本质上体现的是马克思主义关于人民群众是历史的创造者这一基本原理。</p>\n<p>坚持群众路线，就要坚持人民是推动历史发展的根本力量。</p>\n<p>坚持群众路线，就要坚持全心全意为人民服务的根本宗旨。</p>\n<p>坚持群众路线，就要保持党同人民群众的血肉联系。</p>\n<h5 id=\"独立自主\">独立自主</h5>\n<p>独立自主，就是坚持独立思考，走自己的路，就是坚定不移地维护民族独立、捍卫国家主权，把立足点放在依靠自己力量的基础上，同时积极争取外援，开展国际经济文化交流，学习外国一切对我们有益的先进事物。</p>\n<p>不论过去、现在和将来，我们都要把国家和民族的发展放在自己力量的基点上，增强民族自尊心和自信心，坚定不移走自己的路。</p>\n<p>坚持独立自主原则，是毛泽东针对党内存在的“左”倾教条主义倾向，从中国革命遭受挫折的教训中提出的正确思想主张。</p>\n<p>坚持独立自主，就要坚持中国的事情必须由中国人民自己作主张、自己来处理。</p>\n<p>坚持独立自主，就要坚持独立自主的和平外交政策，坚定不移走和平发展道路。</p>\n<h3 id=\"毛泽东思想的历史地位\">毛泽东思想的历史地位</h3>\n<p>熟读小标题</p>\n<ol type=\"1\">\n<li>马克思主义中国化时代化的第一个重大理论成果</li>\n<li>中国革命和建设的科学指南</li>\n<li>中国共产党和中国人民宝贵的精神财富</li>\n</ol>\n<h2 id=\"新民主主义革命理论\">新民主主义革命理论</h2>\n<h3 id=\"新民主主义革命理论形成的依据\">新民主主义革命理论形成的依据</h3>\n<ol type=\"1\">\n<li><p>近代中国国情</p>\n<p>中国逐步成为半殖民地半封建社会，这是近代中国最基本的国情。</p></li>\n<li><p>近代中国革命的时代特征</p>\n<p>近代中国的社会性质和主要矛盾，决定了中国革命仍然是资产阶级民主革命。但中国资产阶级民主革命不同于一般的资产阶级民主革命，经历了从旧民主主义革命向新民主主义革命的转变，具有鲜明的时代特征。</p></li>\n</ol>\n<p>新民主主义革命和一般意义上的社会主义革命也不相同，它只推翻帝国主义、封建主义和官僚资本主义的反动统治，而不破坏参加反帝反封建的资本主义成分。这样的民主主义革命，不是旧范畴的民主主义革命,而是新民主主义革命。由此中国革命分两步走，第一步是完成反帝反封建的新民主主义革命任务，第二步是完成社会主义革命任务，这是质不同但又相互联系的两个革命过程。</p>\n<h3 id=\"新民主主义革命理论的实践基础\">新民主主义革命理论的实践基础</h3>\n<h4\nid=\"新民主主义革命的艰辛探索奠定了革命理论形成的实践基础\">新民主主义革命的艰辛探索奠定了革命理论形成的实践基础</h4>\n<p>熟读 见书本</p>\n<h3\nid=\"新民主主义革命的总路线和基本纲领\">新民主主义革命的总路线和基本纲领</h3>\n<h4 id=\"新民主主义革命的总路线\">新民主主义革命的总路线</h4>\n<p>总路线是党和国家在某个历史阶段制定各方面具体工作路线和政策的总依据，是根本指导路线。</p>\n<p>1939\n年，毛泽东在==《中国革命和中国共产党》==一文中第一次提出了==“新民主主义的革命”==的科学概念。</p>\n<p>1948\n年，毛泽东在==《在晋绥干部会议上的讲话》==中完整地总结和概括了新民主主义革命总路线的内容，即==无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命==。</p>\n<h5 id=\"新民主主义革命的对象\">新民主主义革命的对象</h5>\n<p>中国革命的对象是==帝国主义、封建主义和官僚资本主义==，它们是压在中国人民头上的三座大山。</p>\n<h5 id=\"新民主主义革命的动力\">新民主主义革命的动力</h5>\n<p>新民主主义革命的动力包括无产阶级、农民阶级、城市小资产阶级和民族资产阶级。</p>\n<ul>\n<li>无产阶级是中国革命==最基本==的动力。</li>\n<li>农民是中国革命的==主力军==。</li>\n<li>城市小资产阶级是无产阶级的==可靠同盟者==。</li>\n<li>民族资产阶级也是中国革命的==动力之一==</li>\n</ul>\n<h5 id=\"新民主主义革命的领导力量\">新民主主义革命的领导力量</h5>\n<p>区别新旧两种不同范畴的民主主义革命的根本标志是，革命的==领导权==是掌握在无产阶级手中还是掌握在资产阶级手中。</p>\n<p>中国无产阶级除了具有与先进的生产方式相联系、没有私人占有的生产资料、富于组织纪律性等一般无产阶级的基本优点外，还具有自身的特点和优点。</p>\n<ol type=\"1\">\n<li>从诞生之日起，就身受外国资本主义、本国封建势力和资产阶级的三重压迫，而这些压迫的严重性和残酷性，是世界各民族中少见的。因此，中国无产阶级在革命斗争中比任何别的阶级都来得坚决和彻底。</li>\n<li>集中分布在少数大城市和大企业，有利于组织和团结，有利于革命思想的传播和强大革命力量的形成。</li>\n<li>成员中大部分出身于破产农民，和农民有着天然的联系，便于和农民结成亲密的联盟，共同团结战斗。</li>\n</ol>\n<h4 id=\"新民主主义的基本纲领\">新民主主义的基本纲领</h4>\n<h5 id=\"新民主主义的政治纲领\">新民主主义的政治纲领</h5>\n<p>新民主主义的政治纲领是：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国。</p>\n<p>新民主主义共和国是一定历史时期的国家形式，是过渡的形式</p>\n<h5 id=\"新民主主义的经济纲领\">新民主主义的经济纲领</h5>\n<p>新民主主义的经济纲领是：没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业。</p>\n<h5 id=\"新民主主义的文化纲领\">新民主主义的文化纲领</h5>\n<p>新民主主义文化，就是无产阶级领导的人民大众的反帝反封建的文化，即民族的科学的大众的文化。</p>\n<h3\nid=\"新民主主义革命的道路和基本经验\">新民主主义革命的道路和基本经验</h3>\n<h4 id=\"新民主主义革命的道路\">新民主主义革命的道路</h4>\n<h5 id=\"新民主主义革命道路的提出\">新民主主义革命道路的提出</h5>\n<p>1938 年 11\n月，他在党的六届六中全会上明确指出：“共产党的任务，基本地不是经过长期合法斗争以进入起义和战争，也不是先占城市后取乡村，而是走相反的道路。”从而确立了经过长期武装斗争，先占乡村，后取城市，最后夺取全国胜利的革命道路。</p>\n<p>二、新民主主义革命的三大法宝</p>\n<ol type=\"1\">\n<li>统一战线</li>\n<li>武装斗争</li>\n<li>党的建设</li>\n</ol>\n<p>第一，必须把思想建设始终放在党的建设的首位。加强党的思想建设，关键是要以无产阶级思想克服和改造各种非无产阶级思想。第二，必须在任何时候都重视党的组织建设。加强党的组织建设，根本的是要贯彻民主集中制这一根本组织原则，坚持在民主基础上的集中和在集中指导下的民主相结合，个人服从组织，少数服从多数，下级服从上级，全党服从中央。第三，必须重视党的作风建设。</p>\n<p>革命时期，思想建设首位</p>\n<p>现在，政治建设首位</p>\n<p>三大法宝与毛泽东思想活的灵魂区分</p>\n<h2 id=\"社会主义改造理论\">社会主义改造理论</h2>\n<h3 id=\"从新民主主义到社会主义的转变\">从新民主主义到社会主义的转变</h3>\n<h4\nid=\"新民主主义社会是一个过渡性的社会\">新民主主义社会是一个过渡性的社会</h4>\n<p>从中华人民共和国成立到社会主义改造基本完成，是我国从新民主主义到社会主义的过渡时期。这一时期，我国社会的性质是新民主主义社会。新民主主义社会不是一个独立的社会形态，而是由新民主主义向社会主义转变的过渡性社会形态</p>\n<p>辨析：新民主主义社会是社会主义社会吗？不是，过渡</p>\n<p>主要的经济成分是三种：社会主义经济、个体经济和资本主义经济。</p>\n<p>新民主主义社会要继续向前发展，就要不断扩大国营经济.同时逐步将资本主义经济和个体经济改变为社会主义经济，使社会主义经济逐步成为我国的经济基础。</p>\n<p>一化三改</p>\n<p>1953 年 6\n月，毛泽东在中央政治局会议上正式提出过渡时期的总路线和总任务，同年 12\n月形成了关于总路线的完整表述：“从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期。党在这个过渡时期的总路线和总任务，是要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业.对手工业和对资本主义工商业的社会主义改造。</p>\n<h5\nid=\"党在过渡时期的总路线的现实依据\">党在过渡时期的总路线的现实依据</h5>\n<p>经过 1949 年到 1952\n年三年的努力，我国已经有了相对强大和迅速发展的社会主义国营经济。</p>\n<p>土地改革完成后，为发展生产、抵御自然灾害，广大农民具有走互助合作道路的要求。</p>\n<p>新中国成立初期，党和国家在合理调整工商业的过程中，出现了加工订货、经销代销、统购包销、公私合营等一系列从低级到高级的国家资本主义形式。</p>\n<p>当时的国际形势也有利于中国向社会主义过渡。</p>\n<h3 id=\"社会主义改造道路和历史经验\">社会主义改造道路和历史经验</h3>\n<h4\nid=\"适合中国特点的社会主义改造道路\">适合中国特点的社会主义改造道路</h4>\n<h5 id=\"农业手工业的社会主义改造\">农业、手工业的社会主义改造</h5>\n<ol type=\"1\">\n<li>积极引导农民组织起来，走互助合作道路。</li>\n<li>遵循自愿互利、典型示范和国家帮助的原则，以互助合作的优越性吸引农民走互助合作道路。</li>\n<li>正确分析农村的阶级和阶层状况，制定正确的阶级政策。</li>\n<li>坚持积极领导、稳步前进的方针，采取循序渐进的步骤。</li>\n</ol>\n<p>手工业一二三略</p>\n<h5 id=\"资本主义工商业的社会主义改造\">资本主义工商业的社会主义改造</h5>\n<ol type=\"1\">\n<li>用和平赎买的方法改造资本主义工商业。</li>\n<li>采取从低级到高级的国家资本主义的过渡形式。\n四马分肥：企业的利润，按国家所得税、企业公积金、工人福利费、资方红利这四个方面进行分配，即当时所说的“四马分肥”。</li>\n<li>把资本主义工商业者改造成为自食其力的社会主义劳动者。</li>\n</ol>\n<h4 id=\"社会主义改造的历史经验\">社会主义改造的历史经验</h4>\n<ol type=\"1\">\n<li>坚持社会主义工业化建设与社会主义改造同时并举。</li>\n<li>采取积极引导、逐步过渡的方式。</li>\n<li>用和平方法进行改造。</li>\n</ol>\n<h2 id=\"社会主义建设道路\">社会主义建设道路</h2>\n<p>初步探索的理论成果</p>\n<p>第一节初步探索的重要理论成果</p>\n<h3\nid=\"调动一切积极因素为社会主义事业服务\">调动一切积极因素为社会主义事业服务</h3>\n<p>特别是在社会主义改造基本完成以后怎样建设社会主义的道路问题上，仍然需要把马克思列宁主义基本原理同中国具体实际进行“第二次结合”，努力找到适合中国特点的社会主义建设道路。</p>\n<p>《论十大关系》标志着党探索中国社会主义建设道路的良好开端。</p>\n<p>《论十大关系》确定了一个基本方针，就是“努力把党内党外、国内国外的一切积极的因素，直接的、间接的积极因素，全部调动起来”③，为社会主义建设服务。</p>\n<h3\nid=\"正确认识和处理社会主义社会矛盾的思想\">正确认识和处理社会主义社会矛盾的思想</h3>\n<p>党在八大前后，特别是毛泽东在 1957 年 2\n月所作的《关于正确处理人民内部矛盾的问题》的报告，系统论述了社会主义社会矛盾的理论。</p>\n<h4 id=\"走中国工业化道路的思想\">走中国工业化道路的思想</h4>\n<p>毛泽东还主张企业要建立合理的规章制度和严格的责任制，要实行民主管理，实行干部参加劳动，工人参加管理，改革不合理的规章制度，工人群众、领导干部和技术人员三结合，即“两参一改三结合”。</p>\n<h4 id=\"初步探索的其他理论成果\">初步探索的其他理论成果</h4>\n<p>毛泽东提出：“社会主义这个阶段，又可能分为两个阶段，第一个阶段是不发达的社会主义，第二个阶段是比较发达的社会主义。后一阶段可能比前一阶段需要更长的时间。经过后一阶段，到了物质产品、精神财富都极为丰富和人们的共产主义觉悟极大提高的时候，就可以进入共产主义社会了。”</p>\n<p>“一纲四目”</p>\n<ul>\n<li><p>“一纲”是：只要台湾归回祖国，其他一切问题悉尊重台湾领导人意见妥善处理。</p></li>\n<li><p>“四目”是：</p>\n<ol type=\"1\">\n<li>台湾归回祖国后，除外交必须统一于中央外，所有军政大权人事安排等悉由台湾领导人全权处理；</li>\n<li>所有军政及建设费用，不足之数，悉由中央拨付；</li>\n<li>台湾之社会改革，可以从缓，必俟条件成熟，并尊重台湾领导人意见协商决定，然后进行；</li>\n<li>双方互约不派人进行破坏对方团结之事。</li>\n</ol></li>\n</ul>\n<h3 id=\"初步探索的意义和经验教训\">初步探索的意义和经验教训</h3>\n<h4 id=\"初步探索的意义\">初步探索的意义</h4>\n<ol type=\"1\">\n<li>巩固和发展了我国的社会主义制度。</li>\n<li>为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础。</li>\n<li>丰富了科学社会主义的理论和实践。</li>\n</ol>\n<h4 id=\"初步探索的经验教训\">初步探索的经验教训</h4>\n<ol type=\"1\">\n<li>必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路。</li>\n<li>必须正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力。</li>\n<li>必须从实际出发进行社会主义建设，建设规模和速度要与国力相适应，不能急于求成。</li>\n<li>必须发展社会主义民主，健全社会主义法制。</li>\n<li>必须坚持党的民主集中制和集体领导制度，加强执政党建设。</li>\n<li>必须坚持对外开放，借鉴和吸收人类文明成果建设社会主义，不能关起门来搞建设。</li>\n</ol>\n<!--第五章跳过-->\n<h2 id=\"邓小平理论\">邓小平理论</h2>\n<h3\nid=\"邓小平理论首要的基本的理论问题\">邓小平理论首要的基本的理论问题</h3>\n<p>在中国这样一个经济文化比较落后的国家==建设什么样的社会主义、怎样建设社会主义==是一个首要的基本的理论问题。</p>\n<p>“什么是社会主义，怎样建设社会主义”</p>\n<p>1992\n年初，邓小平在南方谈话中对社会主义本质作出了总结性的理论概括，他指出：“社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕。”</p>\n<h3 id=\"邓小平理论的精髓\">邓小平理论的精髓</h3>\n<p>==解放思想、实事求是==</p>\n<p>与毛泽东三大法宝区分</p>\n<p>实事求是，群众路线，独立自主</p>\n<h3 id=\"邓小平理论的主要内容\">邓小平理论的主要内容</h3>\n<h4\nid=\"社会主义初级阶段理论和党的基本路线\">社会主义初级阶段理论和党的基本路线</h4>\n<h5 id=\"社会主义初级阶段理论\">社会主义初级阶段理论</h5>\n<p>党的十三大系统地阐述了社会主义初级阶段的科学内涵。首先，阐明了社会主义初级阶段这个论断包括两层含义：</p>\n<ol type=\"1\">\n<li>我国社会已经是社会主义社会。我们必须坚持而不能离开社会主义。</li>\n<li>我国的社会主义社会还处在初级阶段。</li>\n</ol>\n<p>其次，强调了社会主义初级阶段的长期性。\n最后，阐述了社会主义初级阶段的基本特征。</p>\n<h5\nid=\"党在社会主义初级阶段的基本路线\">党在社会主义初级阶段的基本路线</h5>\n<p>熟读</p>\n<p>党的十三大从我国社会主义初级阶段的基本国情出发，在科学认识我国社会主要矛盾的基础上，提出了党在社会主义初级阶段的基本路线：“领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强、民主、文明的社会主义现代化国家而奋斗。”</p>\n<p>记</p>\n<ol type=\"1\">\n<li>坚持社会主义道路、</li>\n<li>坚持无产阶级专政（后表述为人民民主专政）、</li>\n<li>坚持共产党的领导、</li>\n<li>坚持马列主义毛泽东思想</li>\n</ol>\n<p>这四项基本原则</p>\n<h4\nid=\"社会主义根本任务和发展战略理论\">社会主义根本任务和发展战略理论</h4>\n<h5 id=\"社会主义根本任务的理论\">社会主义根本任务的理论</h5>\n<p>社会主义的根本任务是发展生产力</p>\n<h5\nid=\"分三步走基本实现现代化的发展战略\">分三步走基本实现现代化的发展战略</h5>\n<p>了解</p>\n<h4\nid=\"社会主义改革开放和社会主义市场经济理论\">社会主义改革开放和社会主义市场经济理论</h4>\n<h5 id=\"社会主义改革开放理论\">社会主义改革开放理论</h5>\n<p>党的十一届三中全会作出把党和国家工作中心转移到经济建设上来、实行改革开放的历史性决策，实现了新中国成立以来党的历史上具有深远意义的伟大转折，开启了改革开放和社会主义现代化的伟大征程。</p>\n<p>改革是一场深刻的社会变革，是中国的第二次革命，是实现中国现代化的必由之路。</p>\n<p>归根到底，主要看是否有利于发展社会主义社会的生产力，是否有利于增强社会主义国家的综合国力，是否有利于提高人民生活水平，即“三个有利于”标准。</p>\n<h5 id=\"社会主义市场经济理论\">社会主义市场经济理论</h5>\n<p>辨析：计划经济就是社会主义，市场经济就是资本主义。</p>\n<p>1992\n年，邓小平在南方谈话中明确指出：“计划多一点还是市场多一点，不是社会主义与资本主义的本质区别。计划经济不等于社会主义，资本主义也有计划；市场经济不等于资本主义，社会主义也有市场。计划和市场都是经济手段。”</p>\n<p>邓小平的社会主义市场经济理论具有丰富的内涵：</p>\n<ol type=\"1\">\n<li>计划经济和市场经济不是划分社会制度的标志，计划经济不等于社会主义，市场经济也不等于资本主义；</li>\n<li>计划和市场都是经济手段，对经济活动的调节各有优劣，社会主义实行市场经济是要把两者优势结合起来；</li>\n<li>市场经济作为资源配置手段本身不具有制度属性，可以和不同的社会制度结合，从而表现出不同的性质。</li>\n</ol>\n<h4\nid=\"中国特色社会主义外交和国际战略\">中国特色社会主义外交和国际战略</h4>\n<p>邓小平对时代主题的判断，其基本点是：</p>\n<ol type=\"1\">\n<li>世界大战在一个相当长的时期内可以避免.我们有可能争取较长时期的和平环境；</li>\n<li>从经济角度来说，和平与发展是当今世界两大带有全球性的战略问题，是东西方之间、发达国家与发展中国家之间矛盾全局的集中体现；</li>\n<li>和平与发展是相辅相成的，世界和平是促进各国共同发展的前提条件，各国的共同发展则是保持世界和平的重要基础；</li>\n<li>和平与发展成为时代主题，并不意味着这两个问题已经解决。</li>\n</ol>\n<p>判断：现在世界只需努力发展（取得和平）</p>\n<ul>\n<li>错误，都没有解决，要一起解决，要清醒地看到，当今世界和平与发展这两大问题一个都没有得到解决，还需要各国人民长期不懈地共同努力。</li>\n</ul>\n<h3 id=\"邓小平理论的历史地位\">邓小平理论的历史地位</h3>\n<p>熟读小标题即可</p>\n<ol type=\"1\">\n<li>马克思列宁主义、毛泽东思想的继承和发展</li>\n<li>中国特色社会主义理论体系的开篇之作</li>\n<li>改革开放和社会主义现代化建设的科学指南</li>\n</ol>\n<h2 id=\"三个代表重要思想\">“三个代表”重要思想</h2>\n<h3 id=\"三个代表重要思想的核心观点\">“三个代表”重要思想的核心观点</h3>\n<ol type=\"1\">\n<li>始终代表中国先进生产力的发展要求</li>\n<li>始终代表中国先进文化的前进方向</li>\n</ol>\n<h3 id=\"三个代表重要思想的主要内容\">“三个代表”重要思想的主要内容</h3>\n<ol type=\"1\">\n<li><p>发展是党执政兴国的第一要务</p></li>\n<li><p>建立社会主义市场经济体制</p>\n<p>在建立什么样的经济体制问题上，江泽民根据邓小平南方谈话精神，明确提出使用“社会主义市场经济体制”这个提法。党的十四大正式把建立社会主义市场经济体制确立为我国经济体制改革的目标。</p></li>\n<li><p>实施“引进来”和“走出去”相结合的对外开放战略</p>\n<p>对外开放是一项长期的基本国策。</p></li>\n</ol>\n<h3 id=\"三个代表重要思想的历史地位\">“三个代表”重要思想的历史地位</h3>\n<h4\nid=\"中国特色社会主义理论体系的丰富发展\">中国特色社会主义理论体系的丰富发展</h4>\n<h4\nid=\"加强和改进党的建设推进中国特色社会主义事业的强大理论武器\">加强和改进党的建设、推进中国特色社会主义事业的强大理论武器</h4>\n<h2 id=\"科学发展观\">科学发展观</h2>\n<h3 id=\"科学发展观的科学内涵\">科学发展观的科学内涵</h3>\n<p>熟读小标题</p>\n<ol type=\"1\">\n<li>推动经济社会发展是科学发展观的第一要义</li>\n<li>以人为本是科学发展观的核心立场</li>\n<li>全面协调可持续是科学发展观的基本要求</li>\n<li>统筹兼顾是科学发展观的根本方法</li>\n</ol>\n<h3 id=\"科学发展观的主要内容\">科学发展观的主要内容</h3>\n<h4 id=\"加快转变经济发展方式\">加快转变经济发展方式</h4>\n<p>推动经济持续健康发展，必须坚持以科学发展为主题，以加快转变经济发展方式为主线。</p>\n<p>主题和主线</p>\n<h4 id=\"发展社会主义民主政治\">发展社会主义民主政治</h4>\n<p>社会主义民主政治的本质和核心是==人民当家作主==。</p>\n<h4 id=\"构建社会主义和谐社会\">构建社会主义和谐社会</h4>\n<p>胡锦涛明确指出：“社会和谐是中国特色社会主义的本质属性。”</p>\n<h4 id=\"全面提高党的建设科学化水平\">全面提高党的建设科学化水平</h4>\n<p>党的建设是党领导的伟大事业不断取得胜利的重要法宝。</p>\n<h4 id=\"科学发展观的历史地位\">科学发展观的历史地位</h4>\n<p>熟读小标题</p>\n<ol type=\"1\">\n<li>中国特色社会主义理论体系在新世纪新阶段的接续发展</li>\n<li>全面建设小康社会、加快推进社会主义现代化的根本指针</li>\n</ol>\n"},{"title":"数据结构笔记","math":true,"_content":"\n[oiWiki 中的数据结构](https://oi-wiki.org/ds)\n\n## 引言\n\n### 算法与数据结构\n\n数据结构的研究内容\n\n1. 数据之间的**逻辑关系**，以及这种关系对应的操作\n2. **储存实现**：数据及逻辑关系的存储\n3. **运算实现**：具体存储模式下，运算的实现，即**算法**\n\n#### 数据的逻辑结构\n\n- **集合结构**\n  次序任意，元素之间除了**同处于一个集合内**之外没有任意其他的关系.\n- **线性结构**\n  数据元素的**有序**排列，除了头尾的元素外其余元素都有一个前趋和一个后继.\n- **树形结构**\n  除了根元素之外，每个节点都有且仅有一个前趋，但是后继数量不限.\n- **图形结构**\n  每个元素的前趋和后继数量都不限\n  ![FourLogicalDataStructures](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/FourLogicalDataStructures.png)\n\n#### 数据结构的操作\n\n- **创造**\n- **清除**\n- **插入**\n- **删除**\n- **更新**\n- **搜索**\n- **访问**\n- **遍历（traverse）**：按照某种次序访问数据结构中的每一元素，使每个元素恰好被访问一次\n- 每一种数据结构的特定操作\n\n数据结构的**五大类**：构建类、属性类、数据操纵类、遍历类、特定类\n\n### 存储实现\n\n### 算法分析\n\n#### 时间复杂度的概念\n\n- 是一种抽象的度量，表示运算量和问题规模（输入规模）之间的关系，$T(n)$\n- 算法的时间复杂度也与被处理的数据分布有关\n- 算法的时间复杂度分为三种\n  - 最好的\n  - 最坏的\n  - 平均\n\n#### 算法运算量的计算\n\n#### 渐进时间复杂度\n\n#### 算法的优化\n\n#### 空间复杂度的概念\n\n- 渐进的空间复杂度\n- 一般只考虑**辅助**空间的占用情况\n- 空间复杂度一般按照最坏情况处理\n- 空间复杂度的计算、表示方法与时间复杂度相同\n\n### 面向对象方法\n\n#### 类模板的定义\n\n类模板允许用户为类定义一种模式，使得类中的某些数据成员、某些成员函数的参数或返回值能取任意数据类型\n\n##### 定义格式\n\n```cpp\ntemplate <class 标识符>\nclass 类名\n{\n    // 类成员声明\n};\n```\n\n##### 类定义的一般格式\n\n```cpp\nclass 类名\n{\n  [private:]\n    // 私有数据成员和成员函数声明\n  public:\n    // 公有数据成员和成员函数声明\n};\n```\n\n#### 虚函数\n\n- 在基类中用关键词 `virtual` 声明的成员函数，并在派生类中重新定义的函数称为虚函数\n- 虚函数的一般格式\n\n  ```cpp\n  virtual 返回类型 函数名(参数表)\n  {\n    // 函数体\n  };\n  ```\n\n- 在派生类中重新定义时，其函数原型，包括返回类型、函数名、参数个数和参数类型的顺序都必须与基类中的原型完全相同（**继承**）\n- 当把一个函数定义为虚函数时，等于告诉编译器，这个成员函数在派生类中可能有不同的实现。必须在执行时根据传递的参数来决定调用哪一个函数\n- 虚函数在基类中有默认实现，派生类可以选择性地对其进行重写\n\n#### 纯虚函数\n\n- 是一个在基类中说明的虚函数，它在该基类中没有实现，但要在它的派生类里定义和实现自己的版本，或重新说明为纯虚函数\n- 纯虚函数的一般形式\n\n  ```cpp\n  virtual 返回类型 函数名(参数表) = 0;\n  ```\n\n- 纯虚函数在基类中无实现，只有函数原型，派生类必须实现\n\n#### 抽象类\n\n- 如果一个类中**至少有一个纯虚函数**，那么这个类就是抽象类\n- 抽象类只能作为其他类的基类，不能建立抽象类的对象\n\n#### 继承\n\n- 在已有类的基础上建立新的类\n- 基类（父类）和派生类（子类）\n- 继承可以让程序员在已有类的基础上通过增加或修改少量代码的方法得到新的类，从而解决代码重用的问题\n\n##### 派生类\n\n- 一般格式\n\n  ```cpp\n  class 派生类名 : [派生方式] 基类名\n  {\n    // 派生类新增的数据成员和成员函数\n  };\n  ```\n\n- 派生方法\n  - 公有派生：`public`\n  - 私有派生：`protected`\n  - 保护派生：`private`\n- `class` 默认是 `private` 继承， `struct` 默认是 `public` 继承\n\n###### 派生类对基类成员的访问性\n\n|                  | `public` 继承 | `protected` 继承 | `private` 继承 |\n| :--------------: | :-----------: | :--------------: | :------------: |\n|  `public` 成员   |    public     |    protected     |    private     |\n| `protected` 成员 |   protected   |    protected     |    private     |\n|  `private` 成员  |   不可访问    |     不可访问     |    不可访问    |\n\n#### 类定义时常见的两种`const`用法\n\n以函数 `int search(constelemType&x) const` 为例\n\n1. 修饰参数 `x` 的 `const` 和 `&` 组合\n   - `const` 修饰参数 `x`，表示函数 `search` 不会修改参数 `x` 的值\n   - 参数加了 `const` 之后，编译器会在程序编译阶段帮助程序检查函数实现代码中是否含有对参数 `x` 的修改操作，若有则会报错\n   - **如果确认函数实现中不准备改变 `x` 的值，养成加 `const`的习惯**\n   - `&` 修饰参数 `x`，表示参数 `x` 是引用传递，即传递的是实参的地址，而不是实参的值\n2. 修饰函数 `search` 的 `const`\n   - 参数表后的 `const` 保护调用对象的值不被修改\n   - 如果没有 `const` 修饰，那么在调用对象为 `const` 类型时，不能调用该函数\n     常量对象只能调用参数表后带 `const` 的常量成员函数\n\n## 线性表\n\n### 线性表的定义\n\n#### 线性表的概念\n\n- 是一种**线性结构**，是由 $n(n\\geq0)$ 个数据元素组成的有限序列\n- 除了首节点 $A_0$ 和尾节点 $A_{n-1}$ 之外，每个节点 $A_i$ 有且仅有一个前趋 $A_{i-1}$ 和一个后继 $A_{i+1}$\n- $A_0$ 只有后趋，$A_{n-1}$ 只有前趋\n\n  ![线性表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271603830.png)\n\n#### 表的基本操作\n\n- **创建 `create()`**：创建一个空的线性表\n- **清除 `clear()`**：删除线性表中的所有数据元素\n- **长度 `length()`**：返回线性表的长度\n- **插入 `insert(i,x)`**：在线性表的第 $i$ 个位置插入一个新元素 `x`\n- **删除 `remove(i)`**：删除线性表中第 $i$ 个位置的元素\n- **搜索 `search(x)`**：在线性表中搜索元素 `x`，返回其位置\n- **访问 `visit(i)`**：返回线性表中第 $i$ 个位置的元素\n- **遍历 `traverse()`**：依次访问线性表中的每个元素\n\n#### 线性表的抽象类\n\n```cpp\ntemplate <class elemType>\nclass list\n{\n  public:\n    virtual void clear() = 0;                           // 清空\n    virtual int length() const = 0;                     // 返回长度\n    virtual void insert(int i, const elemType &x) = 0;  // 插入\n    virtual void remove(int i) = 0;                     // 删除\n    virtual int search(const elemType &x) const = 0;    // 搜索\n    virtual elemType visit(int i) const = 0;            // 访问\n    virtual void traverse() const = 0;                  // 遍历\n    virtual ~list() {}                                  // 析构函数\n};\n```\n\n- 抽象类定义了线性表基本的操作，全是用纯虚函数定义，不做实现\n- **抽象类无构造函数**\n\n### 线性表的顺序实现\n\n#### 顺序存储结构\n\n- 节点存储在存储器的一块**连续**的空间中\n- 节点依照逻辑顺序依次**存放**\n- 节点存放的物理位置和逻辑顺序是对应的\n- 线性表的顺序实现通常被称为**顺序表**\n\n#### 顺序表类的定义\n\n```cpp\ntemplate <class elemType>\nclass seqList : public list<elemtype>\n{\n  private:\n    elemType *data;\n    int currentLength;\n    int maxSize;\n    void doubleSpace();\n  public:\n    seqList(int initSize = 10);             // 构造函数\n    ~seqList()                              // 析构函数\n    {\n      delete[] data;\n    }\n    void clear()                            //清空\n    {\n      currentLength = 0;\n    }\n    int length() const                      // 返回长度\n    {\n      return currentLength;\n    }\n    void insert(int i, const elemType &x);  // 插入\n    void remove(int i);                     // 删除\n    int search(const elemType &x) const;    // 搜索\n    elemType visit(int i) const;            // 访问\n    void traverse() const;                  // 遍历\n};\n```\n\n#### 函数实现\n\n##### 构造函数\n\n- 定义对象时自动调用，用于初始化对象的数据成员\n- **函数名与类名相同**\n- 可以有任何类型的参数，也可以没有参数，但是**不能有返回类型**，所以定义时不能说明类型\n- 若没有给出构造函数，编译器会自动生成一个默认的构造函数，只为对象开辟空间，里面的内容为随机数\n\n```cpp\ntemplate<class elemType>\nseqList<elemType>::seqList(int initSize)\n{\n  data = new elemType[initSize];\n  maxSize = initSize;\n  currentLength = 0;\n}\n```\n\n![seqList](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271640573.png)\n\n##### 析构函数\n\n- 用于释放对象所占用的内存空间，由编译系统自动调用\n- **函数名与类名相同，前面加 `~`**\n- 不能有参数，也不能有返回类型\n- 若没有给出析构函数，编译器会自动生成一个默认的析构函数\n- 不是所有类都要由析构函数\n- 一般在构造函数中动态申请内存的，必须有析构函数\n\n```cpp\n~seqList()\n{\n  delete[] data;\n}  //在线性表的类中已经实现了，不用到类外定义\n```\n\n##### 顺序表的运算实现\n\n###### `search`\n\n从数组的第 0 个下标变量开始一次往后检查每一个元素，直到找到 `x` 或找到表尾\n\n```cpp\ntemplate<class elemType>\nint seqList<elemType>::search(const elemType &x) const\n{\n  int i ;\n  for (i = 0 ; i < currentLength && data[i] != x ; ++i);\n  if (i == currentLength)\n  {\n    return -1;\n  }\n  else\n  {\n    return i;\n  }\n}\n```\n\n###### `traverse`\n\n从数组的第 0 个下标变量开始一次往后访问每一个元素，直到表尾\n\n```cpp\ntemplate<class elemtype>\nvoid seqList<elemType>::traverse() const\n{\n  for (int i = 0 ; i < currentLength ; ++i)\n  {\n    cout << data[i] << ' ';\n  }\n}\n```\n\n###### `insert`\n\n- 在第 `i` 个位置插入元素 `x`\n- 若插入后表长超过 `maxSize`，则将 `maxSize` 扩大一倍\n\n![seqList::insert](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271747022.png)\n\n```cpp\ntemplate<class elemType>\nvoid seqList<elemType>::insert(int i , const elemType &x)\n{\n  if (currentSize = maxSize)\n  {\n    doubleSpace();\n  }\n  for (int j = currentLength ; j > i ; --j)\n  {\n    data[j] = data[j - 1];\n  }\n  data[i] = x;\n  ++currentLength;\n}\n```\n\n###### `doubleSpace` 操作的实现\n\n- 重新申请一个更大规模的动态数组，将原有数组的内容拷贝到新数组中，释放原有数组空间，将新数组作为存储线性表的存储区\n\n![seqList::doublespace](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281230588.png)\n\n```cpp\ntemplate<class elemType>\nvoid seqList<elemType>::doublespace()\n{\n  elemtype *tmp = data;\n  maxSize *= 2;\n  data = new elemtype[maxSize];\n  for (int i = 0 ; i < currentLength ; ++1)\n  {\n    data[i] = tmp[i];\n  }\n  delete[] tmp;\n}\n```\n\n###### `remove`\n\n![seqlist::remove](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281238735.png)\n\n```cpp\ntemplate<class elemType>\nvoid seqList<elemType>::remove(int i)\n{\n  if (i < 0 ||i > currentlength)\n  {\n    throw OutOfBound();\n  }\n  for (int j = i ; j < currentlength -1 ; ++j)\n  {\n    data[j] = data[j + 1];\n  }\n  --currentLength;\n}\n```\n\n### 线性表的链接存储\n\n#### 单链表\n\n- 每个节点附加指针字段，如 `next`，指向直接后继节点，最后一个节点的 `next` 指向 `nullptr`\n\n![单链表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281247119.png)\n\n##### 头节点、头指针\n\n- 在表头额外增加一个相同类型的特殊结点\n- 不是线性表中的组成部分\n- 头节点使得在表头位置上进行插入和删除和在其他节点位置上是完全一致的，使得插入和删除算法得到简化\n\n![带头节点的单链表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281407312.png)\n\n##### 结点及其组成\n\n- 链表的节点包含两个部分\n  - 数据字段\n    - 可以存储任何类型的数据，仍然使用 `elemType` 表示\n  - 指针字段\n    - 用于存储**后继节点**的地址值\n  - 结点类型是链表专用的，可以设为内嵌类\n  - 将节点类定义为 `struct` 方便链表类访问\n\n##### 单链表类的定义\n\n```cpp\ntemplate <class elemType>\nclass sLinkList:public list<elemtype>\n{\n  private:\n    struct node                                    // 节点类\n    {\n      elemType data;\n      node *next;\n      node(const elemType &x , node *n = nullptr)\n      {\n        data = x;\n        next = n;\n      }\n      node():next(nullptr){}\n      ~node(){}\n    };\n\n    node *head;\n    int currentLength;\n    node *move(int i) const;\n  public:\n    sLinkList();\n    ~sLinkList();\n    void clear();\n    int length() const\n    {\n      return currentLength;\n    }\n    void insert(int i , const elemType &x);\n    void remove(int i);\n    int search(const elemType &x) const;\n    elemType visit(int i) const;\n    void traverse() const;\n};\n```\n\n##### 构造函数\n\n![sLinklist](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281418321.png)\n\n```cpp\ntemplate <class elemType>\nsLinkList<elemType>::sLinkList()\n{\n  head = new node();\n  currentLength = 0;\n}\n```\n\n##### `clear`\n\n- 将单链表变成一个空表\n- 回收节点空间\n\n![sLinkList::clear](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281420756.png)\n\n```cpp\ntemplate <class elemType>\nvoid sLinkList<elemType>::clear()\n{\n  node *p = head->next , *q;\n\n  while (p != nullptr)        // 删除节点\n  {\n    q = p->next;\n    delete p;\n    p = q;\n  }\n  currentLength = 0;\n}\n```\n\n##### `move`\n\n- 返回第 $i$ 个元素的指针\n\n```cpp\ntemplate <class elemType>\nstruct sLinkList<elemType>::node *sLinkList<elemType>::move(int i) const\n{\n  node *p = head;\n  for (int j = 0 ; j < i ; ++j)\n  {\n    p = p->next;\n  }\n  return p;\n}\n```\n\n##### `insert`\n\n1. 指针 `p` 指向要插入的位置 `i` 的前一个节点\n2. 申请一个新节点 `s`\n3. 将 `s` 的 `next` 指向 `p` 的 `next`\n4. 将 `p` 的 `next` 指向 `s`\n\n![sLinkList::insert](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281437080.png)\n\n```cpp\ntemplate <class elemType>\nvoid sinkList<elemtype>::insert(int i , const elemType &x)\n{\n  if (i < 0 || i > currentLength)\n  {\n    throw OutOfBound();\n  }\n  node *p = move(i-1);\n  node *s = new node(x , p->next);\n  p->next = s;\n  ++currentLength;\n}\n```\n\n##### `remove`\n\n1. 找到被删除节点的前一个节点 `pos`\n2. 让 `delp` 指向被删除节点\n3. 让 `pos` 的 `next` 指向 `delp` 的 `next`\n4. 释放 `delp` 的空间\n\n![sLinkList::remove](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281444167.png)\n\n```cpp\ntemplate <class elemType>\nvoid sLinkList<elemType>::remove(int i)\n{\n  if (i < 0 || i >= currentLength)\n  {\n    throw OutOfBound();\n  }\n  node *pos = move(i-1);\n  node *delp = pos->next;\n  pos->next = delp->next;\n  delete delp;\n  --currentLength;\n}\n```\n\n##### `search`\n\n- 从头节点开始，依次访问每个节点，直到找到 `x` 或到达表尾\n\n```cpp\ntemplate <class elemType>\nint sLinkList<elemType>::search(const elemtype 7x) const\n{\n  node *p = head -> next;\n  int i = 0;\n  while (p != nullptr && p->data != x) // 访问每个节点，条件的顺序不能交换\n  {\n    p = p->next;\n    ++i;\n  }\n  if (p == nullptr)\n  {\n    return -1;\n  }\n  else\n  {\n    return i;\n  }\n}\n```\n\n- 如果判定条件改为 `p->data != x && p != nullptr`，会在 `p` 为空时试图访问 `p->data`，导致访问空指针，从而产生未定义行为\n\n##### `visit`\n\n1. 找到第 `i` 个节点\n2. 返回 `p->data`\n\n```cpp\ntemplate <class elemType>\nelemType sLinkList<elemType>::visit(int i) const\n{\n  if (i < 0 || i >= currentLength)\n  {\n    throw OutOfBound();\n  }\n  return move(i)->data;\n}\n```\n\n##### `traverse`\n\n```cpp\ntemplate <class elemType>\nvoid sLinkList<elemType>::traverse() const\n{\n  node *p = head->next;\n  while (p != nullptr)\n  {\n    cout << p->data << ' ';\n    p = p->next;\n  }\n}\n```\n\n#### 双链表\n\n- 每个节点有两个指针字段\n  - `next` 指向直接后继节点\n  - `prev` 指向直接前驱节点\n\n##### 双链表的头尾节点\n\n- 头节点\n  - `prev` 指向 `nullptr`\n  - `next` 指向首节点\n- 尾节点 `tail`\n  - `prev` 指向最后一个节点\n  - `next` 指向 `nullptr`\n\n![双链表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291712872.png)\n\n##### 双链表类的定义\n\n```cpp\ntemplate <class elemType>\nclass dLinkList:public list<elemType>\n{\n  private:\n    struct node                                                         // 双链表中的节点类\n    {\n      elemType data;\n      node *next;\n      node *prev;\n      node(const elemType &x , node *p = nullptr , node *n = nullptr)\n      {\n        data = x;\n        prev = p;\n        next = n;\n      }\n      node():next(nullptr),prev(nullptr){}\n      ~node(){}\n    };\n    node *head , *tail;                                                  // 头节点和尾节点\n    int currentLength;                                                   // 当前长度\n    node *move(int i) const;                                             // 返回第 i 个节点的指针\n  public:\n    dLinkList();\n    ~dLinkList();\n    void clear();\n    int length() const\n    {\n      return currentLength;\n    }\n    void insert(int i , const elemType &x);\n    void remove(int i);\n    int search(const elemType &x) const;\n    elemType visit(int i) const;\n    void traverse() const;\n};\n```\n\n##### 构造函数\n\n- 申请头节点和尾节点\n\n![dLinkList](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291715359.png)\n\n```cpp\ntemplate <class elemType>\ndLinkList<elemType>::dLinkList()\n{\n  head = new node();\n  tail = new node();\n  head->next = tail;\n  tail->prev = head;\n  currentLength = 0;\n}\n```\n\n##### `insert`\n\n1. 申请一个新节点 `tmp`，找到要插入的位置 `pos`\n2. 将 `tmp` 的 `prev` 指向 `pos` 的 `prev`，`tmp` 的 `next` 指向 `pos`\n3. 将 `pos` 的前一个结点的 `next` 指向 `tmp`\n4. 将 `pos` 的 `prev` 指向 `tmp`\n\n![dLinkList::insert](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291718343.png)\n\n```cpp\ntemplate <class elemType>\nvoid dLinkList<elemtype>::insert(int i ,const elemTypr &x)\n[\n  node *pos , *tmp;\n\n  pos = move(i);\n  temp = new node(x,pos -> prev , pos);\n  pos->prev->next = tmp;\n  pos->prev = tmp;\n\n  ++currentLength;\n]\n```\n\n##### `remove`\n\n1. 找到要删除的节点 `pos`\n2. 将 `pos` 的前一个节点的 `next` 指向 `pos` 的后一个节点\n3. 将 `pos` 的后一个节点的 `prev` 指向 `pos` 的前一个节点\n\n![dLinkList::remove](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291730399.png)\n\n```cpp\ntemplate <class elemType>\nvoid dLinkList<elemType>::remove(int i)\n{\n  node *pos = move(i);\n\n  pos->prev->next = pos->next;\n  pos->next->prev = pos->prev;\n\n  delete pos;\n  --currentLength;\n}\n```\n\n#### 单循环链表\n\n- 一般单循环链表不带头节点\n\n![单循环链表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291732560.png)\n\n#### 双循环链表\n\n- 头结点中 `prev` 字段给出尾结点的地址，尾结点中 `next` 字段给出头结点的地址\n- 一般也不设置头尾节点\n\n## 栈\n\n### 栈的定义\n\n- 栈是一种特殊的线性表\n- 只允许在一段进行插入和删除操作\n- 先进后出（LIFO，Last In First Out）\n\n![栈](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291811552.png)\n\n#### 栈的基本操作\n\n- **创建 `create()`**：创建一个空栈\n- **进栈 `push(x)`**：将元素 `x` 压入栈顶\n- **出栈 `pop()`**：删除栈顶元素并返回其值\n- **访问栈顶元素 `top()`**：返回栈顶元素的值但是不删除\n- **判断是否为空 `isEmpty()`**：若栈空返回 `true`，否则返回 `false`\n\n#### 栈的抽象类\n\n```cpp\ntemplate <class elemType>\nclass stack\n{\n  public:\n    virtual void push(const elemType &x) = 0;       // 进栈\n    virtual elemType pop() = 0;                     // 出栈\n    virtual elemType top() const = 0;               // 访问栈顶元素\n    virtual bool isEmpty() const = 0;               // 是否为空\n    virtual ~stack() {}                             // 析构函数\n};\n```\n\n### 栈的顺序实现\n\n- 使用数组储存栈中的节点\n- 进栈和出栈都是在栈顶进行，不会引起类似顺序表中的大量元素的移动，数组的后端为栈顶\n\n![顺序栈](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291817453.png)\n\n#### 顺序栈类\n\n```cpp\ntemplate <class elemType>\nclass seqStack:public stack<elemType>\n{\n  private:\n    elemType *data;                     // 数据域\n    int top_p;                          // 栈顶指针\n    int maxSize;                        // 栈的最大容量\n    void doubleSpace();\n  public:\n    seqStack(int initSize = 10);        // 构造函数\n    ~seqStack();                        // 析构函数\n    bool isEmpty() const;               // 是否为空\n    void push(const elemType &x);       // 进栈\n    elemType pop();                    // 出栈\n    elemType top() const;               // 访问栈顶元素\n};\n```\n\n#### 顺序存储的运算实现\n\n##### 构造函数\n\n- 按照用户估计的栈的规模申请一个动态数组，将数组地址保存在 `elem` 中，数组规模保存在 `maxSize` 中，并设 `top_p` 的值为 $-1$\n\n```cpp\ntemplate <class elemType>\nseqStack<elemType>::seqStack(int initSize)\n{\n  elem = new elemType[initSize];\n  maxSize = initSize;\n  top_p = -1;\n}\n```\n\n#### `push`\n\n- 先判断栈是否已满，若满则调用 `doubleSpace` 扩大栈的容量\n- 将 `top_p` 加 1，指向栈顶元素\n- 将 `x` 压入栈顶\n\n```cpp\ntemplate <class elemType>\nvoid seqStack<elemType>::push(const elemType &x)\n{\n  if (top_p == maxSize - 1)\n  {\n    doubleSpace();\n  }\n  elem[++top_p] = x;\n}\n```\n\n##### `doubleSpace`\n\n```cpp\ntemplate <class elemType>\nvoid seqStack<elemType>::doubleSpace()\n{\n  elemType *tmp = elem;\n  elem = new elemType[maxSize * 2];\n  for (int i = 0 ; i < maxSize ; ++i)\n  {\n    elem[i] = tmp[i];\n  }\n  maxSize *= 2;\n  delete[] tmp;\n}\n```\n\n##### `pop`\n\n- 返回 `top_p` 指向的元素\n- 将 `top_p` 减 1\n\n```cpp\ntemplate <class elemType>\nelemType seqStack<elemType>::pop()\n{\n  return elem[top_p--];\n}\n```\n\n##### `top`\n\n- 返回 `top_p` 指向的元素\n\n```cpp\ntemplate <class elemType>\nelemType seqStack<elemType>::top() const\n{\n  return elem[top_p];\n}\n```\n\n##### `isEmpty`\n\n- 判断 `top_p` 是否为 $-1$，若是则栈空\n\n```cpp\ntemplate <class elemType>\nbool seqStack<elemType>::isEmpty() const\n{\n  return top_p == -1;\n}\n```\n\n#### 析构函数\n\n```cpp\ntemplate <class elemType>\nseqStack<elemType>::~seqStack()\n{\n  delete[] elem;\n}\n```\n\n#### 性能分析\n\n- 所有运算实现的时间复杂度都为 $O(1)$\n- 进栈运算在最坏的情况下的时间复杂度为 $O(n)$ （需要 `doublespace` 时）\n\n### 栈的链接实现\n\n- 使用**不含头结点的单链表**实现栈\n- 从使用方便性上看，将单链表的头指针指向栈顶\n\n![链接栈](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291834782.png)\n\n#### 链接栈类\n\n```cpp\ntemplate <class elemType>\nclass LinkedStack:public stack<elemType>\n{\n  private:\n    struct node\n    {\n      elemType data;\n      node *next;\n      node(const elemType &x , node *n = nullptr)\n      {\n        data = x;\n        next = n;\n      }\n      node():next(nullptr){}\n      ~node(){}\n    };\n    node *top_p;                       // 栈顶指针\n  public:\n    LinkedStack();                    // 构造函数\n    ~LinkedStack();                   // 析构函数\n    bool isEmpty() const;             // 是否为空\n    void push(const elemType &x);     // 进栈\n    elemType pop();                   // 出栈\n    elemType top() const;             // 访问栈顶元素\n};\n```\n\n#### 链接存储的运算实现\n\n##### 构造函数\n\n- 将 `top_p` 初始化为 `nullptr`\n\n```cpp\ntemplate <class elemType>\nLinkedStack<elemType>::LinkedStack()\n{\n  top_p = nullptr;\n}\n```\n\n##### 析构函数\n\n```cpp\ntemplate <class elemType>\nLinkStack<elemType>::~LinkStack()\n{\n  node *tmp;\n  while (top_p != nullptr)\n  {\n    tmp = top_p;\n    top_p = top_p->next;\n    delete tmp;\n  }\n}\n```\n\n##### `push`\n\n- 在表头插入\n\n```cpp\ntemplate <class elemType>\nvoid LinkedStack<elemType>::push(const elemType &x)\n{\n  top_p = new node(x , top_p);\n}\n```\n\n##### `pop`\n\n- 删除表头节点\n\n```cpp\ntemplate <class elemType>\nelemType LinkedStack<elemType>::pop()\n{\n  node *tmp = top_p;\n  elemType x = top_p->data;\n  top_p = top_p->next;\n  delete tmp;\n  return x;\n}\n```\n\n##### `top`\n\n- 返回 `top_p` 指向的节点的 `data`\n\n```cpp\ntemplate <class elemType>\nelemType LinkedStack<elemType>::top() const\n{\n  return top_p->data;\n}\n```\n\n##### `isEmpty`\n\n- 判断 `top_p` 是否为 `nullptr`\n\n```cpp\ntemplate <class elemType>\nbool LinkedStack<elemType>::isEmpty() const\n{\n  return top_p == nullptr;\n}\n```\n\n#### 性能分析\n\n- 所有运算实现的时间复杂度都为 $O(1)$，因为都是对栈顶进行操作\n\n### 栈的应用\n\n#### 递归函数的非递归实现\n\n##### 函数调用\n\n- 递归的本质是函数调用，函数调用又是通过栈实现的，递归时会产生隐式栈\n\n```cpp\nvoid main()\n{\n  ...\n  r1:f1();\n  r2:\n  ..\n}\n\nvoid f1()\n{\n  ...\n  t1:f2();\n  t2:\n  ...\n}\n\nvoid f2()\n{\n  ...\n  ...\n}\n```\n\n![函数执行过程](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503301445662.png)\n\n- 设置一个栈模拟函数调用，当调用发生时，将函数压入栈中\n- 函数返回时，将栈顶元素弹出\n\n###### 递归算法的例子\n\nhanoi 塔算法\n\n```cpp\nvoid Move(int Height , int FromNeedle ,int ToNeedle ,int UsingNeedle) // FromNeedle是起始针，ToNeedle是目标针，UsingNeedle是辅助针\n{\n  if (Height > 0)\n  {\n    Move(Height - 1，FromNeedle , UsingNeeedle,ToNeedle); // 将上面n-1个盘子从FromNeedle移动到UsingNeedle\n    cout << FromNeedle << \"->\" << ToNeedle << endl; // 将最底下的盘子从FromNeedle移动到ToNeedle>\n    Move(Height - 1,UsingNeedle , ToNeedle , FromNeedle); // 将上面的盘子从UsingNeedle移动到ToNeedle\n  }\n}\n```\n\n##### 递归算法的时间复杂度\n\n###### 数学归纳法\n\n以 Hanio 塔问题为例\n\n$$\n\\begin{dcases}\nT(n) = 2T(n-1) + 1 &\\\\\nT(1) = 1 &\n\\end{dcases}\n$$\n\n可以使用数学归纳法证明 $T(n) = 2^n - 1$\n\n###### 递归方程\n\n**主定理**：设 $a \\geq 1$，$b > 1$ 为常数，$f(n)$ 是一个函数，则递归方程\n\n$$\nT(n) = aT(\\frac{n}{b}) + f(n) \\quad (n > 1)\n$$\n\n的解为\n\n1. 若 $f(n) < O\\left(n^{\\log_{b}a}\\right)$，则 $T(n)=O\\left(n^{\\log_{b}a}\\right)$\n2. 若 $f(n) = O\\left(n^{\\log_{b}a}\\right)$，则 $T(n)=O\\left(n^{\\log_{b}a}\\log_{2}n\\right)$\n3. 若 $f(n) > O\\left(n^{\\log_{b}a}\\right)$，则 $T(n)=O\\left(f(n)\\right)$\n\n###### 生成函数\n\n**定义**：设 $u_0 , u_1 , u_2 , \\ldots , u_n ,\\ldots$ 是一无穷序列，称形式幂级数 $\\displaystyle G(t) = \\sum_{i\\geq0}u_it^i$ 为其生成函数\n\n利用生成函数求通项的方法\n\n1. 按照递归关系式消去无限延长的部分\n2. 展开为 $t$ 的幂级数求通项\n\n以 Fibonacci 数列为例\n\n$$\n\\begin{dcases}\nF_{0} =0 & \\\\\nF_{1} =1 & \\\\\nF_{n} =F_{n-1} +F_{n-2} &\n\\end{dcases}\n$$\n\n$$\n\\begin{aligned}\n  &G(t) = F_{0}t^0 + F_{1}t^1 + F_{2}t^2 + F_{3}t^3 + \\cdots \\\\\n  &G(t) = t + t^2 + t^3 + \\cdots \\\\\n  &tG(t)=t^2 + t^3 + t^4 + \\cdots \\\\\n  &t^2G(t)=t^3 + t^4 + t^5 + \\cdots \\\\\n  &(1-t-t^2)G(t) = t \\\\\n  &G(t) = \\frac{t}{1-t-t^2} = \\frac{1}{\\sqrt{5}} \\left(\\frac{1}{1-\\frac{1+\\sqrt{5}}{2}t} - \\frac{1}{1-\\frac{1-\\sqrt{5}}{2}t}\\right) \\\\\n\\end{aligned}\n$$\n\n令 $\\Phi = \\frac{1}{2}(1+\\sqrt{5})$，$\\hat{\\Phi}=\\frac{1}{2}(1-\\sqrt{5})$\n\n$$\nG(t) =\\frac{1}{\\sqrt{5}}(\\frac{1}{1-\\Phi t} - \\frac{1}{1-\\hat{\\Phi}t})\n$$\n\n有 $\\displaystyle\\frac{1}{1-\\Phi t} = \\sum_{n=0}^{\\infty} \\Phi^n t^n$\n\n$$\nG(t) = \\frac{1}{\\sqrt{5}} \\sum_{n=0}^{\\infty} (\\Phi^n t^n - \\hat{\\Phi}^n t^n)\n$$\n\n则\n\n$$\nF_n = \\frac{1}{\\sqrt{5}}(\\Phi^n - \\hat{\\Phi}^n)\n$$\n\n#### 递归消除\n\n以打印正整数为例\n\n##### 递归实现\n\n###### 代码\n\n```cpp\nvoid printNum(int num)\n{\n  if (num >= 10)\n  {\n    printNum(num / 10);\n    cout.put(num % 10 + '0');\n  }\n  else\n  {\n    cout.put(num + '0');\n  }\n}\n```\n\n###### 代码运行过程中栈的变化\n\n1. `push(1234)`\n2. `pop(1234)`，`push(4)`，`push(123)`\n3. `pop(123)`，`push(3)`，`push(12)`\n4. `pop(12)`，`push(2)`，`push(1)`\n5. `pop(1)`，`pop(2)`，`pop(3)`，`pop(4)`\n\n##### 非递归实现\n\n```cpp\nvoid printNum(int num)\n{\n  LinkStack<int> s;\n  int tmp;\n  s.push(num);\n  while (!isEmpty())\n  {\n    tmp = s.pop();\n    if (tmp > 9)\n    {\n      s.push(tmp % 10);\n      s.push(tmp / 10);\n    }\n    else\n    {\n      cout.put(tmp + '0');\n    }\n  }\n}\n```\n\n### 括号匹配\n\n- 判断一个表达式中的括号是否匹配\n- 遇到左括号就入栈，遇到右括号就出栈\n\n判断错误的原则\n\n1. 栈空时遇到右括号\n2. 出栈时遇到不匹配的括号\n3. 栈不空时结束\n\n### 简单的计算数学表达式\n\n#### 前缀式、中缀式和后缀式\n\n对于一个表达式 $a+b$\n\n- 前缀式 `+ab`，波兰式\n- 中缀式 `a+b`\n- 后缀式 `ab+`，逆波兰式\n\n#### 后缀式的优点\n\n- 不需要括号\n- 不需要考虑运算符的优先级\n- 计算机容易处理\n\n#### 后缀式的计算\n\n- 使用栈来存储操作数\n- 遇到操作数就入栈\n- 遇到操作符就出栈两个操作数，进行计算，将结果入栈\n- 最后栈中只剩下一个元素，就是结果\n\n#### 中缀式转换为后缀式的算法\n\n操作方法见[中缀计算式转换为后缀计算式](/本科/编程/数据结构/中缀计算式转换为后缀计算式.md)\n\n## 队列\n\n- 队列的定义\n\n- 先进先出（FIFO，First In First Out）\n- 只允许在一端（队首）进行插入操作，另一端（队尾）进行删除操作\n\n![队列](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503310847159.png)\n\n#### 队列的基本操作\n\n- **创建 `create()`**：创建一个空队列\n- **入队 `enQueue(x)`**：将元素 `x` 入队\n- **出队 `deQueue()`**：删除队首元素并返回其值\n- **访问队首元素 `getHead()`**：返回队首元素的值但不删除\n- **判断是否为空 `isEmpty()`**：若队列空返回 `true`，否则返回 `false`\n\n#### 队列的抽象类\n\n```cpp\ntemplate <class elemType>\nclass queue\n{\n  public:\n    virtual void enQueue(const elemType &x) = 0;       // 入队\n    virtual elemType deQueue() = 0;                    // 出队\n    virtual elemType getHead() const = 0;              // 访问队首元素\n    virtual bool isEmpty() const = 0;                  // 是否为空\n    virtual ~queue() {}                                 // 析构函数\n};\n```\n\n### 队列的顺序实现\n\n- 使用数组来存储队列中的元素\n- 元素下标的范围为 $0$ 到 `maxSize - 1`\n- 存储队里的三种组织方法\n  1. 队头位置固定\n  2. 队头位置不固定\n  3. 循环队列\n\n#### 队头位置固定\n\n![队头位置固定](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311613560.png)\n\n**缺点**：出队的时间复杂度为 $O(n)$，因为出队时需要将所有元素向前移动一位\n\n#### 队头位置不固定\n\n![队头位置不固定](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311614368.png)\n\n**优点**：所有操作的时间复杂度均为 $O(1)$\n**缺点**：浪费大量的空间\n\n#### 循环队列\n\n![循环队列](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311626377.png)\n\n- 入队\n  - `rear = (rear + 1) % maxSize`; `elem[rear] = x`\n- 出队\n  - `front = (front + 1) % maxSize`; `return elem[front]`\n\n为了解决队列空和队列满的判断问题，令 `front` 指向的单元不能存储队列元素，只能起到标志作用\n\n- 队列空：`front == rear`\n- 队列满：`(rear + 1) % maxSize == front`\n\n###### 循环队列类的定义\n\n```cpp\ntemplate <class elemType>\nclass seqQueue:public queue<elemType>\n{\n  private:\n    elemType *elem;\n    int maxSize;\n    int front , rear;\n    void doubleSpace();\n  public:\n    seqQueue(int initSize = 10);        // 构造函数\n    ~seqQueue();                        // 析构函数\n    bool isEmpty();                     // 是否为空\n    void enQueue(const elemType &x);    // 入队\n    elemType deQueue();                 // 出队\n    elemType getHead();                 // 访问队首元素\n};\n```\n\n##### 构造函数\n\n- 申请一块空间，将 `front` 和 `rear` 初始化为 $0$\n\n```cpp\ntemplate <class elemType>\nseqQueue<elemType>::seqQueue(int initSize)\n{\n  elem = new elemType[initSize];\n  maxSize = initSize;\n  front = rear = 0;\n}\n```\n\n##### 析构函数\n\n```cpp\ntemplate <class elemType>\nseqQueue<elemType>::~seqQueue()\n{\n  delete[] elem;\n}\n```\n\n##### `enQueue`\n\n- 先判断队列是否已满，若满则调用 `doubleSpace` 扩大队列的容量\n- 将 `rear` 加 1，指向队尾元素\n\n```cpp\ntemplate <class elemType>\nvoid seqQueue<elemType>::enQueue(const elemType &x)\n{\n  if ((rear + 1) % maxSize == front)\n  {\n    doubleSpace();\n  }\n  rear = (rear + 1) % maxSize;\n  elem[rear] = x;\n}\n```\n\n##### `doubleSpace`\n\n```cpp\ntemplate <class elemType>\nvoid seqQueue<elemType>::doubleSpace()\n{\n  elemType *tmp = elem;\n  elem = new elemType[maxSize * 2];\n  for (int i = 0 ; i < maxSize ; ++i)\n  {\n    elem[i] = tmp[(front + i) % maxSize];\n  }\n  front = 0;\n  rear = maxSize - 1;\n  maxSize *= 2;\n  delete[] tmp;\n}\n```\n\n##### `deQueue`\n\n- 将 `front` 加 1，指向队首元素\n- 返回 `elem[front]`\n\n```cpp\ntemplate <class elemType>\nelemType seqQueue<elemType>::deQueue()\n{\n  front = (front + 1) % maxSize;\n  return elem[front];\n}\n```\n\n##### `getHead`\n\n- 返回 `elem[(front + 1) % maxSize]`\n\n```cpp\ntemplate <class elemType>\nelemType seqQueue<elemType>::getHead()\n{\n  return elem[(front + 1) % maxSize];\n}\n```\n\n##### `isEmpty`\n\n- 判断 `front` 是否等于 `rear`\n\n```cpp\ntemplate <class elemType>\nbool seqQueue<elemType>::isEmpty()\n{\n  return front == rear;\n}\n```\n\n### 队列的链接实现\n\n- 为了方便操作，使用含头节点和尾节点的单链表实现\n\n![链接队列](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311804800.png)\n\n**链接队列的特点**\n\n- 不会出现队列满的情况，但是会出现队列空的情况\n- 队列为空时，单链表中没有节点存在，即头尾指针都为 `nullptr`\n- 保存一个链接队列只需要两个分别指向单链表节点的指针 `front` 和 `rear`\n  - `front` 指向队首元素\n  - `rear` 指向队尾元素\n\n#### 连接队列类\n\n```cpp\ntemplate <class elemType>\nclass linkQueue:public queue<elemType>\n{\n  private:\n    struct node\n    {\n      elemType data;\n      node *next;\n      node(const elemType &x , node *n = nullptr)\n      {\n        data = x;\n        next = n;\n      }\n      node():next(nullptr){}\n      ~node(){}\n    };\n    node *front , *rear;                // 队头和队尾指针\n  public:\n    linkQueue();                       // 构造函数\n    ~linkQueue();                      // 析构函数\n    bool isEmpty() ;              // 是否为空\n    void enQueue(const elemType &x);   // 入队\n    elemType deQueue();                // 出队\n    elemType getHead() const;          // 访问队首元素\n};\n```\n\n##### 构造函数\n\n- 将 `front` 和 `rear` 初始化为 `nullptr`\n\n```cpp\ntemplate <class elemType>\nlinkQueue<elemType>::linkQueue()\n{\n  front = rear = nullptr;\n}\n```\n\n##### `enQueue`\n\n1. 申请一个节点空间 `x`\n2. 将 `rear` 指向的节点的 `next` 指向 `x`\n3. 将 `rear` 指向 `x`\n\n**注意**：存在队列为空的情况，此时我们只需要将 `front` 和 `rear` 都指向 `x` 即可\n\n```cpp\ntemplate <class elemType>\nvoid linkQueue<elemType>::enQueue(const elemType &x)\n{\n  if (rear == nullptr)\n  {\n    front = rear = new node(x);\n  }\n  else\n  {\n    rear = rear->next = new node(x);\n  }\n}\n```\n\n##### `deQueue`\n\n1. 返回 `front` 指向的节点的 `data`\n2. 将 `front` 指向的节点从链表中摘下\n3. 释放空间\n\n**注意**：当队列中只有一个元素时，删除后队列为空，此时需要将 `front` 和 `rear` 都置为 `nullptr`\n\n```cpp\ntemplate <class elemType>\nvoid LinkQueue<elemType>::deQueue()\n{\n  node *tmp = front;\n  if (front)\n  {\n    emelType value = front->data;\n    front = front->next;\n    if (front == nullptr)\n    {\n      rear = nullptr;\n    }\n    delete tmp;\n    return value;\n  }\n}\n```\n\n##### `getHead`\n\n- 返回 `front` 指向的节点的 `data`\n\n```cpp\ntemplate <class elemType>\nelemType linkQueue<elemType>::getHead() const\n{\n  return front->data;\n}\n```\n\n##### `isEmpty`\n\n- 判断 `front` 或 `rear` 是否为 `nullptr`\n\n```cpp\ntemplate <class elemType>\nbool linkQueue<elemType>::isEmpty()\n{\n  return front == nullptr;\n}\n```\n\n##### 析构函数\n\n```cpp\ntemplate <class elemType>\nlinkQueue<elemType>::~linkQueue()\n{\n  node *tmp;\n  while (front != nullptr)\n  {\n    tmp = front;\n    front = front->next;\n    delete tmp;\n  }\n}\n```\n\n## 树\n\n### 树的定义\n\n#### 树的递归定义\n\n- 树是 $n$ 个节点的有限集合，它或者是空集，或者满足\n  - 有一个特殊的节点称为根节点\n  - 除根节点外，其他节点分为 $m$ 个互不相交的有限集合 $T_1 , T_2 , \\ldots , T_m$，每个集合都是一棵树\n\n#### 树的术语\n\n- **根节点、叶节点、内部节点**：\n  - 根节点：没有父节点的节点\n  - 叶节点：没有子节点的节点\n  - 内部节点：有子节点的节点\n- **节点的度和树的度**：\n  - 节点的度：节点的子树个数\n  - 树的度：树中所有节点的度的最大值\n- **儿子节点**\n- **父亲节点**\n- **兄弟节点**\n- **祖先节点**\n- **子孙节点**\n- **节点所处层次**\n- **树的高度**\n- **有序树**\n- **无序树**\n- **森林**\n\n#### 树的运算\n\n- **建树 `create()`**：创建一个空树\n- **清空 `clear()`**：删除树中所有节点\n- **判空 `IsEmpty()`**：判断是否为空树\n- **找根节点 `root()`**：找出树的根节点值，若为空树则返回特殊值\n- **找父节点 `parent()`**：找到节点的父节点，若该节点不存在或为根节点则返回特殊值\n- **找子节点 `child()`**：找到节点的某个子节点，若该节点不存在或没有子节点则返回特殊值\n- **剪枝 `remove()`**：删除节点的某棵子树\n- **遍历 `traverse()`**：访问树上的每个节点\n\n#### 树的抽象类\n\n```cpp\ntemplate <class T>\nclass tree\n{\n  public:\n    virtual void clear() = 0;\n    virtual bool isEmpty() const = 0;\n    virtual T root(T flag) const = 0;\n    virtual T parent(T x , T flag) const = 0;\n    virtual T child(T x , int i , T flag) const = 0;\n    virtual void remove(T x) = 0;\n    virtual void traverse() const = 0;\n};\n```\n\n### 二叉树\n\n#### 二叉树的定义\n\n- 二叉树（Binary Tree）是节点的有限集合，要么为空，要么由一个根节点以及两棵互不相交的左右子树构成，而其左右子树也是二叉树\n\n**注意**：二叉树是**有序树**，必须严格区分左右子树，即使只有一棵子树也要说明是左子树还是右子树，交换左右子树得到另一棵二叉树\n\n二叉树有五种基本形态\n\n1. 空树\n2. 只有一个节点的树\n3. 只有左子树的树\n4. 只有右子树的树\n5. 左右子树都有的树\n\n##### 满二叉树\n\n![满二叉树](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311916690.png)\n\n- 每个节点的度都为 $0$ 或 $2$ 的二叉树称为满二叉树\n- 性质\n  - 高度为 $h$ 的满二叉树有 $2^h - 1$ 个节点\n  - 任意一层的节点个数达到了上限 $2^{n-1}$\n\n##### 完全二叉树\n\n![完全二叉树](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311917668.png)\n\n- 在满二叉树的最底层从右向左依次删除若干个节点得到的树为完全二叉树\n- 满二叉树是完全二叉树，完全二叉树不一定是满二叉树\n- 性质\n  - 所有的叶节点都出现在最低的两层生\n  - 对于任意节点，如果其右子树的高度为 $h$，则其左子树的高度为 $h$ 或 $h+1$\n\n#### 二叉树的性质\n\n1. 二叉树的第 $i$ 层最多有 $2^{i-1}$ 个节点\n2. 二叉树的深度为 $h$，则最多有 $2^h - 1$ 个节点\n3. 对于一棵非空二叉树，若其叶节点个数为 $n_0$，则其度为 $2$ 的节点个数为 $n_2$，则有 $n_0 = n_2 + 1$\n4. 具有 $n$ 个节点的二叉树的高度为 $h$，则 $h = \\lfloor \\log_2n \\rfloor +1$\n5. 对于一棵具有 $n$ 个节点的完全二叉树中的节点按层自上而下，每层从左到右编号，若设根节点的编号为 $1$，则对任一编号为 $u$ 的节点，有\n   1. 如果 $i=1$，则 $u$ 为根节点\n   2. 如果 $i>1$，则 $u$ 的父节点编号为 $\\lfloor \\frac{u}{2} \\rfloor$\n   3. 如果 $2i \\geq n$，则编号为 $i$ 的节点为叶子节点，没有儿子；否则，其左子编号为 $2i$\n   4. 如果 $2i+1 \\geq n$，则编号为 $i$ 的节点无右儿子；否则，其右子编号为 $2i+1$\n\n#### 二叉树的基本运算\n\n- **建树 `create()`**：创建一棵空树\n- **清空 `clear()`**：删除树中所有节点\n- **判空 `isEmpty()`**：判断是否为空树\n- **找根节点 `root()`**：找出树的根节点值，若为空树则返回特殊值\n- **找父节点 `parent()`**：找到节点的父节点，若该节点不存在或为根节点则返回特殊值\n- **找左子节点 `lchild()`**：找到节点的左子节点，若该节点不存在或没有左子节点则返回特殊值\n- **找右子节点 `rchild()`**：找到节点的右子节点，若该节点不存在或没有右子节点则返回特殊值\n- **删除左子树 `delLeft()`**：删除节点的左子树\n- **删除右子树 `delRight()`**：删除节点的右子树\n- **遍历 `traverse()`**：访问树上的每个节点\n\n#### 二叉树的遍历\n\n##### 前序遍历\n\n- 如果树为空，则操作为空\n- 如果树不空，则访问根节点，然后前序遍历左子树，最后前序遍历右子树\n\n##### 中序遍历\n\n- 如果树为空，则操作为空\n- 如果树不空，则中序遍历左子树，然后访问根节点，最后中序遍历右子树\n\n##### 后序遍历\n\n- 如果树为空，则操作为空\n- 如果树不空，则后序遍历左子树，然后后序遍历右子树，最后访问根节点\n\n##### 层次遍历\n\n- 从上到下，从左到右访问树的每个节点\n\n##### 性质\n\n- 由前序遍历和中序遍历可以唯一确定一棵二叉树\n- 由中序遍历和后序遍历可以唯一确定一棵二叉树\n- 由前序遍历和后序遍历**不能**唯一确定一棵二叉树\n\n#### 二叉树抽象类\n\n```cpp\ntemplate <class T>\nclass binaryTree\n{\n  public:\n    virtual void clear() = 0;                     // 清空\n    virtual bool isEmpty() const = 0;             // 是否为空\n    virtual T root(T flag) const = 0;             // 找根节点\n    virtual T parent(T x , T flag) const = 0;     // 找父节点\n    virtual T lchild(T x , T flag) const = 0;     // 找左子节点\n    virtual T rchild(T x , T flag) const = 0;     // 找右子节点\n    virtual void delLeft(T x) = 0;                // 删除左子树\n    virtual void delRight(T x) = 0;               // 删除右子树\n    virtual void preOrder() const = 0;            // 前序遍历\n    virtual void midOrder() const = 0;            // 中序遍历\n    virtual void postOrder() const = 0;           // 后序遍历\n    virtual void levelOrder() const = 0;          // 层次遍历\n};\n```\n\n#### 二叉树的实现\n\n##### 二叉树的顺序实现\n\n- 使用数组来存储二叉树中的节点\n- 将二叉树补全为完全二叉树再进行存储\n- 会导致空间浪费\n\n![顺序二叉树](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504031058255.png)\n\n##### 二叉树的链接实现\n\n- 使用链表来存储二叉树中的节点\n  - 标准形式：`left`，`data`，`right`\n\n![标准形式](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504041445826.png)\n\n- 广义标准形式：`data`，`left`，`parent`，`right`\n\n![广义标准形式](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504041445472.png)\n\n#### 二叉树类\n\n##### 节点类\n\n```cpp\ntemplate <class T>\nstruct Node\n{\n  public:\n    Node *left *right;                                                                // 左右子树指针\n    T data;                                                                           // 节点数据\n    Node():left(nullptr),right(nullptr){}                                             // 默认构造函数\n    Node(T item , Node *L = nullptr,Node *R = nullptr):data(item),left(L),right(R){}  // 带参数的构造函数\n    ~Node(){}                                                                         // 析构函数\n};\n```\n\n##### 二叉树类\n\n```cpp\ntemplate <class T>\nclass binaryTree:public tree<T>\n{\n    friend void printTree(const binaryTree &t, t flag);\n  private:\n    struct Node\n    {\n      public:\n        Node *left *right;\n        T data;\n        Node():left(nullptr),right(nullptr){}\n        Node(T item , Node *L = nullptr,Node *R = nullptr):data(item),left(L),right(R){}\n        ~Node(){}\n    }\n    Node *root;\n  public:\n    binaryTree():root(nullptr){}                    // 构造函数,创建空树\n    binaryTree(T x):root(new Node(x)){}             // 构造函数,创建只有根节点的树\n    ~binaryTree(){}                                 // 析构函数\n    void clear();                                   // 清空\n    bool isEmpty() const;                           // 是否为空\n    T Root(T flag) const;                           // 找根节点\n    T lchild(const T &x , T flag) const;            // 找左子节点\n    T rchild(const T &x , T flag) const;            // 找右子节点\n    void delLeft(const T &x);                       // 删除左子树\n    void delRight(const T &x);                      // 删除右子树\n    void preOrder() const;                          // 前序遍历\n    void midOrder() const;                          // 中序遍历\n    void postOrder() const;                         // 后序遍历\n    void levelOrder() const;                        // 层次遍历\n    coid creatTree(T flag);                         // 创建树\n    T parent(const T &x , T flag) const             // 找父节点\n    {\n      return flag;\n    }\n  private:\n    Node *Find(const T &x, Node *t) const;            // 查找节点\n    void clear(Node *&x);                             // 清空\n    void preOrder(Node *t) const;                     // 前序遍历\n    void midOrder(Node *t) const;                     // 中序遍历\n    void postOrder(Node *t) const;                    // 后序遍历\n};\n```\n\n##### 构造函数\n\n将 `root` 初始化为 `nullptr`\n\n```cpp\ntemplate <class T>\nbinaryTree<T>::binaryTree()\n{\n  root = nullptr;\n}\n```\n\n##### `isEmpty`\n\n- 判断 `root` 是否为 `nullptr`\n\n```cpp\ntemplate <class T>\nbool binaryTree<T>::isEmpty() const\n{\n  return root == nullptr;\n}\n```\n\n##### `Root`\n\n返回 `Root` 指向的节点的数据，若为空树则返回特殊值\n\n```cpp\ntemplate <class T>\nT binaryTree<T>::Root(T flag)const\n{\n  if (root == nullptr)\n  {\n    return flag;\n  }\n  else\n  {\n    return root->data;\n  }\n}\n```\n\n##### 二叉树的遍历\n\n###### 前序遍历\n\n1. 访问根节点\n2. 前序遍历左子树\n3. 前序遍历右子树\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::preOrder(binaryTree<T>::Node *t) const\n{\n  if (t == nullptr)\n  {\n    return;\n  }\n  else\n  {\n    cout << t -> data << \" \";\n    preorder(t -> left);\n    preorder(t -> right);\n  }\n}\n```\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::preOrder() const\n{\n  cout << \"\\n前序遍历：\"\n  preOrder(root);\n}\n```\n\n###### 中序遍历\n\n1. 中序遍历左子树\n2. 访问根节点\n3. 中序遍历右子树\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::midOrder(binaryTree<T>::Node *t) const\n{\n  if (t == nullptr)\n  {\n    return;\n  }\n  else\n  {\n    midOrder(t -> left);\n    cout << t -> data << \" \";\n    midOrder(t -> right);\n  }\n}\n```\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::midOrder() const\n{\n  cout << \"\\n中序遍历：\"\n  midOrder(root);\n}\n```\n\n###### 后序遍历\n\n1. 后序遍历左子树\n2. 后序遍历右子树\n3. 访问根节点\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::postOrder(binaryTree<T>::Node *t) const\n{\n  if (t == nullptr)\n  {\n    return;\n  }\n  else\n  {\n    postOrder(t -> left);\n    postOrder(t -> right);\n    cout << t -> data << \" \";\n  }\n}\n```\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::postOrder() const\n{\n  cout << \"\\n后序遍历：\"\n  postOrder(root);\n}\n```\n\n##### `size`\n\n```cpp\ntemplate <class T>\nint binaryTree<t>::size(binarytree<t>::Node *t) const\n{\n  if (t = nullptr)\n  {\n    return 0;\n  }\n  else\n  {\n    return 1+sizze(t -> left)+size(t -> right);\n  }\n}\n```\n\n```cpp\ntemplate <class T>\nint binaryTree<T>::size() const\n{\n  return size(root);\n}\n```\n\n##### `height`\n\n```cpp\ntemplate <class T>\nint binaryTree<T>::size(binaryTree<T>::Node *t) const\n{\n  if (t == nullptr)\n  {\n    return 0;\n  }\n  else\n  {\n    int lt = height(t -> left);\n    int rt = height(t -> right);\n    return (lt > rt ? lt : rt) + 1;\n  }\n}\n```\n\n```cpp\ntemplate <class T>\nint binaryTree<T>::height() const\n{\n  return height(root);\n}\n```\n\n##### 层次遍历\n\n- 使用链接队列实现\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::levelOrder() const\n{\n  linkQueue<Node *> que;\n  Node *tmp;\n  cout << \"\\n层次遍历：\";\n  que.enQueue(root);\n  while (!que.isEmpty())\n  {\n    tmp = que.deQueue();\n    cout << tmp -> data << \" \";\n    if (tmp.left)\n    {\n      que.enQueue(tmp -> left);\n    }\n    if (tmp.right)\n    {\n      que.enQueue(tmp -> right);\n    }\n  }\n}\n```\n\n##### `clear`\n\n- 递归删除树中所有节点\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::clear(Node *&t)\n{\n  if (t == nullptr)\n  {\n    return;\n  }\n  else\n  {\n    clear(t -> left);\n    clear(t -> right);\n    delete t;\n    t = nullptr;\n  }\n}\n```\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::clear()\n{\n  clear(root);\n}\n```\n\n##### 析构函数\n\n- 调用 `clear` 函数删除树中所有节点\n\n```cpp\ntemplate <class T>\nbinaryTree<T>::~binaryTree()\n{\n  clear();\n}\n```\n\n##### `Find`\n\n- 使用前序遍历查找 `x` 节点\n- 首先检查根节点是否存放 `x` 的值，若是则返回根节点地址\n- 对左子树递归调用 `Find` 函数，若返回空指针则说明 `x` 不在左子树中\n- 对右子树递归调用 `Find` 函数，若返回空指针则说明 `x` 不在右子树中\n\n```cpp\ntemplate <class T>\nstruct binaryTree<T>:: Node *binaryTree<T>::Find(const T &x ,binaryTree<T>::Node *t) const\n{\n  if (t == nullptr)\n  {\n    return nullptr;\n  }\n  else if (t -> data == x)\n  {\n    return t;\n  }\n  else\n  {\n    if (tmp = Find(x,t->left))\n    {\n      return tmp;\n    }\n    else\n    {\n      return Find(x,t->right);\n    }\n  }\n}\n```\n\n##### `delLeft`\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::delLeft(const T &x)\n{\n  Node *tmp = Find(x,root);\n  if (tmp == nullptr)\n  {\n    return;\n  }\n  clear(tmp -> left);\n}\n```\n\n##### `delRight`\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::delRight(const T &x)\n{\n  Node *tmp = Find(x,root);\n  if (tmp == nullptr)\n  {\n    return;\n  }\n  clear(tmp -> right);\n}\n```\n\n##### `lchild`\n\n```cpp\ntemplate <class T>\nT binaryTree<T>::lchild(const T &x ,T flag) const\n{\n  Node *tmp = Find(x,root)\n  if (tmp == nullptr || tmp -> left ==nullptr)\n  {\n    return flag;\n  }\n  else\n  {\n    return tmp -> left;\n  }\n}\n```\n\n##### `rchild`\n\n```cpp\ntemplate <class T>\nT binaryTree<T>::rchild(const T &x ,T flag) const\n{\n  Node *tmp = Find(x,root)\n  if (tmp == nullptr || tmp -> right ==nullptr)\n  {\n    return flag;\n  }\n  else\n  {\n    return tmp -> right;\n  }\n}\n```\n\n##### `createTree`\n\n- 创建过程（类似层次遍历？）\n  1. 输入根节点的值，创建根节点\n  2. 对已添加到树上的每个节点，依次输入它的两个儿子的值，若没有儿子则输入 `flag`\n- 实现过程\n  - 使用队列，将新加入到书中的节点添加到队列中\n  - 依次出队，对每个出队的元素输入它的儿子\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::createTree(T flag)\n{\n  linkQueue<Node *> que;\n  Node *tmp;\n  T x , ldata , rdata;\n\n  // 创建树，flag表示空\n  cout << \"\\n输入根节点：\"\n  cin >> x;\n  root = new Node(x);\n  que.enQueue(root);\n  while (!que.isEmpty())\n  {\n    tmp = que,deQueue();\n    cout << \"\\n输入\" << tmp -> data << \"的两个儿子（\"<<flag<<\"表示空节点）：\";\n    cin >> ldata >> rdata;\n    if (ldata != flag)\n    {\n      tmp -> left = new Node(ldata);\n      que.enQueue(tmp -> left);\n    }\n    if (rdata != flag)\n    {\n      tmp -> right = new Node(rdata);\n      que.enQueue(tmp -> right);\n    }\n  }\n  cout << \"that's good!\\n\";\n}\n```\n\n##### `printTree`\n\n- 层次遍历输出每个节点和它的左右孩子\n\n```cpp\ntemplate <class T>\nvoid printTree(const binaryTree<T> &t,T flag)\n{\n  linkQueue<T> que;\n  que.enQueue(t.root());\n  while(!que.isEmpty())\n  {\n    T tmp = que.deQueue();\n    T l = tmp.lchild(tmp , flag);\n    T r = tmp.rchild(tmp , flag);\n    cout << p << \" \" << l << \" \" << r << endl;\n    if (l != flag)\n    {\n      que.enQueue(l);\n    }\n    if (r != flag)\n    {\n      que.enQueue(r);\n    }\n  }\n}\n```\n\n#### 二叉树遍历的非递归实现\n\n##### 前序遍历\n\n1. 将根节点入栈\n2. 栈顶元素出栈并输出值\n3. 将左右子树入栈（先右后左，以便输出时先输出左子树）\n4. 循环直至栈为空\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::preOrder(const binaryTree<T>::Node *t) const\n{\n  linkStack<Node *> s;\n  Node *tmp = t;\n\n  cout << \"\\n前序遍历：\";\n  while (!s.isEmpty())\n  {\n    tmp = s.pop();\n    cout << tm -> data << \" \";\n    if (tmp -> right != nullptr)\n    {\n      s.push(tmp -> right);\n    }\n    if (tmp -> left != nullptr)\n    {\n      s.push(tmp -> left);\n    }\n  }\n}\n```\n\n##### 中序遍历\n\n1. 根节点入栈\n2. 左子树入栈\n3. 栈顶元素出栈并输出值\n4. 左子树出栈完成之后根节点出栈\n5. 右子树入栈\n6. 循环直至栈为空\n\n栈的设计\n\n- 根节点入栈出栈两次\n  - 第一次出栈时不能被访问，立刻重新入栈，并将左子树入栈\n  - 第二次出栈后返回值，并且将右子树入栈\n- 对于根节点要记住\n  - 在哪棵树上\n  - 第几次出栈\n- 每个节点在某种意义上都是根节点\n\n###### `StNode` 类定义\n\n```cpp\nstruct StNode\n{\n  Node *node;\n  int TimesPop;\n  StNode(Node *N=nullptr):node(N),TimesPop(0){}\n};\n```\n\n###### 中序遍历的非递归实现\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::midOrder(const binaryTree<T>::Node *t) const\n{\n  linkStack<Node *t> s;\n  StNode current(root);\n\n  cout << \"\\n中序遍历：\";\n  s.push(current);\n  while(!s.isEmpty())\n  {\n    current = s.pop();\n    if (++current.TimesPop == 2)\n    {\n      cout << current.node -> data;\n      if (current.node -> right != nullptr)\n      {\n        s.push(StNode(current.node -> right));\n      }\n    }\n    else\n    {\n      s.push(current);\n      if (current.node -> left != nullptr)\n      {\n        s.push(StNode(current.node -> left));\n      }\n    }\n  }\n}\n```\n\n##### 后序遍历\n\n1. 根节点入栈\n2. 左子树入栈\n3. 右子树入栈\n4. 栈顶元素出栈并输出值\n5. 循环直至栈为空\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::postOrder(const binaryTree<T>::Node *t) const\n{\n  linkStack<Node *> s;\n  StNode current(root);\n\n  cout << \"\\n后序遍历：\";\n  s.push(current);\n  while(!s.isEmpty())\n  {\n    current = s.pop();\n    if (++current.TimesPop == 3)\n    {\n      cout << current.node -> data;\n      continue;\n    }\n    else\n    {\n      s.push(current);\n      if (current.node -> right != nullptr)\n      {\n        s.push(StNode(current.node -> right));\n      }\n      if (current.node -> left != nullptr)\n      {\n        s.push(StNode(current.node -> left));\n      }\n    }\n  }\n}\n```\n\n### 哈夫曼树和哈夫曼编码\n\n#### 字符的机内表示\n\n- 用二进制数来表示字符\n- 前缀编码\n  - 字符只放在叶结点中\n  - 字符编码可以有不同的长度\n  - 每个字符的编码都不可能是其他字符编码的前缀\n  - 可以被唯一解码\n\n#### 哈夫曼树\n\n- 最小代价，即带权路径长度最小的二叉树\n- 所有字符都在叶结点上\n- 权值大的字符离根节点近，权值小的字符离根节点远\n- 哈夫曼编码是一种前缀编码\n\n![huffmanTree](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141528425.png)\n\n#### 哈夫曼算法\n\n1. 给定一个具有 $n$ 个权值 $\\{w_1 , w_2 , \\ldots , w_4\\}$ 的节点的集合 $\\mathbb{A}$\n   $\\mathbb{F} = \\{T_1 , T_2 , \\ldots , T_n\\}$\n2. 初始时，设集合 $\\mathbb{A} = \\mathbb{F}$\n3. 执行从 $i$ 到 $n-1$ 的循环\n   1. 从当前集合中选取权值最小、次最小的两个节点，以这两个节点作为内部节点 $b_i$ 的左右儿子，$b_i$ 的权值为这两个节点的权值之和\n   2. 集合中去除这两个节点，将 $b_i$ 加入其中\n4. 循环结束后，集合 $\\mathbb{A}$中只剩下一个节点 $b_n$，即为哈夫曼树的根节点\n\n#### 哈夫曼编码\n\n- 每个节点的编码是从根节点到该节点的路径\n- 左子树为 `0`，右子树为 `1`\n\n#### 哈夫曼树类的实现\n\n1. 接受一组符号以及对应的权值,并返回每个符号对应的哈夫曼编码\n2. 有两个公有的成员函数\n   1. 构造函数：接受一组待编码的符号以及它们的权值，构造哈夫曼树\n   2. `getCode`：根据保存的哈夫曼树，返回每个符号对应的哈夫曼编码\n\n##### 哈夫曼树的存储\n\n- 在哈夫曼树中，每个要编码的元素都是一个叶节点，其余的节点都是度为 $2$ 的节点\n- 若待编码的元素个数为 $n$，则哈夫曼树的节点数为 $2n-1$\n- 哈夫曼树使用一个大小为 $2n$ 的数组来存储，不使用 $0$ 节点，将根节点存储在下标为 $1$ 的位置，叶节点依次存储在下标为 $n+1$ 到 $2n$ 的位置，$0$ 结点作为结束的判断依据\n- 每个数组保存 **节点的数据**，**节点的权值**，**节点的父节点下标**，**左子节点下标**，**右子节点下标**\n\n```cpp\ntemplate <class Type>\nclass hfTree\n{\n  private:\n    struct Node\n    {\n      Type data; //节点数据\n      int weight; //节点权值\n      int parent; //父节点下标\n      int left , right; //左右子节点下标\n    };\n\n    Node *elem;\n    int length;\n\n  public:\n    struct hfCode\n    {\n      Type data; //节点数据\n      string code; //哈夫曼编码\n    };\n\n    hfTree(const Type *v , const int *w , int size);\n    void getCode(hfCode result[]);\n    ~hfTree()\n    {\n      delete [] elem;\n    }\n};\n```\n\n##### 构造函数\n\n```cpp\ntemplate <class Type>\nhfTree<Type>::hfTree(const Type *v , const int *w , int size)\n{\n  const int MAX_INT = 32767;\n  int min1 , min2; // 最小树、次最小树的权值\n  int x , y ; // 最小树、次最小树的下标\n\n  /* 初始化 */\n  length = 2 * size ;                                            // 哈夫曼树的节点数为 $2\\text{size}-1$，但我们只需要存储 $2\\text{size}$ 个节点\n  elem = new Node[length];                                       // 创建一个大小为 $2\\text{size}$ 的数组来存储哈夫曼树的节点\n  for (int i = size ; i < length ; i++)                          // 对数组 `elem` 中的节点进行初始化，前 $\\text{size}$ 个节点存储待编码的元素，从下标 `size` 开始，依次存储待编码的元素的权值\n  {\n    elem[i].weight = w[i-size]; // 储存权值\n    elem[i].data = v[i-size]; // 储存待编码的元素\n    elem[i].parent = elem[i].left = elem[i].right = 0;           // 初始化父节点、左子节点和右子节点的下标为 `0`\n  }\n\n  /* 构造新的二叉树 */\n  for (int i = size - 1 ; i > 0 ; i--)                           // 从下标为 `size-1` 的节点开始，依次向上构造哈夫曼树的节点\n  {\n    min1 = min2 = MAX_INT;                                       // 初始化这两个变量为一个很大的值，以确保能够找到真正最小和次小的权值\n    x = y = 0;\n    for (int j = i + 1 ; j < length ; j++)                       // 遍历当前节点之后的所有节点\n    {\n      if (elem[j].parent == 0)                                   // 判断是否未加入树中\n      {\n        if (elem[j].weight < min1)                               // 找到真正的最小值和次小值以及他们对应的下标\n        {\n          min2 = min1;\n          min1 = elem[j].weight;\n          x = y;\n          y = j;\n        }\n        else if(elem[j].weight < min2)\n        {\n          min2 = elem[j].weight;\n          x = j;\n        }\n      }\n    }\n    elem[i].weight = min1 + min2;                                // 将最小值和次小值的权值相加，作为当前节点的权值\n    elem[i].left = x;                                            // 将最小值的节点作为当前节点的左子节点\n    elem[i].right = y;                                           // 将次小值的节点作为当前节点的右子节点\n    elem[x].parent = i;                                          // 将当前节点作为最小值节点的父节点\n    elem[y].parent = i;                                          // 将当前节点作为次小值节点的父节点\n  }\n}\n```\n\n##### `getCode`\n\n```cpp\ntemplate <class Type>\nvoid hdTree<Type>::getcode(hfCode result[])\n{\n  int size = length / 2 ;\n  int p , s ;\n  for (int i = size; i < length; ++i)\n  {\n    result[i -size].data = elem[i].data;\n    result[i -size].code = \"\";\n    p = elem[i].parent; s = i;\n    while (p)\n    {\n      if (elem[p].left == s)\n      {\n        result[i -size].code = '0' + result[i -size].code;\n      }\n      else\n      {\n        result[i -size].code = '1' + result[i -size].code;\n      }\n      s = p;\n      p = elem[p].parent;\n    }\n  }\n}\n```\n\n### 树和森林\n\n#### 树的存储实现\n\n- **标准形式**：除了数据字段之外，还有 $K$ 个指针字段，指向 $K$ 个孩子节点，其中 $K$ 是树的度\n- **广义标准形式**：除了数据字段之外，还有 $K$ 个指针字段，指向 $K$ 个孩子节点和一个指针字段，指向父节点\n\n![树的存储实现](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504211450009.png)\n\n#### 树的表示方法\n\n##### 孩子链表示法\n\n- 每个节点的所有孩子组织成一个链表\n- 节点由两个部分组成\n\n  - 储存数据元素值的数据部分\n  - 指向孩子链的指针\n\n- **静态**的孩子链表：树的所有节点存放在一个名叫表头数组的**数组**中\n- **动态**的孩子链表：树的所有节点组织成一个**链表**\n\n##### 孩子兄弟链表示法\n\n- 将一棵树转化为二叉树\n- 左子树指向第一颗子树树根的指针\n- 右子树指向兄弟节点的指针\n\n![孩子兄弟链](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504211559361.png)\n\n##### 双亲表示法\n\n- 每一个节点由两个部分组成\n  - 储存数据元素的数据字段\n  - 储存父节点的父指针字段\n- 便于查找节点的祖先，但是不便于查找指定节点的子孙\n\n### 树的遍历\n\n#### 前序遍历\n\n1. 访问根节点\n2. 依次前序遍历所有子树\n\n#### 后序遍历\n\n1. 依次后序遍历所有子树\n2. 访问根节点\n\n#### 层次遍历\n\n1. 访问根节点\n2. 若第 $i$ 层已被访问，且第 $i+1$ 层的结点尚未被访问，则从左到右依次访问第 $i+1$ 层的结点\n\n#### 特点\n\n- 树的前序遍历和用儿子兄弟链表示法转化的二叉树的前序遍历是相同的\n- 树的后序遍历和用儿子兄弟链表示法转化的二叉树的中序遍历是相同的\n\n由前序遍历和后序遍历可以唯一确定一棵树\n\n### 树、森林和二叉树\n\n#### 森林的定义\n\n- 森林通常被定义为树的集合或树的序列\n- 存储\n  - 存储森林的每一棵树\n  - 表示这些树属于同一个森林\n\n#### 森林的二叉树存储\n\n1. 将每棵树 $T_i$ 转化为二叉树 $B_i$\n2. 将 $B_i$ 作为 $B_{i-1}$ 根节点的右子树\n\n## 优先级队列\n\n### 优先级队列的定义\n\n- 节点之间的关系是由节点的优先级决定的\n- 优先级高的先出队，优先级低的后出队\n- 继承于队列的抽象类\n\n### 优先级队列的简单实现\n\n1. 入队时进行排序，出队操作不变\n   入队时间复杂度为 $O(n)$，出队时间复杂度为 $O(1)$\n2. 出队时进行排序，入队操作不变\n   入队时间复杂度为 $O(1)$，出队时间复杂度为 $O(n)$\n\n### 二叉堆\n\n- 二叉堆是一个完全二叉树\n- 二叉堆满足下述关系之一（下标是按层次遍历的次序）\n  1. **最大化堆**：$k_i > k_{2i},\\quad k_i > k{2i+1} \\quad (i = 1,2,\\ldots,\\lfloor \\frac{n}{2}\\rfloor$\n  2. **最小化堆**：$k_i < k_{2i},\\quad k_i < k{2i+1} \\quad (i = 1,2,\\ldots,\\lfloor \\frac{n}{2}\\rfloor)$\n- 后面的讨论都以最小化堆为例\n\n![binaryHeap](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504081709343.png)\n\n#### 二叉堆的特性\n\n- **结构性**\n  - 符合完全二叉树的结构\n- **有序性**\n  - 父节点小于子节点（最小化堆）\n  - 父节点大于子节点（最大化堆）\n\n### 基于二叉堆的优先级队列\n\n- 如果数值越小，优先级越高，则可以用一个最小化堆存储优先级队列\n- 最小化堆中，最小元素为根元素，存放在数组下标为 `1` 的位置\n  - 获取队头元素的操作为返回下标为 `1` 的元素值\n  - 出队操作为删除下标为 `1` 的元素，重新调整堆\n  - 入队操作为将新元素插入到堆的最后一个位置，然后向上调整堆\n\n### 优先级队列类的定义\n\n```cpp\ntemplate <class T>\nclass priorityQueue:public quque<T>\n{\n  private:\n    int currentSize;\n    T *array;\n    int maxSize;\n    void doubleSpace();\n    voif buildHeap();  // 建堆，被 priorityQueue() 调用\n    void percolateDown(int hole); // 向下过滤\n  public:\n    priorityQueue(int capacity = 100) // 构造函数\n    {\n      array = new T[capacity];\n      maxSize = capacity;\n      currentSize = 0;\n    }\n    priorityQueue(const T data[] , int size); // 构造函数\n    ~priorityQueue(); // 析构函数\n    bool isEmpty() const // 是否为空\n    {\n      return currentSize == 0;\n    }\n    void enQueue(const T &x); //入队\n    T deQueue(); // 出队\n    T getHead() const // 获取队头元素\n    {\n      return array[1];\n    }\n};\n```\n\n#### `enQueue`\n\n- 在堆中插入一个新元素\n- 在最大序号中的元素之后插入新的元素或者节点\n- 如果没有违反堆的**有序性**，则操作结束，否则向父节点移动，直到满足有序性或者到达根节点\n\n```cpp\ntemplate <class T>\nvoid priorityQueue<T>::enQueue(const T &x)\n{\n  if (currentSize == maxSize - 1)\n  {\n    doubleSpace();\n  }\n\n  // 向上过滤\n  int hole = ++currentSize;\n  for (;hole > 1 && x < array[hole/2] ; hole /= 2)\n  {\n    array[hole] = array[hole/2];\n  }\n  array[hole] = x;\n}\n```\n\n- 最坏情况时间复杂度为 $O(\\log n)$\n- 平均情况来说，过滤会提前结束。资料表明平均为 $2.6$ 次比较，即平均上移 $1.6$ 层\n\n#### `deQueue`\n\n- 删除堆顶元素，同时删除最后一个节点，以满足是完全二叉树\n- 空节点向下过滤，找到一个较小的子节点，将该儿子放入空节点，空节点向下推一层，直至删除的节点能够被放入空节点\n\n```cpp\ntemplate <class T>\nT priorityQueue<T>::deQueue()\n{\n  T minItem;\n  minItem = array[1];\n  array[1] = array[currentSize--];\n  percolateDown(1);\n  return minItem;\n}\n```\n\n#### `percolateDown`\n\n```cpp\ntemplate <class T>\nvoid priorityQueue<T>::precolateDown(int hole)\n{\n  int child;\n  T tmp = array[hole];\n\n  for (;hole * 2 <= currentSize; hole = child)\n  {\n    child = hole * 2;\n    if (child != currentSIze && array[child + 1] < array[child])\n    {\n      child++;\n    }\n    if (array[child] < tmp)\n    {\n      array[hole] = array[child];\n    }\n    else\n    {\n      break;\n    }\n  }\n  array[hole] = tmp;\n}\n```\n\n#### `buildHeap`\n\n##### 连续插入\n\n- 时间复杂度为 $O(n \\log n)$\n\n##### 自上而下调整二叉树\n\n- 对左子树和右子树递归调用 `buildHeaap`，再对根节点向下过滤\n- 时间复杂度为 $O(n)$\n\n##### 非递归实现\n\n从编号最大的非叶节点 $\\lfloor \\frac{n}{2} \\rfloor$ 开始逆层次遍历，每个节点调用 `percolateDown`，直到根节点\n\n## 集合与静态查找表\n\n### 集合的基本概念\n\n1. 数据元素除了属于同一集合之外，没有任何逻辑关系\n2. 每个数据元素有一个区别于其他元素的唯一标识，称为**键值**或者**关键字值**\n\n```cpp\ntemplate<calss KEY , class OTHER>\nstruct SET\n{\n  KEY key; // 关键字值\n  OTHER other; // 其他信息\n}\n```\n\n运算\n\n- **查找** 某一元素是否存在\n- 将集合中的元素按照它的唯一标识排序\n\n这些都是对 `key` 的操作\n\n### 集合的存储\n\n- 任何容器都能存储集合\n- 常用的表达形式是借鉴于**线性表**和**树**\n- 唯一一个仅适合于存储和处理集合的数据结构是**散列表**\n\n### 查找\n\n#### 查找的基本概念\n\n- 用于查找的集合称之为**查找表**\n- 查找表的分类\n  - 静态查找表\n  - 动态查找表\n  - 内部查找\n  - 外部查找\n\n#### 静态查找表\n\n- 数据元素的个数和值不允许变化的查找表称为静态查找表\n- 不允许插入和删除操作\n- 实例：字典\n- 可以用顺序表 `seqList` 存储，或直接存储在 C++的原始数组中\n\n#### 无序表的查找\n\n- 只能做顺序查找\n- 时间复杂度为 $O(n)$\n- 可以使用哨兵减少 $n$ 次查找\n\n- 优化后的顺序查找\n\n```cpp\ntemplate <class KEY, class OTHER>\nint seqSearch(SET<KEY, OTHER> data[] , int size , const KEY &x)\n{\n  data[0].key = x;\n  for (int i = size ; x != data[i].key; --i)\n  {\n    return i;\n  }\n}\n13\n```\n\n#### 有序表的查找\n\n##### 顺序查找\n\n- 与无序表的顺序查找类似，只是当被查元素在表中不存在时，不需要查到表头\n- 时间复杂度为 $O(n)$\n\n- 有序表的顺序查找\n\n```cpp\ntemplate <class KEY, class OTHER>\nint seqSearch(SET<KEY , OTHER> data[] , int size , const KEY &x)\n{\n  data[0].key = x;\n  for (int i = size ; x < data[i].key; --i);\n  if (x == data[i].key)\n  {\n    return i;\n  }\nelse\n{\n  return 0;\n}\n```\n\n##### 二分查找\n\n1. 每次检查中间的元素（向下取整）\n2. 若中间的元素等于要查找的元素，则查找成功\n3. 若中间的元素大于要查找的元素，则在左半部分继续查找\n4. 若中间的元素小于要查找的元素，则在右半部分继续查找\n\n- 时间复杂度为 $O(\\log n)$\n\n```cpp\ntemplate <class KEY, class OTHER>\nint binarySearch(SET<KEY , OTHER>data[] , int size , const KEY &x)\n{\n  int low = 1,  high = size, mid;\n    while (low <= high)\n    {                 //查找区间存在\n      mid = (low + high) / 2;         //计算中间位置\n      if ( x == data[mid].key )\n      {\n        return mid;\n      }\n      if (x < data[mid].key)\n      {\n        high = mid - 1;\n      }\n      else low = mid + 1;\n    }\n  return 0;\n}\n```\n\n##### 插值查找\n\n- 适用于数据分布较为均匀的情况\n- 计算中间位置的公式为\n\n$$\n\\text{next} = \\text{low} + \\frac{(x - a[\\text{low}])}{(a[\\text{high}] - a[\\text{low}])} \\times (\\text{high} - \\text{low}+1)\n$$\n\n- 缺点：计算量大\n\n##### 分块查找\n\n- 将数据分成若干个块，每个块内可以是有序和无序的，但块之间是有序的\n- 查找分为两个阶段\n  1. 查找索引\n  2. 查找块\n     设表长为 $n$，块长为 $m$\n     则平均所需的时间为 $\\frac{m+1}{2}+\\frac{\\frac{n}{m}+1}{2}$\n     当 $m=\\sqrt{n}$ 时，平均所需的时间**最短**，为 $O(\\sqrt{n})$\n\n## 动态查找表\n\n### 二叉查找树\n\n#### 抽象类\n\n```cpp\ntemplate <class KEY, class OTHER>\nclass dynamicSearchTable\n{\n  public:\n    virtual SET<KEY, OTHER> *find(const KEY &x) const = 0;\n    virtual void insert(const SET<KEY, OTHER> &x) = 0;\n    virtual void remove(const KEY &x) = 0;\n    virtual ~dynamicSearchTable() {};\n};\n```\n\n#### 二叉查找树的定义\n\n- 对于任意一个节点 `p`\n  - `p` 的左子树中所有节点的值都小于 `p` 的值\n  - `p` 的右子树中所有节点的值都大于 `p` 的值\n  - `p` 的左子树和右子树都是二叉查找树\n- 二叉查找树的**中序遍历**是排好序的，又称为**排序树**\n- 最大和最小的元素不一定存放在叶节点中，但是最大节点的右子树、最小节点的左子树都是空的\n\n#### 二叉查找树的存储实现\n\n- 使用二叉链表存储，需要一个指向根节点的数据成员\n\n```cpp\ntemplate <class KEY, class OTHER>\nclass BinarySearchTree:public dynamicSearchTable<KEY , OTHER>\n{\n  private:\n    struct BinaryNode\n    {\n      SET<KEY, OTHER> data;\n      BinaryNode*left;\n      BinaryNode*right;\n      BinaryNode( const SET<KEY, OTHER> & thedata,\n      BinaryNode *lt = nullptr , BinaryNode *rt = nullptr):data(thedata) , left(lt) , right(rt){}\n    };\n    BinaryNode*root;\n\n  public:\n    BinarySearchTree();\n    ~BinarySearchTree();\n    SET<KEY, OTHER> *find(const KEY &x) const ;\n    void insert(const SET<KEY , OTHER> &x );\n    void remove(const KEY &x);\n\n  private:\n    void insert(const SET<KEY , OTHER> &x, BinaryNode *&t);\n    void remove(const KEY &x , BinaryNode *&t);\n    SET<KEY , OTHER> *find(const KEY &x , BinaryNode *t ) const;\n    void makeEmpty(BinaryNode *t);//析构用，同二叉树的clear\n};\n```\n\n#### 二叉查找树的操作\n\n##### 查找\n\n1. 检查根节点的关键字值\n2. 如果等于要查找的值，则查找成功，返回根节点地址\n3. 如果小于要查找的值，则在右子树中查找\n4. 如果大于要查找的值，则在左子树中查找\n\n- 公有函数 `find(const KEY &x)`\n\n```cpp\ntemplate <class KEY, class OTHER>\nSET<KEY, OTHER> *BinarySearchTree<KEY, OTHER>::find(const KEY &x ) const\n{\n  return find( x, root );\n}\n```\n\n- 私有辅助函数 `find(const KEY &x, BinaryNode *t)`\n\n```cpp\ntemplate <class KEY, class OTHER>\nSET<KEY, OTHER> *BinarySearchTree<KEY, OTHER>::find(const KEY &x, BinaryNode *t ) const\n{\n  if (t == nullptr || t->data.key == x)\n  {\n    return (SET<KEY , OTHER> *)t;//强制类型转换\n  }\n  if(x < t->data.key)\n  {\n    return find(x , t->left);\n  }\n  else\n  {\n    return find(x , t->right );\n  }\n}\n```\n\n##### 插入\n\n- 若二叉树为空树，则插入的节点为根节点\n- 若二叉树非空\n\n  - 判断是左儿子还是右儿子，作为叶节点插入\n\n- 公有的 `insert(const SET<KEY, OTHER> &x)`\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid BinarySearchTree<KEY, OTHER>::insert(const SET<KEY , OTHER> &x)\n{\n  insert(x, root);\n}\n```\n\n- 私有的 `insert(const SET<KEY, OTHER> &x, BinaryNode *&t)`\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid BinarySearchTree<KEY , OTHER>::insert(const SET<KEY , OTHER> &x, BinaryNode *&t)\n{\n  if(t == nullptr)\n  t = new BinaryNode(x , nullptr , nullptr);\n  else if(x.key< t->data.key)\n  {\n    insert(x, t->left);\n  }\n  else if(x.key > t->data.key)\n  {\n    insert(x , t->right);\n  }\n  else\n  {\n    cout << x.key << “is exist” << endl;\n  }\n}\n```\n\n##### 删除\n\n- $P_L$ 和 $P_R$ 分别是 $P$ 的左子树和右子树\n\n  1.  如果 $P$ 是叶节点，则直接删除\n  2.  如果 $P$ 只有一个子树，则将 $P$ 的父节点指向 $P$ 的子树\n  3.  如果 $P$ 有两个子树，则\n      1. 找到 $P$ 的右子树中最左的节点或者左子树的最右节点 $Q$\n      2. 将 $Q$ 的值赋给 $P$\n      3. 删除 $Q$ 节点\n\n- 公有的 `remove(const KEY &x)`\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid BinarySearchTree<KEY, OTHER>::remove(const KEY &x)\n{\n  remove(x , root);\n}\n```\n\n- 私有的 `remove(const KEY &x, BinaryNode *&t)`\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid BinarySearchTree<KEY , OTHER>::remove(const KEY &x , BinaryNode *&t)\n{\n  if(t == nullptr)\n  {\n    cout << x.key << \"is not exist\" << endl;\n  }\n  else if(x.key < t->data.key)\n  {\n    remove(x , t->left);\n  }\n  else if(x.key > t->data.key)\n  {\n    remove(x , t->right);\n  }\n  else if(t->left != nullptr && t->right != nullptr)\n  {\n    BinaryNode *p = t->right;\n    while(p->left != nullptr)\n    {\n      p = p->left;\n    }\n    t->data = p->data;\n    remove(p->data.key , t->right);\n  }\n  else\n  {\n    BinaryNode *oldNode = t;\n    t = (t->left != nullptr) ? t->left : t->right;\n    delete oldNode;\n  }\n}\n```\n\n#### 二叉查找树的性能\n\n- 二叉查找树的操作的时间复杂度为树的高度\n- 如果二叉查找树是平衡的，则访问的代价是 $O(\\log n)$\n- 最坏的情况下，二叉查找树会退化成一个单链表，时间复杂度为 $O(n)$\n\n**平均性能**\n\n具有 $n$ 个节点的二叉查找树可能有 $n$ 种不同的形态\n$(0,1,n-1) , (1 , 1 n-2) , (2 , 1 , n-3) , \\ldots , (n-1 , 1 , 0)$\n若设这些形态出现的概率是相同的，设 $P(n)$ 为查找 $n$ 个节点的二叉查找树的平均查找时间，则有如下递归关系式：\n\n$$\nP(n) = \\frac{\\sum_{i = 0}^{n-1} \\left[ 1 + (P(i)+1) \\cdot i + (P( n - i - 1)+1)\\cdot (n-i-1)\\right]}{n} \\leq 2(1 + \\frac{1}{n})\\ln{n} \\approx 1.33 \\log{n}\n$$\n\n### AVL 树\n\n#### AVL 树的定义\n\n- 也叫平衡树\n  - 对于任意一个节点的两棵子树的高度至多相差 1\n- 平衡因子\n  - 节点的左子树的高度减去右子树的高度\n  - 平衡因子只能是 $-1$，$0$，$1$\n- 优点\n  - 查找，插入和删除操作的时间复杂度都是 $O(\\log n)$\n\n##### 查找性能\n\n- 与二叉树的高度成正比\n\n- 定理：\n  - 具有 $n$ 个节点的平衡树，高度 $h$ 满足 $\\log_2(n+1) \\leq h \\leq 1.44\\log_2(n+2)-0.328$\n  - 因此，平衡二叉树的操作都是 $O(\\log n)$\n\n##### 斐波那契树\n\n- 斐波那契树是平衡树的最坏情况，其每一子树的左右子树高度差都为 1\n\n- 定义\n  1. 空树是高度为 0 的斐波那契树\n  2. 单个节点是高度为 1 的斐波那契树\n  3. 若 $T_{h-1}$ 和 $T_{h-2}$ 分别为高度为 $h-1$ 和 $h-2$ 的斐波那契树，则 $T_h ={T_{h-1},x,T_{h-2}}$ 是高度为 $h$ 的斐波那契树\n  4. 没有其他的树是斐波那契树\n\n###### 斐波那契树的特点\n\n对于高度为 $h$ 的斐波那契树，节点数 $n$ 满足\n\n- $n_0 = 0$\n- $n_1 = 1$\n- $n_h = n_{h-1} + n_{h-2} + 1$\n\n#### AVL 树的存储实现\n\n- 使用二叉链表\n- 每个节点必须保存平衡信息\n  - 每棵树的高度\n  - 平衡度即左右子树的高度差\n\n##### AVL 树类的实现\n\n```cpp\ntemplate <clas KEY,class OTHER>\nclass AvlTree:public dynamicSearchTable<KEY , OTHER>\n{\n    struct AvlNode\n    {\n      SET<KEY , OTHER> data ; // 关键字\n      AvlNode *left , *right; // 左右子树指针\n      int height;            // 节点高度\n\n      AvlNode(const SET<KEY , OTHER> &element , AvlNode *lt ,AvlNode   *rt , int h = 1):data(elemeent) , left(lt) , right(rt) , height  (h) {} // 构造函数\n    };\n\n    AvlNode *root; // 根节点\n  public:\n    AvlTree() // 构造函数\n    {\n      root = nullptr;\n    }\n    ~AvlTree() // 析构函数\n    {\n      makeEmpty(root);\n    }\n    SET<KEY, OTHER> *find(const KEY &x) const;\n    void remove(const KEY & x);\n  private:\n    void insert( const SET<KEY, OTHER> & x, AvlNode * & t ) ; // 插入\n    bool remove( const KEY & x, AvlNode * & t ) ;\n    void makeEmpty( AvlNode *t );\n    int height(AvlNode *t) const  // 返回节点的高度\n    {\n      return t == nullptr ? 0 : t -> height;\n    }\n    void LL( AvlNode * & t ); // 左旋\n    void RR( AvlNode * & t ); // 右旋\n    void LR( AvlNode * & t ); // 左右旋\n    void RL( AvlNode * & t ); // 右左旋\n    int max(int a, int b)     // 返回两个数中较大的一个\n    {\n      return a > b ? a : b;\n    }\n    bool adjust(AvlNode *&t, int subTree); //用于删除\n};\n```\n\n#### AVL 树的查找\n\n- 与二叉查找树相同\n- 二叉查找树类采用递归实现\n- AVL 树类展示非递归实现\n\n##### 查找的非递归实现\n\n1. 设当前节点为根节点\n2. 若当前节点非空\n   1. 若当前节点的值等于 `x`，则返回当前节点\n   2. 若当前节点的值大于 `x`，则将当前节点指向左子树\n   3. 若当前节点的值小于 `x`，则将当前节点指向右子树\n3. 若当前节点为空，则返回空\n\n```cpp\ntemplate <class KEY,class OTHER>\nSET<KEY, OTHER> *AvlTree<KEY, OTHER>::find(const KEY & x) const\n{\n  AvlNode *t = root; \n  while (t!=nullptr && t->data.key != x)\n  {\n    if (x < t->data.key)\n    {\n      t = t->left;\n    }\n    else\n    {\n      t = t->right;\n    }\n  }\n  if (t == nullptr)\n  {\n    return nullptr;\n  }\n  else\n  {\n    return t->data;\n  }\n}\n```\n\n#### AVL 树的插入\n\n- 与二叉查找树相同\n  - 可能改变了根到插入节点的路径上某些节点的平衡度\n  - 需要向上修改树的结构\n\n##### 可能引起节点不平衡的情况\n\n- 节点的左孩子的左子树上插入（LL）\n- 节点的左孩子的右子树上插入（LR）\n- 节点的右孩子的左子树上插入（RL）\n- 节点的右孩子的右子树上插入（RR）\n\n##### 重构的方法\n\n- 指针调整\n  - 按照投影序保持结点相邻关系不变\n  - 辈分可以改变\n\n###### LL 问题\n\n![LL](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141158768.png)\n\n- **左旋**\n  1. 将失衡点的左儿子作为新的根节点\n  2. 左儿子的右儿子作为原根节点的左儿子\n- 若为 RR 问题，则将失衡点的右儿子作为新的根节点，右儿子的左儿子作为原根节点的右儿子，称为**右旋**\n- 左旋和右旋统称为**单旋转**，保留了树的有序性和原先的高度\n\n###### LR 问题\n\n![LR](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141206204.png)\n\n- **双旋转**\n  1. 将失衡点的左儿子右旋\n  2. 将失衡点左旋\n- 若为 RL 问题，则将失衡点的右儿子左旋，再将失衡点右旋\n- 先对失衡结点的儿子和孙子进行一次单旋转，使孙子变成儿子。然后是失衡结点和新的儿子进行一次单旋转，使**原先的孙子变成根**\n\n##### 私有的`insert` 函数\n\n```cpp\ntemplate <class KEY,class OTHER>\nvoid AvlTree<KEY, OTHER>::insert(const SET<KEY, OTHER> & x, AvlNode * & t)\n{\n  if (t == nullptr)\n  {\n    t = new AvlNode(x , nullptr , nullptr);\n  }\n  else if (x.key < t->data.key)\n  {\n    insert(x , t->left);\n    if (height(t->left) - height(t->right) == 2)\n    {\n      if (x.key < t->left->data.key)\n      {\n        LL(t);\n      }\n      else\n      {\n        LR(t);\n      }\n    }\n  }\n  else if (x.key > t->data.key)\n  {\n    insert(x , t->right);\n    if (height(t->right) - height(t->left) == 2)\n    {\n      if (x.key > t->right->data.key)\n      {\n        RR(t);\n      }\n      else\n      {\n        RL(t);\n      }\n    }\n  }\n  t->height = max(height(t->left) , height(t->right)) + 1; // 更新高度\n}\n```\n\n###### `LL`\n\n```cpp\ntemplate <class KEY,class OTHER>\nvoid AvlTree<KEY,OTHER>::LL(AvlNode *& t)\n{\n  AvlNode *t1 = t->left;\n  t->left = t1->right;\n  t1->right = t;\n  t->height = max(height(t->left) , height(t->right)) + 1;\n  t1->height = max(height(t1->left) , height(t1->right)) + 1;\n  t = t1;\n}\n```\n\n###### `RR`\n\n```cpp\ntemplate <class KEY,class OTHER>\nvoid AvlTree<KEY,OTHER>::RR(AvlNode *& t)\n{\n  AvlNode *t1 = t->right;\n  t->right = t1->left;\n  t1->left = t;\n  t->height = max(height(t->left) , height(t->right)) + 1;\n  t1->height = max(height(t1->left) , height(t1->right)) + 1;\n  t = t1;\n}\n```\n\n###### `LR`\n\n```cpp\ntemplate <class KEY,class OTHER>\nvoid AvlTree<KEY,OTHER>::LR(AvlNode *& t)\n{\n  RR(t->left);\n  LL(t);\n}\n```\n\n###### `RL`\n\n```cpp\ntemplate <class KEY,class OTHER>\nvoid AvlTree<KEY,OTHER>::RL(AvlNode *& t)\n{\n  LL(t->right);\n  RR(t);\n}\n```\n\n所有旋转的算法时间复杂度都是 $O(1)$，且只运行一次，所以 `insert` 的时间复杂度为 $O(\\log n)$\n\n#### AVL 树的删除\n\n1. 在 AVL 树上删除节点 `x`，删除操作和二叉查找树相同\n2. 调整平衡，与插入操作相同\n\n#### 调整\n\n- 与插入操作相同，失衡节点存在于被删的节点到根节点的路径上。删除一个节点之后，必须沿着到根节点的路径向上回溯，随时调整路径上的节点的平衡度\n- 删除时无法保证子树在平衡调整之后的高度不变\n- 递归的删除函数有一个 bool 型的返回值，当返回值为 `true` 时，调整停止\n\n#### 五种情况\n\n##### 情况 a\n\n![Sitiationa](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191603536.png)\n\n此时没有失衡，高度也没有改变，返回`true`\n\n##### 情况 b\n\n![Situationb](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191604348.png)\n\n此时没有失衡，但是高度变矮，返回`false`\n\n##### 情况 c\n\n![Situationc](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191607359.png)\n\n经过 RR 旋转后高度变矮，返回`false`\n\n##### 情况 d\n\n![Situationd](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191609189.png)\n\n经过 RL 旋转后高度变矮，返回`false`\n\n##### 情况 e\n\n![Situatione](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191613240.png)\n\n经过 RR 或 RL 旋转后高度不变，返回`true`\n\n#### 删除总结\n\n- 节点删除同二叉查找树。在删除了叶节点或者只有一个孩子的节点后，子树变矮，返回 `false`\n- 在每次调用后，检查返回值，如果是 `true`，则返回 `true`，否则分 5 种情况进行处理\n\n#### 私有的 `remove` 函数\n\n```cpp\ntemplate<class KEY,class OTHER>\nvoid AvlTree<KEY , OTHER>::remove(const KEY &x , AvlNOde *&x)\n{\n  if (t = nullptr) // 被删除节点不存在\n  {\n    return true;\n  }\n  if (x == t-> data.key)\n  {\n    if (t->left == nullptr || t-> right == nullptr)\n    {\n      AvlNode *oldNode = t;\n      t = (t->left == nullptr) ? t->right : t->left; // 删除节点的孩子节点\n      delete oldNode;\n      return false; // 删除了一个节点，返回 `false`\n    }\n    else\n    {\n      AvlNode *tmp = t-> right;\n      while (tmp->left != nullptr) // 找到右子树的最小节点\n      {\n        tmp = tmp->left;\n      }\n      t->data = tmp.data;\n      if (remove(tmp->data,key , t->right))\n      {\n        return adjust(t,1);\n      }\n    }\n  }\n  if (x < t->data,key)\n  {\n    if (remove(x,t->left))\n    {\n      teturn true;\n    }\n    return adjust(t,0);\n  }\n  else\n  {\n    if (remove(x , t->right))\n    {\n      return true;\n    }\n    return adjust(t,1);\n  }\n}\n```\n\n#### `adjust`\n\n- 进入调整函数的条件是某棵子树变矮了\n- 调整函数需要检查节点是否失衡，若失衡则进行相应的调整\n- 函数的返回值是子树是否变矮\n  - `true`：子树没有变矮\n  - `false`：子树变矮\n- 需要传入两个参数\n  - `AVlNode *&t`：传入的节点\n  - `int subTree`：参数 `t` 变矮的子树\n    - `0`：左子树\n    - `1`：右子树\n\n```cpp\ntemplate<class KEY , classs OTHER>\nbool AvlTree<KEY , OTHER>::adjust(AvlNode *&t , int SubTree)\n{\n  if (subTree) // 在右子树上删除\n  {\n    if (height(t->left) - height(t->right) == 1) // Situation a\n    {\n      return true;\n    }\n    if (height(t->right) == height(t->left)) // Situation b\n    {\n      return false;\n    }\n    if (height(t->left->right) > height(t->left->left)) // Situation d\n    {\n      LR(t);\n      return false;\n    }\n    LL(t); // Situation c and e\n    if (height(t->left) == height(t->right))s\n    {\n      return false;\n    }\n    else\n    {\n      return true;\n    }\n  }\n  else // 在左子树上删除\n  {\n    if (height(t->right) - height(t->left) == 1) // Situation a\n    {\n      return true;\n    }\n    if (height(t->right) == height(t->left)) // Situation b\n    {\n      return false;\n    }s\n    if (height(t->right->left) > height(t->right->right)) // Situation d\n    {\n      RL(t);\n      return false;\n    }\n    RR(t); // Situation c and e\n    if (height(t->right) == height(t->left))\n    {\n      return false;\n    }\n    else\n    {\n      return true;\n    }\n  }\n}\n```\n\n### 散列表\n\n- 也叫哈希表\n- 通过所求节点的关键字词 `KEY` 找到这个节点\n- 时间复杂度为 $O(1)$\n\n#### 基本概念\n\n1. 初始化\n   将数组转化为一个特殊的、表示单元为空的值\n2. `insert(i)`\n   将 `i` 存放到 `a[i.key]` 中\n3. `find(i)`\n   取出 `a[i.key]` 中的值\n4. `remove(i)`\n   将 `a[i.key]` 中的值置为空\n\n#### 散列函数\n\n将一个项映射成一个较小的下标的函数称为散列函数（hush function）\n\n- $D = H(key)$\n  D 为存储地址，key 为关键值，H 为散列函数\n- 散列函数的要求\n  - 计算速度快\n  - 散列地址均匀分布\n\n#### 常用的散列函数\n\n##### 直接地址法\n\n$H(key) = key$ 或 $H(key) = a \\times key + b$\n\n##### **除留余数法**\n\n$H(key) = key \\mod p$ 或 $H(key) = key \\mod p + c$ 这里的 $p$ 是一个小于等于 $m$ 的素数\n\n##### 数字分析法\n\n对关键字集合中的所有关键字，分析每一位上数字分布。取数字分布均匀的位作为地址的组成部分\n\n##### 平方取中法\n\n如果关键字中各位的分布都比较均匀，但关键字的值域比数组规模大，则可以将关键字**平方后**，取其结果的中间各位作为散列函数值。由于中间各位和每一位数字都有关系，因此均匀分布的可能性较大。\n\n##### 折叠法\n\n- 如果关键字相当长，以至于和散列表的单元总数相比大得多时，可采用此法\n- 选取一个长度后，将关键字按此长度分组相加\n\n#### 冲突问题\n\n当两个以上的关键字映射到一个存储单元时，称为**冲突或碰撞**\n\n- 解决冲突的方法\n  - 闭散列表：利用本散列表中的空余单元\n    - 线性探测法\n    - 二次探测法\n    - 再次散列法\n  - 开散列表：将碰撞的节点存放在散列表外的各自的线性表中（链接法）\n\n##### 闭散列表类的实现\n\n- 支持三种操作\n  - `insert`：插入一个元素\n  - `remove`：删除一个元素\n  - `find`：查找一个元素\n- 由一个数组实现，数组的大小由用户定义散列表时指定\n- 由于删除时的迟删除，每个数组元素还要保存一个状态值\n  - `0`：空\n  - `1`：有效\n  - `2`：删除\n\n```cpp\ntemplate <class KEY, class OTHER>\nclass closeHashTable:public dynamicSearchTable<KEY, OTHER>\n{\n  private:\n    struct node  //散列表的结点类\n    {\n      SET <KEY, OTHER> data;\n      int state; //0 -- empty 1 -- active 2 -- deleted\n      node()\n      {\n        state = 0;\n      }\n    };\n    node *array;\n\n    int size;\n    int (*key)(const KEY &x);//哈希函数\n    static int defaultKey(const int &x)\n    {\n      return x;\n    }\n  public:\n    closeHashTable(int length = 101, int (*f)(const KEY &x) = defaultKey)\n    ~closeHashTable()\n    {\n      delete [] array;\n    }\n    SET<KEY, OTHER> *find(const KEY &x) const;\n    void insert(const SET<KEY, OTHER> &x);\n    void remove(const KEY &x);\n};\n```\n\n- 构造函数\n\n```cpp\ntemplate <class KEY, class OTHER>\ncloseHashTable<KEY, OTHER>::closeHashTable(int length, int (*f)(const KEY &x))\n{\n  size = length;\n  array = new node[size];\n  key = f; //哈希函数为f\n}\n```\n\n- `insert`\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid closeHashTable<KEY, OTHER>::insert(const SET<KEY, OTHER> &x)\n{\n  int initPos, pos ;\n  initPos= pos = key(x.key) % size; //%size保护作用，避免越界\n  do\n  {\n    if (array[pos].state != 1)\n    { // 0或2，找到空单元\n      array[pos].data = x;\n      array[pos].state = 1;\n      return;\n    }\n    pos = (pos+1) % size;\n  } while (pos != initPos);\n}\n```\n\n- `remove`\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid closeHashTable<KEY, OTHER>::remove(const KEY &x)\n{\n  int initPos, pos ;\n  initPos= pos = key(x) % size;\n  do\n  {\n    if (array[pos].state == 0) return; //没找到\n    if (array[pos].state == 1 && array[pos].data.key== x)// 找到，删除\n    {\n      array[pos].state = 2;\n      return;\n    }\n    pos = (pos+1) % size; //没找到，需要往后找\n  } while (pos != initPos);\n}\n```\n\n- `find`\n\n```cpp\ntemplate <class KEY, class OTHER>\nSET<KEY, OTHER> *closeHashTable<KEY, OTHER>::find(const KEY &x) const\n{\n  int initPos, pos ;\n  initPos = pos = key(x) % size;\n  do\n  {\n    if (array[pos].state == 0) // 没有找到\n    {\n      return nullptr;\n    }\n    if (array[pos].state == 1 && array[pos].data.key == x) // 找到\n    {\n      return (SET<KEY,OTHER> *)&array[pos];\n    }\n    pos = (pos+1) % size;\n  } while (pos != initPos);\n}\n```\n\n###### 线性探测法\n\n当散列发生冲突时，依次**探测下一个单元**，直到发现一个空单元\n\n![线性探测法](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504210826498.png)\n\n###### 二次探测法\n\n以此向后探测 $1^2$，$2^2$，$3^2$，$4^2$，$5^2$，$\\ldots$\n\n**定理**\n\n- 如果采用二次探测法，并且表的大小是一个素数，那么，如果表至少有一半是空的（负载因子 $<0.5$），新的元素总能被插入。并且在插入过程中，没有一个单元被探测两次\n\n###### 再次散列法\n\n- 采用一个新的散列函数 $H_2(key)$\n- $H_1(x)$，$H_1(x)+H_2(x)$ ，$H_1(x)+2H_2(x)$，$H_1(x)+3H_2(x)$，$\\ldots$\n\n##### 开散列表\n\n链地址法\n\n- 将具有同一散列地址的结点保存于 `M` 存区的各自的链表之中\n\n###### 开散列表的实现\n\n- 将所有散列到同一地址的元素链接成一个单链表\n- 采用不带头结点的单链表\n- 散列表保存在一个数组中，每个元素是一个指向对应单链表的首地址的指针\n\n```cpp\ntemplate <class KEY , class OTHER>\nclass openHashTable:public dynamicSearchTable<KEU , OTHER>\n{\n  private:\n    struct node\n    {\n      SET<KEY , OTHER> data;\n      node *next;\n      node (const SET<KEY , OTHER> &d , nde *n = nullptr)\n      {\n        data = d;\n        next = n;\n      }\n      node()\n      {\n        next = nullptr;\n      }\n    };\n    node **array; // 散列表，指针数组\n     int size;\n     static int defaultKry(const int &x)\n     {\n        return x;\n     }\n  public:\n    openHashTable(int length = 101,int (*f)(const KEY &x) = defaultKey);\n    ~openashTable();\n    SET<KEY,OTHER> *finf(const KEY &x) const;\n    void insert(const SET<KEY,OTHER> &x);\n    void remove(const KEY &x);\n};\n```\n\n- 构造函数\n\n```cpp\ntemplate <class KEY, class OTHER>\nopenHashTable<KEY, OTHER>::~openHashTable()\n{\n  node *p, *q;\n  for (int i = 0; i< size; ++i)\n  {\n    p = array[i];\n    while (p!=nullptr)\n    {\n      q= p->next; delete p; p = q;\n    }\n  }\n  delete [] array；\n}\n```\n\n- `insert`\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid openHashTable<KEY, OTHER>::insert(const SET<KEY, OTHER> &x)\n{\n  int pos;\n  node *p;\n  //插入单链表的头部\n  pos = key(x.key) % size;\n  array[pos] = new node(x, array[pos]);\n}\n```\n\n- `remove`\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid openHashTable<KEY, OTHER>::remove(const KEY &x)\n{\n  int pos ;\n  node *p, *q;\n  pos = key(x) % size;\n  if (array[pos] == nullptr)\n  {\n    return;\n  }\n  p = array[pos];\n  if (array[pos]->data.key== x)\n  { // 删除第一个结点\n    array[pos] = p->next;\n    delete p;\n    return;\n  }\n  while (p->next != nullptr && !(p->next->data.key== x))\n  {\n    p = p->next;\n  }\n  if (p->next != nullptr)\n  {\n    q = p->next;\n    p->next = q->next;\n    delete q;\n  }\n}\n```\n\n- `find`\n\n```cpp\ntemplate <class KEY, class OTHER>\nSET<KEY, OTHER> *openHashTable<KEY, OTHER>::find(const KEY &x) const\n{\n  int pos ;\n  node *p;\n  pos = key(x) % size;\n  p = array[pos];\n  while (p != nullptr && !(p->data.key == x))\n  {\n    p = p->next;\n  }\n  if (p == nullptr)\n  {\n    return nullptr;\n  }\n  else\n  {\n    return (SET<KEY, OTHER> *)p;\n  }\n}\n```\n\n## 排序\n\n### 基本概念\n\n- 按照关键字的非递减或非递增序排成一个序列\n- **稳定与非稳定排序**:关键字值相同的数据元素在排序前后的相对次序保持不变，则称为稳定排序，否则称为不稳定排序\n- 内排序与外排序\n  - **内排序：**排序的数据元素全部存放在计算机的内存之中，并且在内存中调整数据元素的相对位置\n  - **外排序：**在排序的过程中，数据元素主要存放在外存储器中，借助于内存储器逐步调整数据元素之间的相对位置\n\n### 插入排序\n\n首先将由第一个数据元素组成的序列看成是有序的，然后将剩余的 n-1 个元素依次插入到前面的已排好序的子序列中去，使得每次插入后的子序列也是有序的\n\n#### 直接插入排序\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid simpleInsertSort(SET<KEY, OTHER>a[], int size)\n{\n  int k;\n  SET<KEY, OTHER> tmp;\n  for (int j=1; j<size; ++j)\n  {\n  tmp = a[j];\n  for ( k = j-1; tmp.key < a[k].key && k >= 0; --k)\n  {\n    a[k+1] = a[k];\n  }\n  a[k+1] = tmp;\n  }\n}\n```\n\n- 空间复杂度：$O(1)$\n- 稳定性：稳定\n- 时间复杂度\n  - 最好：$O(n)$\n  - 最坏：$O(n^2)$\n  - 平均：$O(n^2)$\n- 适用情况：短序列或者几乎已经排好序的\n\n#### 折半插入排序\n\n先用二分排序找到插入位置\n\n- 时间复杂度\n  - 最好：$O(n\\log n)$\n  - 最坏：$O(n^2)$\n  - 平均：$O(n^2)$\n- 空间复杂度：$O(1)$\n- 稳定性：稳定\n\n改进很小，对于接近排好序的序列甚至**更差**\n\n#### 希尔排序\n\n- 相隔一定的距离的记录组成一个子序列\n- 逐渐扩大小序列的规模，减小序列的个数，使得待排序列处于更有序的状态\n- 最后再用直接插入排序对整个序列进行一次排序\n\n##### 步长序列的选择\n\n- $1,2,4,8,\\ldots$\n- 时间复杂度：$O(n^2)$\n\n- Knuth 推荐：$1,3,7,15,31,63,\\ldots$\n- 时间复杂度：$O(n^{1.5})$\n- 空间复杂度：$O(1)$\n- 不稳定\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid shellSort(SET<KEY, OTHER> a[], int size)\n{\n  int step, i, j;\n  SET<KEY, OTHER> tmp;\n  for (step = size/2; step > 0; step /= 2) //step为希尔增量\n  {\n    for (i = step; i < size; ++i)\n    {\n      tmp = a[i];\n      for (j = i -step; j >= 0 && a[j].key > tmp.key; j -= step)\n      {\n        a[j+step] = a[j];\n      }\n      a[j+step] = tmp;\n    }\n}\n```\n\n### 选择排序\n\n1. 在 $n$ 个元素中选出最小的元素\n2. 从剩下的 $n-1$ 个元素中选出最小的元素\n3. 以此类推，直到最后一个元素\n\n#### 直接选择排序\n\n1. 在所有元素中逐个比较找到最小元素，与第一个元素交换\n2. 在剩下的元素中逐个比较找到最小元素，与第二个元素交换\n3. 以此类推，直到最后一个元素\n\n- 时间复杂度：$O(n^2)$\n- 空间复杂度：$O(1)$\n- 不稳定\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid simpleSelectSort(SET<KEY, OTHER> a[], int size)\n{\n  int i, j, min;\n  SET<KEY, OTHER> tmp;\n  for (i = 0; i < size -1; ++i)\n  {\n  min = i;\n  for (j = i+1; j < size; ++j)\n  {\n    if (a[j].key < a[min].key)\n    {\n      min = j;\n    }\n  }\n  tmp = a[i]; a[i] = a[min]; a[min] = tmp;\n  }\n}\n```\n\n#### 堆排序\n\n1. 建立一个最大堆\n2. 执行 $n$ 次 `deQuqeue` 操作取出每个项\n\n- 时间复杂度 $O(n\\log n)$\n\n- 堆排序\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid heapSort(SET<KEY, OTHER> a[], int size)\n{\n  int i;\n  SET<KEY, OTHER> tmp; // 创建初始的堆\n  for( i = size / 2 -1; i >= 0; i--)\n  {\n    percolateDown( a, i, size );\n  }\n  //执行n-1次deQueue\n  for ( i = size -1; i > 0; --i)\\\n  {\n  tmp = a[0]; a[0] = a[i]; a[i] = tmp; //delete a[0]\n  percolateDown( a, 0, i );\n  }\n}\n```\n\n- `precolateDown`\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid percolateDown( SET<KEY, OTHER> a[], int hole, int size)\n{\n  int child;\n  SET<KEY, OTHER> tmp= a[ hole ];\n  for( ; hole * 2 + 1 < size; hole = child )\n  {\n    child = hole * 2 + 1;\n    if( child != size -1 && a[ child + 1 ].key > a[ child ].key )\n    {\n      child++;\n    }\n    if( a[ child ].key >tmp.key)\n    {\n      a[ hole ] = a[ child ];\n    }\n    else\n    {\n      break;\n    }\n  }\n  a[ hole ] = tmp;\n}\n```\n\n### 交换排序\n\n通过交换，将关键字值较大的数据元素向序列的尾部移动，关键字值较小的数据元素向序列的头部移动\n\n#### 冒泡排序\n\n从头到尾比较相邻的两个元素，将小的换到前面，大的换到后面。经过了从头到尾的一趟比较，就把最大的元素交换到了最后一个位置。这个过程称为一趟起泡\n\n然后再从头开始到倒数第二个元素进行第二趟起泡。经过了第二趟比较，又将第二大的元素放到了倒数第二个位置\n\n依次类推，经过第 $n-1$ 趟起泡，将倒数第 $n-1$ 个大的元素放入第 2 个单元\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid bubbleSort(SET<KEY, OTHER> a[], int size)\n{\n  int i, j;\n  SET<KEY, OTHER> tmp;\n  bool flag = true; //记录一趟起泡中有没有发生过交换\n  for (i = 1; i < size&& flag; ++i)\n  { //size-1次起泡\n    flag = false;\n    for (j = 0; j < size-i; ++j) //第i次起泡\n    if (a[j+1].key < a[j].key)\n    {\n      tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp;\n      flag = true;\n    }\n  }\n}\n```\n\n#### 快速排序\n\n- 选择一个基准元素，将比基准元素小的元素放在左边，比基准元素大的元素放在右边\n- 然后对基准元素左边和右边的子序列进行递归排序\n\n##### 选择中心点\n\n- 第一个元素\n- 随机\n- 中值（采样得到）\n\n##### 划分（第一个元素为中心点）\n\n1. 序列的下标上界为 `high`，下届为 `low`，中心点选取第一个元素，关键值为 `K`，`low` 位置空出\n2. 从右向左开始检查：如果 `high` 的关键值大于 `K`，该位置中的值位置正确，`high` 减 $1$，继续往前检查，直到遇到一个小于 `K` 的值\n3. 将小于 `k` 的这个值放入 `low` 的位置，此时 `high` 的位置又空出。然后从 `low` 位置开始从左向右检查，直到遇到一个大于 `K` 的值\n4. 将 `low` 位置的值放入 `high` 位置，重复第 2 步，直到 `low` 和 `high` 重叠，将 `K` 放入此位置\n\n划分函数的实现\n\n```cpp\ntemplate <class KEY, class OTHER>\nint divide( SET<KEY, OTHER> a[], int low, int high)\n{\n  SET<KEY, OTHER> k = a[low];\n  do\n  {\n    while (low < high && a[high].key >= k.key)\n    {\n      --high;\n    }\n    if (low < high)\n    {\n      a[low] = a[high]; ++low;\n    }\n    while (low < high && a[low].key <= k.key)\n    {\n      ++low;\n    }\n    if (low < high)\n    {\n      a[high] = a[low]; --high;\n    }\n  } while (low != high);\n  a[low] = k;\n  return low;\n}\n```\n\n### 归并排序\n\n- 将待排序的序列分成两个子序列，分别进行排序\n- 将两个有序的子序列合并成一个有序的序列\n- 递归进行\n\n### 基数排序\n\n- 称为口袋排序法\n- 通过分配的方法进行排序\n- 基数（r）：子关键字的值域的元素的个数\n  - 十进制数：$0,1,2,\\ldots,9$，基数为 $10$\n  - 二进制数：$0,1$，基数为 $2$\n  - 英文字符：$A,B,C,\\ldots,Z$，基数为 $26$\n\n#### 高位优先法（MSD）\n\n- 先将高位进入口袋中你进行排序，再将低位放入口袋中进入排序，最终将最小的口袋依次链接在一起形成有序序列\n\n#### 低位优先法（LSD）\n\n- 先将最低为进入口袋进行排序，再将所有记录按照口袋的顺序收在一起\n- 然后将次低位进入口袋进行排序，依次类推\n- 最后将所有记录按照口袋的顺序收在一起\n\n## 外存储器中的查找和排序\n\n### 主存储器与外存储器\n\n- 主存储器：计算机的内存，用于存储正在运行的程序代码以及处理数据\n- 外存储器：计算机的硬盘、光盘、磁带等，用于长期存储数据和程序，用于存储长期保存的信息\n  - 价格低廉、存储量大、永久保存、**访问速度慢**\n\n### 外部查找\n\n#### B 树\n\nB 树是一棵平衡的 M 叉查找树，需要 $M-1$ 个关键字来判断到哪个分支查找\n\n##### B 树的定义\n\n- 一棵 $m$ 阶 B 树要么为空，要么满足一下条件\n  - 根节点要么是叶节点，要么至少有两个儿子，至多有 $m$ 个儿子\n  - 每个非根节点至少有 $\\lceil m/2 \\rceil$ 个儿子，至多有 $m$ 个儿子\n  - 有 $s$ 个儿子的非叶节点具有 $n=s-1$ 个关键字\n  - 所有的叶子节点都出现在同一层上\n\n##### B 树的插入\n\n- 在最底层进行插入\n\n1. 在 $m$ 阶 B 树上进行查找操作，确定新插入的关键字 `key` 在最底层非叶节点的插入位置\n2. 如果被插入节点的关键字个数小于等于 $m-1$，则插入结束\n3. 如果被插入节点的关键字个数大于 $m-1$，则需要进行分裂\n\n- 被插入节点分为三个部分\n  - 前半部分：前 $m/2$ 个关键字\n  - 中间部分：中间的关键字\n  - 后半部分：后 $m/2$ 个关键字\n- 中间部分的关键字上升到父节点\n- 前后半部分生成新的两个节点\n\n##### B 树的删除\n\n- 采用替身法，替身为右子树的最小值或者左子树的最大值\n\n1. 删除节点，替身进入\n2. 如果删除后的替身原来在的节点满足，则直接删除\n3. 如果删除后的关键字小于下限，\n   - 向该节点的左或右兄弟借一个关键字\n   - 如果兄弟节点的关键字个数等于下限，则需要进行合并\n\n##### M 的选择\n\n#### B+树\n\nB+树是既能提供随机查找，也能提供顺序访问的存储结构\n\n##### B+树的定义\n\n- 所有数据都记录在叶节点中，所有叶节点连成一个单链表\n- 非叶节点至多保存 $m-1$ 个关键字来引导查找，键 $i$ 表示子树 $i+1$ 中键的最小值\n- 根节点或者是叶节点，或者有 $2$ 到 $m$ 个子树\n- 除了根节点之外的所有非叶节点至少有 $m/2$ 个儿子，最多有 $m$ 个儿子\n- 所有的叶节点都在同一层上，并且每个叶子有 $\\lceil L/2 \\rceil$ 到 $L$ 个关键字\n\n##### B+树的插入\n\n- 叶结点不满：把新结点插入叶子，重新调整该叶子中数据的顺序\n- 叶子已经装满 ：通过分裂该叶子，形成两个半满的叶子来插入一个新的项\n  - 更新父结点\n  - 如果父亲的儿子数量已经满了，就继续分裂父亲\n\n### 外排序\n\n一次外存操作所需的时间可以执行数百条甚至上千条指令，因此在外排序中主要考虑的是如何减少外存储器的读写（I/O 操作）\n\n#### 外排序模型\n\n- 外排序由两个阶段组成\n  1. 预处理阶段：根据内存的大小将一个有 n 个记录的文件分批读入内存，用各种内排序算法排序，形成一个个有序片段\n  2. 归并阶段：将这些有序片段逐步归并成一个有序文件\n\n减少 I/O 操作的关键\n\n1. 减少归并轮数\n2. 减少有序片段数量\n3. 增加合并路数\n\n#### 预处理\n\n##### 减少有序片段数量\n\n- 每次读入的记录数越多，形成的初始的已排序的片段越少，归并的次数也越少\n- 最简单的方法是按照内存的容量尽可能多地读入数据记录，然后再内存中进行排序，排序地结果写入文件，形成一个已排序片段\n\n##### 置换排序\n\n置换选择可以在只能容纳 $p$ 个记录的内存中生成平均长度为 $2p$ 的初始的已排序片段\n\n只要前面的元素被写到文件上，它所用的内存空间就可以给别的元素使用。如果输入文件中的下一个元素比刚刚输出的元素大，它能被放入这个已排序片段\n\n具体方法\n\n1. 初始时，将 $m$ 个元素读入内存，用 `buildHeap` 建立一个优先级队列\n2. 执行一次 `deQuqeue`，将最小的元素写入输出文件\n3. 从输入磁带读入下一个元素\n   - 如果它比刚才写进去的元素大，那么将它加入到优先级队列中\n   - 否则，则无法写入队列，进行下一次 `deQuqeue`\n4. 重复第 2、3 步，直到输入文件读完\n5. 重新执行 `buildHeap`，使用存放在空余位置中的元素\n\n#### 归并\n\n##### 二路归并\n\n- 归并时，每次将两个有序文件归并为一个有序文件\n- 如果生成的有序片段数量为 $M$，则归并次数为 $\\lceil \\log_2 M \\rceil$\n\n##### 多路归并\n\n- 归并时，每次将 $k$ 个有序文件归并为一个有序文件\n- 优点：减少归并次数，为 $\\lceil \\log_k M \\rceil$ 次\n- 缺点：寻找最小元素的操作复杂，通常可以将每个文件的第一个记录组成一个优先级队列\n\n##### 多阶段归并\n\n- 可以仅使用 $K+1$ 条磁带实现 $K$ 路归并，称为**多阶段归并**\n\n**实现的过程**\n\n1. 按照非均匀的方法分解原来的已排序的片段\n2. 将每个片段分成 $K$ 个子片段\n\n## 图\n\n### 图的定义\n\n- 图可以用 $G=(V, E)$ 表示。其中，$V$ 是顶点集，$E$ 是边集。\n- 如果边是有方向的，称为**有向图**.有向图的边用 $\\langle \\rangle$ 表示\n  - $\\langle A, B \\rangle$ 表示从 $A$ 到 $B$ 的一条边\n- 如果边是无方向的，称为**无向图**.无向图的边用 $()$ 表示\n  - $(A, B)$ 表示 $A$ 和 $B$ 之间有一条边\n  - 无向图也称为双向图\n- **加权图：** 边被赋予一个权值的图称为加权图.如果图是有向的，称为加权有向图，如果是无向的，称为加权无向图\n  - 加权图中边的表示：$(V_i,V_j,W)$\n\n### 图的基本术语\n\n- 邻接\n  - 若 $(V_i,V_j)$ 是图 $G$ 的一条边，则称 $V_i$ 和 $V_j$ 是邻接的；若 $\\langle V_i,V_j \\rangle$ 是图 $G$ 的一条边，则称 $V_i$ 邻接到 $V_j$，$V_j$ 和 $V_i$ 邻接\n- 度\n  无向图中邻接与某一顶点的边的总数\n- 入度\n  有向图中进入某一顶点的边数\n- 出度\n  有向图中离开某一顶点的边数\n- 边与度的关系\n  $\\displaystyle e=\\frac{1}{2}\\sum_{i=1}^n d_i$，其中 $e$ 是边数，$d_i$ 是顶点 $V_i$ 的度\n\n#### 子图\n\n设有两个图 $G_1=(V_1,E_1)$ 和 $G_2=(V_2,E_2)$，如果 $V_1 \\subseteq V_2$，$E_1 \\subseteq E_2$，则称 $G_1$ 是 $G_2$ 的子图\n\n#### 路径和路径长度\n\n- 对于 $1<i<N$，顶点序列 $w_1,w_2,\\ldots,w_N$ 中的顶点对 $(w_i,w_{i+1})$ 都有 $(W_i,w_{i+1})\\in E$ 或 $\\langle w_i,w_{i+1} \\rangle \\in E$，则称 $w_1,w_2,\\ldots,w_N$ 是图中的一条**路径**\n- **非加权的路径长度**就是组成路径的边数，对于路径 $w_1,w_2,\\ldots,w_N$，路径长度为 $N-1$\n- **加权的路径长度**是指路径上所有边的权值之和\n- **简单路径和环：** 如果一条路径上所有顶点，除了起始顶点和终止顶点可能相同外，其余的顶点都不相同，则称其为简单路径。一个回路或环是一条简单路径，其起始顶点和终止顶点相同，且路径长度至少为 $1$\n\n#### 无向图的连通性\n\n- **连通：** 顶点 $V$ 和顶点 $V'$ 之间又路径存在\n- **连通图：** 无向图 G 的任意两点之间都是连通的\n- **连通分量：** 非连通图中的极大连通子图\n\n#### 有向图的连通性\n\n- **强连通图：** 有向图 G 的任意两点之间都是连通的，则称 G 是强连通图\n- **强连通分量：** 极大连通子图\n- **弱连通图：** 如有向图 G 不是强连通的，但是如果把它看作是无向图时则是连通的，则称该图是弱连通的\n\n#### 完全图\n\n- **完全图：** 每两个顶点之间都有边的无向图称为完全图。完全图有 $\\frac{n(n-1)}{2}$ 条边，即 $C_n^2$\n- **有向完全图：** 每两个顶点之间都有两条边的有向图称为有向完全图。有向完全图有 $n(n-1)$ 条边，即 $P_n^2$\n- **有向无环图：** 不含环的有向图\n\n#### 生成树与最小生成树\n\n- **生成树**是图 G 的**极小**连通子图 G'，其中 $V(G')=V(G)$\n- 用一棵树把图 G 的所有顶点都连起来，并且没有回路\n- 生成树有 $n$ 个顶点，$n-1$ 条边\n- 生成树可以有多个\n- **最小生成树**是所有生成树中权值之和最小的生成树\n\n### 图的运算\n\n- 常规操作\n  - 构造一个由若干个顶点、若干条边组成的图\n  - 判断两个顶点之间是否有边存在\n  - 在图中添加或删除一条边\n  - 返回图中的顶点数或边数\n  - 按某种规则**遍历**图中的所有顶点\n- 和应用紧密结合的运算\n  - 拓扑排序和关键路径\n  - 找最小生成树\n  - 找最短路径等\n\n### 图的抽象类\n\n```cpp\ntemplate <class TypeOfVer, class TypeOfEdge>\nclass graph\n{\n  public:\n    virtual void insert(TypeOfVer x, TypeOfVer y, TypeOfEdge w) = 0;\n    virtual void remove(TypeOfVer x, TypeOfVer y) = 0;\n    virtual bool exist(TypeOfVer x, TypeOfVer y) const = 0;\n    int numOfVer() const\n    {\n      return Vers;\n    }\n    int numOfEdge() const\n    {\n      return Edges;\n    }\n \n  protected:\n    int Vers, Edges;\n};\n```\n\n### 图的存储\n\n#### 邻接矩阵和加权邻接矩阵\n\n##### 有向图的邻接矩阵\n\n设有向图有 $n$ 个顶点，则用一个 $n \\times n$ 的布尔矩阵 $A$ 来表示该有向图\n\n![有向图的邻接矩阵](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505212328867.png)\n\n- 分别使用 $0,1,2,\\ldots,n-1$ 表示 顶点 $V_0,V_1,\\ldots,V_{n-1}$，如果存在一条从 $V_i$ 到 $V_j$ 的边，则 $A[i][j]=1$，否则 $A[i][j]=0$\n- 出度：$i$ 行之和\n- 入度：$j$ 列之和\n- 真正的顶点数据字段之值放入一个一维数组之中\n\n##### 无向图的邻接矩阵\n\n设无向图有 $n$ 个顶点，则用一个 $n \\times n$ 的布尔矩阵 $A$ 来表示该无向图\n\n![无向图的邻接矩阵](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505212332916.png)\n\n- 分别使用 $0,1,2,\\ldots,n-1$ 表示 顶点 $V_0,V_1,\\ldots,V_{n-1}$，如果存在一条从 $V_i$ 到 $V_j$ 的边，则 $A[i][j]=A[j][i]=1$，否则 $A[i][j]=A[j][i]=0$\n- 顶点 $i$ 的度：第 $i$ 行或第 $i$ 列之和\n- 无向图的邻接矩阵是一个三角对称矩阵\n\n##### 邻接矩阵的特点\n\n- 优点：判断任意两点之间是否有边方便，仅耗费 $O(1)$ 时间\n- 缺点：即使 $\\ll n_2$ 条边，也需内存 $n_2$ 单元，太多; 仅读入数据耗费 $O(n_2)$ 时间，太长。而大多数的图的边数远远小于 $n_2$。**适合稠密网**\n- 不适合增减顶点\n\n#### 邻接表\n\n- 设有向图或者无向图由 $n$ 个顶点，则用**顶点表**和**边表**来表示该有向图或无向图\n- **顶点表：** 用数组或单链表的形式存放所有的顶点\n  - 如果顶点数 $n$ 已知，则采用数组\n  - 如果顶点数未知，则采用单链表\n  - 每个元素包含两个部分\n    - 顶点值\n    - 指向该顶点对应的边表的首地址\n- **边表：** 每条边用一个节点进行表示\n\n  同一个顶点出发的所有的边形成它的边界点单链表\n\n![邻接表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505222230615.png)\n\n#### 邻接表的特点\n\n- 邻接表是图的**标准**存储方式\n- 优点\n  - $\\text{内存} = \\text{顶点数} +\\text{边数}$，时间复杂度为 $O\\left(\\vert V\\vert +\\vert E\\vert \\right)$，**适合稀疏网**\n- 当谈及图的线性算法时，一般指的是 $O\\left(\\vert V\\vert +\\vert E\\vert \\right)$\n- 缺点\n  - 确定 $i\\rightarrow j$ 是否有边，最坏需耗费 $O(n)$ 时间\n  - 无向图同一条边表示两次。边表空间浪费一倍\n  - 有向图中寻找进入某结点的边，非常困难（逆邻接表）\n\n### 图的遍历\n\n按照某种次序系统地访问图中的所有顶点，并且使得**每个顶点需且只能被访问一次**\n\n需对访问过的顶点加以**标记**\n\n#### 深度优先搜索\n\n1. 选中第一个被访问的顶点\n2. 对顶点作已访问过的标志\n3. 依次从顶点的未被访问过的第一个、第二个、第三个……邻接顶点出发，进行深度优先搜索\n\n出现了问题\n\n##### 存在的问题\n\n<span id=\"DFSdamn\">如果图不是连通或强连通，在进行 DFS 时，有时并不一定能够保证从某一个结点出发能访问到所有的顶点</span>\n\n##### 深度优先生成森林\n\n在[这种情况](##图###图的遍历####深度优先搜索#####存在的问题)下，必须再选中一个未访问过的顶点，继续进行深度优先搜索。直至所有的顶点都被访问过为止\n\n此时生成的是一组树而不是一棵树，这一组树被称为深度优先生成**森林**\n\n所以将深度优先搜索的流程改为\n\n1. 选中第一个被访问的顶点\n2. 对顶点作已访问过的标志\n3. 依次从顶点的未被访问过的第一个、第二个、第三个……邻接顶点出发，进行深度优先搜索\n4. 如果还有顶点未被访问，则选中一个起始顶点，转向 2\n5. 所有的顶点都被访问到，则结束\n\n##### 深度优先搜索的实现\n\n- 公有的 `dfs` 函数的伪代码\n\n```cpp\nvoid dfs()\n{\n  visited [v] =false; //对每个节点标记为未访问\n\n  while(v=尚未访问的节点)\n  {\n    dfs(v,visited);\n  }\n}\n```\n\n- 私有的 `dfs` 函数的伪代码\n\n```cpp\nvoid dfs(v,visited)\n{\n  visited(v)=true;\n  for 每个 v 的邻接点 w\n  {\n    if(!visited[w])\n    {\n      dfs(w,visited);\n    }\n  }\n}\n```\n\n#### 广度优先搜索\n\n1. 选中第一个被访问的顶点\n2. 对顶点作已访问过的标志\n3. 依次访问已访问顶点的未被访问过的第 $1$ 个、第 $2$ 个、第 $3$ 个、$\\ldots$ 、第 $m$ 个邻接顶点 $W_1,W_2,W_3,\\ldots,W_m$ ，进行访问且进行标记，转向 3\n4. 如果还有顶点未被访问，则选中一个起始顶点，转向 2\n5. 所有的顶点都被访问到，则结束\n\n按照顶点序号小的先访问，大的后访问的原则以**队列**的形式实现\n\n同样能够生成广度优先生成森林\n\n##### 广度优先搜索的实现\n\n1. 将序号最小的顶点放入队列\n2. 重复取队列的队头元素进行处理，直到队列为空。对出队的每个元素，首先检查该元素是否已被访问\n   - 如果没有被访问过，则访问该元素，并将它的所有的没有被访问过的后继入队\n3. 检查是否还有顶点未被访问。如果有，重复上述两个步骤\n\n```cpp\ntemplate <class TypeOfVer, class TypeOfEdge>\nvoid adjListGraph<TypeOfVer, TypeOfEdge>::bfs() const\n{\n  bool *visited = new bool[Vers];\n  int currentNode;\n  linkQueue<int> q;\n  edgeNode *p;\n  for (int i=0; i < Vers; ++i)\n  {\n   visited[i] = false;\n  }\n  cout << \"当前图的广度优先遍历序列为：\"<< endl;\n  for (i = 0; i < Vers; ++i)\n  {\n    if (visited[i] == true)\n    {\n      continue;\n    }\n    while (!q.isEmpty()) //连续访问队列的队头，将其拉出，若其后继非空则拉入队列\n    {\n      currentNode = q.deQueue();\n      if (visited[currentNode] == true)\n      {\n        continue;\n      }\n      cout << verList[currentNode].ver <<'\\t';\n      visited[currentNode] = true;\n      p = verList[currentNode].head;\n      while (p != NULL)\n      {\n        if (visited[p->end] == false)\n        q.enQueue(p->end);\n        p = p->next;\n      }\n    }\n    cout << endl;\n  }\n}\n```\n\n### 图遍历的应用\n\n#### 无向图的连通性\n\n- 如果无向图是连通的，则从无向图中的任意顶点出发进行深度优先搜索或广度优先搜索都可以访问到每一个顶点。访问的次序是一棵深度/广度优先**生成树**\n- 如果图是非连通的，深度/广度优先搜索可以找到一片深度/广度优先**生成森林**。每棵树就是一个**连通分量**。对无向图来说，深度/广度优先搜索可以找到了它的所有连通分量\n- 在深度优先搜索和广度优先搜索函数的输出中，每一行代表一个连通分量\n\n#### 有向图的连通性\n\n- 对有向图，深度优先搜索可以**测试是否强连通**，并**找出所有强连通分量**\n  1. 从任意顶点开始**深度优先遍历** $G$\n  2. 对森林中的每棵树进行**后序遍历**，并按遍历的顺序给每个顶点编号\n  3. 将 $G$ 的每条边逆向，形成 $G_r$\n  4. 从编号**最大**的顶点开始**深度优先遍历 $G_r$**。得到的深度优先遍历森林的每棵树就是 $G$ 的强连通分量\n\n#### 欧拉回路\n\n- 哥尼斯堡七桥问题：能否找到一条走遍这七座桥，而且每座桥只经过一次，最后又回到原出发点的路径\n\n![哥尼斯堡七桥问题](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505230120835.png)\n\n##### 欧拉的证明\n\n- 如果都是偶数桥，从任意地方出发都能回到原点 **（欧拉回路）**\n- 如果都是偶数桥，从任意地方出发都能回到原点 **（欧拉路径）**\n- 如果有奇数桥的地方不止两个，满足要求的路径是找不到的\n\n##### 查找欧拉回路的基本想法\n\n- 执行一次**不允许回溯**的 `DFS` ，也被称为一笔画问题\n- 但是很多搜索都是不符合的\n\n##### 解决方法\n\n找出路径上的另外一个尚有未访问的边的顶点，开始另一次深度优先的搜索，将得到的遍历序列拼接到原来的序列中，直到所有的边都已被访问\n\n![欧拉回路解决方法](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505230128080.png)\n\n#### 拓扑排序\n\n设 $G=(V,E)$ 是一个具有 $n$ 个顶点的**有向无环图**\n\n若 $V$ 中的顶点序列 $V_1,V_2,\\ldots ,V_n$ 满足下列条件\n\n- 在 $G$ 中，从 $V_i$ 到 $V_j$ 有一条路径\n- 在序列中 $V_i$ 在 $V_j$ 之前\n\n则称 $V_1,V_2,\\ldots ,V_n$ 是 $G$ 的一个**拓扑排序**\n\n拓扑排序将图转换为线性序，相对前去后继关系不变\n\n##### 顶点活动网络（Activu on vertex network）\n\n- 顶点表示各项子任务\n- 有向边表示具有先决条件关系\n- 仅当作为某一子任务的所有作为先决条件的子任务实施完成后，该子任务才能得以实施\n\n**AOV**的特点\n\n1. 有起始顶点\n2. 无回路\n\n##### 找出拓扑排序的过程\n\n- 第一个输出的顶点必须无前驱，即入度为 $0$\n- 无前驱以及后继的顶点在任何时候都可以输出\n- 逻辑删除法：当某个顶点被输出之后，该顶点以及从该顶点出发的边都被删除，所有以该顶点作为前驱的入度的所有顶点的入度 $-1$\n\n##### 拓扑排序的实现\n\n- 计算每个顶点的入度，保存在数组 `inDegree` 中\n- 检查 `inDegree` 中的每个元素，将入度为 $0$ 的顶点入队\n- 不断从队列中将入度为 $0$ 的顶点入队，输出此顶点，并将该顶点的入度 $-1$，如果某个邻接点的入度为 $0$，则将其入队\n\n```cpp\ntemplate <class TypeOfVer, class TypeOfEdge>\nvoid adjListGraph<TypeOfVer, TypeOfEdge>::topSort() const\n{\n  linkQueue<int> q;\n  edgeNode *p;\n  int current, *inDegree = new int[Vers];\n  for (int i = 0; i < Vers; ++i)\n  {\n    inDegree[i] = 0;\n  }\n  for ( i = 0; i < Vers; ++i)\n  {\n    for (p = verList[i].head; p != NULL; p = p->next)\n    {\n    ++inDegree[p->end];\n    }\n  }                                                                 //计算入度\n  for (i = 0; i < Vers; ++i)   if (inDegree[i] == 0) q.enQueue(i);  //入度0节点入队\n  cout << \"拓扑排序为：\" << endl;\n  while(!q.isEmpty())\n  {\n    current = q.deQueue( );\n    cout << verList[current].ver << '\\t';\n    for (p = verList[current].head; p != NULL; p = p->next)\n    if( --inDegree[p->end] == 0 )    q.enQueue( p->end );\n  }                                                                 //出队，删除关联的边\n  cout << endl;\n}\n```\n\n**时间复杂度：**\n\n- 若图以邻接表表示\n- 计算入度的时间复杂度为 $O(\\vert V\\vert +\\vert E\\vert)$，搜索入度为 $0$ 的顶点的时间复杂度为 $O(\\vert V\\vert)$，出队和删除边的时间复杂度为 $O(\\vert E\\vert)$，总执行时间为 $O(\\vert V\\vert +\\vert E\\vert)$\n\n#### 关键路径\n\n##### 边活动网络（Activity on Edge）\n\n- **AOE 网络：** 加权有向无环图\n  - 顶点表示事件，边表示活动\n  - 有向边的权值表示活动的持续时间\n  - 有向边的方向表示事件发生的先后次序\n  - 顶点的进入表示事件发生后允许开始的活动\n  - 有一个源点、一个终点\n\n##### 关键路径的定义\n\nAOE 网路可用于描述整个工程的各个活动之间的关系，活动安排的先后次序\n\n再次基础上可以用来估算工程的完成时间以及哪些活动是关键的活动\n","source":"_posts/数据结构笔记.md","raw":"---\ntitle: 数据结构笔记\nmath: true\n---\n\n[oiWiki 中的数据结构](https://oi-wiki.org/ds)\n\n## 引言\n\n### 算法与数据结构\n\n数据结构的研究内容\n\n1. 数据之间的**逻辑关系**，以及这种关系对应的操作\n2. **储存实现**：数据及逻辑关系的存储\n3. **运算实现**：具体存储模式下，运算的实现，即**算法**\n\n#### 数据的逻辑结构\n\n- **集合结构**\n  次序任意，元素之间除了**同处于一个集合内**之外没有任意其他的关系.\n- **线性结构**\n  数据元素的**有序**排列，除了头尾的元素外其余元素都有一个前趋和一个后继.\n- **树形结构**\n  除了根元素之外，每个节点都有且仅有一个前趋，但是后继数量不限.\n- **图形结构**\n  每个元素的前趋和后继数量都不限\n  ![FourLogicalDataStructures](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/FourLogicalDataStructures.png)\n\n#### 数据结构的操作\n\n- **创造**\n- **清除**\n- **插入**\n- **删除**\n- **更新**\n- **搜索**\n- **访问**\n- **遍历（traverse）**：按照某种次序访问数据结构中的每一元素，使每个元素恰好被访问一次\n- 每一种数据结构的特定操作\n\n数据结构的**五大类**：构建类、属性类、数据操纵类、遍历类、特定类\n\n### 存储实现\n\n### 算法分析\n\n#### 时间复杂度的概念\n\n- 是一种抽象的度量，表示运算量和问题规模（输入规模）之间的关系，$T(n)$\n- 算法的时间复杂度也与被处理的数据分布有关\n- 算法的时间复杂度分为三种\n  - 最好的\n  - 最坏的\n  - 平均\n\n#### 算法运算量的计算\n\n#### 渐进时间复杂度\n\n#### 算法的优化\n\n#### 空间复杂度的概念\n\n- 渐进的空间复杂度\n- 一般只考虑**辅助**空间的占用情况\n- 空间复杂度一般按照最坏情况处理\n- 空间复杂度的计算、表示方法与时间复杂度相同\n\n### 面向对象方法\n\n#### 类模板的定义\n\n类模板允许用户为类定义一种模式，使得类中的某些数据成员、某些成员函数的参数或返回值能取任意数据类型\n\n##### 定义格式\n\n```cpp\ntemplate <class 标识符>\nclass 类名\n{\n    // 类成员声明\n};\n```\n\n##### 类定义的一般格式\n\n```cpp\nclass 类名\n{\n  [private:]\n    // 私有数据成员和成员函数声明\n  public:\n    // 公有数据成员和成员函数声明\n};\n```\n\n#### 虚函数\n\n- 在基类中用关键词 `virtual` 声明的成员函数，并在派生类中重新定义的函数称为虚函数\n- 虚函数的一般格式\n\n  ```cpp\n  virtual 返回类型 函数名(参数表)\n  {\n    // 函数体\n  };\n  ```\n\n- 在派生类中重新定义时，其函数原型，包括返回类型、函数名、参数个数和参数类型的顺序都必须与基类中的原型完全相同（**继承**）\n- 当把一个函数定义为虚函数时，等于告诉编译器，这个成员函数在派生类中可能有不同的实现。必须在执行时根据传递的参数来决定调用哪一个函数\n- 虚函数在基类中有默认实现，派生类可以选择性地对其进行重写\n\n#### 纯虚函数\n\n- 是一个在基类中说明的虚函数，它在该基类中没有实现，但要在它的派生类里定义和实现自己的版本，或重新说明为纯虚函数\n- 纯虚函数的一般形式\n\n  ```cpp\n  virtual 返回类型 函数名(参数表) = 0;\n  ```\n\n- 纯虚函数在基类中无实现，只有函数原型，派生类必须实现\n\n#### 抽象类\n\n- 如果一个类中**至少有一个纯虚函数**，那么这个类就是抽象类\n- 抽象类只能作为其他类的基类，不能建立抽象类的对象\n\n#### 继承\n\n- 在已有类的基础上建立新的类\n- 基类（父类）和派生类（子类）\n- 继承可以让程序员在已有类的基础上通过增加或修改少量代码的方法得到新的类，从而解决代码重用的问题\n\n##### 派生类\n\n- 一般格式\n\n  ```cpp\n  class 派生类名 : [派生方式] 基类名\n  {\n    // 派生类新增的数据成员和成员函数\n  };\n  ```\n\n- 派生方法\n  - 公有派生：`public`\n  - 私有派生：`protected`\n  - 保护派生：`private`\n- `class` 默认是 `private` 继承， `struct` 默认是 `public` 继承\n\n###### 派生类对基类成员的访问性\n\n|                  | `public` 继承 | `protected` 继承 | `private` 继承 |\n| :--------------: | :-----------: | :--------------: | :------------: |\n|  `public` 成员   |    public     |    protected     |    private     |\n| `protected` 成员 |   protected   |    protected     |    private     |\n|  `private` 成员  |   不可访问    |     不可访问     |    不可访问    |\n\n#### 类定义时常见的两种`const`用法\n\n以函数 `int search(constelemType&x) const` 为例\n\n1. 修饰参数 `x` 的 `const` 和 `&` 组合\n   - `const` 修饰参数 `x`，表示函数 `search` 不会修改参数 `x` 的值\n   - 参数加了 `const` 之后，编译器会在程序编译阶段帮助程序检查函数实现代码中是否含有对参数 `x` 的修改操作，若有则会报错\n   - **如果确认函数实现中不准备改变 `x` 的值，养成加 `const`的习惯**\n   - `&` 修饰参数 `x`，表示参数 `x` 是引用传递，即传递的是实参的地址，而不是实参的值\n2. 修饰函数 `search` 的 `const`\n   - 参数表后的 `const` 保护调用对象的值不被修改\n   - 如果没有 `const` 修饰，那么在调用对象为 `const` 类型时，不能调用该函数\n     常量对象只能调用参数表后带 `const` 的常量成员函数\n\n## 线性表\n\n### 线性表的定义\n\n#### 线性表的概念\n\n- 是一种**线性结构**，是由 $n(n\\geq0)$ 个数据元素组成的有限序列\n- 除了首节点 $A_0$ 和尾节点 $A_{n-1}$ 之外，每个节点 $A_i$ 有且仅有一个前趋 $A_{i-1}$ 和一个后继 $A_{i+1}$\n- $A_0$ 只有后趋，$A_{n-1}$ 只有前趋\n\n  ![线性表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271603830.png)\n\n#### 表的基本操作\n\n- **创建 `create()`**：创建一个空的线性表\n- **清除 `clear()`**：删除线性表中的所有数据元素\n- **长度 `length()`**：返回线性表的长度\n- **插入 `insert(i,x)`**：在线性表的第 $i$ 个位置插入一个新元素 `x`\n- **删除 `remove(i)`**：删除线性表中第 $i$ 个位置的元素\n- **搜索 `search(x)`**：在线性表中搜索元素 `x`，返回其位置\n- **访问 `visit(i)`**：返回线性表中第 $i$ 个位置的元素\n- **遍历 `traverse()`**：依次访问线性表中的每个元素\n\n#### 线性表的抽象类\n\n```cpp\ntemplate <class elemType>\nclass list\n{\n  public:\n    virtual void clear() = 0;                           // 清空\n    virtual int length() const = 0;                     // 返回长度\n    virtual void insert(int i, const elemType &x) = 0;  // 插入\n    virtual void remove(int i) = 0;                     // 删除\n    virtual int search(const elemType &x) const = 0;    // 搜索\n    virtual elemType visit(int i) const = 0;            // 访问\n    virtual void traverse() const = 0;                  // 遍历\n    virtual ~list() {}                                  // 析构函数\n};\n```\n\n- 抽象类定义了线性表基本的操作，全是用纯虚函数定义，不做实现\n- **抽象类无构造函数**\n\n### 线性表的顺序实现\n\n#### 顺序存储结构\n\n- 节点存储在存储器的一块**连续**的空间中\n- 节点依照逻辑顺序依次**存放**\n- 节点存放的物理位置和逻辑顺序是对应的\n- 线性表的顺序实现通常被称为**顺序表**\n\n#### 顺序表类的定义\n\n```cpp\ntemplate <class elemType>\nclass seqList : public list<elemtype>\n{\n  private:\n    elemType *data;\n    int currentLength;\n    int maxSize;\n    void doubleSpace();\n  public:\n    seqList(int initSize = 10);             // 构造函数\n    ~seqList()                              // 析构函数\n    {\n      delete[] data;\n    }\n    void clear()                            //清空\n    {\n      currentLength = 0;\n    }\n    int length() const                      // 返回长度\n    {\n      return currentLength;\n    }\n    void insert(int i, const elemType &x);  // 插入\n    void remove(int i);                     // 删除\n    int search(const elemType &x) const;    // 搜索\n    elemType visit(int i) const;            // 访问\n    void traverse() const;                  // 遍历\n};\n```\n\n#### 函数实现\n\n##### 构造函数\n\n- 定义对象时自动调用，用于初始化对象的数据成员\n- **函数名与类名相同**\n- 可以有任何类型的参数，也可以没有参数，但是**不能有返回类型**，所以定义时不能说明类型\n- 若没有给出构造函数，编译器会自动生成一个默认的构造函数，只为对象开辟空间，里面的内容为随机数\n\n```cpp\ntemplate<class elemType>\nseqList<elemType>::seqList(int initSize)\n{\n  data = new elemType[initSize];\n  maxSize = initSize;\n  currentLength = 0;\n}\n```\n\n![seqList](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271640573.png)\n\n##### 析构函数\n\n- 用于释放对象所占用的内存空间，由编译系统自动调用\n- **函数名与类名相同，前面加 `~`**\n- 不能有参数，也不能有返回类型\n- 若没有给出析构函数，编译器会自动生成一个默认的析构函数\n- 不是所有类都要由析构函数\n- 一般在构造函数中动态申请内存的，必须有析构函数\n\n```cpp\n~seqList()\n{\n  delete[] data;\n}  //在线性表的类中已经实现了，不用到类外定义\n```\n\n##### 顺序表的运算实现\n\n###### `search`\n\n从数组的第 0 个下标变量开始一次往后检查每一个元素，直到找到 `x` 或找到表尾\n\n```cpp\ntemplate<class elemType>\nint seqList<elemType>::search(const elemType &x) const\n{\n  int i ;\n  for (i = 0 ; i < currentLength && data[i] != x ; ++i);\n  if (i == currentLength)\n  {\n    return -1;\n  }\n  else\n  {\n    return i;\n  }\n}\n```\n\n###### `traverse`\n\n从数组的第 0 个下标变量开始一次往后访问每一个元素，直到表尾\n\n```cpp\ntemplate<class elemtype>\nvoid seqList<elemType>::traverse() const\n{\n  for (int i = 0 ; i < currentLength ; ++i)\n  {\n    cout << data[i] << ' ';\n  }\n}\n```\n\n###### `insert`\n\n- 在第 `i` 个位置插入元素 `x`\n- 若插入后表长超过 `maxSize`，则将 `maxSize` 扩大一倍\n\n![seqList::insert](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271747022.png)\n\n```cpp\ntemplate<class elemType>\nvoid seqList<elemType>::insert(int i , const elemType &x)\n{\n  if (currentSize = maxSize)\n  {\n    doubleSpace();\n  }\n  for (int j = currentLength ; j > i ; --j)\n  {\n    data[j] = data[j - 1];\n  }\n  data[i] = x;\n  ++currentLength;\n}\n```\n\n###### `doubleSpace` 操作的实现\n\n- 重新申请一个更大规模的动态数组，将原有数组的内容拷贝到新数组中，释放原有数组空间，将新数组作为存储线性表的存储区\n\n![seqList::doublespace](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281230588.png)\n\n```cpp\ntemplate<class elemType>\nvoid seqList<elemType>::doublespace()\n{\n  elemtype *tmp = data;\n  maxSize *= 2;\n  data = new elemtype[maxSize];\n  for (int i = 0 ; i < currentLength ; ++1)\n  {\n    data[i] = tmp[i];\n  }\n  delete[] tmp;\n}\n```\n\n###### `remove`\n\n![seqlist::remove](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281238735.png)\n\n```cpp\ntemplate<class elemType>\nvoid seqList<elemType>::remove(int i)\n{\n  if (i < 0 ||i > currentlength)\n  {\n    throw OutOfBound();\n  }\n  for (int j = i ; j < currentlength -1 ; ++j)\n  {\n    data[j] = data[j + 1];\n  }\n  --currentLength;\n}\n```\n\n### 线性表的链接存储\n\n#### 单链表\n\n- 每个节点附加指针字段，如 `next`，指向直接后继节点，最后一个节点的 `next` 指向 `nullptr`\n\n![单链表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281247119.png)\n\n##### 头节点、头指针\n\n- 在表头额外增加一个相同类型的特殊结点\n- 不是线性表中的组成部分\n- 头节点使得在表头位置上进行插入和删除和在其他节点位置上是完全一致的，使得插入和删除算法得到简化\n\n![带头节点的单链表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281407312.png)\n\n##### 结点及其组成\n\n- 链表的节点包含两个部分\n  - 数据字段\n    - 可以存储任何类型的数据，仍然使用 `elemType` 表示\n  - 指针字段\n    - 用于存储**后继节点**的地址值\n  - 结点类型是链表专用的，可以设为内嵌类\n  - 将节点类定义为 `struct` 方便链表类访问\n\n##### 单链表类的定义\n\n```cpp\ntemplate <class elemType>\nclass sLinkList:public list<elemtype>\n{\n  private:\n    struct node                                    // 节点类\n    {\n      elemType data;\n      node *next;\n      node(const elemType &x , node *n = nullptr)\n      {\n        data = x;\n        next = n;\n      }\n      node():next(nullptr){}\n      ~node(){}\n    };\n\n    node *head;\n    int currentLength;\n    node *move(int i) const;\n  public:\n    sLinkList();\n    ~sLinkList();\n    void clear();\n    int length() const\n    {\n      return currentLength;\n    }\n    void insert(int i , const elemType &x);\n    void remove(int i);\n    int search(const elemType &x) const;\n    elemType visit(int i) const;\n    void traverse() const;\n};\n```\n\n##### 构造函数\n\n![sLinklist](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281418321.png)\n\n```cpp\ntemplate <class elemType>\nsLinkList<elemType>::sLinkList()\n{\n  head = new node();\n  currentLength = 0;\n}\n```\n\n##### `clear`\n\n- 将单链表变成一个空表\n- 回收节点空间\n\n![sLinkList::clear](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281420756.png)\n\n```cpp\ntemplate <class elemType>\nvoid sLinkList<elemType>::clear()\n{\n  node *p = head->next , *q;\n\n  while (p != nullptr)        // 删除节点\n  {\n    q = p->next;\n    delete p;\n    p = q;\n  }\n  currentLength = 0;\n}\n```\n\n##### `move`\n\n- 返回第 $i$ 个元素的指针\n\n```cpp\ntemplate <class elemType>\nstruct sLinkList<elemType>::node *sLinkList<elemType>::move(int i) const\n{\n  node *p = head;\n  for (int j = 0 ; j < i ; ++j)\n  {\n    p = p->next;\n  }\n  return p;\n}\n```\n\n##### `insert`\n\n1. 指针 `p` 指向要插入的位置 `i` 的前一个节点\n2. 申请一个新节点 `s`\n3. 将 `s` 的 `next` 指向 `p` 的 `next`\n4. 将 `p` 的 `next` 指向 `s`\n\n![sLinkList::insert](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281437080.png)\n\n```cpp\ntemplate <class elemType>\nvoid sinkList<elemtype>::insert(int i , const elemType &x)\n{\n  if (i < 0 || i > currentLength)\n  {\n    throw OutOfBound();\n  }\n  node *p = move(i-1);\n  node *s = new node(x , p->next);\n  p->next = s;\n  ++currentLength;\n}\n```\n\n##### `remove`\n\n1. 找到被删除节点的前一个节点 `pos`\n2. 让 `delp` 指向被删除节点\n3. 让 `pos` 的 `next` 指向 `delp` 的 `next`\n4. 释放 `delp` 的空间\n\n![sLinkList::remove](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281444167.png)\n\n```cpp\ntemplate <class elemType>\nvoid sLinkList<elemType>::remove(int i)\n{\n  if (i < 0 || i >= currentLength)\n  {\n    throw OutOfBound();\n  }\n  node *pos = move(i-1);\n  node *delp = pos->next;\n  pos->next = delp->next;\n  delete delp;\n  --currentLength;\n}\n```\n\n##### `search`\n\n- 从头节点开始，依次访问每个节点，直到找到 `x` 或到达表尾\n\n```cpp\ntemplate <class elemType>\nint sLinkList<elemType>::search(const elemtype 7x) const\n{\n  node *p = head -> next;\n  int i = 0;\n  while (p != nullptr && p->data != x) // 访问每个节点，条件的顺序不能交换\n  {\n    p = p->next;\n    ++i;\n  }\n  if (p == nullptr)\n  {\n    return -1;\n  }\n  else\n  {\n    return i;\n  }\n}\n```\n\n- 如果判定条件改为 `p->data != x && p != nullptr`，会在 `p` 为空时试图访问 `p->data`，导致访问空指针，从而产生未定义行为\n\n##### `visit`\n\n1. 找到第 `i` 个节点\n2. 返回 `p->data`\n\n```cpp\ntemplate <class elemType>\nelemType sLinkList<elemType>::visit(int i) const\n{\n  if (i < 0 || i >= currentLength)\n  {\n    throw OutOfBound();\n  }\n  return move(i)->data;\n}\n```\n\n##### `traverse`\n\n```cpp\ntemplate <class elemType>\nvoid sLinkList<elemType>::traverse() const\n{\n  node *p = head->next;\n  while (p != nullptr)\n  {\n    cout << p->data << ' ';\n    p = p->next;\n  }\n}\n```\n\n#### 双链表\n\n- 每个节点有两个指针字段\n  - `next` 指向直接后继节点\n  - `prev` 指向直接前驱节点\n\n##### 双链表的头尾节点\n\n- 头节点\n  - `prev` 指向 `nullptr`\n  - `next` 指向首节点\n- 尾节点 `tail`\n  - `prev` 指向最后一个节点\n  - `next` 指向 `nullptr`\n\n![双链表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291712872.png)\n\n##### 双链表类的定义\n\n```cpp\ntemplate <class elemType>\nclass dLinkList:public list<elemType>\n{\n  private:\n    struct node                                                         // 双链表中的节点类\n    {\n      elemType data;\n      node *next;\n      node *prev;\n      node(const elemType &x , node *p = nullptr , node *n = nullptr)\n      {\n        data = x;\n        prev = p;\n        next = n;\n      }\n      node():next(nullptr),prev(nullptr){}\n      ~node(){}\n    };\n    node *head , *tail;                                                  // 头节点和尾节点\n    int currentLength;                                                   // 当前长度\n    node *move(int i) const;                                             // 返回第 i 个节点的指针\n  public:\n    dLinkList();\n    ~dLinkList();\n    void clear();\n    int length() const\n    {\n      return currentLength;\n    }\n    void insert(int i , const elemType &x);\n    void remove(int i);\n    int search(const elemType &x) const;\n    elemType visit(int i) const;\n    void traverse() const;\n};\n```\n\n##### 构造函数\n\n- 申请头节点和尾节点\n\n![dLinkList](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291715359.png)\n\n```cpp\ntemplate <class elemType>\ndLinkList<elemType>::dLinkList()\n{\n  head = new node();\n  tail = new node();\n  head->next = tail;\n  tail->prev = head;\n  currentLength = 0;\n}\n```\n\n##### `insert`\n\n1. 申请一个新节点 `tmp`，找到要插入的位置 `pos`\n2. 将 `tmp` 的 `prev` 指向 `pos` 的 `prev`，`tmp` 的 `next` 指向 `pos`\n3. 将 `pos` 的前一个结点的 `next` 指向 `tmp`\n4. 将 `pos` 的 `prev` 指向 `tmp`\n\n![dLinkList::insert](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291718343.png)\n\n```cpp\ntemplate <class elemType>\nvoid dLinkList<elemtype>::insert(int i ,const elemTypr &x)\n[\n  node *pos , *tmp;\n\n  pos = move(i);\n  temp = new node(x,pos -> prev , pos);\n  pos->prev->next = tmp;\n  pos->prev = tmp;\n\n  ++currentLength;\n]\n```\n\n##### `remove`\n\n1. 找到要删除的节点 `pos`\n2. 将 `pos` 的前一个节点的 `next` 指向 `pos` 的后一个节点\n3. 将 `pos` 的后一个节点的 `prev` 指向 `pos` 的前一个节点\n\n![dLinkList::remove](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291730399.png)\n\n```cpp\ntemplate <class elemType>\nvoid dLinkList<elemType>::remove(int i)\n{\n  node *pos = move(i);\n\n  pos->prev->next = pos->next;\n  pos->next->prev = pos->prev;\n\n  delete pos;\n  --currentLength;\n}\n```\n\n#### 单循环链表\n\n- 一般单循环链表不带头节点\n\n![单循环链表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291732560.png)\n\n#### 双循环链表\n\n- 头结点中 `prev` 字段给出尾结点的地址，尾结点中 `next` 字段给出头结点的地址\n- 一般也不设置头尾节点\n\n## 栈\n\n### 栈的定义\n\n- 栈是一种特殊的线性表\n- 只允许在一段进行插入和删除操作\n- 先进后出（LIFO，Last In First Out）\n\n![栈](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291811552.png)\n\n#### 栈的基本操作\n\n- **创建 `create()`**：创建一个空栈\n- **进栈 `push(x)`**：将元素 `x` 压入栈顶\n- **出栈 `pop()`**：删除栈顶元素并返回其值\n- **访问栈顶元素 `top()`**：返回栈顶元素的值但是不删除\n- **判断是否为空 `isEmpty()`**：若栈空返回 `true`，否则返回 `false`\n\n#### 栈的抽象类\n\n```cpp\ntemplate <class elemType>\nclass stack\n{\n  public:\n    virtual void push(const elemType &x) = 0;       // 进栈\n    virtual elemType pop() = 0;                     // 出栈\n    virtual elemType top() const = 0;               // 访问栈顶元素\n    virtual bool isEmpty() const = 0;               // 是否为空\n    virtual ~stack() {}                             // 析构函数\n};\n```\n\n### 栈的顺序实现\n\n- 使用数组储存栈中的节点\n- 进栈和出栈都是在栈顶进行，不会引起类似顺序表中的大量元素的移动，数组的后端为栈顶\n\n![顺序栈](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291817453.png)\n\n#### 顺序栈类\n\n```cpp\ntemplate <class elemType>\nclass seqStack:public stack<elemType>\n{\n  private:\n    elemType *data;                     // 数据域\n    int top_p;                          // 栈顶指针\n    int maxSize;                        // 栈的最大容量\n    void doubleSpace();\n  public:\n    seqStack(int initSize = 10);        // 构造函数\n    ~seqStack();                        // 析构函数\n    bool isEmpty() const;               // 是否为空\n    void push(const elemType &x);       // 进栈\n    elemType pop();                    // 出栈\n    elemType top() const;               // 访问栈顶元素\n};\n```\n\n#### 顺序存储的运算实现\n\n##### 构造函数\n\n- 按照用户估计的栈的规模申请一个动态数组，将数组地址保存在 `elem` 中，数组规模保存在 `maxSize` 中，并设 `top_p` 的值为 $-1$\n\n```cpp\ntemplate <class elemType>\nseqStack<elemType>::seqStack(int initSize)\n{\n  elem = new elemType[initSize];\n  maxSize = initSize;\n  top_p = -1;\n}\n```\n\n#### `push`\n\n- 先判断栈是否已满，若满则调用 `doubleSpace` 扩大栈的容量\n- 将 `top_p` 加 1，指向栈顶元素\n- 将 `x` 压入栈顶\n\n```cpp\ntemplate <class elemType>\nvoid seqStack<elemType>::push(const elemType &x)\n{\n  if (top_p == maxSize - 1)\n  {\n    doubleSpace();\n  }\n  elem[++top_p] = x;\n}\n```\n\n##### `doubleSpace`\n\n```cpp\ntemplate <class elemType>\nvoid seqStack<elemType>::doubleSpace()\n{\n  elemType *tmp = elem;\n  elem = new elemType[maxSize * 2];\n  for (int i = 0 ; i < maxSize ; ++i)\n  {\n    elem[i] = tmp[i];\n  }\n  maxSize *= 2;\n  delete[] tmp;\n}\n```\n\n##### `pop`\n\n- 返回 `top_p` 指向的元素\n- 将 `top_p` 减 1\n\n```cpp\ntemplate <class elemType>\nelemType seqStack<elemType>::pop()\n{\n  return elem[top_p--];\n}\n```\n\n##### `top`\n\n- 返回 `top_p` 指向的元素\n\n```cpp\ntemplate <class elemType>\nelemType seqStack<elemType>::top() const\n{\n  return elem[top_p];\n}\n```\n\n##### `isEmpty`\n\n- 判断 `top_p` 是否为 $-1$，若是则栈空\n\n```cpp\ntemplate <class elemType>\nbool seqStack<elemType>::isEmpty() const\n{\n  return top_p == -1;\n}\n```\n\n#### 析构函数\n\n```cpp\ntemplate <class elemType>\nseqStack<elemType>::~seqStack()\n{\n  delete[] elem;\n}\n```\n\n#### 性能分析\n\n- 所有运算实现的时间复杂度都为 $O(1)$\n- 进栈运算在最坏的情况下的时间复杂度为 $O(n)$ （需要 `doublespace` 时）\n\n### 栈的链接实现\n\n- 使用**不含头结点的单链表**实现栈\n- 从使用方便性上看，将单链表的头指针指向栈顶\n\n![链接栈](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291834782.png)\n\n#### 链接栈类\n\n```cpp\ntemplate <class elemType>\nclass LinkedStack:public stack<elemType>\n{\n  private:\n    struct node\n    {\n      elemType data;\n      node *next;\n      node(const elemType &x , node *n = nullptr)\n      {\n        data = x;\n        next = n;\n      }\n      node():next(nullptr){}\n      ~node(){}\n    };\n    node *top_p;                       // 栈顶指针\n  public:\n    LinkedStack();                    // 构造函数\n    ~LinkedStack();                   // 析构函数\n    bool isEmpty() const;             // 是否为空\n    void push(const elemType &x);     // 进栈\n    elemType pop();                   // 出栈\n    elemType top() const;             // 访问栈顶元素\n};\n```\n\n#### 链接存储的运算实现\n\n##### 构造函数\n\n- 将 `top_p` 初始化为 `nullptr`\n\n```cpp\ntemplate <class elemType>\nLinkedStack<elemType>::LinkedStack()\n{\n  top_p = nullptr;\n}\n```\n\n##### 析构函数\n\n```cpp\ntemplate <class elemType>\nLinkStack<elemType>::~LinkStack()\n{\n  node *tmp;\n  while (top_p != nullptr)\n  {\n    tmp = top_p;\n    top_p = top_p->next;\n    delete tmp;\n  }\n}\n```\n\n##### `push`\n\n- 在表头插入\n\n```cpp\ntemplate <class elemType>\nvoid LinkedStack<elemType>::push(const elemType &x)\n{\n  top_p = new node(x , top_p);\n}\n```\n\n##### `pop`\n\n- 删除表头节点\n\n```cpp\ntemplate <class elemType>\nelemType LinkedStack<elemType>::pop()\n{\n  node *tmp = top_p;\n  elemType x = top_p->data;\n  top_p = top_p->next;\n  delete tmp;\n  return x;\n}\n```\n\n##### `top`\n\n- 返回 `top_p` 指向的节点的 `data`\n\n```cpp\ntemplate <class elemType>\nelemType LinkedStack<elemType>::top() const\n{\n  return top_p->data;\n}\n```\n\n##### `isEmpty`\n\n- 判断 `top_p` 是否为 `nullptr`\n\n```cpp\ntemplate <class elemType>\nbool LinkedStack<elemType>::isEmpty() const\n{\n  return top_p == nullptr;\n}\n```\n\n#### 性能分析\n\n- 所有运算实现的时间复杂度都为 $O(1)$，因为都是对栈顶进行操作\n\n### 栈的应用\n\n#### 递归函数的非递归实现\n\n##### 函数调用\n\n- 递归的本质是函数调用，函数调用又是通过栈实现的，递归时会产生隐式栈\n\n```cpp\nvoid main()\n{\n  ...\n  r1:f1();\n  r2:\n  ..\n}\n\nvoid f1()\n{\n  ...\n  t1:f2();\n  t2:\n  ...\n}\n\nvoid f2()\n{\n  ...\n  ...\n}\n```\n\n![函数执行过程](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503301445662.png)\n\n- 设置一个栈模拟函数调用，当调用发生时，将函数压入栈中\n- 函数返回时，将栈顶元素弹出\n\n###### 递归算法的例子\n\nhanoi 塔算法\n\n```cpp\nvoid Move(int Height , int FromNeedle ,int ToNeedle ,int UsingNeedle) // FromNeedle是起始针，ToNeedle是目标针，UsingNeedle是辅助针\n{\n  if (Height > 0)\n  {\n    Move(Height - 1，FromNeedle , UsingNeeedle,ToNeedle); // 将上面n-1个盘子从FromNeedle移动到UsingNeedle\n    cout << FromNeedle << \"->\" << ToNeedle << endl; // 将最底下的盘子从FromNeedle移动到ToNeedle>\n    Move(Height - 1,UsingNeedle , ToNeedle , FromNeedle); // 将上面的盘子从UsingNeedle移动到ToNeedle\n  }\n}\n```\n\n##### 递归算法的时间复杂度\n\n###### 数学归纳法\n\n以 Hanio 塔问题为例\n\n$$\n\\begin{dcases}\nT(n) = 2T(n-1) + 1 &\\\\\nT(1) = 1 &\n\\end{dcases}\n$$\n\n可以使用数学归纳法证明 $T(n) = 2^n - 1$\n\n###### 递归方程\n\n**主定理**：设 $a \\geq 1$，$b > 1$ 为常数，$f(n)$ 是一个函数，则递归方程\n\n$$\nT(n) = aT(\\frac{n}{b}) + f(n) \\quad (n > 1)\n$$\n\n的解为\n\n1. 若 $f(n) < O\\left(n^{\\log_{b}a}\\right)$，则 $T(n)=O\\left(n^{\\log_{b}a}\\right)$\n2. 若 $f(n) = O\\left(n^{\\log_{b}a}\\right)$，则 $T(n)=O\\left(n^{\\log_{b}a}\\log_{2}n\\right)$\n3. 若 $f(n) > O\\left(n^{\\log_{b}a}\\right)$，则 $T(n)=O\\left(f(n)\\right)$\n\n###### 生成函数\n\n**定义**：设 $u_0 , u_1 , u_2 , \\ldots , u_n ,\\ldots$ 是一无穷序列，称形式幂级数 $\\displaystyle G(t) = \\sum_{i\\geq0}u_it^i$ 为其生成函数\n\n利用生成函数求通项的方法\n\n1. 按照递归关系式消去无限延长的部分\n2. 展开为 $t$ 的幂级数求通项\n\n以 Fibonacci 数列为例\n\n$$\n\\begin{dcases}\nF_{0} =0 & \\\\\nF_{1} =1 & \\\\\nF_{n} =F_{n-1} +F_{n-2} &\n\\end{dcases}\n$$\n\n$$\n\\begin{aligned}\n  &G(t) = F_{0}t^0 + F_{1}t^1 + F_{2}t^2 + F_{3}t^3 + \\cdots \\\\\n  &G(t) = t + t^2 + t^3 + \\cdots \\\\\n  &tG(t)=t^2 + t^3 + t^4 + \\cdots \\\\\n  &t^2G(t)=t^3 + t^4 + t^5 + \\cdots \\\\\n  &(1-t-t^2)G(t) = t \\\\\n  &G(t) = \\frac{t}{1-t-t^2} = \\frac{1}{\\sqrt{5}} \\left(\\frac{1}{1-\\frac{1+\\sqrt{5}}{2}t} - \\frac{1}{1-\\frac{1-\\sqrt{5}}{2}t}\\right) \\\\\n\\end{aligned}\n$$\n\n令 $\\Phi = \\frac{1}{2}(1+\\sqrt{5})$，$\\hat{\\Phi}=\\frac{1}{2}(1-\\sqrt{5})$\n\n$$\nG(t) =\\frac{1}{\\sqrt{5}}(\\frac{1}{1-\\Phi t} - \\frac{1}{1-\\hat{\\Phi}t})\n$$\n\n有 $\\displaystyle\\frac{1}{1-\\Phi t} = \\sum_{n=0}^{\\infty} \\Phi^n t^n$\n\n$$\nG(t) = \\frac{1}{\\sqrt{5}} \\sum_{n=0}^{\\infty} (\\Phi^n t^n - \\hat{\\Phi}^n t^n)\n$$\n\n则\n\n$$\nF_n = \\frac{1}{\\sqrt{5}}(\\Phi^n - \\hat{\\Phi}^n)\n$$\n\n#### 递归消除\n\n以打印正整数为例\n\n##### 递归实现\n\n###### 代码\n\n```cpp\nvoid printNum(int num)\n{\n  if (num >= 10)\n  {\n    printNum(num / 10);\n    cout.put(num % 10 + '0');\n  }\n  else\n  {\n    cout.put(num + '0');\n  }\n}\n```\n\n###### 代码运行过程中栈的变化\n\n1. `push(1234)`\n2. `pop(1234)`，`push(4)`，`push(123)`\n3. `pop(123)`，`push(3)`，`push(12)`\n4. `pop(12)`，`push(2)`，`push(1)`\n5. `pop(1)`，`pop(2)`，`pop(3)`，`pop(4)`\n\n##### 非递归实现\n\n```cpp\nvoid printNum(int num)\n{\n  LinkStack<int> s;\n  int tmp;\n  s.push(num);\n  while (!isEmpty())\n  {\n    tmp = s.pop();\n    if (tmp > 9)\n    {\n      s.push(tmp % 10);\n      s.push(tmp / 10);\n    }\n    else\n    {\n      cout.put(tmp + '0');\n    }\n  }\n}\n```\n\n### 括号匹配\n\n- 判断一个表达式中的括号是否匹配\n- 遇到左括号就入栈，遇到右括号就出栈\n\n判断错误的原则\n\n1. 栈空时遇到右括号\n2. 出栈时遇到不匹配的括号\n3. 栈不空时结束\n\n### 简单的计算数学表达式\n\n#### 前缀式、中缀式和后缀式\n\n对于一个表达式 $a+b$\n\n- 前缀式 `+ab`，波兰式\n- 中缀式 `a+b`\n- 后缀式 `ab+`，逆波兰式\n\n#### 后缀式的优点\n\n- 不需要括号\n- 不需要考虑运算符的优先级\n- 计算机容易处理\n\n#### 后缀式的计算\n\n- 使用栈来存储操作数\n- 遇到操作数就入栈\n- 遇到操作符就出栈两个操作数，进行计算，将结果入栈\n- 最后栈中只剩下一个元素，就是结果\n\n#### 中缀式转换为后缀式的算法\n\n操作方法见[中缀计算式转换为后缀计算式](/本科/编程/数据结构/中缀计算式转换为后缀计算式.md)\n\n## 队列\n\n- 队列的定义\n\n- 先进先出（FIFO，First In First Out）\n- 只允许在一端（队首）进行插入操作，另一端（队尾）进行删除操作\n\n![队列](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503310847159.png)\n\n#### 队列的基本操作\n\n- **创建 `create()`**：创建一个空队列\n- **入队 `enQueue(x)`**：将元素 `x` 入队\n- **出队 `deQueue()`**：删除队首元素并返回其值\n- **访问队首元素 `getHead()`**：返回队首元素的值但不删除\n- **判断是否为空 `isEmpty()`**：若队列空返回 `true`，否则返回 `false`\n\n#### 队列的抽象类\n\n```cpp\ntemplate <class elemType>\nclass queue\n{\n  public:\n    virtual void enQueue(const elemType &x) = 0;       // 入队\n    virtual elemType deQueue() = 0;                    // 出队\n    virtual elemType getHead() const = 0;              // 访问队首元素\n    virtual bool isEmpty() const = 0;                  // 是否为空\n    virtual ~queue() {}                                 // 析构函数\n};\n```\n\n### 队列的顺序实现\n\n- 使用数组来存储队列中的元素\n- 元素下标的范围为 $0$ 到 `maxSize - 1`\n- 存储队里的三种组织方法\n  1. 队头位置固定\n  2. 队头位置不固定\n  3. 循环队列\n\n#### 队头位置固定\n\n![队头位置固定](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311613560.png)\n\n**缺点**：出队的时间复杂度为 $O(n)$，因为出队时需要将所有元素向前移动一位\n\n#### 队头位置不固定\n\n![队头位置不固定](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311614368.png)\n\n**优点**：所有操作的时间复杂度均为 $O(1)$\n**缺点**：浪费大量的空间\n\n#### 循环队列\n\n![循环队列](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311626377.png)\n\n- 入队\n  - `rear = (rear + 1) % maxSize`; `elem[rear] = x`\n- 出队\n  - `front = (front + 1) % maxSize`; `return elem[front]`\n\n为了解决队列空和队列满的判断问题，令 `front` 指向的单元不能存储队列元素，只能起到标志作用\n\n- 队列空：`front == rear`\n- 队列满：`(rear + 1) % maxSize == front`\n\n###### 循环队列类的定义\n\n```cpp\ntemplate <class elemType>\nclass seqQueue:public queue<elemType>\n{\n  private:\n    elemType *elem;\n    int maxSize;\n    int front , rear;\n    void doubleSpace();\n  public:\n    seqQueue(int initSize = 10);        // 构造函数\n    ~seqQueue();                        // 析构函数\n    bool isEmpty();                     // 是否为空\n    void enQueue(const elemType &x);    // 入队\n    elemType deQueue();                 // 出队\n    elemType getHead();                 // 访问队首元素\n};\n```\n\n##### 构造函数\n\n- 申请一块空间，将 `front` 和 `rear` 初始化为 $0$\n\n```cpp\ntemplate <class elemType>\nseqQueue<elemType>::seqQueue(int initSize)\n{\n  elem = new elemType[initSize];\n  maxSize = initSize;\n  front = rear = 0;\n}\n```\n\n##### 析构函数\n\n```cpp\ntemplate <class elemType>\nseqQueue<elemType>::~seqQueue()\n{\n  delete[] elem;\n}\n```\n\n##### `enQueue`\n\n- 先判断队列是否已满，若满则调用 `doubleSpace` 扩大队列的容量\n- 将 `rear` 加 1，指向队尾元素\n\n```cpp\ntemplate <class elemType>\nvoid seqQueue<elemType>::enQueue(const elemType &x)\n{\n  if ((rear + 1) % maxSize == front)\n  {\n    doubleSpace();\n  }\n  rear = (rear + 1) % maxSize;\n  elem[rear] = x;\n}\n```\n\n##### `doubleSpace`\n\n```cpp\ntemplate <class elemType>\nvoid seqQueue<elemType>::doubleSpace()\n{\n  elemType *tmp = elem;\n  elem = new elemType[maxSize * 2];\n  for (int i = 0 ; i < maxSize ; ++i)\n  {\n    elem[i] = tmp[(front + i) % maxSize];\n  }\n  front = 0;\n  rear = maxSize - 1;\n  maxSize *= 2;\n  delete[] tmp;\n}\n```\n\n##### `deQueue`\n\n- 将 `front` 加 1，指向队首元素\n- 返回 `elem[front]`\n\n```cpp\ntemplate <class elemType>\nelemType seqQueue<elemType>::deQueue()\n{\n  front = (front + 1) % maxSize;\n  return elem[front];\n}\n```\n\n##### `getHead`\n\n- 返回 `elem[(front + 1) % maxSize]`\n\n```cpp\ntemplate <class elemType>\nelemType seqQueue<elemType>::getHead()\n{\n  return elem[(front + 1) % maxSize];\n}\n```\n\n##### `isEmpty`\n\n- 判断 `front` 是否等于 `rear`\n\n```cpp\ntemplate <class elemType>\nbool seqQueue<elemType>::isEmpty()\n{\n  return front == rear;\n}\n```\n\n### 队列的链接实现\n\n- 为了方便操作，使用含头节点和尾节点的单链表实现\n\n![链接队列](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311804800.png)\n\n**链接队列的特点**\n\n- 不会出现队列满的情况，但是会出现队列空的情况\n- 队列为空时，单链表中没有节点存在，即头尾指针都为 `nullptr`\n- 保存一个链接队列只需要两个分别指向单链表节点的指针 `front` 和 `rear`\n  - `front` 指向队首元素\n  - `rear` 指向队尾元素\n\n#### 连接队列类\n\n```cpp\ntemplate <class elemType>\nclass linkQueue:public queue<elemType>\n{\n  private:\n    struct node\n    {\n      elemType data;\n      node *next;\n      node(const elemType &x , node *n = nullptr)\n      {\n        data = x;\n        next = n;\n      }\n      node():next(nullptr){}\n      ~node(){}\n    };\n    node *front , *rear;                // 队头和队尾指针\n  public:\n    linkQueue();                       // 构造函数\n    ~linkQueue();                      // 析构函数\n    bool isEmpty() ;              // 是否为空\n    void enQueue(const elemType &x);   // 入队\n    elemType deQueue();                // 出队\n    elemType getHead() const;          // 访问队首元素\n};\n```\n\n##### 构造函数\n\n- 将 `front` 和 `rear` 初始化为 `nullptr`\n\n```cpp\ntemplate <class elemType>\nlinkQueue<elemType>::linkQueue()\n{\n  front = rear = nullptr;\n}\n```\n\n##### `enQueue`\n\n1. 申请一个节点空间 `x`\n2. 将 `rear` 指向的节点的 `next` 指向 `x`\n3. 将 `rear` 指向 `x`\n\n**注意**：存在队列为空的情况，此时我们只需要将 `front` 和 `rear` 都指向 `x` 即可\n\n```cpp\ntemplate <class elemType>\nvoid linkQueue<elemType>::enQueue(const elemType &x)\n{\n  if (rear == nullptr)\n  {\n    front = rear = new node(x);\n  }\n  else\n  {\n    rear = rear->next = new node(x);\n  }\n}\n```\n\n##### `deQueue`\n\n1. 返回 `front` 指向的节点的 `data`\n2. 将 `front` 指向的节点从链表中摘下\n3. 释放空间\n\n**注意**：当队列中只有一个元素时，删除后队列为空，此时需要将 `front` 和 `rear` 都置为 `nullptr`\n\n```cpp\ntemplate <class elemType>\nvoid LinkQueue<elemType>::deQueue()\n{\n  node *tmp = front;\n  if (front)\n  {\n    emelType value = front->data;\n    front = front->next;\n    if (front == nullptr)\n    {\n      rear = nullptr;\n    }\n    delete tmp;\n    return value;\n  }\n}\n```\n\n##### `getHead`\n\n- 返回 `front` 指向的节点的 `data`\n\n```cpp\ntemplate <class elemType>\nelemType linkQueue<elemType>::getHead() const\n{\n  return front->data;\n}\n```\n\n##### `isEmpty`\n\n- 判断 `front` 或 `rear` 是否为 `nullptr`\n\n```cpp\ntemplate <class elemType>\nbool linkQueue<elemType>::isEmpty()\n{\n  return front == nullptr;\n}\n```\n\n##### 析构函数\n\n```cpp\ntemplate <class elemType>\nlinkQueue<elemType>::~linkQueue()\n{\n  node *tmp;\n  while (front != nullptr)\n  {\n    tmp = front;\n    front = front->next;\n    delete tmp;\n  }\n}\n```\n\n## 树\n\n### 树的定义\n\n#### 树的递归定义\n\n- 树是 $n$ 个节点的有限集合，它或者是空集，或者满足\n  - 有一个特殊的节点称为根节点\n  - 除根节点外，其他节点分为 $m$ 个互不相交的有限集合 $T_1 , T_2 , \\ldots , T_m$，每个集合都是一棵树\n\n#### 树的术语\n\n- **根节点、叶节点、内部节点**：\n  - 根节点：没有父节点的节点\n  - 叶节点：没有子节点的节点\n  - 内部节点：有子节点的节点\n- **节点的度和树的度**：\n  - 节点的度：节点的子树个数\n  - 树的度：树中所有节点的度的最大值\n- **儿子节点**\n- **父亲节点**\n- **兄弟节点**\n- **祖先节点**\n- **子孙节点**\n- **节点所处层次**\n- **树的高度**\n- **有序树**\n- **无序树**\n- **森林**\n\n#### 树的运算\n\n- **建树 `create()`**：创建一个空树\n- **清空 `clear()`**：删除树中所有节点\n- **判空 `IsEmpty()`**：判断是否为空树\n- **找根节点 `root()`**：找出树的根节点值，若为空树则返回特殊值\n- **找父节点 `parent()`**：找到节点的父节点，若该节点不存在或为根节点则返回特殊值\n- **找子节点 `child()`**：找到节点的某个子节点，若该节点不存在或没有子节点则返回特殊值\n- **剪枝 `remove()`**：删除节点的某棵子树\n- **遍历 `traverse()`**：访问树上的每个节点\n\n#### 树的抽象类\n\n```cpp\ntemplate <class T>\nclass tree\n{\n  public:\n    virtual void clear() = 0;\n    virtual bool isEmpty() const = 0;\n    virtual T root(T flag) const = 0;\n    virtual T parent(T x , T flag) const = 0;\n    virtual T child(T x , int i , T flag) const = 0;\n    virtual void remove(T x) = 0;\n    virtual void traverse() const = 0;\n};\n```\n\n### 二叉树\n\n#### 二叉树的定义\n\n- 二叉树（Binary Tree）是节点的有限集合，要么为空，要么由一个根节点以及两棵互不相交的左右子树构成，而其左右子树也是二叉树\n\n**注意**：二叉树是**有序树**，必须严格区分左右子树，即使只有一棵子树也要说明是左子树还是右子树，交换左右子树得到另一棵二叉树\n\n二叉树有五种基本形态\n\n1. 空树\n2. 只有一个节点的树\n3. 只有左子树的树\n4. 只有右子树的树\n5. 左右子树都有的树\n\n##### 满二叉树\n\n![满二叉树](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311916690.png)\n\n- 每个节点的度都为 $0$ 或 $2$ 的二叉树称为满二叉树\n- 性质\n  - 高度为 $h$ 的满二叉树有 $2^h - 1$ 个节点\n  - 任意一层的节点个数达到了上限 $2^{n-1}$\n\n##### 完全二叉树\n\n![完全二叉树](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311917668.png)\n\n- 在满二叉树的最底层从右向左依次删除若干个节点得到的树为完全二叉树\n- 满二叉树是完全二叉树，完全二叉树不一定是满二叉树\n- 性质\n  - 所有的叶节点都出现在最低的两层生\n  - 对于任意节点，如果其右子树的高度为 $h$，则其左子树的高度为 $h$ 或 $h+1$\n\n#### 二叉树的性质\n\n1. 二叉树的第 $i$ 层最多有 $2^{i-1}$ 个节点\n2. 二叉树的深度为 $h$，则最多有 $2^h - 1$ 个节点\n3. 对于一棵非空二叉树，若其叶节点个数为 $n_0$，则其度为 $2$ 的节点个数为 $n_2$，则有 $n_0 = n_2 + 1$\n4. 具有 $n$ 个节点的二叉树的高度为 $h$，则 $h = \\lfloor \\log_2n \\rfloor +1$\n5. 对于一棵具有 $n$ 个节点的完全二叉树中的节点按层自上而下，每层从左到右编号，若设根节点的编号为 $1$，则对任一编号为 $u$ 的节点，有\n   1. 如果 $i=1$，则 $u$ 为根节点\n   2. 如果 $i>1$，则 $u$ 的父节点编号为 $\\lfloor \\frac{u}{2} \\rfloor$\n   3. 如果 $2i \\geq n$，则编号为 $i$ 的节点为叶子节点，没有儿子；否则，其左子编号为 $2i$\n   4. 如果 $2i+1 \\geq n$，则编号为 $i$ 的节点无右儿子；否则，其右子编号为 $2i+1$\n\n#### 二叉树的基本运算\n\n- **建树 `create()`**：创建一棵空树\n- **清空 `clear()`**：删除树中所有节点\n- **判空 `isEmpty()`**：判断是否为空树\n- **找根节点 `root()`**：找出树的根节点值，若为空树则返回特殊值\n- **找父节点 `parent()`**：找到节点的父节点，若该节点不存在或为根节点则返回特殊值\n- **找左子节点 `lchild()`**：找到节点的左子节点，若该节点不存在或没有左子节点则返回特殊值\n- **找右子节点 `rchild()`**：找到节点的右子节点，若该节点不存在或没有右子节点则返回特殊值\n- **删除左子树 `delLeft()`**：删除节点的左子树\n- **删除右子树 `delRight()`**：删除节点的右子树\n- **遍历 `traverse()`**：访问树上的每个节点\n\n#### 二叉树的遍历\n\n##### 前序遍历\n\n- 如果树为空，则操作为空\n- 如果树不空，则访问根节点，然后前序遍历左子树，最后前序遍历右子树\n\n##### 中序遍历\n\n- 如果树为空，则操作为空\n- 如果树不空，则中序遍历左子树，然后访问根节点，最后中序遍历右子树\n\n##### 后序遍历\n\n- 如果树为空，则操作为空\n- 如果树不空，则后序遍历左子树，然后后序遍历右子树，最后访问根节点\n\n##### 层次遍历\n\n- 从上到下，从左到右访问树的每个节点\n\n##### 性质\n\n- 由前序遍历和中序遍历可以唯一确定一棵二叉树\n- 由中序遍历和后序遍历可以唯一确定一棵二叉树\n- 由前序遍历和后序遍历**不能**唯一确定一棵二叉树\n\n#### 二叉树抽象类\n\n```cpp\ntemplate <class T>\nclass binaryTree\n{\n  public:\n    virtual void clear() = 0;                     // 清空\n    virtual bool isEmpty() const = 0;             // 是否为空\n    virtual T root(T flag) const = 0;             // 找根节点\n    virtual T parent(T x , T flag) const = 0;     // 找父节点\n    virtual T lchild(T x , T flag) const = 0;     // 找左子节点\n    virtual T rchild(T x , T flag) const = 0;     // 找右子节点\n    virtual void delLeft(T x) = 0;                // 删除左子树\n    virtual void delRight(T x) = 0;               // 删除右子树\n    virtual void preOrder() const = 0;            // 前序遍历\n    virtual void midOrder() const = 0;            // 中序遍历\n    virtual void postOrder() const = 0;           // 后序遍历\n    virtual void levelOrder() const = 0;          // 层次遍历\n};\n```\n\n#### 二叉树的实现\n\n##### 二叉树的顺序实现\n\n- 使用数组来存储二叉树中的节点\n- 将二叉树补全为完全二叉树再进行存储\n- 会导致空间浪费\n\n![顺序二叉树](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504031058255.png)\n\n##### 二叉树的链接实现\n\n- 使用链表来存储二叉树中的节点\n  - 标准形式：`left`，`data`，`right`\n\n![标准形式](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504041445826.png)\n\n- 广义标准形式：`data`，`left`，`parent`，`right`\n\n![广义标准形式](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504041445472.png)\n\n#### 二叉树类\n\n##### 节点类\n\n```cpp\ntemplate <class T>\nstruct Node\n{\n  public:\n    Node *left *right;                                                                // 左右子树指针\n    T data;                                                                           // 节点数据\n    Node():left(nullptr),right(nullptr){}                                             // 默认构造函数\n    Node(T item , Node *L = nullptr,Node *R = nullptr):data(item),left(L),right(R){}  // 带参数的构造函数\n    ~Node(){}                                                                         // 析构函数\n};\n```\n\n##### 二叉树类\n\n```cpp\ntemplate <class T>\nclass binaryTree:public tree<T>\n{\n    friend void printTree(const binaryTree &t, t flag);\n  private:\n    struct Node\n    {\n      public:\n        Node *left *right;\n        T data;\n        Node():left(nullptr),right(nullptr){}\n        Node(T item , Node *L = nullptr,Node *R = nullptr):data(item),left(L),right(R){}\n        ~Node(){}\n    }\n    Node *root;\n  public:\n    binaryTree():root(nullptr){}                    // 构造函数,创建空树\n    binaryTree(T x):root(new Node(x)){}             // 构造函数,创建只有根节点的树\n    ~binaryTree(){}                                 // 析构函数\n    void clear();                                   // 清空\n    bool isEmpty() const;                           // 是否为空\n    T Root(T flag) const;                           // 找根节点\n    T lchild(const T &x , T flag) const;            // 找左子节点\n    T rchild(const T &x , T flag) const;            // 找右子节点\n    void delLeft(const T &x);                       // 删除左子树\n    void delRight(const T &x);                      // 删除右子树\n    void preOrder() const;                          // 前序遍历\n    void midOrder() const;                          // 中序遍历\n    void postOrder() const;                         // 后序遍历\n    void levelOrder() const;                        // 层次遍历\n    coid creatTree(T flag);                         // 创建树\n    T parent(const T &x , T flag) const             // 找父节点\n    {\n      return flag;\n    }\n  private:\n    Node *Find(const T &x, Node *t) const;            // 查找节点\n    void clear(Node *&x);                             // 清空\n    void preOrder(Node *t) const;                     // 前序遍历\n    void midOrder(Node *t) const;                     // 中序遍历\n    void postOrder(Node *t) const;                    // 后序遍历\n};\n```\n\n##### 构造函数\n\n将 `root` 初始化为 `nullptr`\n\n```cpp\ntemplate <class T>\nbinaryTree<T>::binaryTree()\n{\n  root = nullptr;\n}\n```\n\n##### `isEmpty`\n\n- 判断 `root` 是否为 `nullptr`\n\n```cpp\ntemplate <class T>\nbool binaryTree<T>::isEmpty() const\n{\n  return root == nullptr;\n}\n```\n\n##### `Root`\n\n返回 `Root` 指向的节点的数据，若为空树则返回特殊值\n\n```cpp\ntemplate <class T>\nT binaryTree<T>::Root(T flag)const\n{\n  if (root == nullptr)\n  {\n    return flag;\n  }\n  else\n  {\n    return root->data;\n  }\n}\n```\n\n##### 二叉树的遍历\n\n###### 前序遍历\n\n1. 访问根节点\n2. 前序遍历左子树\n3. 前序遍历右子树\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::preOrder(binaryTree<T>::Node *t) const\n{\n  if (t == nullptr)\n  {\n    return;\n  }\n  else\n  {\n    cout << t -> data << \" \";\n    preorder(t -> left);\n    preorder(t -> right);\n  }\n}\n```\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::preOrder() const\n{\n  cout << \"\\n前序遍历：\"\n  preOrder(root);\n}\n```\n\n###### 中序遍历\n\n1. 中序遍历左子树\n2. 访问根节点\n3. 中序遍历右子树\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::midOrder(binaryTree<T>::Node *t) const\n{\n  if (t == nullptr)\n  {\n    return;\n  }\n  else\n  {\n    midOrder(t -> left);\n    cout << t -> data << \" \";\n    midOrder(t -> right);\n  }\n}\n```\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::midOrder() const\n{\n  cout << \"\\n中序遍历：\"\n  midOrder(root);\n}\n```\n\n###### 后序遍历\n\n1. 后序遍历左子树\n2. 后序遍历右子树\n3. 访问根节点\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::postOrder(binaryTree<T>::Node *t) const\n{\n  if (t == nullptr)\n  {\n    return;\n  }\n  else\n  {\n    postOrder(t -> left);\n    postOrder(t -> right);\n    cout << t -> data << \" \";\n  }\n}\n```\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::postOrder() const\n{\n  cout << \"\\n后序遍历：\"\n  postOrder(root);\n}\n```\n\n##### `size`\n\n```cpp\ntemplate <class T>\nint binaryTree<t>::size(binarytree<t>::Node *t) const\n{\n  if (t = nullptr)\n  {\n    return 0;\n  }\n  else\n  {\n    return 1+sizze(t -> left)+size(t -> right);\n  }\n}\n```\n\n```cpp\ntemplate <class T>\nint binaryTree<T>::size() const\n{\n  return size(root);\n}\n```\n\n##### `height`\n\n```cpp\ntemplate <class T>\nint binaryTree<T>::size(binaryTree<T>::Node *t) const\n{\n  if (t == nullptr)\n  {\n    return 0;\n  }\n  else\n  {\n    int lt = height(t -> left);\n    int rt = height(t -> right);\n    return (lt > rt ? lt : rt) + 1;\n  }\n}\n```\n\n```cpp\ntemplate <class T>\nint binaryTree<T>::height() const\n{\n  return height(root);\n}\n```\n\n##### 层次遍历\n\n- 使用链接队列实现\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::levelOrder() const\n{\n  linkQueue<Node *> que;\n  Node *tmp;\n  cout << \"\\n层次遍历：\";\n  que.enQueue(root);\n  while (!que.isEmpty())\n  {\n    tmp = que.deQueue();\n    cout << tmp -> data << \" \";\n    if (tmp.left)\n    {\n      que.enQueue(tmp -> left);\n    }\n    if (tmp.right)\n    {\n      que.enQueue(tmp -> right);\n    }\n  }\n}\n```\n\n##### `clear`\n\n- 递归删除树中所有节点\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::clear(Node *&t)\n{\n  if (t == nullptr)\n  {\n    return;\n  }\n  else\n  {\n    clear(t -> left);\n    clear(t -> right);\n    delete t;\n    t = nullptr;\n  }\n}\n```\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::clear()\n{\n  clear(root);\n}\n```\n\n##### 析构函数\n\n- 调用 `clear` 函数删除树中所有节点\n\n```cpp\ntemplate <class T>\nbinaryTree<T>::~binaryTree()\n{\n  clear();\n}\n```\n\n##### `Find`\n\n- 使用前序遍历查找 `x` 节点\n- 首先检查根节点是否存放 `x` 的值，若是则返回根节点地址\n- 对左子树递归调用 `Find` 函数，若返回空指针则说明 `x` 不在左子树中\n- 对右子树递归调用 `Find` 函数，若返回空指针则说明 `x` 不在右子树中\n\n```cpp\ntemplate <class T>\nstruct binaryTree<T>:: Node *binaryTree<T>::Find(const T &x ,binaryTree<T>::Node *t) const\n{\n  if (t == nullptr)\n  {\n    return nullptr;\n  }\n  else if (t -> data == x)\n  {\n    return t;\n  }\n  else\n  {\n    if (tmp = Find(x,t->left))\n    {\n      return tmp;\n    }\n    else\n    {\n      return Find(x,t->right);\n    }\n  }\n}\n```\n\n##### `delLeft`\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::delLeft(const T &x)\n{\n  Node *tmp = Find(x,root);\n  if (tmp == nullptr)\n  {\n    return;\n  }\n  clear(tmp -> left);\n}\n```\n\n##### `delRight`\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::delRight(const T &x)\n{\n  Node *tmp = Find(x,root);\n  if (tmp == nullptr)\n  {\n    return;\n  }\n  clear(tmp -> right);\n}\n```\n\n##### `lchild`\n\n```cpp\ntemplate <class T>\nT binaryTree<T>::lchild(const T &x ,T flag) const\n{\n  Node *tmp = Find(x,root)\n  if (tmp == nullptr || tmp -> left ==nullptr)\n  {\n    return flag;\n  }\n  else\n  {\n    return tmp -> left;\n  }\n}\n```\n\n##### `rchild`\n\n```cpp\ntemplate <class T>\nT binaryTree<T>::rchild(const T &x ,T flag) const\n{\n  Node *tmp = Find(x,root)\n  if (tmp == nullptr || tmp -> right ==nullptr)\n  {\n    return flag;\n  }\n  else\n  {\n    return tmp -> right;\n  }\n}\n```\n\n##### `createTree`\n\n- 创建过程（类似层次遍历？）\n  1. 输入根节点的值，创建根节点\n  2. 对已添加到树上的每个节点，依次输入它的两个儿子的值，若没有儿子则输入 `flag`\n- 实现过程\n  - 使用队列，将新加入到书中的节点添加到队列中\n  - 依次出队，对每个出队的元素输入它的儿子\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::createTree(T flag)\n{\n  linkQueue<Node *> que;\n  Node *tmp;\n  T x , ldata , rdata;\n\n  // 创建树，flag表示空\n  cout << \"\\n输入根节点：\"\n  cin >> x;\n  root = new Node(x);\n  que.enQueue(root);\n  while (!que.isEmpty())\n  {\n    tmp = que,deQueue();\n    cout << \"\\n输入\" << tmp -> data << \"的两个儿子（\"<<flag<<\"表示空节点）：\";\n    cin >> ldata >> rdata;\n    if (ldata != flag)\n    {\n      tmp -> left = new Node(ldata);\n      que.enQueue(tmp -> left);\n    }\n    if (rdata != flag)\n    {\n      tmp -> right = new Node(rdata);\n      que.enQueue(tmp -> right);\n    }\n  }\n  cout << \"that's good!\\n\";\n}\n```\n\n##### `printTree`\n\n- 层次遍历输出每个节点和它的左右孩子\n\n```cpp\ntemplate <class T>\nvoid printTree(const binaryTree<T> &t,T flag)\n{\n  linkQueue<T> que;\n  que.enQueue(t.root());\n  while(!que.isEmpty())\n  {\n    T tmp = que.deQueue();\n    T l = tmp.lchild(tmp , flag);\n    T r = tmp.rchild(tmp , flag);\n    cout << p << \" \" << l << \" \" << r << endl;\n    if (l != flag)\n    {\n      que.enQueue(l);\n    }\n    if (r != flag)\n    {\n      que.enQueue(r);\n    }\n  }\n}\n```\n\n#### 二叉树遍历的非递归实现\n\n##### 前序遍历\n\n1. 将根节点入栈\n2. 栈顶元素出栈并输出值\n3. 将左右子树入栈（先右后左，以便输出时先输出左子树）\n4. 循环直至栈为空\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::preOrder(const binaryTree<T>::Node *t) const\n{\n  linkStack<Node *> s;\n  Node *tmp = t;\n\n  cout << \"\\n前序遍历：\";\n  while (!s.isEmpty())\n  {\n    tmp = s.pop();\n    cout << tm -> data << \" \";\n    if (tmp -> right != nullptr)\n    {\n      s.push(tmp -> right);\n    }\n    if (tmp -> left != nullptr)\n    {\n      s.push(tmp -> left);\n    }\n  }\n}\n```\n\n##### 中序遍历\n\n1. 根节点入栈\n2. 左子树入栈\n3. 栈顶元素出栈并输出值\n4. 左子树出栈完成之后根节点出栈\n5. 右子树入栈\n6. 循环直至栈为空\n\n栈的设计\n\n- 根节点入栈出栈两次\n  - 第一次出栈时不能被访问，立刻重新入栈，并将左子树入栈\n  - 第二次出栈后返回值，并且将右子树入栈\n- 对于根节点要记住\n  - 在哪棵树上\n  - 第几次出栈\n- 每个节点在某种意义上都是根节点\n\n###### `StNode` 类定义\n\n```cpp\nstruct StNode\n{\n  Node *node;\n  int TimesPop;\n  StNode(Node *N=nullptr):node(N),TimesPop(0){}\n};\n```\n\n###### 中序遍历的非递归实现\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::midOrder(const binaryTree<T>::Node *t) const\n{\n  linkStack<Node *t> s;\n  StNode current(root);\n\n  cout << \"\\n中序遍历：\";\n  s.push(current);\n  while(!s.isEmpty())\n  {\n    current = s.pop();\n    if (++current.TimesPop == 2)\n    {\n      cout << current.node -> data;\n      if (current.node -> right != nullptr)\n      {\n        s.push(StNode(current.node -> right));\n      }\n    }\n    else\n    {\n      s.push(current);\n      if (current.node -> left != nullptr)\n      {\n        s.push(StNode(current.node -> left));\n      }\n    }\n  }\n}\n```\n\n##### 后序遍历\n\n1. 根节点入栈\n2. 左子树入栈\n3. 右子树入栈\n4. 栈顶元素出栈并输出值\n5. 循环直至栈为空\n\n```cpp\ntemplate <class T>\nvoid binaryTree<T>::postOrder(const binaryTree<T>::Node *t) const\n{\n  linkStack<Node *> s;\n  StNode current(root);\n\n  cout << \"\\n后序遍历：\";\n  s.push(current);\n  while(!s.isEmpty())\n  {\n    current = s.pop();\n    if (++current.TimesPop == 3)\n    {\n      cout << current.node -> data;\n      continue;\n    }\n    else\n    {\n      s.push(current);\n      if (current.node -> right != nullptr)\n      {\n        s.push(StNode(current.node -> right));\n      }\n      if (current.node -> left != nullptr)\n      {\n        s.push(StNode(current.node -> left));\n      }\n    }\n  }\n}\n```\n\n### 哈夫曼树和哈夫曼编码\n\n#### 字符的机内表示\n\n- 用二进制数来表示字符\n- 前缀编码\n  - 字符只放在叶结点中\n  - 字符编码可以有不同的长度\n  - 每个字符的编码都不可能是其他字符编码的前缀\n  - 可以被唯一解码\n\n#### 哈夫曼树\n\n- 最小代价，即带权路径长度最小的二叉树\n- 所有字符都在叶结点上\n- 权值大的字符离根节点近，权值小的字符离根节点远\n- 哈夫曼编码是一种前缀编码\n\n![huffmanTree](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141528425.png)\n\n#### 哈夫曼算法\n\n1. 给定一个具有 $n$ 个权值 $\\{w_1 , w_2 , \\ldots , w_4\\}$ 的节点的集合 $\\mathbb{A}$\n   $\\mathbb{F} = \\{T_1 , T_2 , \\ldots , T_n\\}$\n2. 初始时，设集合 $\\mathbb{A} = \\mathbb{F}$\n3. 执行从 $i$ 到 $n-1$ 的循环\n   1. 从当前集合中选取权值最小、次最小的两个节点，以这两个节点作为内部节点 $b_i$ 的左右儿子，$b_i$ 的权值为这两个节点的权值之和\n   2. 集合中去除这两个节点，将 $b_i$ 加入其中\n4. 循环结束后，集合 $\\mathbb{A}$中只剩下一个节点 $b_n$，即为哈夫曼树的根节点\n\n#### 哈夫曼编码\n\n- 每个节点的编码是从根节点到该节点的路径\n- 左子树为 `0`，右子树为 `1`\n\n#### 哈夫曼树类的实现\n\n1. 接受一组符号以及对应的权值,并返回每个符号对应的哈夫曼编码\n2. 有两个公有的成员函数\n   1. 构造函数：接受一组待编码的符号以及它们的权值，构造哈夫曼树\n   2. `getCode`：根据保存的哈夫曼树，返回每个符号对应的哈夫曼编码\n\n##### 哈夫曼树的存储\n\n- 在哈夫曼树中，每个要编码的元素都是一个叶节点，其余的节点都是度为 $2$ 的节点\n- 若待编码的元素个数为 $n$，则哈夫曼树的节点数为 $2n-1$\n- 哈夫曼树使用一个大小为 $2n$ 的数组来存储，不使用 $0$ 节点，将根节点存储在下标为 $1$ 的位置，叶节点依次存储在下标为 $n+1$ 到 $2n$ 的位置，$0$ 结点作为结束的判断依据\n- 每个数组保存 **节点的数据**，**节点的权值**，**节点的父节点下标**，**左子节点下标**，**右子节点下标**\n\n```cpp\ntemplate <class Type>\nclass hfTree\n{\n  private:\n    struct Node\n    {\n      Type data; //节点数据\n      int weight; //节点权值\n      int parent; //父节点下标\n      int left , right; //左右子节点下标\n    };\n\n    Node *elem;\n    int length;\n\n  public:\n    struct hfCode\n    {\n      Type data; //节点数据\n      string code; //哈夫曼编码\n    };\n\n    hfTree(const Type *v , const int *w , int size);\n    void getCode(hfCode result[]);\n    ~hfTree()\n    {\n      delete [] elem;\n    }\n};\n```\n\n##### 构造函数\n\n```cpp\ntemplate <class Type>\nhfTree<Type>::hfTree(const Type *v , const int *w , int size)\n{\n  const int MAX_INT = 32767;\n  int min1 , min2; // 最小树、次最小树的权值\n  int x , y ; // 最小树、次最小树的下标\n\n  /* 初始化 */\n  length = 2 * size ;                                            // 哈夫曼树的节点数为 $2\\text{size}-1$，但我们只需要存储 $2\\text{size}$ 个节点\n  elem = new Node[length];                                       // 创建一个大小为 $2\\text{size}$ 的数组来存储哈夫曼树的节点\n  for (int i = size ; i < length ; i++)                          // 对数组 `elem` 中的节点进行初始化，前 $\\text{size}$ 个节点存储待编码的元素，从下标 `size` 开始，依次存储待编码的元素的权值\n  {\n    elem[i].weight = w[i-size]; // 储存权值\n    elem[i].data = v[i-size]; // 储存待编码的元素\n    elem[i].parent = elem[i].left = elem[i].right = 0;           // 初始化父节点、左子节点和右子节点的下标为 `0`\n  }\n\n  /* 构造新的二叉树 */\n  for (int i = size - 1 ; i > 0 ; i--)                           // 从下标为 `size-1` 的节点开始，依次向上构造哈夫曼树的节点\n  {\n    min1 = min2 = MAX_INT;                                       // 初始化这两个变量为一个很大的值，以确保能够找到真正最小和次小的权值\n    x = y = 0;\n    for (int j = i + 1 ; j < length ; j++)                       // 遍历当前节点之后的所有节点\n    {\n      if (elem[j].parent == 0)                                   // 判断是否未加入树中\n      {\n        if (elem[j].weight < min1)                               // 找到真正的最小值和次小值以及他们对应的下标\n        {\n          min2 = min1;\n          min1 = elem[j].weight;\n          x = y;\n          y = j;\n        }\n        else if(elem[j].weight < min2)\n        {\n          min2 = elem[j].weight;\n          x = j;\n        }\n      }\n    }\n    elem[i].weight = min1 + min2;                                // 将最小值和次小值的权值相加，作为当前节点的权值\n    elem[i].left = x;                                            // 将最小值的节点作为当前节点的左子节点\n    elem[i].right = y;                                           // 将次小值的节点作为当前节点的右子节点\n    elem[x].parent = i;                                          // 将当前节点作为最小值节点的父节点\n    elem[y].parent = i;                                          // 将当前节点作为次小值节点的父节点\n  }\n}\n```\n\n##### `getCode`\n\n```cpp\ntemplate <class Type>\nvoid hdTree<Type>::getcode(hfCode result[])\n{\n  int size = length / 2 ;\n  int p , s ;\n  for (int i = size; i < length; ++i)\n  {\n    result[i -size].data = elem[i].data;\n    result[i -size].code = \"\";\n    p = elem[i].parent; s = i;\n    while (p)\n    {\n      if (elem[p].left == s)\n      {\n        result[i -size].code = '0' + result[i -size].code;\n      }\n      else\n      {\n        result[i -size].code = '1' + result[i -size].code;\n      }\n      s = p;\n      p = elem[p].parent;\n    }\n  }\n}\n```\n\n### 树和森林\n\n#### 树的存储实现\n\n- **标准形式**：除了数据字段之外，还有 $K$ 个指针字段，指向 $K$ 个孩子节点，其中 $K$ 是树的度\n- **广义标准形式**：除了数据字段之外，还有 $K$ 个指针字段，指向 $K$ 个孩子节点和一个指针字段，指向父节点\n\n![树的存储实现](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504211450009.png)\n\n#### 树的表示方法\n\n##### 孩子链表示法\n\n- 每个节点的所有孩子组织成一个链表\n- 节点由两个部分组成\n\n  - 储存数据元素值的数据部分\n  - 指向孩子链的指针\n\n- **静态**的孩子链表：树的所有节点存放在一个名叫表头数组的**数组**中\n- **动态**的孩子链表：树的所有节点组织成一个**链表**\n\n##### 孩子兄弟链表示法\n\n- 将一棵树转化为二叉树\n- 左子树指向第一颗子树树根的指针\n- 右子树指向兄弟节点的指针\n\n![孩子兄弟链](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504211559361.png)\n\n##### 双亲表示法\n\n- 每一个节点由两个部分组成\n  - 储存数据元素的数据字段\n  - 储存父节点的父指针字段\n- 便于查找节点的祖先，但是不便于查找指定节点的子孙\n\n### 树的遍历\n\n#### 前序遍历\n\n1. 访问根节点\n2. 依次前序遍历所有子树\n\n#### 后序遍历\n\n1. 依次后序遍历所有子树\n2. 访问根节点\n\n#### 层次遍历\n\n1. 访问根节点\n2. 若第 $i$ 层已被访问，且第 $i+1$ 层的结点尚未被访问，则从左到右依次访问第 $i+1$ 层的结点\n\n#### 特点\n\n- 树的前序遍历和用儿子兄弟链表示法转化的二叉树的前序遍历是相同的\n- 树的后序遍历和用儿子兄弟链表示法转化的二叉树的中序遍历是相同的\n\n由前序遍历和后序遍历可以唯一确定一棵树\n\n### 树、森林和二叉树\n\n#### 森林的定义\n\n- 森林通常被定义为树的集合或树的序列\n- 存储\n  - 存储森林的每一棵树\n  - 表示这些树属于同一个森林\n\n#### 森林的二叉树存储\n\n1. 将每棵树 $T_i$ 转化为二叉树 $B_i$\n2. 将 $B_i$ 作为 $B_{i-1}$ 根节点的右子树\n\n## 优先级队列\n\n### 优先级队列的定义\n\n- 节点之间的关系是由节点的优先级决定的\n- 优先级高的先出队，优先级低的后出队\n- 继承于队列的抽象类\n\n### 优先级队列的简单实现\n\n1. 入队时进行排序，出队操作不变\n   入队时间复杂度为 $O(n)$，出队时间复杂度为 $O(1)$\n2. 出队时进行排序，入队操作不变\n   入队时间复杂度为 $O(1)$，出队时间复杂度为 $O(n)$\n\n### 二叉堆\n\n- 二叉堆是一个完全二叉树\n- 二叉堆满足下述关系之一（下标是按层次遍历的次序）\n  1. **最大化堆**：$k_i > k_{2i},\\quad k_i > k{2i+1} \\quad (i = 1,2,\\ldots,\\lfloor \\frac{n}{2}\\rfloor$\n  2. **最小化堆**：$k_i < k_{2i},\\quad k_i < k{2i+1} \\quad (i = 1,2,\\ldots,\\lfloor \\frac{n}{2}\\rfloor)$\n- 后面的讨论都以最小化堆为例\n\n![binaryHeap](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504081709343.png)\n\n#### 二叉堆的特性\n\n- **结构性**\n  - 符合完全二叉树的结构\n- **有序性**\n  - 父节点小于子节点（最小化堆）\n  - 父节点大于子节点（最大化堆）\n\n### 基于二叉堆的优先级队列\n\n- 如果数值越小，优先级越高，则可以用一个最小化堆存储优先级队列\n- 最小化堆中，最小元素为根元素，存放在数组下标为 `1` 的位置\n  - 获取队头元素的操作为返回下标为 `1` 的元素值\n  - 出队操作为删除下标为 `1` 的元素，重新调整堆\n  - 入队操作为将新元素插入到堆的最后一个位置，然后向上调整堆\n\n### 优先级队列类的定义\n\n```cpp\ntemplate <class T>\nclass priorityQueue:public quque<T>\n{\n  private:\n    int currentSize;\n    T *array;\n    int maxSize;\n    void doubleSpace();\n    voif buildHeap();  // 建堆，被 priorityQueue() 调用\n    void percolateDown(int hole); // 向下过滤\n  public:\n    priorityQueue(int capacity = 100) // 构造函数\n    {\n      array = new T[capacity];\n      maxSize = capacity;\n      currentSize = 0;\n    }\n    priorityQueue(const T data[] , int size); // 构造函数\n    ~priorityQueue(); // 析构函数\n    bool isEmpty() const // 是否为空\n    {\n      return currentSize == 0;\n    }\n    void enQueue(const T &x); //入队\n    T deQueue(); // 出队\n    T getHead() const // 获取队头元素\n    {\n      return array[1];\n    }\n};\n```\n\n#### `enQueue`\n\n- 在堆中插入一个新元素\n- 在最大序号中的元素之后插入新的元素或者节点\n- 如果没有违反堆的**有序性**，则操作结束，否则向父节点移动，直到满足有序性或者到达根节点\n\n```cpp\ntemplate <class T>\nvoid priorityQueue<T>::enQueue(const T &x)\n{\n  if (currentSize == maxSize - 1)\n  {\n    doubleSpace();\n  }\n\n  // 向上过滤\n  int hole = ++currentSize;\n  for (;hole > 1 && x < array[hole/2] ; hole /= 2)\n  {\n    array[hole] = array[hole/2];\n  }\n  array[hole] = x;\n}\n```\n\n- 最坏情况时间复杂度为 $O(\\log n)$\n- 平均情况来说，过滤会提前结束。资料表明平均为 $2.6$ 次比较，即平均上移 $1.6$ 层\n\n#### `deQueue`\n\n- 删除堆顶元素，同时删除最后一个节点，以满足是完全二叉树\n- 空节点向下过滤，找到一个较小的子节点，将该儿子放入空节点，空节点向下推一层，直至删除的节点能够被放入空节点\n\n```cpp\ntemplate <class T>\nT priorityQueue<T>::deQueue()\n{\n  T minItem;\n  minItem = array[1];\n  array[1] = array[currentSize--];\n  percolateDown(1);\n  return minItem;\n}\n```\n\n#### `percolateDown`\n\n```cpp\ntemplate <class T>\nvoid priorityQueue<T>::precolateDown(int hole)\n{\n  int child;\n  T tmp = array[hole];\n\n  for (;hole * 2 <= currentSize; hole = child)\n  {\n    child = hole * 2;\n    if (child != currentSIze && array[child + 1] < array[child])\n    {\n      child++;\n    }\n    if (array[child] < tmp)\n    {\n      array[hole] = array[child];\n    }\n    else\n    {\n      break;\n    }\n  }\n  array[hole] = tmp;\n}\n```\n\n#### `buildHeap`\n\n##### 连续插入\n\n- 时间复杂度为 $O(n \\log n)$\n\n##### 自上而下调整二叉树\n\n- 对左子树和右子树递归调用 `buildHeaap`，再对根节点向下过滤\n- 时间复杂度为 $O(n)$\n\n##### 非递归实现\n\n从编号最大的非叶节点 $\\lfloor \\frac{n}{2} \\rfloor$ 开始逆层次遍历，每个节点调用 `percolateDown`，直到根节点\n\n## 集合与静态查找表\n\n### 集合的基本概念\n\n1. 数据元素除了属于同一集合之外，没有任何逻辑关系\n2. 每个数据元素有一个区别于其他元素的唯一标识，称为**键值**或者**关键字值**\n\n```cpp\ntemplate<calss KEY , class OTHER>\nstruct SET\n{\n  KEY key; // 关键字值\n  OTHER other; // 其他信息\n}\n```\n\n运算\n\n- **查找** 某一元素是否存在\n- 将集合中的元素按照它的唯一标识排序\n\n这些都是对 `key` 的操作\n\n### 集合的存储\n\n- 任何容器都能存储集合\n- 常用的表达形式是借鉴于**线性表**和**树**\n- 唯一一个仅适合于存储和处理集合的数据结构是**散列表**\n\n### 查找\n\n#### 查找的基本概念\n\n- 用于查找的集合称之为**查找表**\n- 查找表的分类\n  - 静态查找表\n  - 动态查找表\n  - 内部查找\n  - 外部查找\n\n#### 静态查找表\n\n- 数据元素的个数和值不允许变化的查找表称为静态查找表\n- 不允许插入和删除操作\n- 实例：字典\n- 可以用顺序表 `seqList` 存储，或直接存储在 C++的原始数组中\n\n#### 无序表的查找\n\n- 只能做顺序查找\n- 时间复杂度为 $O(n)$\n- 可以使用哨兵减少 $n$ 次查找\n\n- 优化后的顺序查找\n\n```cpp\ntemplate <class KEY, class OTHER>\nint seqSearch(SET<KEY, OTHER> data[] , int size , const KEY &x)\n{\n  data[0].key = x;\n  for (int i = size ; x != data[i].key; --i)\n  {\n    return i;\n  }\n}\n13\n```\n\n#### 有序表的查找\n\n##### 顺序查找\n\n- 与无序表的顺序查找类似，只是当被查元素在表中不存在时，不需要查到表头\n- 时间复杂度为 $O(n)$\n\n- 有序表的顺序查找\n\n```cpp\ntemplate <class KEY, class OTHER>\nint seqSearch(SET<KEY , OTHER> data[] , int size , const KEY &x)\n{\n  data[0].key = x;\n  for (int i = size ; x < data[i].key; --i);\n  if (x == data[i].key)\n  {\n    return i;\n  }\nelse\n{\n  return 0;\n}\n```\n\n##### 二分查找\n\n1. 每次检查中间的元素（向下取整）\n2. 若中间的元素等于要查找的元素，则查找成功\n3. 若中间的元素大于要查找的元素，则在左半部分继续查找\n4. 若中间的元素小于要查找的元素，则在右半部分继续查找\n\n- 时间复杂度为 $O(\\log n)$\n\n```cpp\ntemplate <class KEY, class OTHER>\nint binarySearch(SET<KEY , OTHER>data[] , int size , const KEY &x)\n{\n  int low = 1,  high = size, mid;\n    while (low <= high)\n    {                 //查找区间存在\n      mid = (low + high) / 2;         //计算中间位置\n      if ( x == data[mid].key )\n      {\n        return mid;\n      }\n      if (x < data[mid].key)\n      {\n        high = mid - 1;\n      }\n      else low = mid + 1;\n    }\n  return 0;\n}\n```\n\n##### 插值查找\n\n- 适用于数据分布较为均匀的情况\n- 计算中间位置的公式为\n\n$$\n\\text{next} = \\text{low} + \\frac{(x - a[\\text{low}])}{(a[\\text{high}] - a[\\text{low}])} \\times (\\text{high} - \\text{low}+1)\n$$\n\n- 缺点：计算量大\n\n##### 分块查找\n\n- 将数据分成若干个块，每个块内可以是有序和无序的，但块之间是有序的\n- 查找分为两个阶段\n  1. 查找索引\n  2. 查找块\n     设表长为 $n$，块长为 $m$\n     则平均所需的时间为 $\\frac{m+1}{2}+\\frac{\\frac{n}{m}+1}{2}$\n     当 $m=\\sqrt{n}$ 时，平均所需的时间**最短**，为 $O(\\sqrt{n})$\n\n## 动态查找表\n\n### 二叉查找树\n\n#### 抽象类\n\n```cpp\ntemplate <class KEY, class OTHER>\nclass dynamicSearchTable\n{\n  public:\n    virtual SET<KEY, OTHER> *find(const KEY &x) const = 0;\n    virtual void insert(const SET<KEY, OTHER> &x) = 0;\n    virtual void remove(const KEY &x) = 0;\n    virtual ~dynamicSearchTable() {};\n};\n```\n\n#### 二叉查找树的定义\n\n- 对于任意一个节点 `p`\n  - `p` 的左子树中所有节点的值都小于 `p` 的值\n  - `p` 的右子树中所有节点的值都大于 `p` 的值\n  - `p` 的左子树和右子树都是二叉查找树\n- 二叉查找树的**中序遍历**是排好序的，又称为**排序树**\n- 最大和最小的元素不一定存放在叶节点中，但是最大节点的右子树、最小节点的左子树都是空的\n\n#### 二叉查找树的存储实现\n\n- 使用二叉链表存储，需要一个指向根节点的数据成员\n\n```cpp\ntemplate <class KEY, class OTHER>\nclass BinarySearchTree:public dynamicSearchTable<KEY , OTHER>\n{\n  private:\n    struct BinaryNode\n    {\n      SET<KEY, OTHER> data;\n      BinaryNode*left;\n      BinaryNode*right;\n      BinaryNode( const SET<KEY, OTHER> & thedata,\n      BinaryNode *lt = nullptr , BinaryNode *rt = nullptr):data(thedata) , left(lt) , right(rt){}\n    };\n    BinaryNode*root;\n\n  public:\n    BinarySearchTree();\n    ~BinarySearchTree();\n    SET<KEY, OTHER> *find(const KEY &x) const ;\n    void insert(const SET<KEY , OTHER> &x );\n    void remove(const KEY &x);\n\n  private:\n    void insert(const SET<KEY , OTHER> &x, BinaryNode *&t);\n    void remove(const KEY &x , BinaryNode *&t);\n    SET<KEY , OTHER> *find(const KEY &x , BinaryNode *t ) const;\n    void makeEmpty(BinaryNode *t);//析构用，同二叉树的clear\n};\n```\n\n#### 二叉查找树的操作\n\n##### 查找\n\n1. 检查根节点的关键字值\n2. 如果等于要查找的值，则查找成功，返回根节点地址\n3. 如果小于要查找的值，则在右子树中查找\n4. 如果大于要查找的值，则在左子树中查找\n\n- 公有函数 `find(const KEY &x)`\n\n```cpp\ntemplate <class KEY, class OTHER>\nSET<KEY, OTHER> *BinarySearchTree<KEY, OTHER>::find(const KEY &x ) const\n{\n  return find( x, root );\n}\n```\n\n- 私有辅助函数 `find(const KEY &x, BinaryNode *t)`\n\n```cpp\ntemplate <class KEY, class OTHER>\nSET<KEY, OTHER> *BinarySearchTree<KEY, OTHER>::find(const KEY &x, BinaryNode *t ) const\n{\n  if (t == nullptr || t->data.key == x)\n  {\n    return (SET<KEY , OTHER> *)t;//强制类型转换\n  }\n  if(x < t->data.key)\n  {\n    return find(x , t->left);\n  }\n  else\n  {\n    return find(x , t->right );\n  }\n}\n```\n\n##### 插入\n\n- 若二叉树为空树，则插入的节点为根节点\n- 若二叉树非空\n\n  - 判断是左儿子还是右儿子，作为叶节点插入\n\n- 公有的 `insert(const SET<KEY, OTHER> &x)`\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid BinarySearchTree<KEY, OTHER>::insert(const SET<KEY , OTHER> &x)\n{\n  insert(x, root);\n}\n```\n\n- 私有的 `insert(const SET<KEY, OTHER> &x, BinaryNode *&t)`\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid BinarySearchTree<KEY , OTHER>::insert(const SET<KEY , OTHER> &x, BinaryNode *&t)\n{\n  if(t == nullptr)\n  t = new BinaryNode(x , nullptr , nullptr);\n  else if(x.key< t->data.key)\n  {\n    insert(x, t->left);\n  }\n  else if(x.key > t->data.key)\n  {\n    insert(x , t->right);\n  }\n  else\n  {\n    cout << x.key << “is exist” << endl;\n  }\n}\n```\n\n##### 删除\n\n- $P_L$ 和 $P_R$ 分别是 $P$ 的左子树和右子树\n\n  1.  如果 $P$ 是叶节点，则直接删除\n  2.  如果 $P$ 只有一个子树，则将 $P$ 的父节点指向 $P$ 的子树\n  3.  如果 $P$ 有两个子树，则\n      1. 找到 $P$ 的右子树中最左的节点或者左子树的最右节点 $Q$\n      2. 将 $Q$ 的值赋给 $P$\n      3. 删除 $Q$ 节点\n\n- 公有的 `remove(const KEY &x)`\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid BinarySearchTree<KEY, OTHER>::remove(const KEY &x)\n{\n  remove(x , root);\n}\n```\n\n- 私有的 `remove(const KEY &x, BinaryNode *&t)`\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid BinarySearchTree<KEY , OTHER>::remove(const KEY &x , BinaryNode *&t)\n{\n  if(t == nullptr)\n  {\n    cout << x.key << \"is not exist\" << endl;\n  }\n  else if(x.key < t->data.key)\n  {\n    remove(x , t->left);\n  }\n  else if(x.key > t->data.key)\n  {\n    remove(x , t->right);\n  }\n  else if(t->left != nullptr && t->right != nullptr)\n  {\n    BinaryNode *p = t->right;\n    while(p->left != nullptr)\n    {\n      p = p->left;\n    }\n    t->data = p->data;\n    remove(p->data.key , t->right);\n  }\n  else\n  {\n    BinaryNode *oldNode = t;\n    t = (t->left != nullptr) ? t->left : t->right;\n    delete oldNode;\n  }\n}\n```\n\n#### 二叉查找树的性能\n\n- 二叉查找树的操作的时间复杂度为树的高度\n- 如果二叉查找树是平衡的，则访问的代价是 $O(\\log n)$\n- 最坏的情况下，二叉查找树会退化成一个单链表，时间复杂度为 $O(n)$\n\n**平均性能**\n\n具有 $n$ 个节点的二叉查找树可能有 $n$ 种不同的形态\n$(0,1,n-1) , (1 , 1 n-2) , (2 , 1 , n-3) , \\ldots , (n-1 , 1 , 0)$\n若设这些形态出现的概率是相同的，设 $P(n)$ 为查找 $n$ 个节点的二叉查找树的平均查找时间，则有如下递归关系式：\n\n$$\nP(n) = \\frac{\\sum_{i = 0}^{n-1} \\left[ 1 + (P(i)+1) \\cdot i + (P( n - i - 1)+1)\\cdot (n-i-1)\\right]}{n} \\leq 2(1 + \\frac{1}{n})\\ln{n} \\approx 1.33 \\log{n}\n$$\n\n### AVL 树\n\n#### AVL 树的定义\n\n- 也叫平衡树\n  - 对于任意一个节点的两棵子树的高度至多相差 1\n- 平衡因子\n  - 节点的左子树的高度减去右子树的高度\n  - 平衡因子只能是 $-1$，$0$，$1$\n- 优点\n  - 查找，插入和删除操作的时间复杂度都是 $O(\\log n)$\n\n##### 查找性能\n\n- 与二叉树的高度成正比\n\n- 定理：\n  - 具有 $n$ 个节点的平衡树，高度 $h$ 满足 $\\log_2(n+1) \\leq h \\leq 1.44\\log_2(n+2)-0.328$\n  - 因此，平衡二叉树的操作都是 $O(\\log n)$\n\n##### 斐波那契树\n\n- 斐波那契树是平衡树的最坏情况，其每一子树的左右子树高度差都为 1\n\n- 定义\n  1. 空树是高度为 0 的斐波那契树\n  2. 单个节点是高度为 1 的斐波那契树\n  3. 若 $T_{h-1}$ 和 $T_{h-2}$ 分别为高度为 $h-1$ 和 $h-2$ 的斐波那契树，则 $T_h ={T_{h-1},x,T_{h-2}}$ 是高度为 $h$ 的斐波那契树\n  4. 没有其他的树是斐波那契树\n\n###### 斐波那契树的特点\n\n对于高度为 $h$ 的斐波那契树，节点数 $n$ 满足\n\n- $n_0 = 0$\n- $n_1 = 1$\n- $n_h = n_{h-1} + n_{h-2} + 1$\n\n#### AVL 树的存储实现\n\n- 使用二叉链表\n- 每个节点必须保存平衡信息\n  - 每棵树的高度\n  - 平衡度即左右子树的高度差\n\n##### AVL 树类的实现\n\n```cpp\ntemplate <clas KEY,class OTHER>\nclass AvlTree:public dynamicSearchTable<KEY , OTHER>\n{\n    struct AvlNode\n    {\n      SET<KEY , OTHER> data ; // 关键字\n      AvlNode *left , *right; // 左右子树指针\n      int height;            // 节点高度\n\n      AvlNode(const SET<KEY , OTHER> &element , AvlNode *lt ,AvlNode   *rt , int h = 1):data(elemeent) , left(lt) , right(rt) , height  (h) {} // 构造函数\n    };\n\n    AvlNode *root; // 根节点\n  public:\n    AvlTree() // 构造函数\n    {\n      root = nullptr;\n    }\n    ~AvlTree() // 析构函数\n    {\n      makeEmpty(root);\n    }\n    SET<KEY, OTHER> *find(const KEY &x) const;\n    void remove(const KEY & x);\n  private:\n    void insert( const SET<KEY, OTHER> & x, AvlNode * & t ) ; // 插入\n    bool remove( const KEY & x, AvlNode * & t ) ;\n    void makeEmpty( AvlNode *t );\n    int height(AvlNode *t) const  // 返回节点的高度\n    {\n      return t == nullptr ? 0 : t -> height;\n    }\n    void LL( AvlNode * & t ); // 左旋\n    void RR( AvlNode * & t ); // 右旋\n    void LR( AvlNode * & t ); // 左右旋\n    void RL( AvlNode * & t ); // 右左旋\n    int max(int a, int b)     // 返回两个数中较大的一个\n    {\n      return a > b ? a : b;\n    }\n    bool adjust(AvlNode *&t, int subTree); //用于删除\n};\n```\n\n#### AVL 树的查找\n\n- 与二叉查找树相同\n- 二叉查找树类采用递归实现\n- AVL 树类展示非递归实现\n\n##### 查找的非递归实现\n\n1. 设当前节点为根节点\n2. 若当前节点非空\n   1. 若当前节点的值等于 `x`，则返回当前节点\n   2. 若当前节点的值大于 `x`，则将当前节点指向左子树\n   3. 若当前节点的值小于 `x`，则将当前节点指向右子树\n3. 若当前节点为空，则返回空\n\n```cpp\ntemplate <class KEY,class OTHER>\nSET<KEY, OTHER> *AvlTree<KEY, OTHER>::find(const KEY & x) const\n{\n  AvlNode *t = root; \n  while (t!=nullptr && t->data.key != x)\n  {\n    if (x < t->data.key)\n    {\n      t = t->left;\n    }\n    else\n    {\n      t = t->right;\n    }\n  }\n  if (t == nullptr)\n  {\n    return nullptr;\n  }\n  else\n  {\n    return t->data;\n  }\n}\n```\n\n#### AVL 树的插入\n\n- 与二叉查找树相同\n  - 可能改变了根到插入节点的路径上某些节点的平衡度\n  - 需要向上修改树的结构\n\n##### 可能引起节点不平衡的情况\n\n- 节点的左孩子的左子树上插入（LL）\n- 节点的左孩子的右子树上插入（LR）\n- 节点的右孩子的左子树上插入（RL）\n- 节点的右孩子的右子树上插入（RR）\n\n##### 重构的方法\n\n- 指针调整\n  - 按照投影序保持结点相邻关系不变\n  - 辈分可以改变\n\n###### LL 问题\n\n![LL](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141158768.png)\n\n- **左旋**\n  1. 将失衡点的左儿子作为新的根节点\n  2. 左儿子的右儿子作为原根节点的左儿子\n- 若为 RR 问题，则将失衡点的右儿子作为新的根节点，右儿子的左儿子作为原根节点的右儿子，称为**右旋**\n- 左旋和右旋统称为**单旋转**，保留了树的有序性和原先的高度\n\n###### LR 问题\n\n![LR](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141206204.png)\n\n- **双旋转**\n  1. 将失衡点的左儿子右旋\n  2. 将失衡点左旋\n- 若为 RL 问题，则将失衡点的右儿子左旋，再将失衡点右旋\n- 先对失衡结点的儿子和孙子进行一次单旋转，使孙子变成儿子。然后是失衡结点和新的儿子进行一次单旋转，使**原先的孙子变成根**\n\n##### 私有的`insert` 函数\n\n```cpp\ntemplate <class KEY,class OTHER>\nvoid AvlTree<KEY, OTHER>::insert(const SET<KEY, OTHER> & x, AvlNode * & t)\n{\n  if (t == nullptr)\n  {\n    t = new AvlNode(x , nullptr , nullptr);\n  }\n  else if (x.key < t->data.key)\n  {\n    insert(x , t->left);\n    if (height(t->left) - height(t->right) == 2)\n    {\n      if (x.key < t->left->data.key)\n      {\n        LL(t);\n      }\n      else\n      {\n        LR(t);\n      }\n    }\n  }\n  else if (x.key > t->data.key)\n  {\n    insert(x , t->right);\n    if (height(t->right) - height(t->left) == 2)\n    {\n      if (x.key > t->right->data.key)\n      {\n        RR(t);\n      }\n      else\n      {\n        RL(t);\n      }\n    }\n  }\n  t->height = max(height(t->left) , height(t->right)) + 1; // 更新高度\n}\n```\n\n###### `LL`\n\n```cpp\ntemplate <class KEY,class OTHER>\nvoid AvlTree<KEY,OTHER>::LL(AvlNode *& t)\n{\n  AvlNode *t1 = t->left;\n  t->left = t1->right;\n  t1->right = t;\n  t->height = max(height(t->left) , height(t->right)) + 1;\n  t1->height = max(height(t1->left) , height(t1->right)) + 1;\n  t = t1;\n}\n```\n\n###### `RR`\n\n```cpp\ntemplate <class KEY,class OTHER>\nvoid AvlTree<KEY,OTHER>::RR(AvlNode *& t)\n{\n  AvlNode *t1 = t->right;\n  t->right = t1->left;\n  t1->left = t;\n  t->height = max(height(t->left) , height(t->right)) + 1;\n  t1->height = max(height(t1->left) , height(t1->right)) + 1;\n  t = t1;\n}\n```\n\n###### `LR`\n\n```cpp\ntemplate <class KEY,class OTHER>\nvoid AvlTree<KEY,OTHER>::LR(AvlNode *& t)\n{\n  RR(t->left);\n  LL(t);\n}\n```\n\n###### `RL`\n\n```cpp\ntemplate <class KEY,class OTHER>\nvoid AvlTree<KEY,OTHER>::RL(AvlNode *& t)\n{\n  LL(t->right);\n  RR(t);\n}\n```\n\n所有旋转的算法时间复杂度都是 $O(1)$，且只运行一次，所以 `insert` 的时间复杂度为 $O(\\log n)$\n\n#### AVL 树的删除\n\n1. 在 AVL 树上删除节点 `x`，删除操作和二叉查找树相同\n2. 调整平衡，与插入操作相同\n\n#### 调整\n\n- 与插入操作相同，失衡节点存在于被删的节点到根节点的路径上。删除一个节点之后，必须沿着到根节点的路径向上回溯，随时调整路径上的节点的平衡度\n- 删除时无法保证子树在平衡调整之后的高度不变\n- 递归的删除函数有一个 bool 型的返回值，当返回值为 `true` 时，调整停止\n\n#### 五种情况\n\n##### 情况 a\n\n![Sitiationa](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191603536.png)\n\n此时没有失衡，高度也没有改变，返回`true`\n\n##### 情况 b\n\n![Situationb](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191604348.png)\n\n此时没有失衡，但是高度变矮，返回`false`\n\n##### 情况 c\n\n![Situationc](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191607359.png)\n\n经过 RR 旋转后高度变矮，返回`false`\n\n##### 情况 d\n\n![Situationd](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191609189.png)\n\n经过 RL 旋转后高度变矮，返回`false`\n\n##### 情况 e\n\n![Situatione](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191613240.png)\n\n经过 RR 或 RL 旋转后高度不变，返回`true`\n\n#### 删除总结\n\n- 节点删除同二叉查找树。在删除了叶节点或者只有一个孩子的节点后，子树变矮，返回 `false`\n- 在每次调用后，检查返回值，如果是 `true`，则返回 `true`，否则分 5 种情况进行处理\n\n#### 私有的 `remove` 函数\n\n```cpp\ntemplate<class KEY,class OTHER>\nvoid AvlTree<KEY , OTHER>::remove(const KEY &x , AvlNOde *&x)\n{\n  if (t = nullptr) // 被删除节点不存在\n  {\n    return true;\n  }\n  if (x == t-> data.key)\n  {\n    if (t->left == nullptr || t-> right == nullptr)\n    {\n      AvlNode *oldNode = t;\n      t = (t->left == nullptr) ? t->right : t->left; // 删除节点的孩子节点\n      delete oldNode;\n      return false; // 删除了一个节点，返回 `false`\n    }\n    else\n    {\n      AvlNode *tmp = t-> right;\n      while (tmp->left != nullptr) // 找到右子树的最小节点\n      {\n        tmp = tmp->left;\n      }\n      t->data = tmp.data;\n      if (remove(tmp->data,key , t->right))\n      {\n        return adjust(t,1);\n      }\n    }\n  }\n  if (x < t->data,key)\n  {\n    if (remove(x,t->left))\n    {\n      teturn true;\n    }\n    return adjust(t,0);\n  }\n  else\n  {\n    if (remove(x , t->right))\n    {\n      return true;\n    }\n    return adjust(t,1);\n  }\n}\n```\n\n#### `adjust`\n\n- 进入调整函数的条件是某棵子树变矮了\n- 调整函数需要检查节点是否失衡，若失衡则进行相应的调整\n- 函数的返回值是子树是否变矮\n  - `true`：子树没有变矮\n  - `false`：子树变矮\n- 需要传入两个参数\n  - `AVlNode *&t`：传入的节点\n  - `int subTree`：参数 `t` 变矮的子树\n    - `0`：左子树\n    - `1`：右子树\n\n```cpp\ntemplate<class KEY , classs OTHER>\nbool AvlTree<KEY , OTHER>::adjust(AvlNode *&t , int SubTree)\n{\n  if (subTree) // 在右子树上删除\n  {\n    if (height(t->left) - height(t->right) == 1) // Situation a\n    {\n      return true;\n    }\n    if (height(t->right) == height(t->left)) // Situation b\n    {\n      return false;\n    }\n    if (height(t->left->right) > height(t->left->left)) // Situation d\n    {\n      LR(t);\n      return false;\n    }\n    LL(t); // Situation c and e\n    if (height(t->left) == height(t->right))s\n    {\n      return false;\n    }\n    else\n    {\n      return true;\n    }\n  }\n  else // 在左子树上删除\n  {\n    if (height(t->right) - height(t->left) == 1) // Situation a\n    {\n      return true;\n    }\n    if (height(t->right) == height(t->left)) // Situation b\n    {\n      return false;\n    }s\n    if (height(t->right->left) > height(t->right->right)) // Situation d\n    {\n      RL(t);\n      return false;\n    }\n    RR(t); // Situation c and e\n    if (height(t->right) == height(t->left))\n    {\n      return false;\n    }\n    else\n    {\n      return true;\n    }\n  }\n}\n```\n\n### 散列表\n\n- 也叫哈希表\n- 通过所求节点的关键字词 `KEY` 找到这个节点\n- 时间复杂度为 $O(1)$\n\n#### 基本概念\n\n1. 初始化\n   将数组转化为一个特殊的、表示单元为空的值\n2. `insert(i)`\n   将 `i` 存放到 `a[i.key]` 中\n3. `find(i)`\n   取出 `a[i.key]` 中的值\n4. `remove(i)`\n   将 `a[i.key]` 中的值置为空\n\n#### 散列函数\n\n将一个项映射成一个较小的下标的函数称为散列函数（hush function）\n\n- $D = H(key)$\n  D 为存储地址，key 为关键值，H 为散列函数\n- 散列函数的要求\n  - 计算速度快\n  - 散列地址均匀分布\n\n#### 常用的散列函数\n\n##### 直接地址法\n\n$H(key) = key$ 或 $H(key) = a \\times key + b$\n\n##### **除留余数法**\n\n$H(key) = key \\mod p$ 或 $H(key) = key \\mod p + c$ 这里的 $p$ 是一个小于等于 $m$ 的素数\n\n##### 数字分析法\n\n对关键字集合中的所有关键字，分析每一位上数字分布。取数字分布均匀的位作为地址的组成部分\n\n##### 平方取中法\n\n如果关键字中各位的分布都比较均匀，但关键字的值域比数组规模大，则可以将关键字**平方后**，取其结果的中间各位作为散列函数值。由于中间各位和每一位数字都有关系，因此均匀分布的可能性较大。\n\n##### 折叠法\n\n- 如果关键字相当长，以至于和散列表的单元总数相比大得多时，可采用此法\n- 选取一个长度后，将关键字按此长度分组相加\n\n#### 冲突问题\n\n当两个以上的关键字映射到一个存储单元时，称为**冲突或碰撞**\n\n- 解决冲突的方法\n  - 闭散列表：利用本散列表中的空余单元\n    - 线性探测法\n    - 二次探测法\n    - 再次散列法\n  - 开散列表：将碰撞的节点存放在散列表外的各自的线性表中（链接法）\n\n##### 闭散列表类的实现\n\n- 支持三种操作\n  - `insert`：插入一个元素\n  - `remove`：删除一个元素\n  - `find`：查找一个元素\n- 由一个数组实现，数组的大小由用户定义散列表时指定\n- 由于删除时的迟删除，每个数组元素还要保存一个状态值\n  - `0`：空\n  - `1`：有效\n  - `2`：删除\n\n```cpp\ntemplate <class KEY, class OTHER>\nclass closeHashTable:public dynamicSearchTable<KEY, OTHER>\n{\n  private:\n    struct node  //散列表的结点类\n    {\n      SET <KEY, OTHER> data;\n      int state; //0 -- empty 1 -- active 2 -- deleted\n      node()\n      {\n        state = 0;\n      }\n    };\n    node *array;\n\n    int size;\n    int (*key)(const KEY &x);//哈希函数\n    static int defaultKey(const int &x)\n    {\n      return x;\n    }\n  public:\n    closeHashTable(int length = 101, int (*f)(const KEY &x) = defaultKey)\n    ~closeHashTable()\n    {\n      delete [] array;\n    }\n    SET<KEY, OTHER> *find(const KEY &x) const;\n    void insert(const SET<KEY, OTHER> &x);\n    void remove(const KEY &x);\n};\n```\n\n- 构造函数\n\n```cpp\ntemplate <class KEY, class OTHER>\ncloseHashTable<KEY, OTHER>::closeHashTable(int length, int (*f)(const KEY &x))\n{\n  size = length;\n  array = new node[size];\n  key = f; //哈希函数为f\n}\n```\n\n- `insert`\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid closeHashTable<KEY, OTHER>::insert(const SET<KEY, OTHER> &x)\n{\n  int initPos, pos ;\n  initPos= pos = key(x.key) % size; //%size保护作用，避免越界\n  do\n  {\n    if (array[pos].state != 1)\n    { // 0或2，找到空单元\n      array[pos].data = x;\n      array[pos].state = 1;\n      return;\n    }\n    pos = (pos+1) % size;\n  } while (pos != initPos);\n}\n```\n\n- `remove`\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid closeHashTable<KEY, OTHER>::remove(const KEY &x)\n{\n  int initPos, pos ;\n  initPos= pos = key(x) % size;\n  do\n  {\n    if (array[pos].state == 0) return; //没找到\n    if (array[pos].state == 1 && array[pos].data.key== x)// 找到，删除\n    {\n      array[pos].state = 2;\n      return;\n    }\n    pos = (pos+1) % size; //没找到，需要往后找\n  } while (pos != initPos);\n}\n```\n\n- `find`\n\n```cpp\ntemplate <class KEY, class OTHER>\nSET<KEY, OTHER> *closeHashTable<KEY, OTHER>::find(const KEY &x) const\n{\n  int initPos, pos ;\n  initPos = pos = key(x) % size;\n  do\n  {\n    if (array[pos].state == 0) // 没有找到\n    {\n      return nullptr;\n    }\n    if (array[pos].state == 1 && array[pos].data.key == x) // 找到\n    {\n      return (SET<KEY,OTHER> *)&array[pos];\n    }\n    pos = (pos+1) % size;\n  } while (pos != initPos);\n}\n```\n\n###### 线性探测法\n\n当散列发生冲突时，依次**探测下一个单元**，直到发现一个空单元\n\n![线性探测法](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504210826498.png)\n\n###### 二次探测法\n\n以此向后探测 $1^2$，$2^2$，$3^2$，$4^2$，$5^2$，$\\ldots$\n\n**定理**\n\n- 如果采用二次探测法，并且表的大小是一个素数，那么，如果表至少有一半是空的（负载因子 $<0.5$），新的元素总能被插入。并且在插入过程中，没有一个单元被探测两次\n\n###### 再次散列法\n\n- 采用一个新的散列函数 $H_2(key)$\n- $H_1(x)$，$H_1(x)+H_2(x)$ ，$H_1(x)+2H_2(x)$，$H_1(x)+3H_2(x)$，$\\ldots$\n\n##### 开散列表\n\n链地址法\n\n- 将具有同一散列地址的结点保存于 `M` 存区的各自的链表之中\n\n###### 开散列表的实现\n\n- 将所有散列到同一地址的元素链接成一个单链表\n- 采用不带头结点的单链表\n- 散列表保存在一个数组中，每个元素是一个指向对应单链表的首地址的指针\n\n```cpp\ntemplate <class KEY , class OTHER>\nclass openHashTable:public dynamicSearchTable<KEU , OTHER>\n{\n  private:\n    struct node\n    {\n      SET<KEY , OTHER> data;\n      node *next;\n      node (const SET<KEY , OTHER> &d , nde *n = nullptr)\n      {\n        data = d;\n        next = n;\n      }\n      node()\n      {\n        next = nullptr;\n      }\n    };\n    node **array; // 散列表，指针数组\n     int size;\n     static int defaultKry(const int &x)\n     {\n        return x;\n     }\n  public:\n    openHashTable(int length = 101,int (*f)(const KEY &x) = defaultKey);\n    ~openashTable();\n    SET<KEY,OTHER> *finf(const KEY &x) const;\n    void insert(const SET<KEY,OTHER> &x);\n    void remove(const KEY &x);\n};\n```\n\n- 构造函数\n\n```cpp\ntemplate <class KEY, class OTHER>\nopenHashTable<KEY, OTHER>::~openHashTable()\n{\n  node *p, *q;\n  for (int i = 0; i< size; ++i)\n  {\n    p = array[i];\n    while (p!=nullptr)\n    {\n      q= p->next; delete p; p = q;\n    }\n  }\n  delete [] array；\n}\n```\n\n- `insert`\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid openHashTable<KEY, OTHER>::insert(const SET<KEY, OTHER> &x)\n{\n  int pos;\n  node *p;\n  //插入单链表的头部\n  pos = key(x.key) % size;\n  array[pos] = new node(x, array[pos]);\n}\n```\n\n- `remove`\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid openHashTable<KEY, OTHER>::remove(const KEY &x)\n{\n  int pos ;\n  node *p, *q;\n  pos = key(x) % size;\n  if (array[pos] == nullptr)\n  {\n    return;\n  }\n  p = array[pos];\n  if (array[pos]->data.key== x)\n  { // 删除第一个结点\n    array[pos] = p->next;\n    delete p;\n    return;\n  }\n  while (p->next != nullptr && !(p->next->data.key== x))\n  {\n    p = p->next;\n  }\n  if (p->next != nullptr)\n  {\n    q = p->next;\n    p->next = q->next;\n    delete q;\n  }\n}\n```\n\n- `find`\n\n```cpp\ntemplate <class KEY, class OTHER>\nSET<KEY, OTHER> *openHashTable<KEY, OTHER>::find(const KEY &x) const\n{\n  int pos ;\n  node *p;\n  pos = key(x) % size;\n  p = array[pos];\n  while (p != nullptr && !(p->data.key == x))\n  {\n    p = p->next;\n  }\n  if (p == nullptr)\n  {\n    return nullptr;\n  }\n  else\n  {\n    return (SET<KEY, OTHER> *)p;\n  }\n}\n```\n\n## 排序\n\n### 基本概念\n\n- 按照关键字的非递减或非递增序排成一个序列\n- **稳定与非稳定排序**:关键字值相同的数据元素在排序前后的相对次序保持不变，则称为稳定排序，否则称为不稳定排序\n- 内排序与外排序\n  - **内排序：**排序的数据元素全部存放在计算机的内存之中，并且在内存中调整数据元素的相对位置\n  - **外排序：**在排序的过程中，数据元素主要存放在外存储器中，借助于内存储器逐步调整数据元素之间的相对位置\n\n### 插入排序\n\n首先将由第一个数据元素组成的序列看成是有序的，然后将剩余的 n-1 个元素依次插入到前面的已排好序的子序列中去，使得每次插入后的子序列也是有序的\n\n#### 直接插入排序\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid simpleInsertSort(SET<KEY, OTHER>a[], int size)\n{\n  int k;\n  SET<KEY, OTHER> tmp;\n  for (int j=1; j<size; ++j)\n  {\n  tmp = a[j];\n  for ( k = j-1; tmp.key < a[k].key && k >= 0; --k)\n  {\n    a[k+1] = a[k];\n  }\n  a[k+1] = tmp;\n  }\n}\n```\n\n- 空间复杂度：$O(1)$\n- 稳定性：稳定\n- 时间复杂度\n  - 最好：$O(n)$\n  - 最坏：$O(n^2)$\n  - 平均：$O(n^2)$\n- 适用情况：短序列或者几乎已经排好序的\n\n#### 折半插入排序\n\n先用二分排序找到插入位置\n\n- 时间复杂度\n  - 最好：$O(n\\log n)$\n  - 最坏：$O(n^2)$\n  - 平均：$O(n^2)$\n- 空间复杂度：$O(1)$\n- 稳定性：稳定\n\n改进很小，对于接近排好序的序列甚至**更差**\n\n#### 希尔排序\n\n- 相隔一定的距离的记录组成一个子序列\n- 逐渐扩大小序列的规模，减小序列的个数，使得待排序列处于更有序的状态\n- 最后再用直接插入排序对整个序列进行一次排序\n\n##### 步长序列的选择\n\n- $1,2,4,8,\\ldots$\n- 时间复杂度：$O(n^2)$\n\n- Knuth 推荐：$1,3,7,15,31,63,\\ldots$\n- 时间复杂度：$O(n^{1.5})$\n- 空间复杂度：$O(1)$\n- 不稳定\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid shellSort(SET<KEY, OTHER> a[], int size)\n{\n  int step, i, j;\n  SET<KEY, OTHER> tmp;\n  for (step = size/2; step > 0; step /= 2) //step为希尔增量\n  {\n    for (i = step; i < size; ++i)\n    {\n      tmp = a[i];\n      for (j = i -step; j >= 0 && a[j].key > tmp.key; j -= step)\n      {\n        a[j+step] = a[j];\n      }\n      a[j+step] = tmp;\n    }\n}\n```\n\n### 选择排序\n\n1. 在 $n$ 个元素中选出最小的元素\n2. 从剩下的 $n-1$ 个元素中选出最小的元素\n3. 以此类推，直到最后一个元素\n\n#### 直接选择排序\n\n1. 在所有元素中逐个比较找到最小元素，与第一个元素交换\n2. 在剩下的元素中逐个比较找到最小元素，与第二个元素交换\n3. 以此类推，直到最后一个元素\n\n- 时间复杂度：$O(n^2)$\n- 空间复杂度：$O(1)$\n- 不稳定\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid simpleSelectSort(SET<KEY, OTHER> a[], int size)\n{\n  int i, j, min;\n  SET<KEY, OTHER> tmp;\n  for (i = 0; i < size -1; ++i)\n  {\n  min = i;\n  for (j = i+1; j < size; ++j)\n  {\n    if (a[j].key < a[min].key)\n    {\n      min = j;\n    }\n  }\n  tmp = a[i]; a[i] = a[min]; a[min] = tmp;\n  }\n}\n```\n\n#### 堆排序\n\n1. 建立一个最大堆\n2. 执行 $n$ 次 `deQuqeue` 操作取出每个项\n\n- 时间复杂度 $O(n\\log n)$\n\n- 堆排序\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid heapSort(SET<KEY, OTHER> a[], int size)\n{\n  int i;\n  SET<KEY, OTHER> tmp; // 创建初始的堆\n  for( i = size / 2 -1; i >= 0; i--)\n  {\n    percolateDown( a, i, size );\n  }\n  //执行n-1次deQueue\n  for ( i = size -1; i > 0; --i)\\\n  {\n  tmp = a[0]; a[0] = a[i]; a[i] = tmp; //delete a[0]\n  percolateDown( a, 0, i );\n  }\n}\n```\n\n- `precolateDown`\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid percolateDown( SET<KEY, OTHER> a[], int hole, int size)\n{\n  int child;\n  SET<KEY, OTHER> tmp= a[ hole ];\n  for( ; hole * 2 + 1 < size; hole = child )\n  {\n    child = hole * 2 + 1;\n    if( child != size -1 && a[ child + 1 ].key > a[ child ].key )\n    {\n      child++;\n    }\n    if( a[ child ].key >tmp.key)\n    {\n      a[ hole ] = a[ child ];\n    }\n    else\n    {\n      break;\n    }\n  }\n  a[ hole ] = tmp;\n}\n```\n\n### 交换排序\n\n通过交换，将关键字值较大的数据元素向序列的尾部移动，关键字值较小的数据元素向序列的头部移动\n\n#### 冒泡排序\n\n从头到尾比较相邻的两个元素，将小的换到前面，大的换到后面。经过了从头到尾的一趟比较，就把最大的元素交换到了最后一个位置。这个过程称为一趟起泡\n\n然后再从头开始到倒数第二个元素进行第二趟起泡。经过了第二趟比较，又将第二大的元素放到了倒数第二个位置\n\n依次类推，经过第 $n-1$ 趟起泡，将倒数第 $n-1$ 个大的元素放入第 2 个单元\n\n```cpp\ntemplate <class KEY, class OTHER>\nvoid bubbleSort(SET<KEY, OTHER> a[], int size)\n{\n  int i, j;\n  SET<KEY, OTHER> tmp;\n  bool flag = true; //记录一趟起泡中有没有发生过交换\n  for (i = 1; i < size&& flag; ++i)\n  { //size-1次起泡\n    flag = false;\n    for (j = 0; j < size-i; ++j) //第i次起泡\n    if (a[j+1].key < a[j].key)\n    {\n      tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp;\n      flag = true;\n    }\n  }\n}\n```\n\n#### 快速排序\n\n- 选择一个基准元素，将比基准元素小的元素放在左边，比基准元素大的元素放在右边\n- 然后对基准元素左边和右边的子序列进行递归排序\n\n##### 选择中心点\n\n- 第一个元素\n- 随机\n- 中值（采样得到）\n\n##### 划分（第一个元素为中心点）\n\n1. 序列的下标上界为 `high`，下届为 `low`，中心点选取第一个元素，关键值为 `K`，`low` 位置空出\n2. 从右向左开始检查：如果 `high` 的关键值大于 `K`，该位置中的值位置正确，`high` 减 $1$，继续往前检查，直到遇到一个小于 `K` 的值\n3. 将小于 `k` 的这个值放入 `low` 的位置，此时 `high` 的位置又空出。然后从 `low` 位置开始从左向右检查，直到遇到一个大于 `K` 的值\n4. 将 `low` 位置的值放入 `high` 位置，重复第 2 步，直到 `low` 和 `high` 重叠，将 `K` 放入此位置\n\n划分函数的实现\n\n```cpp\ntemplate <class KEY, class OTHER>\nint divide( SET<KEY, OTHER> a[], int low, int high)\n{\n  SET<KEY, OTHER> k = a[low];\n  do\n  {\n    while (low < high && a[high].key >= k.key)\n    {\n      --high;\n    }\n    if (low < high)\n    {\n      a[low] = a[high]; ++low;\n    }\n    while (low < high && a[low].key <= k.key)\n    {\n      ++low;\n    }\n    if (low < high)\n    {\n      a[high] = a[low]; --high;\n    }\n  } while (low != high);\n  a[low] = k;\n  return low;\n}\n```\n\n### 归并排序\n\n- 将待排序的序列分成两个子序列，分别进行排序\n- 将两个有序的子序列合并成一个有序的序列\n- 递归进行\n\n### 基数排序\n\n- 称为口袋排序法\n- 通过分配的方法进行排序\n- 基数（r）：子关键字的值域的元素的个数\n  - 十进制数：$0,1,2,\\ldots,9$，基数为 $10$\n  - 二进制数：$0,1$，基数为 $2$\n  - 英文字符：$A,B,C,\\ldots,Z$，基数为 $26$\n\n#### 高位优先法（MSD）\n\n- 先将高位进入口袋中你进行排序，再将低位放入口袋中进入排序，最终将最小的口袋依次链接在一起形成有序序列\n\n#### 低位优先法（LSD）\n\n- 先将最低为进入口袋进行排序，再将所有记录按照口袋的顺序收在一起\n- 然后将次低位进入口袋进行排序，依次类推\n- 最后将所有记录按照口袋的顺序收在一起\n\n## 外存储器中的查找和排序\n\n### 主存储器与外存储器\n\n- 主存储器：计算机的内存，用于存储正在运行的程序代码以及处理数据\n- 外存储器：计算机的硬盘、光盘、磁带等，用于长期存储数据和程序，用于存储长期保存的信息\n  - 价格低廉、存储量大、永久保存、**访问速度慢**\n\n### 外部查找\n\n#### B 树\n\nB 树是一棵平衡的 M 叉查找树，需要 $M-1$ 个关键字来判断到哪个分支查找\n\n##### B 树的定义\n\n- 一棵 $m$ 阶 B 树要么为空，要么满足一下条件\n  - 根节点要么是叶节点，要么至少有两个儿子，至多有 $m$ 个儿子\n  - 每个非根节点至少有 $\\lceil m/2 \\rceil$ 个儿子，至多有 $m$ 个儿子\n  - 有 $s$ 个儿子的非叶节点具有 $n=s-1$ 个关键字\n  - 所有的叶子节点都出现在同一层上\n\n##### B 树的插入\n\n- 在最底层进行插入\n\n1. 在 $m$ 阶 B 树上进行查找操作，确定新插入的关键字 `key` 在最底层非叶节点的插入位置\n2. 如果被插入节点的关键字个数小于等于 $m-1$，则插入结束\n3. 如果被插入节点的关键字个数大于 $m-1$，则需要进行分裂\n\n- 被插入节点分为三个部分\n  - 前半部分：前 $m/2$ 个关键字\n  - 中间部分：中间的关键字\n  - 后半部分：后 $m/2$ 个关键字\n- 中间部分的关键字上升到父节点\n- 前后半部分生成新的两个节点\n\n##### B 树的删除\n\n- 采用替身法，替身为右子树的最小值或者左子树的最大值\n\n1. 删除节点，替身进入\n2. 如果删除后的替身原来在的节点满足，则直接删除\n3. 如果删除后的关键字小于下限，\n   - 向该节点的左或右兄弟借一个关键字\n   - 如果兄弟节点的关键字个数等于下限，则需要进行合并\n\n##### M 的选择\n\n#### B+树\n\nB+树是既能提供随机查找，也能提供顺序访问的存储结构\n\n##### B+树的定义\n\n- 所有数据都记录在叶节点中，所有叶节点连成一个单链表\n- 非叶节点至多保存 $m-1$ 个关键字来引导查找，键 $i$ 表示子树 $i+1$ 中键的最小值\n- 根节点或者是叶节点，或者有 $2$ 到 $m$ 个子树\n- 除了根节点之外的所有非叶节点至少有 $m/2$ 个儿子，最多有 $m$ 个儿子\n- 所有的叶节点都在同一层上，并且每个叶子有 $\\lceil L/2 \\rceil$ 到 $L$ 个关键字\n\n##### B+树的插入\n\n- 叶结点不满：把新结点插入叶子，重新调整该叶子中数据的顺序\n- 叶子已经装满 ：通过分裂该叶子，形成两个半满的叶子来插入一个新的项\n  - 更新父结点\n  - 如果父亲的儿子数量已经满了，就继续分裂父亲\n\n### 外排序\n\n一次外存操作所需的时间可以执行数百条甚至上千条指令，因此在外排序中主要考虑的是如何减少外存储器的读写（I/O 操作）\n\n#### 外排序模型\n\n- 外排序由两个阶段组成\n  1. 预处理阶段：根据内存的大小将一个有 n 个记录的文件分批读入内存，用各种内排序算法排序，形成一个个有序片段\n  2. 归并阶段：将这些有序片段逐步归并成一个有序文件\n\n减少 I/O 操作的关键\n\n1. 减少归并轮数\n2. 减少有序片段数量\n3. 增加合并路数\n\n#### 预处理\n\n##### 减少有序片段数量\n\n- 每次读入的记录数越多，形成的初始的已排序的片段越少，归并的次数也越少\n- 最简单的方法是按照内存的容量尽可能多地读入数据记录，然后再内存中进行排序，排序地结果写入文件，形成一个已排序片段\n\n##### 置换排序\n\n置换选择可以在只能容纳 $p$ 个记录的内存中生成平均长度为 $2p$ 的初始的已排序片段\n\n只要前面的元素被写到文件上，它所用的内存空间就可以给别的元素使用。如果输入文件中的下一个元素比刚刚输出的元素大，它能被放入这个已排序片段\n\n具体方法\n\n1. 初始时，将 $m$ 个元素读入内存，用 `buildHeap` 建立一个优先级队列\n2. 执行一次 `deQuqeue`，将最小的元素写入输出文件\n3. 从输入磁带读入下一个元素\n   - 如果它比刚才写进去的元素大，那么将它加入到优先级队列中\n   - 否则，则无法写入队列，进行下一次 `deQuqeue`\n4. 重复第 2、3 步，直到输入文件读完\n5. 重新执行 `buildHeap`，使用存放在空余位置中的元素\n\n#### 归并\n\n##### 二路归并\n\n- 归并时，每次将两个有序文件归并为一个有序文件\n- 如果生成的有序片段数量为 $M$，则归并次数为 $\\lceil \\log_2 M \\rceil$\n\n##### 多路归并\n\n- 归并时，每次将 $k$ 个有序文件归并为一个有序文件\n- 优点：减少归并次数，为 $\\lceil \\log_k M \\rceil$ 次\n- 缺点：寻找最小元素的操作复杂，通常可以将每个文件的第一个记录组成一个优先级队列\n\n##### 多阶段归并\n\n- 可以仅使用 $K+1$ 条磁带实现 $K$ 路归并，称为**多阶段归并**\n\n**实现的过程**\n\n1. 按照非均匀的方法分解原来的已排序的片段\n2. 将每个片段分成 $K$ 个子片段\n\n## 图\n\n### 图的定义\n\n- 图可以用 $G=(V, E)$ 表示。其中，$V$ 是顶点集，$E$ 是边集。\n- 如果边是有方向的，称为**有向图**.有向图的边用 $\\langle \\rangle$ 表示\n  - $\\langle A, B \\rangle$ 表示从 $A$ 到 $B$ 的一条边\n- 如果边是无方向的，称为**无向图**.无向图的边用 $()$ 表示\n  - $(A, B)$ 表示 $A$ 和 $B$ 之间有一条边\n  - 无向图也称为双向图\n- **加权图：** 边被赋予一个权值的图称为加权图.如果图是有向的，称为加权有向图，如果是无向的，称为加权无向图\n  - 加权图中边的表示：$(V_i,V_j,W)$\n\n### 图的基本术语\n\n- 邻接\n  - 若 $(V_i,V_j)$ 是图 $G$ 的一条边，则称 $V_i$ 和 $V_j$ 是邻接的；若 $\\langle V_i,V_j \\rangle$ 是图 $G$ 的一条边，则称 $V_i$ 邻接到 $V_j$，$V_j$ 和 $V_i$ 邻接\n- 度\n  无向图中邻接与某一顶点的边的总数\n- 入度\n  有向图中进入某一顶点的边数\n- 出度\n  有向图中离开某一顶点的边数\n- 边与度的关系\n  $\\displaystyle e=\\frac{1}{2}\\sum_{i=1}^n d_i$，其中 $e$ 是边数，$d_i$ 是顶点 $V_i$ 的度\n\n#### 子图\n\n设有两个图 $G_1=(V_1,E_1)$ 和 $G_2=(V_2,E_2)$，如果 $V_1 \\subseteq V_2$，$E_1 \\subseteq E_2$，则称 $G_1$ 是 $G_2$ 的子图\n\n#### 路径和路径长度\n\n- 对于 $1<i<N$，顶点序列 $w_1,w_2,\\ldots,w_N$ 中的顶点对 $(w_i,w_{i+1})$ 都有 $(W_i,w_{i+1})\\in E$ 或 $\\langle w_i,w_{i+1} \\rangle \\in E$，则称 $w_1,w_2,\\ldots,w_N$ 是图中的一条**路径**\n- **非加权的路径长度**就是组成路径的边数，对于路径 $w_1,w_2,\\ldots,w_N$，路径长度为 $N-1$\n- **加权的路径长度**是指路径上所有边的权值之和\n- **简单路径和环：** 如果一条路径上所有顶点，除了起始顶点和终止顶点可能相同外，其余的顶点都不相同，则称其为简单路径。一个回路或环是一条简单路径，其起始顶点和终止顶点相同，且路径长度至少为 $1$\n\n#### 无向图的连通性\n\n- **连通：** 顶点 $V$ 和顶点 $V'$ 之间又路径存在\n- **连通图：** 无向图 G 的任意两点之间都是连通的\n- **连通分量：** 非连通图中的极大连通子图\n\n#### 有向图的连通性\n\n- **强连通图：** 有向图 G 的任意两点之间都是连通的，则称 G 是强连通图\n- **强连通分量：** 极大连通子图\n- **弱连通图：** 如有向图 G 不是强连通的，但是如果把它看作是无向图时则是连通的，则称该图是弱连通的\n\n#### 完全图\n\n- **完全图：** 每两个顶点之间都有边的无向图称为完全图。完全图有 $\\frac{n(n-1)}{2}$ 条边，即 $C_n^2$\n- **有向完全图：** 每两个顶点之间都有两条边的有向图称为有向完全图。有向完全图有 $n(n-1)$ 条边，即 $P_n^2$\n- **有向无环图：** 不含环的有向图\n\n#### 生成树与最小生成树\n\n- **生成树**是图 G 的**极小**连通子图 G'，其中 $V(G')=V(G)$\n- 用一棵树把图 G 的所有顶点都连起来，并且没有回路\n- 生成树有 $n$ 个顶点，$n-1$ 条边\n- 生成树可以有多个\n- **最小生成树**是所有生成树中权值之和最小的生成树\n\n### 图的运算\n\n- 常规操作\n  - 构造一个由若干个顶点、若干条边组成的图\n  - 判断两个顶点之间是否有边存在\n  - 在图中添加或删除一条边\n  - 返回图中的顶点数或边数\n  - 按某种规则**遍历**图中的所有顶点\n- 和应用紧密结合的运算\n  - 拓扑排序和关键路径\n  - 找最小生成树\n  - 找最短路径等\n\n### 图的抽象类\n\n```cpp\ntemplate <class TypeOfVer, class TypeOfEdge>\nclass graph\n{\n  public:\n    virtual void insert(TypeOfVer x, TypeOfVer y, TypeOfEdge w) = 0;\n    virtual void remove(TypeOfVer x, TypeOfVer y) = 0;\n    virtual bool exist(TypeOfVer x, TypeOfVer y) const = 0;\n    int numOfVer() const\n    {\n      return Vers;\n    }\n    int numOfEdge() const\n    {\n      return Edges;\n    }\n \n  protected:\n    int Vers, Edges;\n};\n```\n\n### 图的存储\n\n#### 邻接矩阵和加权邻接矩阵\n\n##### 有向图的邻接矩阵\n\n设有向图有 $n$ 个顶点，则用一个 $n \\times n$ 的布尔矩阵 $A$ 来表示该有向图\n\n![有向图的邻接矩阵](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505212328867.png)\n\n- 分别使用 $0,1,2,\\ldots,n-1$ 表示 顶点 $V_0,V_1,\\ldots,V_{n-1}$，如果存在一条从 $V_i$ 到 $V_j$ 的边，则 $A[i][j]=1$，否则 $A[i][j]=0$\n- 出度：$i$ 行之和\n- 入度：$j$ 列之和\n- 真正的顶点数据字段之值放入一个一维数组之中\n\n##### 无向图的邻接矩阵\n\n设无向图有 $n$ 个顶点，则用一个 $n \\times n$ 的布尔矩阵 $A$ 来表示该无向图\n\n![无向图的邻接矩阵](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505212332916.png)\n\n- 分别使用 $0,1,2,\\ldots,n-1$ 表示 顶点 $V_0,V_1,\\ldots,V_{n-1}$，如果存在一条从 $V_i$ 到 $V_j$ 的边，则 $A[i][j]=A[j][i]=1$，否则 $A[i][j]=A[j][i]=0$\n- 顶点 $i$ 的度：第 $i$ 行或第 $i$ 列之和\n- 无向图的邻接矩阵是一个三角对称矩阵\n\n##### 邻接矩阵的特点\n\n- 优点：判断任意两点之间是否有边方便，仅耗费 $O(1)$ 时间\n- 缺点：即使 $\\ll n_2$ 条边，也需内存 $n_2$ 单元，太多; 仅读入数据耗费 $O(n_2)$ 时间，太长。而大多数的图的边数远远小于 $n_2$。**适合稠密网**\n- 不适合增减顶点\n\n#### 邻接表\n\n- 设有向图或者无向图由 $n$ 个顶点，则用**顶点表**和**边表**来表示该有向图或无向图\n- **顶点表：** 用数组或单链表的形式存放所有的顶点\n  - 如果顶点数 $n$ 已知，则采用数组\n  - 如果顶点数未知，则采用单链表\n  - 每个元素包含两个部分\n    - 顶点值\n    - 指向该顶点对应的边表的首地址\n- **边表：** 每条边用一个节点进行表示\n\n  同一个顶点出发的所有的边形成它的边界点单链表\n\n![邻接表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505222230615.png)\n\n#### 邻接表的特点\n\n- 邻接表是图的**标准**存储方式\n- 优点\n  - $\\text{内存} = \\text{顶点数} +\\text{边数}$，时间复杂度为 $O\\left(\\vert V\\vert +\\vert E\\vert \\right)$，**适合稀疏网**\n- 当谈及图的线性算法时，一般指的是 $O\\left(\\vert V\\vert +\\vert E\\vert \\right)$\n- 缺点\n  - 确定 $i\\rightarrow j$ 是否有边，最坏需耗费 $O(n)$ 时间\n  - 无向图同一条边表示两次。边表空间浪费一倍\n  - 有向图中寻找进入某结点的边，非常困难（逆邻接表）\n\n### 图的遍历\n\n按照某种次序系统地访问图中的所有顶点，并且使得**每个顶点需且只能被访问一次**\n\n需对访问过的顶点加以**标记**\n\n#### 深度优先搜索\n\n1. 选中第一个被访问的顶点\n2. 对顶点作已访问过的标志\n3. 依次从顶点的未被访问过的第一个、第二个、第三个……邻接顶点出发，进行深度优先搜索\n\n出现了问题\n\n##### 存在的问题\n\n<span id=\"DFSdamn\">如果图不是连通或强连通，在进行 DFS 时，有时并不一定能够保证从某一个结点出发能访问到所有的顶点</span>\n\n##### 深度优先生成森林\n\n在[这种情况](##图###图的遍历####深度优先搜索#####存在的问题)下，必须再选中一个未访问过的顶点，继续进行深度优先搜索。直至所有的顶点都被访问过为止\n\n此时生成的是一组树而不是一棵树，这一组树被称为深度优先生成**森林**\n\n所以将深度优先搜索的流程改为\n\n1. 选中第一个被访问的顶点\n2. 对顶点作已访问过的标志\n3. 依次从顶点的未被访问过的第一个、第二个、第三个……邻接顶点出发，进行深度优先搜索\n4. 如果还有顶点未被访问，则选中一个起始顶点，转向 2\n5. 所有的顶点都被访问到，则结束\n\n##### 深度优先搜索的实现\n\n- 公有的 `dfs` 函数的伪代码\n\n```cpp\nvoid dfs()\n{\n  visited [v] =false; //对每个节点标记为未访问\n\n  while(v=尚未访问的节点)\n  {\n    dfs(v,visited);\n  }\n}\n```\n\n- 私有的 `dfs` 函数的伪代码\n\n```cpp\nvoid dfs(v,visited)\n{\n  visited(v)=true;\n  for 每个 v 的邻接点 w\n  {\n    if(!visited[w])\n    {\n      dfs(w,visited);\n    }\n  }\n}\n```\n\n#### 广度优先搜索\n\n1. 选中第一个被访问的顶点\n2. 对顶点作已访问过的标志\n3. 依次访问已访问顶点的未被访问过的第 $1$ 个、第 $2$ 个、第 $3$ 个、$\\ldots$ 、第 $m$ 个邻接顶点 $W_1,W_2,W_3,\\ldots,W_m$ ，进行访问且进行标记，转向 3\n4. 如果还有顶点未被访问，则选中一个起始顶点，转向 2\n5. 所有的顶点都被访问到，则结束\n\n按照顶点序号小的先访问，大的后访问的原则以**队列**的形式实现\n\n同样能够生成广度优先生成森林\n\n##### 广度优先搜索的实现\n\n1. 将序号最小的顶点放入队列\n2. 重复取队列的队头元素进行处理，直到队列为空。对出队的每个元素，首先检查该元素是否已被访问\n   - 如果没有被访问过，则访问该元素，并将它的所有的没有被访问过的后继入队\n3. 检查是否还有顶点未被访问。如果有，重复上述两个步骤\n\n```cpp\ntemplate <class TypeOfVer, class TypeOfEdge>\nvoid adjListGraph<TypeOfVer, TypeOfEdge>::bfs() const\n{\n  bool *visited = new bool[Vers];\n  int currentNode;\n  linkQueue<int> q;\n  edgeNode *p;\n  for (int i=0; i < Vers; ++i)\n  {\n   visited[i] = false;\n  }\n  cout << \"当前图的广度优先遍历序列为：\"<< endl;\n  for (i = 0; i < Vers; ++i)\n  {\n    if (visited[i] == true)\n    {\n      continue;\n    }\n    while (!q.isEmpty()) //连续访问队列的队头，将其拉出，若其后继非空则拉入队列\n    {\n      currentNode = q.deQueue();\n      if (visited[currentNode] == true)\n      {\n        continue;\n      }\n      cout << verList[currentNode].ver <<'\\t';\n      visited[currentNode] = true;\n      p = verList[currentNode].head;\n      while (p != NULL)\n      {\n        if (visited[p->end] == false)\n        q.enQueue(p->end);\n        p = p->next;\n      }\n    }\n    cout << endl;\n  }\n}\n```\n\n### 图遍历的应用\n\n#### 无向图的连通性\n\n- 如果无向图是连通的，则从无向图中的任意顶点出发进行深度优先搜索或广度优先搜索都可以访问到每一个顶点。访问的次序是一棵深度/广度优先**生成树**\n- 如果图是非连通的，深度/广度优先搜索可以找到一片深度/广度优先**生成森林**。每棵树就是一个**连通分量**。对无向图来说，深度/广度优先搜索可以找到了它的所有连通分量\n- 在深度优先搜索和广度优先搜索函数的输出中，每一行代表一个连通分量\n\n#### 有向图的连通性\n\n- 对有向图，深度优先搜索可以**测试是否强连通**，并**找出所有强连通分量**\n  1. 从任意顶点开始**深度优先遍历** $G$\n  2. 对森林中的每棵树进行**后序遍历**，并按遍历的顺序给每个顶点编号\n  3. 将 $G$ 的每条边逆向，形成 $G_r$\n  4. 从编号**最大**的顶点开始**深度优先遍历 $G_r$**。得到的深度优先遍历森林的每棵树就是 $G$ 的强连通分量\n\n#### 欧拉回路\n\n- 哥尼斯堡七桥问题：能否找到一条走遍这七座桥，而且每座桥只经过一次，最后又回到原出发点的路径\n\n![哥尼斯堡七桥问题](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505230120835.png)\n\n##### 欧拉的证明\n\n- 如果都是偶数桥，从任意地方出发都能回到原点 **（欧拉回路）**\n- 如果都是偶数桥，从任意地方出发都能回到原点 **（欧拉路径）**\n- 如果有奇数桥的地方不止两个，满足要求的路径是找不到的\n\n##### 查找欧拉回路的基本想法\n\n- 执行一次**不允许回溯**的 `DFS` ，也被称为一笔画问题\n- 但是很多搜索都是不符合的\n\n##### 解决方法\n\n找出路径上的另外一个尚有未访问的边的顶点，开始另一次深度优先的搜索，将得到的遍历序列拼接到原来的序列中，直到所有的边都已被访问\n\n![欧拉回路解决方法](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505230128080.png)\n\n#### 拓扑排序\n\n设 $G=(V,E)$ 是一个具有 $n$ 个顶点的**有向无环图**\n\n若 $V$ 中的顶点序列 $V_1,V_2,\\ldots ,V_n$ 满足下列条件\n\n- 在 $G$ 中，从 $V_i$ 到 $V_j$ 有一条路径\n- 在序列中 $V_i$ 在 $V_j$ 之前\n\n则称 $V_1,V_2,\\ldots ,V_n$ 是 $G$ 的一个**拓扑排序**\n\n拓扑排序将图转换为线性序，相对前去后继关系不变\n\n##### 顶点活动网络（Activu on vertex network）\n\n- 顶点表示各项子任务\n- 有向边表示具有先决条件关系\n- 仅当作为某一子任务的所有作为先决条件的子任务实施完成后，该子任务才能得以实施\n\n**AOV**的特点\n\n1. 有起始顶点\n2. 无回路\n\n##### 找出拓扑排序的过程\n\n- 第一个输出的顶点必须无前驱，即入度为 $0$\n- 无前驱以及后继的顶点在任何时候都可以输出\n- 逻辑删除法：当某个顶点被输出之后，该顶点以及从该顶点出发的边都被删除，所有以该顶点作为前驱的入度的所有顶点的入度 $-1$\n\n##### 拓扑排序的实现\n\n- 计算每个顶点的入度，保存在数组 `inDegree` 中\n- 检查 `inDegree` 中的每个元素，将入度为 $0$ 的顶点入队\n- 不断从队列中将入度为 $0$ 的顶点入队，输出此顶点，并将该顶点的入度 $-1$，如果某个邻接点的入度为 $0$，则将其入队\n\n```cpp\ntemplate <class TypeOfVer, class TypeOfEdge>\nvoid adjListGraph<TypeOfVer, TypeOfEdge>::topSort() const\n{\n  linkQueue<int> q;\n  edgeNode *p;\n  int current, *inDegree = new int[Vers];\n  for (int i = 0; i < Vers; ++i)\n  {\n    inDegree[i] = 0;\n  }\n  for ( i = 0; i < Vers; ++i)\n  {\n    for (p = verList[i].head; p != NULL; p = p->next)\n    {\n    ++inDegree[p->end];\n    }\n  }                                                                 //计算入度\n  for (i = 0; i < Vers; ++i)   if (inDegree[i] == 0) q.enQueue(i);  //入度0节点入队\n  cout << \"拓扑排序为：\" << endl;\n  while(!q.isEmpty())\n  {\n    current = q.deQueue( );\n    cout << verList[current].ver << '\\t';\n    for (p = verList[current].head; p != NULL; p = p->next)\n    if( --inDegree[p->end] == 0 )    q.enQueue( p->end );\n  }                                                                 //出队，删除关联的边\n  cout << endl;\n}\n```\n\n**时间复杂度：**\n\n- 若图以邻接表表示\n- 计算入度的时间复杂度为 $O(\\vert V\\vert +\\vert E\\vert)$，搜索入度为 $0$ 的顶点的时间复杂度为 $O(\\vert V\\vert)$，出队和删除边的时间复杂度为 $O(\\vert E\\vert)$，总执行时间为 $O(\\vert V\\vert +\\vert E\\vert)$\n\n#### 关键路径\n\n##### 边活动网络（Activity on Edge）\n\n- **AOE 网络：** 加权有向无环图\n  - 顶点表示事件，边表示活动\n  - 有向边的权值表示活动的持续时间\n  - 有向边的方向表示事件发生的先后次序\n  - 顶点的进入表示事件发生后允许开始的活动\n  - 有一个源点、一个终点\n\n##### 关键路径的定义\n\nAOE 网路可用于描述整个工程的各个活动之间的关系，活动安排的先后次序\n\n再次基础上可以用来估算工程的完成时间以及哪些活动是关键的活动\n","slug":"数据结构笔记","published":1,"date":"2025-09-11T11:36:20.596Z","updated":"2025-09-11T16:16:06.115Z","comments":1,"layout":"post","photos":[],"_id":"cmffo52nv000g6xzdca129cek","content":"<p><a href=\"https://oi-wiki.org/ds\">oiWiki 中的数据结构</a></p>\n<h2 id=\"引言\">引言</h2>\n<h3 id=\"算法与数据结构\">算法与数据结构</h3>\n<p>数据结构的研究内容</p>\n<ol type=\"1\">\n<li>数据之间的<strong>逻辑关系</strong>，以及这种关系对应的操作</li>\n<li><strong>储存实现</strong>：数据及逻辑关系的存储</li>\n<li><strong>运算实现</strong>：具体存储模式下，运算的实现，即<strong>算法</strong></li>\n</ol>\n<h4 id=\"数据的逻辑结构\">数据的逻辑结构</h4>\n<ul>\n<li><strong>集合结构</strong>\n次序任意，元素之间除了<strong>同处于一个集合内</strong>之外没有任意其他的关系.</li>\n<li><strong>线性结构</strong>\n数据元素的<strong>有序</strong>排列，除了头尾的元素外其余元素都有一个前趋和一个后继.</li>\n<li><strong>树形结构</strong>\n除了根元素之外，每个节点都有且仅有一个前趋，但是后继数量不限.</li>\n<li><strong>图形结构</strong> 每个元素的前趋和后继数量都不限 <img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/FourLogicalDataStructures.png\"\nalt=\"FourLogicalDataStructures\" /></li>\n</ul>\n<h4 id=\"数据结构的操作\">数据结构的操作</h4>\n<ul>\n<li><strong>创造</strong></li>\n<li><strong>清除</strong></li>\n<li><strong>插入</strong></li>\n<li><strong>删除</strong></li>\n<li><strong>更新</strong></li>\n<li><strong>搜索</strong></li>\n<li><strong>访问</strong></li>\n<li><strong>遍历（traverse）</strong>：按照某种次序访问数据结构中的每一元素，使每个元素恰好被访问一次</li>\n<li>每一种数据结构的特定操作</li>\n</ul>\n<p>数据结构的<strong>五大类</strong>：构建类、属性类、数据操纵类、遍历类、特定类</p>\n<h3 id=\"存储实现\">存储实现</h3>\n<h3 id=\"算法分析\">算法分析</h3>\n<h4 id=\"时间复杂度的概念\">时间复杂度的概念</h4>\n<ul>\n<li>是一种抽象的度量，表示运算量和问题规模（输入规模）之间的关系，<span\nclass=\"math inline\"><em>T</em>(<em>n</em>)</span></li>\n<li>算法的时间复杂度也与被处理的数据分布有关</li>\n<li>算法的时间复杂度分为三种\n<ul>\n<li>最好的</li>\n<li>最坏的</li>\n<li>平均</li>\n</ul></li>\n</ul>\n<h4 id=\"算法运算量的计算\">算法运算量的计算</h4>\n<h4 id=\"渐进时间复杂度\">渐进时间复杂度</h4>\n<h4 id=\"算法的优化\">算法的优化</h4>\n<h4 id=\"空间复杂度的概念\">空间复杂度的概念</h4>\n<ul>\n<li>渐进的空间复杂度</li>\n<li>一般只考虑<strong>辅助</strong>空间的占用情况</li>\n<li>空间复杂度一般按照最坏情况处理</li>\n<li>空间复杂度的计算、表示方法与时间复杂度相同</li>\n</ul>\n<h3 id=\"面向对象方法\">面向对象方法</h3>\n<h4 id=\"类模板的定义\">类模板的定义</h4>\n<p>类模板允许用户为类定义一种模式，使得类中的某些数据成员、某些成员函数的参数或返回值能取任意数据类型</p>\n<h5 id=\"定义格式\">定义格式</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> 标识符&gt;<br><span class=\"hljs-keyword\">class</span> 类名<br>&#123;<br>    <span class=\"hljs-comment\">// 类成员声明</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h5 id=\"类定义的一般格式\">类定义的一般格式</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> 类名<br>&#123;<br>  [<span class=\"hljs-keyword\">private</span>:]<br>    <span class=\"hljs-comment\">// 私有数据成员和成员函数声明</span><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 公有数据成员和成员函数声明</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"虚函数\">虚函数</h4>\n<ul>\n<li><p>在基类中用关键词 <code>virtual</code>\n声明的成员函数，并在派生类中重新定义的函数称为虚函数</p></li>\n<li><p>虚函数的一般格式</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">virtual</span> 返回类型 函数名(参数表)<br>&#123;<br>  <span class=\"hljs-comment\">// 函数体</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>\n<li><p>在派生类中重新定义时，其函数原型，包括返回类型、函数名、参数个数和参数类型的顺序都必须与基类中的原型完全相同（<strong>继承</strong>）</p></li>\n<li><p>当把一个函数定义为虚函数时，等于告诉编译器，这个成员函数在派生类中可能有不同的实现。必须在执行时根据传递的参数来决定调用哪一个函数</p></li>\n<li><p>虚函数在基类中有默认实现，派生类可以选择性地对其进行重写</p></li>\n</ul>\n<h4 id=\"纯虚函数\">纯虚函数</h4>\n<ul>\n<li><p>是一个在基类中说明的虚函数，它在该基类中没有实现，但要在它的派生类里定义和实现自己的版本，或重新说明为纯虚函数</p></li>\n<li><p>纯虚函数的一般形式</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">virtual</span> 返回类型 函数名(参数表) = <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure></li>\n<li><p>纯虚函数在基类中无实现，只有函数原型，派生类必须实现</p></li>\n</ul>\n<h4 id=\"抽象类\">抽象类</h4>\n<ul>\n<li>如果一个类中<strong>至少有一个纯虚函数</strong>，那么这个类就是抽象类</li>\n<li>抽象类只能作为其他类的基类，不能建立抽象类的对象</li>\n</ul>\n<h4 id=\"继承\">继承</h4>\n<ul>\n<li>在已有类的基础上建立新的类</li>\n<li>基类（父类）和派生类（子类）</li>\n<li>继承可以让程序员在已有类的基础上通过增加或修改少量代码的方法得到新的类，从而解决代码重用的问题</li>\n</ul>\n<h5 id=\"派生类\">派生类</h5>\n<ul>\n<li><p>一般格式</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> 派生类名 : [派生方式] 基类名<br>&#123;<br>  <span class=\"hljs-comment\">// 派生类新增的数据成员和成员函数</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>\n<li><p>派生方法</p>\n<ul>\n<li>公有派生：<code>public</code></li>\n<li>私有派生：<code>protected</code></li>\n<li>保护派生：<code>private</code></li>\n</ul></li>\n<li><p><code>class</code> 默认是 <code>private</code> 继承，\n<code>struct</code> 默认是 <code>public</code> 继承</p></li>\n</ul>\n<h6 id=\"派生类对基类成员的访问性\">派生类对基类成员的访问性</h6>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\"></th>\n<th style=\"text-align: center;\"><code>public</code> 继承</th>\n<th style=\"text-align: center;\"><code>protected</code> 继承</th>\n<th style=\"text-align: center;\"><code>private</code> 继承</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\"><code>public</code> 成员</td>\n<td style=\"text-align: center;\">public</td>\n<td style=\"text-align: center;\">protected</td>\n<td style=\"text-align: center;\">private</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><code>protected</code> 成员</td>\n<td style=\"text-align: center;\">protected</td>\n<td style=\"text-align: center;\">protected</td>\n<td style=\"text-align: center;\">private</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><code>private</code> 成员</td>\n<td style=\"text-align: center;\">不可访问</td>\n<td style=\"text-align: center;\">不可访问</td>\n<td style=\"text-align: center;\">不可访问</td>\n</tr>\n</tbody>\n</table>\n<h4\nid=\"类定义时常见的两种const用法\">类定义时常见的两种<code>const</code>用法</h4>\n<p>以函数 <code>int search(constelemType&amp;x) const</code> 为例</p>\n<ol type=\"1\">\n<li>修饰参数 <code>x</code> 的 <code>const</code> 和 <code>&amp;</code>\n组合\n<ul>\n<li><code>const</code> 修饰参数 <code>x</code>，表示函数\n<code>search</code> 不会修改参数 <code>x</code> 的值</li>\n<li>参数加了 <code>const</code>\n之后，编译器会在程序编译阶段帮助程序检查函数实现代码中是否含有对参数\n<code>x</code> 的修改操作，若有则会报错</li>\n<li><strong>如果确认函数实现中不准备改变 <code>x</code> 的值，养成加\n<code>const</code>的习惯</strong></li>\n<li><code>&amp;</code> 修饰参数 <code>x</code>，表示参数 <code>x</code>\n是引用传递，即传递的是实参的地址，而不是实参的值</li>\n</ul></li>\n<li>修饰函数 <code>search</code> 的 <code>const</code>\n<ul>\n<li>参数表后的 <code>const</code> 保护调用对象的值不被修改</li>\n<li>如果没有 <code>const</code> 修饰，那么在调用对象为\n<code>const</code> 类型时，不能调用该函数 常量对象只能调用参数表后带\n<code>const</code> 的常量成员函数</li>\n</ul></li>\n</ol>\n<h2 id=\"线性表\">线性表</h2>\n<h3 id=\"线性表的定义\">线性表的定义</h3>\n<h4 id=\"线性表的概念\">线性表的概念</h4>\n<ul>\n<li><p>是一种<strong>线性结构</strong>，是由 <span\nclass=\"math inline\"><em>n</em>(<em>n</em> ≥ 0)</span>\n个数据元素组成的有限序列</p></li>\n<li><p>除了首节点 <span\nclass=\"math inline\"><em>A</em><sub>0</sub></span> 和尾节点 <span\nclass=\"math inline\"><em>A</em><sub><em>n</em> − 1</sub></span>\n之外，每个节点 <span\nclass=\"math inline\"><em>A</em><sub><em>i</em></sub></span>\n有且仅有一个前趋 <span\nclass=\"math inline\"><em>A</em><sub><em>i</em> − 1</sub></span>\n和一个后继 <span\nclass=\"math inline\"><em>A</em><sub><em>i</em> + 1</sub></span></p></li>\n<li><p><span class=\"math inline\"><em>A</em><sub>0</sub></span>\n只有后趋，<span\nclass=\"math inline\"><em>A</em><sub><em>n</em> − 1</sub></span>\n只有前趋</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271603830.png\"\nalt=\"线性表\" />\n<figcaption aria-hidden=\"true\">线性表</figcaption>\n</figure></li>\n</ul>\n<h4 id=\"表的基本操作\">表的基本操作</h4>\n<ul>\n<li><strong>创建 <code>create()</code></strong>：创建一个空的线性表</li>\n<li><strong>清除\n<code>clear()</code></strong>：删除线性表中的所有数据元素</li>\n<li><strong>长度 <code>length()</code></strong>：返回线性表的长度</li>\n<li><strong>插入 <code>insert(i,x)</code></strong>：在线性表的第 <span\nclass=\"math inline\"><em>i</em></span> 个位置插入一个新元素\n<code>x</code></li>\n<li><strong>删除 <code>remove(i)</code></strong>：删除线性表中第 <span\nclass=\"math inline\"><em>i</em></span> 个位置的元素</li>\n<li><strong>搜索 <code>search(x)</code></strong>：在线性表中搜索元素\n<code>x</code>，返回其位置</li>\n<li><strong>访问 <code>visit(i)</code></strong>：返回线性表中第 <span\nclass=\"math inline\"><em>i</em></span> 个位置的元素</li>\n<li><strong>遍历\n<code>traverse()</code></strong>：依次访问线性表中的每个元素</li>\n</ul>\n<h4 id=\"线性表的抽象类\">线性表的抽象类</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">list</span><br>&#123;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;                           <span class=\"hljs-comment\">// 清空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">length</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;                     <span class=\"hljs-comment\">// 返回长度</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i, <span class=\"hljs-type\">const</span> elemType &amp;x)</span> </span>= <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// 插入</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> </span>= <span class=\"hljs-number\">0</span>;                     <span class=\"hljs-comment\">// 删除</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">search</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;    <span class=\"hljs-comment\">// 搜索</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> elemType <span class=\"hljs-title\">visit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;            <span class=\"hljs-comment\">// 访问</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">traverse</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;                  <span class=\"hljs-comment\">// 遍历</span><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">list</span>() &#123;&#125;                                  <span class=\"hljs-comment\">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>抽象类定义了线性表基本的操作，全是用纯虚函数定义，不做实现</li>\n<li><strong>抽象类无构造函数</strong></li>\n</ul>\n<h3 id=\"线性表的顺序实现\">线性表的顺序实现</h3>\n<h4 id=\"顺序存储结构\">顺序存储结构</h4>\n<ul>\n<li>节点存储在存储器的一块<strong>连续</strong>的空间中</li>\n<li>节点依照逻辑顺序依次<strong>存放</strong></li>\n<li>节点存放的物理位置和逻辑顺序是对应的</li>\n<li>线性表的顺序实现通常被称为<strong>顺序表</strong></li>\n</ul>\n<h4 id=\"顺序表类的定义\">顺序表类的定义</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">seqList</span> : <span class=\"hljs-keyword\">public</span> list&lt;elemtype&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    elemType *data;<br>    <span class=\"hljs-type\">int</span> currentLength;<br>    <span class=\"hljs-type\">int</span> maxSize;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">doubleSpace</span><span class=\"hljs-params\">()</span></span>;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">seqList</span>(<span class=\"hljs-type\">int</span> initSize = <span class=\"hljs-number\">10</span>);             <span class=\"hljs-comment\">// 构造函数</span><br>    ~<span class=\"hljs-built_in\">seqList</span>()                              <span class=\"hljs-comment\">// 析构函数</span><br>    &#123;<br>      <span class=\"hljs-keyword\">delete</span>[] data;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">()</span>                            <span class=\"hljs-comment\">//清空</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      currentLength = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">length</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span>                      <span class=\"hljs-comment\">// 返回长度</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> currentLength;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i, <span class=\"hljs-type\">const</span> elemType &amp;x)</span></span>;  <span class=\"hljs-comment\">// 插入</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;                     <span class=\"hljs-comment\">// 删除</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">search</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span> <span class=\"hljs-type\">const</span></span>;    <span class=\"hljs-comment\">// 搜索</span><br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">visit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> <span class=\"hljs-type\">const</span></span>;            <span class=\"hljs-comment\">// 访问</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">traverse</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;                  <span class=\"hljs-comment\">// 遍历</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"函数实现\">函数实现</h4>\n<h5 id=\"构造函数\">构造函数</h5>\n<ul>\n<li>定义对象时自动调用，用于初始化对象的数据成员</li>\n<li><strong>函数名与类名相同</strong></li>\n<li>可以有任何类型的参数，也可以没有参数，但是<strong>不能有返回类型</strong>，所以定义时不能说明类型</li>\n<li>若没有给出构造函数，编译器会自动生成一个默认的构造函数，只为对象开辟空间，里面的内容为随机数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>seqList&lt;elemType&gt;::<span class=\"hljs-built_in\">seqList</span>(<span class=\"hljs-type\">int</span> initSize)<br>&#123;<br>  data = <span class=\"hljs-keyword\">new</span> elemType[initSize];<br>  maxSize = initSize;<br>  currentLength = <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271640573.png\"\nalt=\"seqList\" />\n<figcaption aria-hidden=\"true\">seqList</figcaption>\n</figure>\n<h5 id=\"析构函数\">析构函数</h5>\n<ul>\n<li>用于释放对象所占用的内存空间，由编译系统自动调用</li>\n<li><strong>函数名与类名相同，前面加 <code>~</code></strong></li>\n<li>不能有参数，也不能有返回类型</li>\n<li>若没有给出析构函数，编译器会自动生成一个默认的析构函数</li>\n<li>不是所有类都要由析构函数</li>\n<li>一般在构造函数中动态申请内存的，必须有析构函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">~<span class=\"hljs-built_in\">seqList</span>()<br>&#123;<br>  <span class=\"hljs-keyword\">delete</span>[] data;<br>&#125;  <span class=\"hljs-comment\">//在线性表的类中已经实现了，不用到类外定义</span><br></code></pre></td></tr></table></figure>\n<h5 id=\"顺序表的运算实现\">顺序表的运算实现</h5>\n<h6 id=\"search\"><code>search</code></h6>\n<p>从数组的第 0 个下标变量开始一次往后检查每一个元素，直到找到\n<code>x</code> 或找到表尾</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">int</span> seqList&lt;elemType&gt;::<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-type\">const</span> elemType &amp;x) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-type\">int</span> i ;<br>  <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span> ; i &lt; currentLength &amp;&amp; data[i] != x ; ++i);<br>  <span class=\"hljs-keyword\">if</span> (i == currentLength)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"traverse\"><code>traverse</code></h6>\n<p>从数组的第 0 个下标变量开始一次往后访问每一个元素，直到表尾</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemtype</span>&gt;<br><span class=\"hljs-type\">void</span> seqList&lt;elemType&gt;::<span class=\"hljs-built_in\">traverse</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span> ; i &lt; currentLength ; ++i)<br>  &#123;<br>    cout &lt;&lt; data[i] &lt;&lt; <span class=\"hljs-string\">&#x27; &#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"insert\"><code>insert</code></h6>\n<ul>\n<li>在第 <code>i</code> 个位置插入元素 <code>x</code></li>\n<li>若插入后表长超过 <code>maxSize</code>，则将 <code>maxSize</code>\n扩大一倍</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271747022.png\"\nalt=\"seqList::insert\" />\n<figcaption aria-hidden=\"true\">seqList::insert</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> seqList&lt;elemType&gt;::<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-type\">int</span> i , <span class=\"hljs-type\">const</span> elemType &amp;x)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (currentSize = maxSize)<br>  &#123;<br>    <span class=\"hljs-built_in\">doubleSpace</span>();<br>  &#125;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = currentLength ; j &gt; i ; --j)<br>  &#123;<br>    data[j] = data[j - <span class=\"hljs-number\">1</span>];<br>  &#125;<br>  data[i] = x;<br>  ++currentLength;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"doublespace-操作的实现\"><code>doubleSpace</code> 操作的实现</h6>\n<ul>\n<li>重新申请一个更大规模的动态数组，将原有数组的内容拷贝到新数组中，释放原有数组空间，将新数组作为存储线性表的存储区</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281230588.png\"\nalt=\"seqList::doublespace\" />\n<figcaption aria-hidden=\"true\">seqList::doublespace</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> seqList&lt;elemType&gt;::<span class=\"hljs-built_in\">doublespace</span>()<br>&#123;<br>  elemtype *tmp = data;<br>  maxSize *= <span class=\"hljs-number\">2</span>;<br>  data = <span class=\"hljs-keyword\">new</span> elemtype[maxSize];<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span> ; i &lt; currentLength ; +<span class=\"hljs-number\">+1</span>)<br>  &#123;<br>    data[i] = tmp[i];<br>  &#125;<br>  <span class=\"hljs-keyword\">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"remove\"><code>remove</code></h6>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281238735.png\"\nalt=\"seqlist::remove\" />\n<figcaption aria-hidden=\"true\">seqlist::remove</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> seqList&lt;elemType&gt;::<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-type\">int</span> i)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">0</span> ||i &gt; currentlength)<br>  &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">OutOfBound</span>();<br>  &#125;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = i ; j &lt; currentlength <span class=\"hljs-number\">-1</span> ; ++j)<br>  &#123;<br>    data[j] = data[j + <span class=\"hljs-number\">1</span>];<br>  &#125;<br>  --currentLength;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"线性表的链接存储\">线性表的链接存储</h3>\n<h4 id=\"单链表\">单链表</h4>\n<ul>\n<li>每个节点附加指针字段，如\n<code>next</code>，指向直接后继节点，最后一个节点的 <code>next</code>\n指向 <code>nullptr</code></li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281247119.png\"\nalt=\"单链表\" />\n<figcaption aria-hidden=\"true\">单链表</figcaption>\n</figure>\n<h5 id=\"头节点头指针\">头节点、头指针</h5>\n<ul>\n<li>在表头额外增加一个相同类型的特殊结点</li>\n<li>不是线性表中的组成部分</li>\n<li>头节点使得在表头位置上进行插入和删除和在其他节点位置上是完全一致的，使得插入和删除算法得到简化</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281407312.png\"\nalt=\"带头节点的单链表\" />\n<figcaption aria-hidden=\"true\">带头节点的单链表</figcaption>\n</figure>\n<h5 id=\"结点及其组成\">结点及其组成</h5>\n<ul>\n<li>链表的节点包含两个部分\n<ul>\n<li>数据字段\n<ul>\n<li>可以存储任何类型的数据，仍然使用 <code>elemType</code> 表示</li>\n</ul></li>\n<li>指针字段\n<ul>\n<li>用于存储<strong>后继节点</strong>的地址值</li>\n</ul></li>\n<li>结点类型是链表专用的，可以设为内嵌类</li>\n<li>将节点类定义为 <code>struct</code> 方便链表类访问</li>\n</ul></li>\n</ul>\n<h5 id=\"单链表类的定义\">单链表类的定义</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">sLinkList</span>:<span class=\"hljs-keyword\">public</span> list&lt;elemtype&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">node</span>                                    <span class=\"hljs-comment\">// 节点类</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      <span class=\"hljs-built_in\">node</span>(<span class=\"hljs-type\">const</span> elemType &amp;x , node *n = <span class=\"hljs-literal\">nullptr</span>)<br>      &#123;<br>        data = x;<br>        next = n;<br>      &#125;<br>      <span class=\"hljs-built_in\">node</span>():<span class=\"hljs-built_in\">next</span>(<span class=\"hljs-literal\">nullptr</span>)&#123;&#125;<br>      ~<span class=\"hljs-built_in\">node</span>()&#123;&#125;<br>    &#125;;<br><br>    node *head;<br>    <span class=\"hljs-type\">int</span> currentLength;<br>    <span class=\"hljs-function\">node *<span class=\"hljs-title\">move</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> <span class=\"hljs-type\">const</span></span>;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">sLinkList</span>();<br>    ~<span class=\"hljs-built_in\">sLinkList</span>();<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">length</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> currentLength;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i , <span class=\"hljs-type\">const</span> elemType &amp;x)</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">search</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">visit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">traverse</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h5 id=\"构造函数-1\">构造函数</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281418321.png\"\nalt=\"sLinklist\" />\n<figcaption aria-hidden=\"true\">sLinklist</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>sLinkList&lt;elemType&gt;::<span class=\"hljs-built_in\">sLinkList</span>()<br>&#123;<br>  head = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">node</span>();<br>  currentLength = <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"clear\"><code>clear</code></h5>\n<ul>\n<li>将单链表变成一个空表</li>\n<li>回收节点空间</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281420756.png\"\nalt=\"sLinkList::clear\" />\n<figcaption aria-hidden=\"true\">sLinkList::clear</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> sLinkList&lt;elemType&gt;::<span class=\"hljs-built_in\">clear</span>()<br>&#123;<br>  node *p = head-&gt;next , *q;<br><br>  <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-literal\">nullptr</span>)        <span class=\"hljs-comment\">// 删除节点</span><br>  &#123;<br>    q = p-&gt;next;<br>    <span class=\"hljs-keyword\">delete</span> p;<br>    p = q;<br>  &#125;<br>  currentLength = <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"move\"><code>move</code></h5>\n<ul>\n<li>返回第 <span class=\"math inline\"><em>i</em></span> 个元素的指针</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">sLinkList</span>&lt;elemType&gt;::node *sLinkList&lt;elemType&gt;::<span class=\"hljs-built_in\">move</span>(<span class=\"hljs-type\">int</span> i) <span class=\"hljs-type\">const</span><br>&#123;<br>  node *p = head;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span> ; j &lt; i ; ++j)<br>  &#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"insert-1\"><code>insert</code></h5>\n<ol type=\"1\">\n<li>指针 <code>p</code> 指向要插入的位置 <code>i</code>\n的前一个节点</li>\n<li>申请一个新节点 <code>s</code></li>\n<li>将 <code>s</code> 的 <code>next</code> 指向 <code>p</code> 的\n<code>next</code></li>\n<li>将 <code>p</code> 的 <code>next</code> 指向 <code>s</code></li>\n</ol>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281437080.png\"\nalt=\"sLinkList::insert\" />\n<figcaption aria-hidden=\"true\">sLinkList::insert</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> sinkList&lt;elemtype&gt;::<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-type\">int</span> i , <span class=\"hljs-type\">const</span> elemType &amp;x)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">0</span> || i &gt; currentLength)<br>  &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">OutOfBound</span>();<br>  &#125;<br>  node *p = <span class=\"hljs-built_in\">move</span>(i<span class=\"hljs-number\">-1</span>);<br>  node *s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">node</span>(x , p-&gt;next);<br>  p-&gt;next = s;<br>  ++currentLength;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"remove-1\"><code>remove</code></h5>\n<ol type=\"1\">\n<li>找到被删除节点的前一个节点 <code>pos</code></li>\n<li>让 <code>delp</code> 指向被删除节点</li>\n<li>让 <code>pos</code> 的 <code>next</code> 指向 <code>delp</code> 的\n<code>next</code></li>\n<li>释放 <code>delp</code> 的空间</li>\n</ol>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281444167.png\"\nalt=\"sLinkList::remove\" />\n<figcaption aria-hidden=\"true\">sLinkList::remove</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> sLinkList&lt;elemType&gt;::<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-type\">int</span> i)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">0</span> || i &gt;= currentLength)<br>  &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">OutOfBound</span>();<br>  &#125;<br>  node *pos = <span class=\"hljs-built_in\">move</span>(i<span class=\"hljs-number\">-1</span>);<br>  node *delp = pos-&gt;next;<br>  pos-&gt;next = delp-&gt;next;<br>  <span class=\"hljs-keyword\">delete</span> delp;<br>  --currentLength;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"search-1\"><code>search</code></h5>\n<ul>\n<li>从头节点开始，依次访问每个节点，直到找到 <code>x</code>\n或到达表尾</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">int</span> sLinkList&lt;elemType&gt;::<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-type\">const</span> elemtype <span class=\"hljs-number\">7</span>x) <span class=\"hljs-type\">const</span><br>&#123;<br>  node *p = head -&gt; next;<br>  <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-literal\">nullptr</span> &amp;&amp; p-&gt;data != x) <span class=\"hljs-comment\">// 访问每个节点，条件的顺序不能交换</span><br>  &#123;<br>    p = p-&gt;next;<br>    ++i;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>如果判定条件改为\n<code>p-&gt;data != x &amp;&amp; p != nullptr</code>，会在\n<code>p</code> 为空时试图访问\n<code>p-&gt;data</code>，导致访问空指针，从而产生未定义行为</li>\n</ul>\n<h5 id=\"visit\"><code>visit</code></h5>\n<ol type=\"1\">\n<li>找到第 <code>i</code> 个节点</li>\n<li>返回 <code>p-&gt;data</code></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>elemType sLinkList&lt;elemType&gt;::<span class=\"hljs-built_in\">visit</span>(<span class=\"hljs-type\">int</span> i) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">0</span> || i &gt;= currentLength)<br>  &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">OutOfBound</span>();<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">move</span>(i)-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"traverse-1\"><code>traverse</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> sLinkList&lt;elemType&gt;::<span class=\"hljs-built_in\">traverse</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  node *p = head-&gt;next;<br>  <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    cout &lt;&lt; p-&gt;data &lt;&lt; <span class=\"hljs-string\">&#x27; &#x27;</span>;<br>    p = p-&gt;next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"双链表\">双链表</h4>\n<ul>\n<li>每个节点有两个指针字段\n<ul>\n<li><code>next</code> 指向直接后继节点</li>\n<li><code>prev</code> 指向直接前驱节点</li>\n</ul></li>\n</ul>\n<h5 id=\"双链表的头尾节点\">双链表的头尾节点</h5>\n<ul>\n<li>头节点\n<ul>\n<li><code>prev</code> 指向 <code>nullptr</code></li>\n<li><code>next</code> 指向首节点</li>\n</ul></li>\n<li>尾节点 <code>tail</code>\n<ul>\n<li><code>prev</code> 指向最后一个节点</li>\n<li><code>next</code> 指向 <code>nullptr</code></li>\n</ul></li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291712872.png\"\nalt=\"双链表\" />\n<figcaption aria-hidden=\"true\">双链表</figcaption>\n</figure>\n<h5 id=\"双链表类的定义\">双链表类的定义</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">dLinkList</span>:<span class=\"hljs-keyword\">public</span> list&lt;elemType&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">node</span>                                                         <span class=\"hljs-comment\">// 双链表中的节点类</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      node *prev;<br>      <span class=\"hljs-built_in\">node</span>(<span class=\"hljs-type\">const</span> elemType &amp;x , node *p = <span class=\"hljs-literal\">nullptr</span> , node *n = <span class=\"hljs-literal\">nullptr</span>)<br>      &#123;<br>        data = x;<br>        prev = p;<br>        next = n;<br>      &#125;<br>      <span class=\"hljs-built_in\">node</span>():<span class=\"hljs-built_in\">next</span>(<span class=\"hljs-literal\">nullptr</span>),<span class=\"hljs-built_in\">prev</span>(<span class=\"hljs-literal\">nullptr</span>)&#123;&#125;<br>      ~<span class=\"hljs-built_in\">node</span>()&#123;&#125;<br>    &#125;;<br>    node *head , *tail;                                                  <span class=\"hljs-comment\">// 头节点和尾节点</span><br>    <span class=\"hljs-type\">int</span> currentLength;                                                   <span class=\"hljs-comment\">// 当前长度</span><br>    <span class=\"hljs-function\">node *<span class=\"hljs-title\">move</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> <span class=\"hljs-type\">const</span></span>;                                             <span class=\"hljs-comment\">// 返回第 i 个节点的指针</span><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">dLinkList</span>();<br>    ~<span class=\"hljs-built_in\">dLinkList</span>();<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">length</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> currentLength;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i , <span class=\"hljs-type\">const</span> elemType &amp;x)</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">search</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">visit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">traverse</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h5 id=\"构造函数-2\">构造函数</h5>\n<ul>\n<li>申请头节点和尾节点</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291715359.png\"\nalt=\"dLinkList\" />\n<figcaption aria-hidden=\"true\">dLinkList</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>dLinkList&lt;elemType&gt;::<span class=\"hljs-built_in\">dLinkList</span>()<br>&#123;<br>  head = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">node</span>();<br>  tail = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">node</span>();<br>  head-&gt;next = tail;<br>  tail-&gt;prev = head;<br>  currentLength = <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"insert-2\"><code>insert</code></h5>\n<ol type=\"1\">\n<li>申请一个新节点 <code>tmp</code>，找到要插入的位置\n<code>pos</code></li>\n<li>将 <code>tmp</code> 的 <code>prev</code> 指向 <code>pos</code> 的\n<code>prev</code>，<code>tmp</code> 的 <code>next</code> 指向\n<code>pos</code></li>\n<li>将 <code>pos</code> 的前一个结点的 <code>next</code> 指向\n<code>tmp</code></li>\n<li>将 <code>pos</code> 的 <code>prev</code> 指向 <code>tmp</code></li>\n</ol>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291718343.png\"\nalt=\"dLinkList::insert\" />\n<figcaption aria-hidden=\"true\">dLinkList::insert</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> dLinkList&lt;elemtype&gt;::<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-type\">int</span> i ,<span class=\"hljs-type\">const</span> elemTypr &amp;x)<br>[<br>  node *pos , *tmp;<br><br>  pos = <span class=\"hljs-built_in\">move</span>(i);<br>  temp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">node</span>(x,pos -&gt; prev , pos);<br>  pos-&gt;prev-&gt;next = tmp;<br>  pos-&gt;prev = tmp;<br><br>  ++currentLength;<br>]<br></code></pre></td></tr></table></figure>\n<h5 id=\"remove-2\"><code>remove</code></h5>\n<ol type=\"1\">\n<li>找到要删除的节点 <code>pos</code></li>\n<li>将 <code>pos</code> 的前一个节点的 <code>next</code> 指向\n<code>pos</code> 的后一个节点</li>\n<li>将 <code>pos</code> 的后一个节点的 <code>prev</code> 指向\n<code>pos</code> 的前一个节点</li>\n</ol>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291730399.png\"\nalt=\"dLinkList::remove\" />\n<figcaption aria-hidden=\"true\">dLinkList::remove</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> dLinkList&lt;elemType&gt;::<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-type\">int</span> i)<br>&#123;<br>  node *pos = <span class=\"hljs-built_in\">move</span>(i);<br><br>  pos-&gt;prev-&gt;next = pos-&gt;next;<br>  pos-&gt;next-&gt;prev = pos-&gt;prev;<br><br>  <span class=\"hljs-keyword\">delete</span> pos;<br>  --currentLength;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"单循环链表\">单循环链表</h4>\n<ul>\n<li>一般单循环链表不带头节点</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291732560.png\"\nalt=\"单循环链表\" />\n<figcaption aria-hidden=\"true\">单循环链表</figcaption>\n</figure>\n<h4 id=\"双循环链表\">双循环链表</h4>\n<ul>\n<li>头结点中 <code>prev</code> 字段给出尾结点的地址，尾结点中\n<code>next</code> 字段给出头结点的地址</li>\n<li>一般也不设置头尾节点</li>\n</ul>\n<h2 id=\"栈\">栈</h2>\n<h3 id=\"栈的定义\">栈的定义</h3>\n<ul>\n<li>栈是一种特殊的线性表</li>\n<li>只允许在一段进行插入和删除操作</li>\n<li>先进后出（LIFO，Last In First Out）</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291811552.png\"\nalt=\"栈\" />\n<figcaption aria-hidden=\"true\">栈</figcaption>\n</figure>\n<h4 id=\"栈的基本操作\">栈的基本操作</h4>\n<ul>\n<li><strong>创建 <code>create()</code></strong>：创建一个空栈</li>\n<li><strong>进栈 <code>push(x)</code></strong>：将元素 <code>x</code>\n压入栈顶</li>\n<li><strong>出栈\n<code>pop()</code></strong>：删除栈顶元素并返回其值</li>\n<li><strong>访问栈顶元素\n<code>top()</code></strong>：返回栈顶元素的值但是不删除</li>\n<li><strong>判断是否为空 <code>isEmpty()</code></strong>：若栈空返回\n<code>true</code>，否则返回 <code>false</code></li>\n</ul>\n<h4 id=\"栈的抽象类\">栈的抽象类</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">stack</span><br>&#123;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span> </span>= <span class=\"hljs-number\">0</span>;       <span class=\"hljs-comment\">// 进栈</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> elemType <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;                     <span class=\"hljs-comment\">// 出栈</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> elemType <span class=\"hljs-title\">top</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;               <span class=\"hljs-comment\">// 访问栈顶元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;               <span class=\"hljs-comment\">// 是否为空</span><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">stack</span>() &#123;&#125;                             <span class=\"hljs-comment\">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"栈的顺序实现\">栈的顺序实现</h3>\n<ul>\n<li>使用数组储存栈中的节点</li>\n<li>进栈和出栈都是在栈顶进行，不会引起类似顺序表中的大量元素的移动，数组的后端为栈顶</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291817453.png\"\nalt=\"顺序栈\" />\n<figcaption aria-hidden=\"true\">顺序栈</figcaption>\n</figure>\n<h4 id=\"顺序栈类\">顺序栈类</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">seqStack</span>:<span class=\"hljs-keyword\">public</span> stack&lt;elemType&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    elemType *data;                     <span class=\"hljs-comment\">// 数据域</span><br>    <span class=\"hljs-type\">int</span> top_p;                          <span class=\"hljs-comment\">// 栈顶指针</span><br>    <span class=\"hljs-type\">int</span> maxSize;                        <span class=\"hljs-comment\">// 栈的最大容量</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">doubleSpace</span><span class=\"hljs-params\">()</span></span>;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">seqStack</span>(<span class=\"hljs-type\">int</span> initSize = <span class=\"hljs-number\">10</span>);        <span class=\"hljs-comment\">// 构造函数</span><br>    ~<span class=\"hljs-built_in\">seqStack</span>();                        <span class=\"hljs-comment\">// 析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;               <span class=\"hljs-comment\">// 是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span></span>;       <span class=\"hljs-comment\">// 进栈</span><br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span></span>;                    <span class=\"hljs-comment\">// 出栈</span><br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">top</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;               <span class=\"hljs-comment\">// 访问栈顶元素</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"顺序存储的运算实现\">顺序存储的运算实现</h4>\n<h5 id=\"构造函数-3\">构造函数</h5>\n<ul>\n<li>按照用户估计的栈的规模申请一个动态数组，将数组地址保存在\n<code>elem</code> 中，数组规模保存在 <code>maxSize</code> 中，并设\n<code>top_p</code> 的值为 <span class=\"math inline\">−1</span></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>seqStack&lt;elemType&gt;::<span class=\"hljs-built_in\">seqStack</span>(<span class=\"hljs-type\">int</span> initSize)<br>&#123;<br>  elem = <span class=\"hljs-keyword\">new</span> elemType[initSize];<br>  maxSize = initSize;<br>  top_p = <span class=\"hljs-number\">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"push\"><code>push</code></h4>\n<ul>\n<li>先判断栈是否已满，若满则调用 <code>doubleSpace</code>\n扩大栈的容量</li>\n<li>将 <code>top_p</code> 加 1，指向栈顶元素</li>\n<li>将 <code>x</code> 压入栈顶</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> seqStack&lt;elemType&gt;::<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-type\">const</span> elemType &amp;x)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (top_p == maxSize - <span class=\"hljs-number\">1</span>)<br>  &#123;<br>    <span class=\"hljs-built_in\">doubleSpace</span>();<br>  &#125;<br>  elem[++top_p] = x;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"doublespace\"><code>doubleSpace</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> seqStack&lt;elemType&gt;::<span class=\"hljs-built_in\">doubleSpace</span>()<br>&#123;<br>  elemType *tmp = elem;<br>  elem = <span class=\"hljs-keyword\">new</span> elemType[maxSize * <span class=\"hljs-number\">2</span>];<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span> ; i &lt; maxSize ; ++i)<br>  &#123;<br>    elem[i] = tmp[i];<br>  &#125;<br>  maxSize *= <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"pop\"><code>pop</code></h5>\n<ul>\n<li>返回 <code>top_p</code> 指向的元素</li>\n<li>将 <code>top_p</code> 减 1</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>elemType seqStack&lt;elemType&gt;::<span class=\"hljs-built_in\">pop</span>()<br>&#123;<br>  <span class=\"hljs-keyword\">return</span> elem[top_p--];<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"top\"><code>top</code></h5>\n<ul>\n<li>返回 <code>top_p</code> 指向的元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>elemType seqStack&lt;elemType&gt;::<span class=\"hljs-built_in\">top</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> elem[top_p];<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"isempty\"><code>isEmpty</code></h5>\n<ul>\n<li>判断 <code>top_p</code> 是否为 <span\nclass=\"math inline\">−1</span>，若是则栈空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">bool</span> seqStack&lt;elemType&gt;::<span class=\"hljs-built_in\">isEmpty</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> top_p == <span class=\"hljs-number\">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"析构函数-1\">析构函数</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>seqStack&lt;elemType&gt;::~<span class=\"hljs-built_in\">seqStack</span>()<br>&#123;<br>  <span class=\"hljs-keyword\">delete</span>[] elem;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"性能分析\">性能分析</h4>\n<ul>\n<li>所有运算实现的时间复杂度都为 <span\nclass=\"math inline\"><em>O</em>(1)</span></li>\n<li>进栈运算在最坏的情况下的时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>)</span> （需要\n<code>doublespace</code> 时）</li>\n</ul>\n<h3 id=\"栈的链接实现\">栈的链接实现</h3>\n<ul>\n<li>使用<strong>不含头结点的单链表</strong>实现栈</li>\n<li>从使用方便性上看，将单链表的头指针指向栈顶</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291834782.png\"\nalt=\"链接栈\" />\n<figcaption aria-hidden=\"true\">链接栈</figcaption>\n</figure>\n<h4 id=\"链接栈类\">链接栈类</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LinkedStack</span>:<span class=\"hljs-keyword\">public</span> stack&lt;elemType&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">node</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      <span class=\"hljs-built_in\">node</span>(<span class=\"hljs-type\">const</span> elemType &amp;x , node *n = <span class=\"hljs-literal\">nullptr</span>)<br>      &#123;<br>        data = x;<br>        next = n;<br>      &#125;<br>      <span class=\"hljs-built_in\">node</span>():<span class=\"hljs-built_in\">next</span>(<span class=\"hljs-literal\">nullptr</span>)&#123;&#125;<br>      ~<span class=\"hljs-built_in\">node</span>()&#123;&#125;<br>    &#125;;<br>    node *top_p;                       <span class=\"hljs-comment\">// 栈顶指针</span><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">LinkedStack</span>();                    <span class=\"hljs-comment\">// 构造函数</span><br>    ~<span class=\"hljs-built_in\">LinkedStack</span>();                   <span class=\"hljs-comment\">// 析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;             <span class=\"hljs-comment\">// 是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span></span>;     <span class=\"hljs-comment\">// 进栈</span><br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span></span>;                   <span class=\"hljs-comment\">// 出栈</span><br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">top</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;             <span class=\"hljs-comment\">// 访问栈顶元素</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"链接存储的运算实现\">链接存储的运算实现</h4>\n<h5 id=\"构造函数-4\">构造函数</h5>\n<ul>\n<li>将 <code>top_p</code> 初始化为 <code>nullptr</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>LinkedStack&lt;elemType&gt;::<span class=\"hljs-built_in\">LinkedStack</span>()<br>&#123;<br>  top_p = <span class=\"hljs-literal\">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"析构函数-2\">析构函数</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>LinkStack&lt;elemType&gt;::~<span class=\"hljs-built_in\">LinkStack</span>()<br>&#123;<br>  node *tmp;<br>  <span class=\"hljs-keyword\">while</span> (top_p != <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    tmp = top_p;<br>    top_p = top_p-&gt;next;<br>    <span class=\"hljs-keyword\">delete</span> tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"push-1\"><code>push</code></h5>\n<ul>\n<li>在表头插入</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> LinkedStack&lt;elemType&gt;::<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-type\">const</span> elemType &amp;x)<br>&#123;<br>  top_p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">node</span>(x , top_p);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"pop-1\"><code>pop</code></h5>\n<ul>\n<li>删除表头节点</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>elemType LinkedStack&lt;elemType&gt;::<span class=\"hljs-built_in\">pop</span>()<br>&#123;<br>  node *tmp = top_p;<br>  elemType x = top_p-&gt;data;<br>  top_p = top_p-&gt;next;<br>  <span class=\"hljs-keyword\">delete</span> tmp;<br>  <span class=\"hljs-keyword\">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"top-1\"><code>top</code></h5>\n<ul>\n<li>返回 <code>top_p</code> 指向的节点的 <code>data</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>elemType LinkedStack&lt;elemType&gt;::<span class=\"hljs-built_in\">top</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> top_p-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"isempty-1\"><code>isEmpty</code></h5>\n<ul>\n<li>判断 <code>top_p</code> 是否为 <code>nullptr</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">bool</span> LinkedStack&lt;elemType&gt;::<span class=\"hljs-built_in\">isEmpty</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> top_p == <span class=\"hljs-literal\">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"性能分析-1\">性能分析</h4>\n<ul>\n<li>所有运算实现的时间复杂度都为 <span\nclass=\"math inline\"><em>O</em>(1)</span>，因为都是对栈顶进行操作</li>\n</ul>\n<h3 id=\"栈的应用\">栈的应用</h3>\n<h4 id=\"递归函数的非递归实现\">递归函数的非递归实现</h4>\n<h5 id=\"函数调用\">函数调用</h5>\n<ul>\n<li>递归的本质是函数调用，函数调用又是通过栈实现的，递归时会产生隐式栈</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  ...<br>  r1:<span class=\"hljs-built_in\">f1</span>();<br>  r2:<br>  ..<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  ...<br>  t1:<span class=\"hljs-built_in\">f2</span>();<br>  t2:<br>  ...<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  ...<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503301445662.png\"\nalt=\"函数执行过程\" />\n<figcaption aria-hidden=\"true\">函数执行过程</figcaption>\n</figure>\n<ul>\n<li>设置一个栈模拟函数调用，当调用发生时，将函数压入栈中</li>\n<li>函数返回时，将栈顶元素弹出</li>\n</ul>\n<h6 id=\"递归算法的例子\">递归算法的例子</h6>\n<p>hanoi 塔算法</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Move</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> Height , <span class=\"hljs-type\">int</span> FromNeedle ,<span class=\"hljs-type\">int</span> ToNeedle ,<span class=\"hljs-type\">int</span> UsingNeedle)</span> <span class=\"hljs-comment\">// FromNeedle是起始针，ToNeedle是目标针，UsingNeedle是辅助针</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (Height &gt; <span class=\"hljs-number\">0</span>)<br>  &#123;<br>    <span class=\"hljs-built_in\">Move</span>(Height - <span class=\"hljs-number\">1</span>，FromNeedle , UsingNeeedle,ToNeedle); <span class=\"hljs-comment\">// 将上面n-1个盘子从FromNeedle移动到UsingNeedle</span><br>    cout &lt;&lt; FromNeedle &lt;&lt; <span class=\"hljs-string\">&quot;-&gt;&quot;</span> &lt;&lt; ToNeedle &lt;&lt; endl; <span class=\"hljs-comment\">// 将最底下的盘子从FromNeedle移动到ToNeedle&gt;</span><br>    <span class=\"hljs-built_in\">Move</span>(Height - <span class=\"hljs-number\">1</span>,UsingNeedle , ToNeedle , FromNeedle); <span class=\"hljs-comment\">// 将上面的盘子从UsingNeedle移动到ToNeedle</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"递归算法的时间复杂度\">递归算法的时间复杂度</h5>\n<h6 id=\"数学归纳法\">数学归纳法</h6>\n<p>以 Hanio 塔问题为例</p>\n<p><span class=\"math display\">$$\n\\begin{dcases}\nT(n) = 2T(n-1) + 1 &amp;\\\\\nT(1) = 1 &amp;\n\\end{dcases}\n$$</span></p>\n<p>可以使用数学归纳法证明 <span\nclass=\"math inline\"><em>T</em>(<em>n</em>) = 2<sup><em>n</em></sup> − 1</span></p>\n<h6 id=\"递归方程\">递归方程</h6>\n<p><strong>主定理</strong>：设 <span\nclass=\"math inline\"><em>a</em> ≥ 1</span>，<span\nclass=\"math inline\"><em>b</em> &gt; 1</span> 为常数，<span\nclass=\"math inline\"><em>f</em>(<em>n</em>)</span>\n是一个函数，则递归方程</p>\n<p><span class=\"math display\">$$\nT(n) = aT(\\frac{n}{b}) + f(n) \\quad (n &gt; 1)\n$$</span></p>\n<p>的解为</p>\n<ol type=\"1\">\n<li>若 <span\nclass=\"math inline\"><em>f</em>(<em>n</em>) &lt; <em>O</em>(<em>n</em><sup>log<sub><em>b</em></sub><em>a</em></sup>)</span>，则\n<span\nclass=\"math inline\"><em>T</em>(<em>n</em>) = <em>O</em>(<em>n</em><sup>log<sub><em>b</em></sub><em>a</em></sup>)</span></li>\n<li>若 <span\nclass=\"math inline\"><em>f</em>(<em>n</em>) = <em>O</em>(<em>n</em><sup>log<sub><em>b</em></sub><em>a</em></sup>)</span>，则\n<span\nclass=\"math inline\"><em>T</em>(<em>n</em>) = <em>O</em>(<em>n</em><sup>log<sub><em>b</em></sub><em>a</em></sup>log<sub>2</sub><em>n</em>)</span></li>\n<li>若 <span\nclass=\"math inline\"><em>f</em>(<em>n</em>) &gt; <em>O</em>(<em>n</em><sup>log<sub><em>b</em></sub><em>a</em></sup>)</span>，则\n<span\nclass=\"math inline\"><em>T</em>(<em>n</em>) = <em>O</em>(<em>f</em>(<em>n</em>))</span></li>\n</ol>\n<h6 id=\"生成函数\">生成函数</h6>\n<p><strong>定义</strong>：设 <span\nclass=\"math inline\"><em>u</em><sub>0</sub>, <em>u</em><sub>1</sub>, <em>u</em><sub>2</sub>, …, <em>u</em><sub><em>n</em></sub>, …</span>\n是一无穷序列，称形式幂级数 <span\nclass=\"math inline\"><em>G</em>(<em>t</em>) = ∑<sub><em>i</em> ≥ 0</sub><em>u</em><sub><em>i</em></sub><em>t</em><sup><em>i</em></sup></span>\n为其生成函数</p>\n<p>利用生成函数求通项的方法</p>\n<ol type=\"1\">\n<li>按照递归关系式消去无限延长的部分</li>\n<li>展开为 <span class=\"math inline\"><em>t</em></span>\n的幂级数求通项</li>\n</ol>\n<p>以 Fibonacci 数列为例</p>\n<p><span class=\"math display\">$$\n\\begin{dcases}\nF_{0} =0 &amp; \\\\\nF_{1} =1 &amp; \\\\\nF_{n} =F_{n-1} +F_{n-2} &amp;\n\\end{dcases}\n$$</span></p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  &amp;G(t) = F_{0}t^0 + F_{1}t^1 + F_{2}t^2 + F_{3}t^3 + \\cdots \\\\\n  &amp;G(t) = t + t^2 + t^3 + \\cdots \\\\\n  &amp;tG(t)=t^2 + t^3 + t^4 + \\cdots \\\\\n  &amp;t^2G(t)=t^3 + t^4 + t^5 + \\cdots \\\\\n  &amp;(1-t-t^2)G(t) = t \\\\\n  &amp;G(t) = \\frac{t}{1-t-t^2} = \\frac{1}{\\sqrt{5}}\n\\left(\\frac{1}{1-\\frac{1+\\sqrt{5}}{2}t} -\n\\frac{1}{1-\\frac{1-\\sqrt{5}}{2}t}\\right) \\\\\n\\end{aligned}\n$$</span></p>\n<p>令 <span class=\"math inline\">$\\Phi =\n\\frac{1}{2}(1+\\sqrt{5})$</span>，<span\nclass=\"math inline\">$\\hat{\\Phi}=\\frac{1}{2}(1-\\sqrt{5})$</span></p>\n<p><span class=\"math display\">$$\nG(t) =\\frac{1}{\\sqrt{5}}(\\frac{1}{1-\\Phi t} - \\frac{1}{1-\\hat{\\Phi}t})\n$$</span></p>\n<p>有 <span class=\"math inline\">$\\displaystyle\\frac{1}{1-\\Phi t} =\n\\sum_{n=0}^{\\infty} \\Phi^n t^n$</span></p>\n<p><span class=\"math display\">$$\nG(t) = \\frac{1}{\\sqrt{5}} \\sum_{n=0}^{\\infty} (\\Phi^n t^n - \\hat{\\Phi}^n\nt^n)\n$$</span></p>\n<p>则</p>\n<p><span class=\"math display\">$$\nF_n = \\frac{1}{\\sqrt{5}}(\\Phi^n - \\hat{\\Phi}^n)\n$$</span></p>\n<h4 id=\"递归消除\">递归消除</h4>\n<p>以打印正整数为例</p>\n<h5 id=\"递归实现\">递归实现</h5>\n<h6 id=\"代码\">代码</h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printNum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (num &gt;= <span class=\"hljs-number\">10</span>)<br>  &#123;<br>    <span class=\"hljs-built_in\">printNum</span>(num / <span class=\"hljs-number\">10</span>);<br>    cout.<span class=\"hljs-built_in\">put</span>(num % <span class=\"hljs-number\">10</span> + <span class=\"hljs-string\">&#x27;0&#x27;</span>);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    cout.<span class=\"hljs-built_in\">put</span>(num + <span class=\"hljs-string\">&#x27;0&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"代码运行过程中栈的变化\">代码运行过程中栈的变化</h6>\n<ol type=\"1\">\n<li><code>push(1234)</code></li>\n<li><code>pop(1234)</code>，<code>push(4)</code>，<code>push(123)</code></li>\n<li><code>pop(123)</code>，<code>push(3)</code>，<code>push(12)</code></li>\n<li><code>pop(12)</code>，<code>push(2)</code>，<code>push(1)</code></li>\n<li><code>pop(1)</code>，<code>pop(2)</code>，<code>pop(3)</code>，<code>pop(4)</code></li>\n</ol>\n<h5 id=\"非递归实现\">非递归实现</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printNum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  LinkStack&lt;<span class=\"hljs-type\">int</span>&gt; s;<br>  <span class=\"hljs-type\">int</span> tmp;<br>  s.<span class=\"hljs-built_in\">push</span>(num);<br>  <span class=\"hljs-keyword\">while</span> (!<span class=\"hljs-built_in\">isEmpty</span>())<br>  &#123;<br>    tmp = s.<span class=\"hljs-built_in\">pop</span>();<br>    <span class=\"hljs-keyword\">if</span> (tmp &gt; <span class=\"hljs-number\">9</span>)<br>    &#123;<br>      s.<span class=\"hljs-built_in\">push</span>(tmp % <span class=\"hljs-number\">10</span>);<br>      s.<span class=\"hljs-built_in\">push</span>(tmp / <span class=\"hljs-number\">10</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      cout.<span class=\"hljs-built_in\">put</span>(tmp + <span class=\"hljs-string\">&#x27;0&#x27;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"括号匹配\">括号匹配</h3>\n<ul>\n<li>判断一个表达式中的括号是否匹配</li>\n<li>遇到左括号就入栈，遇到右括号就出栈</li>\n</ul>\n<p>判断错误的原则</p>\n<ol type=\"1\">\n<li>栈空时遇到右括号</li>\n<li>出栈时遇到不匹配的括号</li>\n<li>栈不空时结束</li>\n</ol>\n<h3 id=\"简单的计算数学表达式\">简单的计算数学表达式</h3>\n<h4 id=\"前缀式中缀式和后缀式\">前缀式、中缀式和后缀式</h4>\n<p>对于一个表达式 <span\nclass=\"math inline\"><em>a</em> + <em>b</em></span></p>\n<ul>\n<li>前缀式 <code>+ab</code>，波兰式</li>\n<li>中缀式 <code>a+b</code></li>\n<li>后缀式 <code>ab+</code>，逆波兰式</li>\n</ul>\n<h4 id=\"后缀式的优点\">后缀式的优点</h4>\n<ul>\n<li>不需要括号</li>\n<li>不需要考虑运算符的优先级</li>\n<li>计算机容易处理</li>\n</ul>\n<h4 id=\"后缀式的计算\">后缀式的计算</h4>\n<ul>\n<li>使用栈来存储操作数</li>\n<li>遇到操作数就入栈</li>\n<li>遇到操作符就出栈两个操作数，进行计算，将结果入栈</li>\n<li>最后栈中只剩下一个元素，就是结果</li>\n</ul>\n<h4 id=\"中缀式转换为后缀式的算法\">中缀式转换为后缀式的算法</h4>\n<p>操作方法见<a\nhref=\"/本科/编程/数据结构/中缀计算式转换为后缀计算式.md\">中缀计算式转换为后缀计算式</a></p>\n<h2 id=\"队列\">队列</h2>\n<ul>\n<li><p>队列的定义</p></li>\n<li><p>先进先出（FIFO，First In First Out）</p></li>\n<li><p>只允许在一端（队首）进行插入操作，另一端（队尾）进行删除操作</p></li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503310847159.png\"\nalt=\"队列\" />\n<figcaption aria-hidden=\"true\">队列</figcaption>\n</figure>\n<h4 id=\"队列的基本操作\">队列的基本操作</h4>\n<ul>\n<li><strong>创建 <code>create()</code></strong>：创建一个空队列</li>\n<li><strong>入队 <code>enQueue(x)</code></strong>：将元素 <code>x</code>\n入队</li>\n<li><strong>出队\n<code>deQueue()</code></strong>：删除队首元素并返回其值</li>\n<li><strong>访问队首元素\n<code>getHead()</code></strong>：返回队首元素的值但不删除</li>\n<li><strong>判断是否为空 <code>isEmpty()</code></strong>：若队列空返回\n<code>true</code>，否则返回 <code>false</code></li>\n</ul>\n<h4 id=\"队列的抽象类\">队列的抽象类</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">queue</span><br>&#123;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">enQueue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span> </span>= <span class=\"hljs-number\">0</span>;       <span class=\"hljs-comment\">// 入队</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> elemType <span class=\"hljs-title\">deQueue</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;                    <span class=\"hljs-comment\">// 出队</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> elemType <span class=\"hljs-title\">getHead</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;              <span class=\"hljs-comment\">// 访问队首元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;                  <span class=\"hljs-comment\">// 是否为空</span><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">queue</span>() &#123;&#125;                                 <span class=\"hljs-comment\">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"队列的顺序实现\">队列的顺序实现</h3>\n<ul>\n<li>使用数组来存储队列中的元素</li>\n<li>元素下标的范围为 <span class=\"math inline\">0</span> 到\n<code>maxSize - 1</code></li>\n<li>存储队里的三种组织方法\n<ol type=\"1\">\n<li>队头位置固定</li>\n<li>队头位置不固定</li>\n<li>循环队列</li>\n</ol></li>\n</ul>\n<h4 id=\"队头位置固定\">队头位置固定</h4>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311613560.png\"\nalt=\"队头位置固定\" />\n<figcaption aria-hidden=\"true\">队头位置固定</figcaption>\n</figure>\n<p><strong>缺点</strong>：出队的时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>)</span>，因为出队时需要将所有元素向前移动一位</p>\n<h4 id=\"队头位置不固定\">队头位置不固定</h4>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311614368.png\"\nalt=\"队头位置不固定\" />\n<figcaption aria-hidden=\"true\">队头位置不固定</figcaption>\n</figure>\n<p><strong>优点</strong>：所有操作的时间复杂度均为 <span\nclass=\"math inline\"><em>O</em>(1)</span>\n<strong>缺点</strong>：浪费大量的空间</p>\n<h4 id=\"循环队列\">循环队列</h4>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311626377.png\"\nalt=\"循环队列\" />\n<figcaption aria-hidden=\"true\">循环队列</figcaption>\n</figure>\n<ul>\n<li>入队\n<ul>\n<li><code>rear = (rear + 1) % maxSize</code>;\n<code>elem[rear] = x</code></li>\n</ul></li>\n<li>出队\n<ul>\n<li><code>front = (front + 1) % maxSize</code>;\n<code>return elem[front]</code></li>\n</ul></li>\n</ul>\n<p>为了解决队列空和队列满的判断问题，令 <code>front</code>\n指向的单元不能存储队列元素，只能起到标志作用</p>\n<ul>\n<li>队列空：<code>front == rear</code></li>\n<li>队列满：<code>(rear + 1) % maxSize == front</code></li>\n</ul>\n<h6 id=\"循环队列类的定义\">循环队列类的定义</h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">seqQueue</span>:<span class=\"hljs-keyword\">public</span> queue&lt;elemType&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    elemType *elem;<br>    <span class=\"hljs-type\">int</span> maxSize;<br>    <span class=\"hljs-type\">int</span> front , rear;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">doubleSpace</span><span class=\"hljs-params\">()</span></span>;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">seqQueue</span>(<span class=\"hljs-type\">int</span> initSize = <span class=\"hljs-number\">10</span>);        <span class=\"hljs-comment\">// 构造函数</span><br>    ~<span class=\"hljs-built_in\">seqQueue</span>();                        <span class=\"hljs-comment\">// 析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span></span>;                     <span class=\"hljs-comment\">// 是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">enQueue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span></span>;    <span class=\"hljs-comment\">// 入队</span><br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">deQueue</span><span class=\"hljs-params\">()</span></span>;                 <span class=\"hljs-comment\">// 出队</span><br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">getHead</span><span class=\"hljs-params\">()</span></span>;                 <span class=\"hljs-comment\">// 访问队首元素</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h5 id=\"构造函数-5\">构造函数</h5>\n<ul>\n<li>申请一块空间，将 <code>front</code> 和 <code>rear</code> 初始化为\n<span class=\"math inline\">0</span></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>seqQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">seqQueue</span>(<span class=\"hljs-type\">int</span> initSize)<br>&#123;<br>  elem = <span class=\"hljs-keyword\">new</span> elemType[initSize];<br>  maxSize = initSize;<br>  front = rear = <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"析构函数-3\">析构函数</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>seqQueue&lt;elemType&gt;::~<span class=\"hljs-built_in\">seqQueue</span>()<br>&#123;<br>  <span class=\"hljs-keyword\">delete</span>[] elem;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"enqueue\"><code>enQueue</code></h5>\n<ul>\n<li>先判断队列是否已满，若满则调用 <code>doubleSpace</code>\n扩大队列的容量</li>\n<li>将 <code>rear</code> 加 1，指向队尾元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> seqQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">enQueue</span>(<span class=\"hljs-type\">const</span> elemType &amp;x)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> ((rear + <span class=\"hljs-number\">1</span>) % maxSize == front)<br>  &#123;<br>    <span class=\"hljs-built_in\">doubleSpace</span>();<br>  &#125;<br>  rear = (rear + <span class=\"hljs-number\">1</span>) % maxSize;<br>  elem[rear] = x;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"doublespace-1\"><code>doubleSpace</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> seqQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">doubleSpace</span>()<br>&#123;<br>  elemType *tmp = elem;<br>  elem = <span class=\"hljs-keyword\">new</span> elemType[maxSize * <span class=\"hljs-number\">2</span>];<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span> ; i &lt; maxSize ; ++i)<br>  &#123;<br>    elem[i] = tmp[(front + i) % maxSize];<br>  &#125;<br>  front = <span class=\"hljs-number\">0</span>;<br>  rear = maxSize - <span class=\"hljs-number\">1</span>;<br>  maxSize *= <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"dequeue\"><code>deQueue</code></h5>\n<ul>\n<li>将 <code>front</code> 加 1，指向队首元素</li>\n<li>返回 <code>elem[front]</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>elemType seqQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">deQueue</span>()<br>&#123;<br>  front = (front + <span class=\"hljs-number\">1</span>) % maxSize;<br>  <span class=\"hljs-keyword\">return</span> elem[front];<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"gethead\"><code>getHead</code></h5>\n<ul>\n<li>返回 <code>elem[(front + 1) % maxSize]</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>elemType seqQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">getHead</span>()<br>&#123;<br>  <span class=\"hljs-keyword\">return</span> elem[(front + <span class=\"hljs-number\">1</span>) % maxSize];<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"isempty-2\"><code>isEmpty</code></h5>\n<ul>\n<li>判断 <code>front</code> 是否等于 <code>rear</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">bool</span> seqQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">isEmpty</span>()<br>&#123;<br>  <span class=\"hljs-keyword\">return</span> front == rear;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"队列的链接实现\">队列的链接实现</h3>\n<ul>\n<li>为了方便操作，使用含头节点和尾节点的单链表实现</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311804800.png\"\nalt=\"链接队列\" />\n<figcaption aria-hidden=\"true\">链接队列</figcaption>\n</figure>\n<p><strong>链接队列的特点</strong></p>\n<ul>\n<li>不会出现队列满的情况，但是会出现队列空的情况</li>\n<li>队列为空时，单链表中没有节点存在，即头尾指针都为\n<code>nullptr</code></li>\n<li>保存一个链接队列只需要两个分别指向单链表节点的指针\n<code>front</code> 和 <code>rear</code>\n<ul>\n<li><code>front</code> 指向队首元素</li>\n<li><code>rear</code> 指向队尾元素</li>\n</ul></li>\n</ul>\n<h4 id=\"连接队列类\">连接队列类</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">linkQueue</span>:<span class=\"hljs-keyword\">public</span> queue&lt;elemType&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">node</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      <span class=\"hljs-built_in\">node</span>(<span class=\"hljs-type\">const</span> elemType &amp;x , node *n = <span class=\"hljs-literal\">nullptr</span>)<br>      &#123;<br>        data = x;<br>        next = n;<br>      &#125;<br>      <span class=\"hljs-built_in\">node</span>():<span class=\"hljs-built_in\">next</span>(<span class=\"hljs-literal\">nullptr</span>)&#123;&#125;<br>      ~<span class=\"hljs-built_in\">node</span>()&#123;&#125;<br>    &#125;;<br>    node *front , *rear;                <span class=\"hljs-comment\">// 队头和队尾指针</span><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">linkQueue</span>();                       <span class=\"hljs-comment\">// 构造函数</span><br>    ~<span class=\"hljs-built_in\">linkQueue</span>();                      <span class=\"hljs-comment\">// 析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> </span>;              <span class=\"hljs-comment\">// 是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">enQueue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span></span>;   <span class=\"hljs-comment\">// 入队</span><br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">deQueue</span><span class=\"hljs-params\">()</span></span>;                <span class=\"hljs-comment\">// 出队</span><br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">getHead</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;          <span class=\"hljs-comment\">// 访问队首元素</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h5 id=\"构造函数-6\">构造函数</h5>\n<ul>\n<li>将 <code>front</code> 和 <code>rear</code> 初始化为\n<code>nullptr</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>linkQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">linkQueue</span>()<br>&#123;<br>  front = rear = <span class=\"hljs-literal\">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"enqueue-1\"><code>enQueue</code></h5>\n<ol type=\"1\">\n<li>申请一个节点空间 <code>x</code></li>\n<li>将 <code>rear</code> 指向的节点的 <code>next</code> 指向\n<code>x</code></li>\n<li>将 <code>rear</code> 指向 <code>x</code></li>\n</ol>\n<p><strong>注意</strong>：存在队列为空的情况，此时我们只需要将\n<code>front</code> 和 <code>rear</code> 都指向 <code>x</code> 即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> linkQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">enQueue</span>(<span class=\"hljs-type\">const</span> elemType &amp;x)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (rear == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    front = rear = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">node</span>(x);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    rear = rear-&gt;next = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">node</span>(x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"dequeue-1\"><code>deQueue</code></h5>\n<ol type=\"1\">\n<li>返回 <code>front</code> 指向的节点的 <code>data</code></li>\n<li>将 <code>front</code> 指向的节点从链表中摘下</li>\n<li>释放空间</li>\n</ol>\n<p><strong>注意</strong>：当队列中只有一个元素时，删除后队列为空，此时需要将\n<code>front</code> 和 <code>rear</code> 都置为 <code>nullptr</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> LinkQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">deQueue</span>()<br>&#123;<br>  node *tmp = front;<br>  <span class=\"hljs-keyword\">if</span> (front)<br>  &#123;<br>    emelType value = front-&gt;data;<br>    front = front-&gt;next;<br>    <span class=\"hljs-keyword\">if</span> (front == <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>      rear = <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">delete</span> tmp;<br>    <span class=\"hljs-keyword\">return</span> value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"gethead-1\"><code>getHead</code></h5>\n<ul>\n<li>返回 <code>front</code> 指向的节点的 <code>data</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>elemType linkQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">getHead</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> front-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"isempty-3\"><code>isEmpty</code></h5>\n<ul>\n<li>判断 <code>front</code> 或 <code>rear</code> 是否为\n<code>nullptr</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">bool</span> linkQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">isEmpty</span>()<br>&#123;<br>  <span class=\"hljs-keyword\">return</span> front == <span class=\"hljs-literal\">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"析构函数-4\">析构函数</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>linkQueue&lt;elemType&gt;::~<span class=\"hljs-built_in\">linkQueue</span>()<br>&#123;<br>  node *tmp;<br>  <span class=\"hljs-keyword\">while</span> (front != <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    tmp = front;<br>    front = front-&gt;next;<br>    <span class=\"hljs-keyword\">delete</span> tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"树\">树</h2>\n<h3 id=\"树的定义\">树的定义</h3>\n<h4 id=\"树的递归定义\">树的递归定义</h4>\n<ul>\n<li>树是 <span class=\"math inline\"><em>n</em></span>\n个节点的有限集合，它或者是空集，或者满足\n<ul>\n<li>有一个特殊的节点称为根节点</li>\n<li>除根节点外，其他节点分为 <span class=\"math inline\"><em>m</em></span>\n个互不相交的有限集合 <span\nclass=\"math inline\"><em>T</em><sub>1</sub>, <em>T</em><sub>2</sub>, …, <em>T</em><sub><em>m</em></sub></span>，每个集合都是一棵树</li>\n</ul></li>\n</ul>\n<h4 id=\"树的术语\">树的术语</h4>\n<ul>\n<li><strong>根节点、叶节点、内部节点</strong>：\n<ul>\n<li>根节点：没有父节点的节点</li>\n<li>叶节点：没有子节点的节点</li>\n<li>内部节点：有子节点的节点</li>\n</ul></li>\n<li><strong>节点的度和树的度</strong>：\n<ul>\n<li>节点的度：节点的子树个数</li>\n<li>树的度：树中所有节点的度的最大值</li>\n</ul></li>\n<li><strong>儿子节点</strong></li>\n<li><strong>父亲节点</strong></li>\n<li><strong>兄弟节点</strong></li>\n<li><strong>祖先节点</strong></li>\n<li><strong>子孙节点</strong></li>\n<li><strong>节点所处层次</strong></li>\n<li><strong>树的高度</strong></li>\n<li><strong>有序树</strong></li>\n<li><strong>无序树</strong></li>\n<li><strong>森林</strong></li>\n</ul>\n<h4 id=\"树的运算\">树的运算</h4>\n<ul>\n<li><strong>建树 <code>create()</code></strong>：创建一个空树</li>\n<li><strong>清空 <code>clear()</code></strong>：删除树中所有节点</li>\n<li><strong>判空 <code>IsEmpty()</code></strong>：判断是否为空树</li>\n<li><strong>找根节点\n<code>root()</code></strong>：找出树的根节点值，若为空树则返回特殊值</li>\n<li><strong>找父节点\n<code>parent()</code></strong>：找到节点的父节点，若该节点不存在或为根节点则返回特殊值</li>\n<li><strong>找子节点\n<code>child()</code></strong>：找到节点的某个子节点，若该节点不存在或没有子节点则返回特殊值</li>\n<li><strong>剪枝 <code>remove()</code></strong>：删除节点的某棵子树</li>\n<li><strong>遍历\n<code>traverse()</code></strong>：访问树上的每个节点</li>\n</ul>\n<h4 id=\"树的抽象类\">树的抽象类</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">tree</span><br>&#123;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> T <span class=\"hljs-title\">root</span><span class=\"hljs-params\">(T flag)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> T <span class=\"hljs-title\">parent</span><span class=\"hljs-params\">(T x , T flag)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> T <span class=\"hljs-title\">child</span><span class=\"hljs-params\">(T x , <span class=\"hljs-type\">int</span> i , T flag)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(T x)</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">traverse</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"二叉树\">二叉树</h3>\n<h4 id=\"二叉树的定义\">二叉树的定义</h4>\n<ul>\n<li>二叉树（Binary\nTree）是节点的有限集合，要么为空，要么由一个根节点以及两棵互不相交的左右子树构成，而其左右子树也是二叉树</li>\n</ul>\n<p><strong>注意</strong>：二叉树是<strong>有序树</strong>，必须严格区分左右子树，即使只有一棵子树也要说明是左子树还是右子树，交换左右子树得到另一棵二叉树</p>\n<p>二叉树有五种基本形态</p>\n<ol type=\"1\">\n<li>空树</li>\n<li>只有一个节点的树</li>\n<li>只有左子树的树</li>\n<li>只有右子树的树</li>\n<li>左右子树都有的树</li>\n</ol>\n<h5 id=\"满二叉树\">满二叉树</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311916690.png\"\nalt=\"满二叉树\" />\n<figcaption aria-hidden=\"true\">满二叉树</figcaption>\n</figure>\n<ul>\n<li>每个节点的度都为 <span class=\"math inline\">0</span> 或 <span\nclass=\"math inline\">2</span> 的二叉树称为满二叉树</li>\n<li>性质\n<ul>\n<li>高度为 <span class=\"math inline\"><em>h</em></span> 的满二叉树有\n<span class=\"math inline\">2<sup><em>h</em></sup> − 1</span> 个节点</li>\n<li>任意一层的节点个数达到了上限 <span\nclass=\"math inline\">2<sup><em>n</em> − 1</sup></span></li>\n</ul></li>\n</ul>\n<h5 id=\"完全二叉树\">完全二叉树</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311917668.png\"\nalt=\"完全二叉树\" />\n<figcaption aria-hidden=\"true\">完全二叉树</figcaption>\n</figure>\n<ul>\n<li>在满二叉树的最底层从右向左依次删除若干个节点得到的树为完全二叉树</li>\n<li>满二叉树是完全二叉树，完全二叉树不一定是满二叉树</li>\n<li>性质\n<ul>\n<li>所有的叶节点都出现在最低的两层生</li>\n<li>对于任意节点，如果其右子树的高度为 <span\nclass=\"math inline\"><em>h</em></span>，则其左子树的高度为 <span\nclass=\"math inline\"><em>h</em></span> 或 <span\nclass=\"math inline\"><em>h</em> + 1</span></li>\n</ul></li>\n</ul>\n<h4 id=\"二叉树的性质\">二叉树的性质</h4>\n<ol type=\"1\">\n<li>二叉树的第 <span class=\"math inline\"><em>i</em></span> 层最多有\n<span class=\"math inline\">2<sup><em>i</em> − 1</sup></span> 个节点</li>\n<li>二叉树的深度为 <span class=\"math inline\"><em>h</em></span>，则最多有\n<span class=\"math inline\">2<sup><em>h</em></sup> − 1</span> 个节点</li>\n<li>对于一棵非空二叉树，若其叶节点个数为 <span\nclass=\"math inline\"><em>n</em><sub>0</sub></span>，则其度为 <span\nclass=\"math inline\">2</span> 的节点个数为 <span\nclass=\"math inline\"><em>n</em><sub>2</sub></span>，则有 <span\nclass=\"math inline\"><em>n</em><sub>0</sub> = <em>n</em><sub>2</sub> + 1</span></li>\n<li>具有 <span class=\"math inline\"><em>n</em></span>\n个节点的二叉树的高度为 <span class=\"math inline\"><em>h</em></span>，则\n<span\nclass=\"math inline\"><em>h</em> = ⌊log<sub>2</sub><em>n</em>⌋ + 1</span></li>\n<li>对于一棵具有 <span class=\"math inline\"><em>n</em></span>\n个节点的完全二叉树中的节点按层自上而下，每层从左到右编号，若设根节点的编号为\n<span class=\"math inline\">1</span>，则对任一编号为 <span\nclass=\"math inline\"><em>u</em></span> 的节点，有\n<ol type=\"1\">\n<li>如果 <span class=\"math inline\"><em>i</em> = 1</span>，则 <span\nclass=\"math inline\"><em>u</em></span> 为根节点</li>\n<li>如果 <span class=\"math inline\"><em>i</em> &gt; 1</span>，则 <span\nclass=\"math inline\"><em>u</em></span> 的父节点编号为 <span\nclass=\"math inline\">$\\lfloor \\frac{u}{2} \\rfloor$</span></li>\n<li>如果 <span\nclass=\"math inline\">2<em>i</em> ≥ <em>n</em></span>，则编号为 <span\nclass=\"math inline\"><em>i</em></span>\n的节点为叶子节点，没有儿子；否则，其左子编号为 <span\nclass=\"math inline\">2<em>i</em></span></li>\n<li>如果 <span\nclass=\"math inline\">2<em>i</em> + 1 ≥ <em>n</em></span>，则编号为 <span\nclass=\"math inline\"><em>i</em></span> 的节点无右儿子；否则，其右子编号为\n<span class=\"math inline\">2<em>i</em> + 1</span></li>\n</ol></li>\n</ol>\n<h4 id=\"二叉树的基本运算\">二叉树的基本运算</h4>\n<ul>\n<li><strong>建树 <code>create()</code></strong>：创建一棵空树</li>\n<li><strong>清空 <code>clear()</code></strong>：删除树中所有节点</li>\n<li><strong>判空 <code>isEmpty()</code></strong>：判断是否为空树</li>\n<li><strong>找根节点\n<code>root()</code></strong>：找出树的根节点值，若为空树则返回特殊值</li>\n<li><strong>找父节点\n<code>parent()</code></strong>：找到节点的父节点，若该节点不存在或为根节点则返回特殊值</li>\n<li><strong>找左子节点\n<code>lchild()</code></strong>：找到节点的左子节点，若该节点不存在或没有左子节点则返回特殊值</li>\n<li><strong>找右子节点\n<code>rchild()</code></strong>：找到节点的右子节点，若该节点不存在或没有右子节点则返回特殊值</li>\n<li><strong>删除左子树\n<code>delLeft()</code></strong>：删除节点的左子树</li>\n<li><strong>删除右子树\n<code>delRight()</code></strong>：删除节点的右子树</li>\n<li><strong>遍历\n<code>traverse()</code></strong>：访问树上的每个节点</li>\n</ul>\n<h4 id=\"二叉树的遍历\">二叉树的遍历</h4>\n<h5 id=\"前序遍历\">前序遍历</h5>\n<ul>\n<li>如果树为空，则操作为空</li>\n<li>如果树不空，则访问根节点，然后前序遍历左子树，最后前序遍历右子树</li>\n</ul>\n<h5 id=\"中序遍历\">中序遍历</h5>\n<ul>\n<li>如果树为空，则操作为空</li>\n<li>如果树不空，则中序遍历左子树，然后访问根节点，最后中序遍历右子树</li>\n</ul>\n<h5 id=\"后序遍历\">后序遍历</h5>\n<ul>\n<li>如果树为空，则操作为空</li>\n<li>如果树不空，则后序遍历左子树，然后后序遍历右子树，最后访问根节点</li>\n</ul>\n<h5 id=\"层次遍历\">层次遍历</h5>\n<ul>\n<li>从上到下，从左到右访问树的每个节点</li>\n</ul>\n<h5 id=\"性质\">性质</h5>\n<ul>\n<li>由前序遍历和中序遍历可以唯一确定一棵二叉树</li>\n<li>由中序遍历和后序遍历可以唯一确定一棵二叉树</li>\n<li>由前序遍历和后序遍历<strong>不能</strong>唯一确定一棵二叉树</li>\n</ul>\n<h4 id=\"二叉树抽象类\">二叉树抽象类</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">binaryTree</span><br>&#123;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;                     <span class=\"hljs-comment\">// 清空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;             <span class=\"hljs-comment\">// 是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> T <span class=\"hljs-title\">root</span><span class=\"hljs-params\">(T flag)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;             <span class=\"hljs-comment\">// 找根节点</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> T <span class=\"hljs-title\">parent</span><span class=\"hljs-params\">(T x , T flag)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;     <span class=\"hljs-comment\">// 找父节点</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> T <span class=\"hljs-title\">lchild</span><span class=\"hljs-params\">(T x , T flag)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;     <span class=\"hljs-comment\">// 找左子节点</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> T <span class=\"hljs-title\">rchild</span><span class=\"hljs-params\">(T x , T flag)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;     <span class=\"hljs-comment\">// 找右子节点</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">delLeft</span><span class=\"hljs-params\">(T x)</span> </span>= <span class=\"hljs-number\">0</span>;                <span class=\"hljs-comment\">// 删除左子树</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">delRight</span><span class=\"hljs-params\">(T x)</span> </span>= <span class=\"hljs-number\">0</span>;               <span class=\"hljs-comment\">// 删除右子树</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">preOrder</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;            <span class=\"hljs-comment\">// 前序遍历</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">midOrder</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;            <span class=\"hljs-comment\">// 中序遍历</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">postOrder</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;           <span class=\"hljs-comment\">// 后序遍历</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">levelOrder</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;          <span class=\"hljs-comment\">// 层次遍历</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"二叉树的实现\">二叉树的实现</h4>\n<h5 id=\"二叉树的顺序实现\">二叉树的顺序实现</h5>\n<ul>\n<li>使用数组来存储二叉树中的节点</li>\n<li>将二叉树补全为完全二叉树再进行存储</li>\n<li>会导致空间浪费</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504031058255.png\"\nalt=\"顺序二叉树\" />\n<figcaption aria-hidden=\"true\">顺序二叉树</figcaption>\n</figure>\n<h5 id=\"二叉树的链接实现\">二叉树的链接实现</h5>\n<ul>\n<li>使用链表来存储二叉树中的节点\n<ul>\n<li>标准形式：<code>left</code>，<code>data</code>，<code>right</code></li>\n</ul></li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504041445826.png\"\nalt=\"标准形式\" />\n<figcaption aria-hidden=\"true\">标准形式</figcaption>\n</figure>\n<ul>\n<li>广义标准形式：<code>data</code>，<code>left</code>，<code>parent</code>，<code>right</code></li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504041445472.png\"\nalt=\"广义标准形式\" />\n<figcaption aria-hidden=\"true\">广义标准形式</figcaption>\n</figure>\n<h4 id=\"二叉树类\">二叉树类</h4>\n<h5 id=\"节点类\">节点类</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span><br>&#123;<br>  <span class=\"hljs-keyword\">public</span>:<br>    Node *left *right;                                                                <span class=\"hljs-comment\">// 左右子树指针</span><br>    T data;                                                                           <span class=\"hljs-comment\">// 节点数据</span><br>    <span class=\"hljs-built_in\">Node</span>():<span class=\"hljs-built_in\">left</span>(<span class=\"hljs-literal\">nullptr</span>),<span class=\"hljs-built_in\">right</span>(<span class=\"hljs-literal\">nullptr</span>)&#123;&#125;                                             <span class=\"hljs-comment\">// 默认构造函数</span><br>    <span class=\"hljs-built_in\">Node</span>(T item , Node *L = <span class=\"hljs-literal\">nullptr</span>,Node *R = <span class=\"hljs-literal\">nullptr</span>):<span class=\"hljs-built_in\">data</span>(item),<span class=\"hljs-built_in\">left</span>(L),<span class=\"hljs-built_in\">right</span>(R)&#123;&#125;  <span class=\"hljs-comment\">// 带参数的构造函数</span><br>    ~<span class=\"hljs-built_in\">Node</span>()&#123;&#125;                                                                         <span class=\"hljs-comment\">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h5 id=\"二叉树类-1\">二叉树类</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">binaryTree</span>:<span class=\"hljs-keyword\">public</span> tree&lt;T&gt;<br>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">friend</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printTree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> binaryTree &amp;t, t flag)</span></span>;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span><br>    &#123;<br>      <span class=\"hljs-keyword\">public</span>:<br>        Node *left *right;<br>        T data;<br>        <span class=\"hljs-built_in\">Node</span>():<span class=\"hljs-built_in\">left</span>(<span class=\"hljs-literal\">nullptr</span>),<span class=\"hljs-built_in\">right</span>(<span class=\"hljs-literal\">nullptr</span>)&#123;&#125;<br>        <span class=\"hljs-built_in\">Node</span>(T item , Node *L = <span class=\"hljs-literal\">nullptr</span>,Node *R = <span class=\"hljs-literal\">nullptr</span>):<span class=\"hljs-built_in\">data</span>(item),<span class=\"hljs-built_in\">left</span>(L),<span class=\"hljs-built_in\">right</span>(R)&#123;&#125;<br>        ~<span class=\"hljs-built_in\">Node</span>()&#123;&#125;<br>    &#125;<br>    Node *root;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">binaryTree</span>():<span class=\"hljs-built_in\">root</span>(<span class=\"hljs-literal\">nullptr</span>)&#123;&#125;                    <span class=\"hljs-comment\">// 构造函数,创建空树</span><br>    <span class=\"hljs-built_in\">binaryTree</span>(T x):<span class=\"hljs-built_in\">root</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(x))&#123;&#125;             <span class=\"hljs-comment\">// 构造函数,创建只有根节点的树</span><br>    ~<span class=\"hljs-built_in\">binaryTree</span>()&#123;&#125;                                 <span class=\"hljs-comment\">// 析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">()</span></span>;                                   <span class=\"hljs-comment\">// 清空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;                           <span class=\"hljs-comment\">// 是否为空</span><br>    <span class=\"hljs-function\">T <span class=\"hljs-title\">Root</span><span class=\"hljs-params\">(T flag)</span> <span class=\"hljs-type\">const</span></span>;                           <span class=\"hljs-comment\">// 找根节点</span><br>    <span class=\"hljs-function\">T <span class=\"hljs-title\">lchild</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T &amp;x , T flag)</span> <span class=\"hljs-type\">const</span></span>;            <span class=\"hljs-comment\">// 找左子节点</span><br>    <span class=\"hljs-function\">T <span class=\"hljs-title\">rchild</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T &amp;x , T flag)</span> <span class=\"hljs-type\">const</span></span>;            <span class=\"hljs-comment\">// 找右子节点</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">delLeft</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T &amp;x)</span></span>;                       <span class=\"hljs-comment\">// 删除左子树</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">delRight</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T &amp;x)</span></span>;                      <span class=\"hljs-comment\">// 删除右子树</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">preOrder</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;                          <span class=\"hljs-comment\">// 前序遍历</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">midOrder</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;                          <span class=\"hljs-comment\">// 中序遍历</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">postOrder</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;                         <span class=\"hljs-comment\">// 后序遍历</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">levelOrder</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;                        <span class=\"hljs-comment\">// 层次遍历</span><br>    <span class=\"hljs-function\">coid <span class=\"hljs-title\">creatTree</span><span class=\"hljs-params\">(T flag)</span></span>;                         <span class=\"hljs-comment\">// 创建树</span><br>    <span class=\"hljs-function\">T <span class=\"hljs-title\">parent</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T &amp;x , T flag)</span> <span class=\"hljs-type\">const</span>             <span class=\"hljs-comment\">// 找父节点</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> flag;<br>    &#125;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-function\">Node *<span class=\"hljs-title\">Find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T &amp;x, Node *t)</span> <span class=\"hljs-type\">const</span></span>;            <span class=\"hljs-comment\">// 查找节点</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">(Node *&amp;x)</span></span>;                             <span class=\"hljs-comment\">// 清空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">preOrder</span><span class=\"hljs-params\">(Node *t)</span> <span class=\"hljs-type\">const</span></span>;                     <span class=\"hljs-comment\">// 前序遍历</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">midOrder</span><span class=\"hljs-params\">(Node *t)</span> <span class=\"hljs-type\">const</span></span>;                     <span class=\"hljs-comment\">// 中序遍历</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">postOrder</span><span class=\"hljs-params\">(Node *t)</span> <span class=\"hljs-type\">const</span></span>;                    <span class=\"hljs-comment\">// 后序遍历</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h5 id=\"构造函数-7\">构造函数</h5>\n<p>将 <code>root</code> 初始化为 <code>nullptr</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br>binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">binaryTree</span>()<br>&#123;<br>  root = <span class=\"hljs-literal\">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"isempty-4\"><code>isEmpty</code></h5>\n<ul>\n<li>判断 <code>root</code> 是否为 <code>nullptr</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">bool</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">isEmpty</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> root == <span class=\"hljs-literal\">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"root\"><code>Root</code></h5>\n<p>返回 <code>Root</code> 指向的节点的数据，若为空树则返回特殊值</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br>T binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">Root</span>(T flag)<span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> flag;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> root-&gt;data;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"二叉树的遍历-1\">二叉树的遍历</h5>\n<h6 id=\"前序遍历-1\">前序遍历</h6>\n<ol type=\"1\">\n<li>访问根节点</li>\n<li>前序遍历左子树</li>\n<li>前序遍历右子树</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">preOrder</span>(binaryTree&lt;T&gt;::Node *t) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    cout &lt;&lt; t -&gt; data &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    <span class=\"hljs-built_in\">preorder</span>(t -&gt; left);<br>    <span class=\"hljs-built_in\">preorder</span>(t -&gt; right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">preOrder</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n前序遍历：&quot;</span><br>  <span class=\"hljs-built_in\">preOrder</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"中序遍历-1\">中序遍历</h6>\n<ol type=\"1\">\n<li>中序遍历左子树</li>\n<li>访问根节点</li>\n<li>中序遍历右子树</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">midOrder</span>(binaryTree&lt;T&gt;::Node *t) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-built_in\">midOrder</span>(t -&gt; left);<br>    cout &lt;&lt; t -&gt; data &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    <span class=\"hljs-built_in\">midOrder</span>(t -&gt; right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">midOrder</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n中序遍历：&quot;</span><br>  <span class=\"hljs-built_in\">midOrder</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"后序遍历-1\">后序遍历</h6>\n<ol type=\"1\">\n<li>后序遍历左子树</li>\n<li>后序遍历右子树</li>\n<li>访问根节点</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">postOrder</span>(binaryTree&lt;T&gt;::Node *t) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-built_in\">postOrder</span>(t -&gt; left);<br>    <span class=\"hljs-built_in\">postOrder</span>(t -&gt; right);<br>    cout &lt;&lt; t -&gt; data &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">postOrder</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n后序遍历：&quot;</span><br>  <span class=\"hljs-built_in\">postOrder</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"size\"><code>size</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">int</span> binaryTree&lt;t&gt;::<span class=\"hljs-built_in\">size</span>(binarytree&lt;t&gt;::Node *t) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t = <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>+<span class=\"hljs-built_in\">sizze</span>(t -&gt; left)+<span class=\"hljs-built_in\">size</span>(t -&gt; right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">int</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">size</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">size</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"height\"><code>height</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">int</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">size</span>(binaryTree&lt;T&gt;::Node *t) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-type\">int</span> lt = <span class=\"hljs-built_in\">height</span>(t -&gt; left);<br>    <span class=\"hljs-type\">int</span> rt = <span class=\"hljs-built_in\">height</span>(t -&gt; right);<br>    <span class=\"hljs-keyword\">return</span> (lt &gt; rt ? lt : rt) + <span class=\"hljs-number\">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">int</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">height</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">height</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"层次遍历-1\">层次遍历</h5>\n<ul>\n<li>使用链接队列实现</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">levelOrder</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  linkQueue&lt;Node *&gt; que;<br>  Node *tmp;<br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n层次遍历：&quot;</span>;<br>  que.<span class=\"hljs-built_in\">enQueue</span>(root);<br>  <span class=\"hljs-keyword\">while</span> (!que.<span class=\"hljs-built_in\">isEmpty</span>())<br>  &#123;<br>    tmp = que.<span class=\"hljs-built_in\">deQueue</span>();<br>    cout &lt;&lt; tmp -&gt; data &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    <span class=\"hljs-keyword\">if</span> (tmp.left)<br>    &#123;<br>      que.<span class=\"hljs-built_in\">enQueue</span>(tmp -&gt; left);<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (tmp.right)<br>    &#123;<br>      que.<span class=\"hljs-built_in\">enQueue</span>(tmp -&gt; right);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"clear-1\"><code>clear</code></h5>\n<ul>\n<li>递归删除树中所有节点</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">clear</span>(Node *&amp;t)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-built_in\">clear</span>(t -&gt; left);<br>    <span class=\"hljs-built_in\">clear</span>(t -&gt; right);<br>    <span class=\"hljs-keyword\">delete</span> t;<br>    t = <span class=\"hljs-literal\">nullptr</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">clear</span>()<br>&#123;<br>  <span class=\"hljs-built_in\">clear</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"析构函数-5\">析构函数</h5>\n<ul>\n<li>调用 <code>clear</code> 函数删除树中所有节点</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br>binaryTree&lt;T&gt;::~<span class=\"hljs-built_in\">binaryTree</span>()<br>&#123;<br>  <span class=\"hljs-built_in\">clear</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"find\"><code>Find</code></h5>\n<ul>\n<li>使用前序遍历查找 <code>x</code> 节点</li>\n<li>首先检查根节点是否存放 <code>x</code>\n的值，若是则返回根节点地址</li>\n<li>对左子树递归调用 <code>Find</code> 函数，若返回空指针则说明\n<code>x</code> 不在左子树中</li>\n<li>对右子树递归调用 <code>Find</code> 函数，若返回空指针则说明\n<code>x</code> 不在右子树中</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">binaryTree</span>&lt;T&gt;:: Node *binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">Find</span>(<span class=\"hljs-type\">const</span> T &amp;x ,binaryTree&lt;T&gt;::Node *t) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (t -&gt; data == x)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> t;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (tmp = <span class=\"hljs-built_in\">Find</span>(x,t-&gt;left))<br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> tmp;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Find</span>(x,t-&gt;right);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"delleft\"><code>delLeft</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">delLeft</span>(<span class=\"hljs-type\">const</span> T &amp;x)<br>&#123;<br>  Node *tmp = <span class=\"hljs-built_in\">Find</span>(x,root);<br>  <span class=\"hljs-keyword\">if</span> (tmp == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-built_in\">clear</span>(tmp -&gt; left);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"delright\"><code>delRight</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">delRight</span>(<span class=\"hljs-type\">const</span> T &amp;x)<br>&#123;<br>  Node *tmp = <span class=\"hljs-built_in\">Find</span>(x,root);<br>  <span class=\"hljs-keyword\">if</span> (tmp == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-built_in\">clear</span>(tmp -&gt; right);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"lchild\"><code>lchild</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br>T binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">lchild</span>(<span class=\"hljs-type\">const</span> T &amp;x ,T flag) <span class=\"hljs-type\">const</span><br>&#123;<br>  Node *tmp = <span class=\"hljs-built_in\">Find</span>(x,root)<br>  <span class=\"hljs-keyword\">if</span> (tmp == <span class=\"hljs-literal\">nullptr</span> || tmp -&gt; left ==<span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> flag;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> tmp -&gt; left;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"rchild\"><code>rchild</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br>T binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">rchild</span>(<span class=\"hljs-type\">const</span> T &amp;x ,T flag) <span class=\"hljs-type\">const</span><br>&#123;<br>  Node *tmp = <span class=\"hljs-built_in\">Find</span>(x,root)<br>  <span class=\"hljs-keyword\">if</span> (tmp == <span class=\"hljs-literal\">nullptr</span> || tmp -&gt; right ==<span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> flag;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> tmp -&gt; right;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"createtree\"><code>createTree</code></h5>\n<ul>\n<li>创建过程（类似层次遍历？）\n<ol type=\"1\">\n<li>输入根节点的值，创建根节点</li>\n<li>对已添加到树上的每个节点，依次输入它的两个儿子的值，若没有儿子则输入\n<code>flag</code></li>\n</ol></li>\n<li>实现过程\n<ul>\n<li>使用队列，将新加入到书中的节点添加到队列中</li>\n<li>依次出队，对每个出队的元素输入它的儿子</li>\n</ul></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">createTree</span>(T flag)<br>&#123;<br>  linkQueue&lt;Node *&gt; que;<br>  Node *tmp;<br>  T x , ldata , rdata;<br><br>  <span class=\"hljs-comment\">// 创建树，flag表示空</span><br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n输入根节点：&quot;</span><br>  cin &gt;&gt; x;<br>  root = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(x);<br>  que.<span class=\"hljs-built_in\">enQueue</span>(root);<br>  <span class=\"hljs-keyword\">while</span> (!que.<span class=\"hljs-built_in\">isEmpty</span>())<br>  &#123;<br>    tmp = que,<span class=\"hljs-built_in\">deQueue</span>();<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n输入&quot;</span> &lt;&lt; tmp -&gt; data &lt;&lt; <span class=\"hljs-string\">&quot;的两个儿子（&quot;</span>&lt;&lt;flag&lt;&lt;<span class=\"hljs-string\">&quot;表示空节点）：&quot;</span>;<br>    cin &gt;&gt; ldata &gt;&gt; rdata;<br>    <span class=\"hljs-keyword\">if</span> (ldata != flag)<br>    &#123;<br>      tmp -&gt; left = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(ldata);<br>      que.<span class=\"hljs-built_in\">enQueue</span>(tmp -&gt; left);<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (rdata != flag)<br>    &#123;<br>      tmp -&gt; right = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(rdata);<br>      que.<span class=\"hljs-built_in\">enQueue</span>(tmp -&gt; right);<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;that&#x27;s good!\\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"printtree\"><code>printTree</code></h5>\n<ul>\n<li>层次遍历输出每个节点和它的左右孩子</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printTree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> binaryTree&lt;T&gt; &amp;t,T flag)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  linkQueue&lt;T&gt; que;<br>  que.<span class=\"hljs-built_in\">enQueue</span>(t.<span class=\"hljs-built_in\">root</span>());<br>  <span class=\"hljs-keyword\">while</span>(!que.<span class=\"hljs-built_in\">isEmpty</span>())<br>  &#123;<br>    T tmp = que.<span class=\"hljs-built_in\">deQueue</span>();<br>    T l = tmp.<span class=\"hljs-built_in\">lchild</span>(tmp , flag);<br>    T r = tmp.<span class=\"hljs-built_in\">rchild</span>(tmp , flag);<br>    cout &lt;&lt; p &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; l &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">if</span> (l != flag)<br>    &#123;<br>      que.<span class=\"hljs-built_in\">enQueue</span>(l);<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (r != flag)<br>    &#123;<br>      que.<span class=\"hljs-built_in\">enQueue</span>(r);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"二叉树遍历的非递归实现\">二叉树遍历的非递归实现</h4>\n<h5 id=\"前序遍历-2\">前序遍历</h5>\n<ol type=\"1\">\n<li>将根节点入栈</li>\n<li>栈顶元素出栈并输出值</li>\n<li>将左右子树入栈（先右后左，以便输出时先输出左子树）</li>\n<li>循环直至栈为空</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">preOrder</span>(<span class=\"hljs-type\">const</span> binaryTree&lt;T&gt;::Node *t) <span class=\"hljs-type\">const</span><br>&#123;<br>  linkStack&lt;Node *&gt; s;<br>  Node *tmp = t;<br><br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n前序遍历：&quot;</span>;<br>  <span class=\"hljs-keyword\">while</span> (!s.<span class=\"hljs-built_in\">isEmpty</span>())<br>  &#123;<br>    tmp = s.<span class=\"hljs-built_in\">pop</span>();<br>    cout &lt;&lt; tm -&gt; data &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    <span class=\"hljs-keyword\">if</span> (tmp -&gt; right != <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>      s.<span class=\"hljs-built_in\">push</span>(tmp -&gt; right);<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (tmp -&gt; left != <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>      s.<span class=\"hljs-built_in\">push</span>(tmp -&gt; left);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"中序遍历-2\">中序遍历</h5>\n<ol type=\"1\">\n<li>根节点入栈</li>\n<li>左子树入栈</li>\n<li>栈顶元素出栈并输出值</li>\n<li>左子树出栈完成之后根节点出栈</li>\n<li>右子树入栈</li>\n<li>循环直至栈为空</li>\n</ol>\n<p>栈的设计</p>\n<ul>\n<li>根节点入栈出栈两次\n<ul>\n<li>第一次出栈时不能被访问，立刻重新入栈，并将左子树入栈</li>\n<li>第二次出栈后返回值，并且将右子树入栈</li>\n</ul></li>\n<li>对于根节点要记住\n<ul>\n<li>在哪棵树上</li>\n<li>第几次出栈</li>\n</ul></li>\n<li>每个节点在某种意义上都是根节点</li>\n</ul>\n<h6 id=\"stnode-类定义\"><code>StNode</code> 类定义</h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">StNode</span><br>&#123;<br>  Node *node;<br>  <span class=\"hljs-type\">int</span> TimesPop;<br>  <span class=\"hljs-built_in\">StNode</span>(Node *N=<span class=\"hljs-literal\">nullptr</span>):<span class=\"hljs-built_in\">node</span>(N),<span class=\"hljs-built_in\">TimesPop</span>(<span class=\"hljs-number\">0</span>)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h6 id=\"中序遍历的非递归实现\">中序遍历的非递归实现</h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">midOrder</span>(<span class=\"hljs-type\">const</span> binaryTree&lt;T&gt;::Node *t) <span class=\"hljs-type\">const</span><br>&#123;<br>  linkStack&lt;Node *t&gt; s;<br>  <span class=\"hljs-function\">StNode <span class=\"hljs-title\">current</span><span class=\"hljs-params\">(root)</span></span>;<br><br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n中序遍历：&quot;</span>;<br>  s.<span class=\"hljs-built_in\">push</span>(current);<br>  <span class=\"hljs-keyword\">while</span>(!s.<span class=\"hljs-built_in\">isEmpty</span>())<br>  &#123;<br>    current = s.<span class=\"hljs-built_in\">pop</span>();<br>    <span class=\"hljs-keyword\">if</span> (++current.TimesPop == <span class=\"hljs-number\">2</span>)<br>    &#123;<br>      cout &lt;&lt; current.node -&gt; data;<br>      <span class=\"hljs-keyword\">if</span> (current.node -&gt; right != <span class=\"hljs-literal\">nullptr</span>)<br>      &#123;<br>        s.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">StNode</span>(current.node -&gt; right));<br>      &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      s.<span class=\"hljs-built_in\">push</span>(current);<br>      <span class=\"hljs-keyword\">if</span> (current.node -&gt; left != <span class=\"hljs-literal\">nullptr</span>)<br>      &#123;<br>        s.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">StNode</span>(current.node -&gt; left));<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"后序遍历-2\">后序遍历</h5>\n<ol type=\"1\">\n<li>根节点入栈</li>\n<li>左子树入栈</li>\n<li>右子树入栈</li>\n<li>栈顶元素出栈并输出值</li>\n<li>循环直至栈为空</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">postOrder</span>(<span class=\"hljs-type\">const</span> binaryTree&lt;T&gt;::Node *t) <span class=\"hljs-type\">const</span><br>&#123;<br>  linkStack&lt;Node *&gt; s;<br>  <span class=\"hljs-function\">StNode <span class=\"hljs-title\">current</span><span class=\"hljs-params\">(root)</span></span>;<br><br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n后序遍历：&quot;</span>;<br>  s.<span class=\"hljs-built_in\">push</span>(current);<br>  <span class=\"hljs-keyword\">while</span>(!s.<span class=\"hljs-built_in\">isEmpty</span>())<br>  &#123;<br>    current = s.<span class=\"hljs-built_in\">pop</span>();<br>    <span class=\"hljs-keyword\">if</span> (++current.TimesPop == <span class=\"hljs-number\">3</span>)<br>    &#123;<br>      cout &lt;&lt; current.node -&gt; data;<br>      <span class=\"hljs-keyword\">continue</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      s.<span class=\"hljs-built_in\">push</span>(current);<br>      <span class=\"hljs-keyword\">if</span> (current.node -&gt; right != <span class=\"hljs-literal\">nullptr</span>)<br>      &#123;<br>        s.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">StNode</span>(current.node -&gt; right));<br>      &#125;<br>      <span class=\"hljs-keyword\">if</span> (current.node -&gt; left != <span class=\"hljs-literal\">nullptr</span>)<br>      &#123;<br>        s.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">StNode</span>(current.node -&gt; left));<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"哈夫曼树和哈夫曼编码\">哈夫曼树和哈夫曼编码</h3>\n<h4 id=\"字符的机内表示\">字符的机内表示</h4>\n<ul>\n<li>用二进制数来表示字符</li>\n<li>前缀编码\n<ul>\n<li>字符只放在叶结点中</li>\n<li>字符编码可以有不同的长度</li>\n<li>每个字符的编码都不可能是其他字符编码的前缀</li>\n<li>可以被唯一解码</li>\n</ul></li>\n</ul>\n<h4 id=\"哈夫曼树\">哈夫曼树</h4>\n<ul>\n<li>最小代价，即带权路径长度最小的二叉树</li>\n<li>所有字符都在叶结点上</li>\n<li>权值大的字符离根节点近，权值小的字符离根节点远</li>\n<li>哈夫曼编码是一种前缀编码</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141528425.png\"\nalt=\"huffmanTree\" />\n<figcaption aria-hidden=\"true\">huffmanTree</figcaption>\n</figure>\n<h4 id=\"哈夫曼算法\">哈夫曼算法</h4>\n<ol type=\"1\">\n<li>给定一个具有 <span class=\"math inline\"><em>n</em></span> 个权值\n<span\nclass=\"math inline\">{<em>w</em><sub>1</sub>, <em>w</em><sub>2</sub>, …, <em>w</em><sub>4</sub>}</span>\n的节点的集合 <span class=\"math inline\">𝔸</span> <span\nclass=\"math inline\">𝔽 = {<em>T</em><sub>1</sub>, <em>T</em><sub>2</sub>, …, <em>T</em><sub><em>n</em></sub>}</span></li>\n<li>初始时，设集合 <span class=\"math inline\">𝔸 = 𝔽</span></li>\n<li>执行从 <span class=\"math inline\"><em>i</em></span> 到 <span\nclass=\"math inline\"><em>n</em> − 1</span> 的循环\n<ol type=\"1\">\n<li>从当前集合中选取权值最小、次最小的两个节点，以这两个节点作为内部节点\n<span class=\"math inline\"><em>b</em><sub><em>i</em></sub></span>\n的左右儿子，<span\nclass=\"math inline\"><em>b</em><sub><em>i</em></sub></span>\n的权值为这两个节点的权值之和</li>\n<li>集合中去除这两个节点，将 <span\nclass=\"math inline\"><em>b</em><sub><em>i</em></sub></span> 加入其中</li>\n</ol></li>\n<li>循环结束后，集合 <span class=\"math inline\">𝔸</span>中只剩下一个节点\n<span\nclass=\"math inline\"><em>b</em><sub><em>n</em></sub></span>，即为哈夫曼树的根节点</li>\n</ol>\n<h4 id=\"哈夫曼编码\">哈夫曼编码</h4>\n<ul>\n<li>每个节点的编码是从根节点到该节点的路径</li>\n<li>左子树为 <code>0</code>，右子树为 <code>1</code></li>\n</ul>\n<h4 id=\"哈夫曼树类的实现\">哈夫曼树类的实现</h4>\n<ol type=\"1\">\n<li>接受一组符号以及对应的权值,并返回每个符号对应的哈夫曼编码</li>\n<li>有两个公有的成员函数\n<ol type=\"1\">\n<li>构造函数：接受一组待编码的符号以及它们的权值，构造哈夫曼树</li>\n<li><code>getCode</code>：根据保存的哈夫曼树，返回每个符号对应的哈夫曼编码</li>\n</ol></li>\n</ol>\n<h5 id=\"哈夫曼树的存储\">哈夫曼树的存储</h5>\n<ul>\n<li>在哈夫曼树中，每个要编码的元素都是一个叶节点，其余的节点都是度为\n<span class=\"math inline\">2</span> 的节点</li>\n<li>若待编码的元素个数为 <span\nclass=\"math inline\"><em>n</em></span>，则哈夫曼树的节点数为 <span\nclass=\"math inline\">2<em>n</em> − 1</span></li>\n<li>哈夫曼树使用一个大小为 <span class=\"math inline\">2<em>n</em></span>\n的数组来存储，不使用 <span class=\"math inline\">0</span>\n节点，将根节点存储在下标为 <span class=\"math inline\">1</span>\n的位置，叶节点依次存储在下标为 <span\nclass=\"math inline\"><em>n</em> + 1</span> 到 <span\nclass=\"math inline\">2<em>n</em></span> 的位置，<span\nclass=\"math inline\">0</span> 结点作为结束的判断依据</li>\n<li>每个数组保存\n<strong>节点的数据</strong>，<strong>节点的权值</strong>，<strong>节点的父节点下标</strong>，<strong>左子节点下标</strong>，<strong>右子节点下标</strong></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Type</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">hfTree</span><br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span><br>    &#123;<br>      Type data; <span class=\"hljs-comment\">//节点数据</span><br>      <span class=\"hljs-type\">int</span> weight; <span class=\"hljs-comment\">//节点权值</span><br>      <span class=\"hljs-type\">int</span> parent; <span class=\"hljs-comment\">//父节点下标</span><br>      <span class=\"hljs-type\">int</span> left , right; <span class=\"hljs-comment\">//左右子节点下标</span><br>    &#125;;<br><br>    Node *elem;<br>    <span class=\"hljs-type\">int</span> length;<br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">hfCode</span><br>    &#123;<br>      Type data; <span class=\"hljs-comment\">//节点数据</span><br>      string code; <span class=\"hljs-comment\">//哈夫曼编码</span><br>    &#125;;<br><br>    <span class=\"hljs-built_in\">hfTree</span>(<span class=\"hljs-type\">const</span> Type *v , <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *w , <span class=\"hljs-type\">int</span> size);<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">getCode</span><span class=\"hljs-params\">(hfCode result[])</span></span>;<br>    ~<span class=\"hljs-built_in\">hfTree</span>()<br>    &#123;<br>      <span class=\"hljs-keyword\">delete</span> [] elem;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h5 id=\"构造函数-8\">构造函数</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Type</span>&gt;<br>hfTree&lt;Type&gt;::<span class=\"hljs-built_in\">hfTree</span>(<span class=\"hljs-type\">const</span> Type *v , <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *w , <span class=\"hljs-type\">int</span> size)<br>&#123;<br>  <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> MAX_INT = <span class=\"hljs-number\">32767</span>;<br>  <span class=\"hljs-type\">int</span> min1 , min2; <span class=\"hljs-comment\">// 最小树、次最小树的权值</span><br>  <span class=\"hljs-type\">int</span> x , y ; <span class=\"hljs-comment\">// 最小树、次最小树的下标</span><br><br>  <span class=\"hljs-comment\">/* 初始化 */</span><br>  length = <span class=\"hljs-number\">2</span> * size ;                                            <span class=\"hljs-comment\">// 哈夫曼树的节点数为 $2\\text&#123;size&#125;-1$，但我们只需要存储 $2\\text&#123;size&#125;$ 个节点</span><br>  elem = <span class=\"hljs-keyword\">new</span> Node[length];                                       <span class=\"hljs-comment\">// 创建一个大小为 $2\\text&#123;size&#125;$ 的数组来存储哈夫曼树的节点</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = size ; i &lt; length ; i++)                          <span class=\"hljs-comment\">// 对数组 `elem` 中的节点进行初始化，前 $\\text&#123;size&#125;$ 个节点存储待编码的元素，从下标 `size` 开始，依次存储待编码的元素的权值</span><br>  &#123;<br>    elem[i].weight = w[i-size]; <span class=\"hljs-comment\">// 储存权值</span><br>    elem[i].data = v[i-size]; <span class=\"hljs-comment\">// 储存待编码的元素</span><br>    elem[i].parent = elem[i].left = elem[i].right = <span class=\"hljs-number\">0</span>;           <span class=\"hljs-comment\">// 初始化父节点、左子节点和右子节点的下标为 `0`</span><br>  &#125;<br><br>  <span class=\"hljs-comment\">/* 构造新的二叉树 */</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = size - <span class=\"hljs-number\">1</span> ; i &gt; <span class=\"hljs-number\">0</span> ; i--)                           <span class=\"hljs-comment\">// 从下标为 `size-1` 的节点开始，依次向上构造哈夫曼树的节点</span><br>  &#123;<br>    min1 = min2 = MAX_INT;                                       <span class=\"hljs-comment\">// 初始化这两个变量为一个很大的值，以确保能够找到真正最小和次小的权值</span><br>    x = y = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = i + <span class=\"hljs-number\">1</span> ; j &lt; length ; j++)                       <span class=\"hljs-comment\">// 遍历当前节点之后的所有节点</span><br>    &#123;<br>      <span class=\"hljs-keyword\">if</span> (elem[j].parent == <span class=\"hljs-number\">0</span>)                                   <span class=\"hljs-comment\">// 判断是否未加入树中</span><br>      &#123;<br>        <span class=\"hljs-keyword\">if</span> (elem[j].weight &lt; min1)                               <span class=\"hljs-comment\">// 找到真正的最小值和次小值以及他们对应的下标</span><br>        &#123;<br>          min2 = min1;<br>          min1 = elem[j].weight;<br>          x = y;<br>          y = j;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(elem[j].weight &lt; min2)<br>        &#123;<br>          min2 = elem[j].weight;<br>          x = j;<br>        &#125;<br>      &#125;<br>    &#125;<br>    elem[i].weight = min1 + min2;                                <span class=\"hljs-comment\">// 将最小值和次小值的权值相加，作为当前节点的权值</span><br>    elem[i].left = x;                                            <span class=\"hljs-comment\">// 将最小值的节点作为当前节点的左子节点</span><br>    elem[i].right = y;                                           <span class=\"hljs-comment\">// 将次小值的节点作为当前节点的右子节点</span><br>    elem[x].parent = i;                                          <span class=\"hljs-comment\">// 将当前节点作为最小值节点的父节点</span><br>    elem[y].parent = i;                                          <span class=\"hljs-comment\">// 将当前节点作为次小值节点的父节点</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"getcode\"><code>getCode</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Type</span>&gt;<br><span class=\"hljs-type\">void</span> hdTree&lt;Type&gt;::<span class=\"hljs-built_in\">getcode</span>(hfCode result[])<br>&#123;<br>  <span class=\"hljs-type\">int</span> size = length / <span class=\"hljs-number\">2</span> ;<br>  <span class=\"hljs-type\">int</span> p , s ;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = size; i &lt; length; ++i)<br>  &#123;<br>    result[i -size].data = elem[i].data;<br>    result[i -size].code = <span class=\"hljs-string\">&quot;&quot;</span>;<br>    p = elem[i].parent; s = i;<br>    <span class=\"hljs-keyword\">while</span> (p)<br>    &#123;<br>      <span class=\"hljs-keyword\">if</span> (elem[p].left == s)<br>      &#123;<br>        result[i -size].code = <span class=\"hljs-string\">&#x27;0&#x27;</span> + result[i -size].code;<br>      &#125;<br>      <span class=\"hljs-keyword\">else</span><br>      &#123;<br>        result[i -size].code = <span class=\"hljs-string\">&#x27;1&#x27;</span> + result[i -size].code;<br>      &#125;<br>      s = p;<br>      p = elem[p].parent;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"树和森林\">树和森林</h3>\n<h4 id=\"树的存储实现\">树的存储实现</h4>\n<ul>\n<li><strong>标准形式</strong>：除了数据字段之外，还有 <span\nclass=\"math inline\"><em>K</em></span> 个指针字段，指向 <span\nclass=\"math inline\"><em>K</em></span> 个孩子节点，其中 <span\nclass=\"math inline\"><em>K</em></span> 是树的度</li>\n<li><strong>广义标准形式</strong>：除了数据字段之外，还有 <span\nclass=\"math inline\"><em>K</em></span> 个指针字段，指向 <span\nclass=\"math inline\"><em>K</em></span>\n个孩子节点和一个指针字段，指向父节点</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504211450009.png\"\nalt=\"树的存储实现\" />\n<figcaption aria-hidden=\"true\">树的存储实现</figcaption>\n</figure>\n<h4 id=\"树的表示方法\">树的表示方法</h4>\n<h5 id=\"孩子链表示法\">孩子链表示法</h5>\n<ul>\n<li><p>每个节点的所有孩子组织成一个链表</p></li>\n<li><p>节点由两个部分组成</p>\n<ul>\n<li>储存数据元素值的数据部分</li>\n<li>指向孩子链的指针</li>\n</ul></li>\n<li><p><strong>静态</strong>的孩子链表：树的所有节点存放在一个名叫表头数组的<strong>数组</strong>中</p></li>\n<li><p><strong>动态</strong>的孩子链表：树的所有节点组织成一个<strong>链表</strong></p></li>\n</ul>\n<h5 id=\"孩子兄弟链表示法\">孩子兄弟链表示法</h5>\n<ul>\n<li>将一棵树转化为二叉树</li>\n<li>左子树指向第一颗子树树根的指针</li>\n<li>右子树指向兄弟节点的指针</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504211559361.png\"\nalt=\"孩子兄弟链\" />\n<figcaption aria-hidden=\"true\">孩子兄弟链</figcaption>\n</figure>\n<h5 id=\"双亲表示法\">双亲表示法</h5>\n<ul>\n<li>每一个节点由两个部分组成\n<ul>\n<li>储存数据元素的数据字段</li>\n<li>储存父节点的父指针字段</li>\n</ul></li>\n<li>便于查找节点的祖先，但是不便于查找指定节点的子孙</li>\n</ul>\n<h3 id=\"树的遍历\">树的遍历</h3>\n<h4 id=\"前序遍历-3\">前序遍历</h4>\n<ol type=\"1\">\n<li>访问根节点</li>\n<li>依次前序遍历所有子树</li>\n</ol>\n<h4 id=\"后序遍历-3\">后序遍历</h4>\n<ol type=\"1\">\n<li>依次后序遍历所有子树</li>\n<li>访问根节点</li>\n</ol>\n<h4 id=\"层次遍历-2\">层次遍历</h4>\n<ol type=\"1\">\n<li>访问根节点</li>\n<li>若第 <span class=\"math inline\"><em>i</em></span> 层已被访问，且第\n<span class=\"math inline\"><em>i</em> + 1</span>\n层的结点尚未被访问，则从左到右依次访问第 <span\nclass=\"math inline\"><em>i</em> + 1</span> 层的结点</li>\n</ol>\n<h4 id=\"特点\">特点</h4>\n<ul>\n<li>树的前序遍历和用儿子兄弟链表示法转化的二叉树的前序遍历是相同的</li>\n<li>树的后序遍历和用儿子兄弟链表示法转化的二叉树的中序遍历是相同的</li>\n</ul>\n<p>由前序遍历和后序遍历可以唯一确定一棵树</p>\n<h3 id=\"树森林和二叉树\">树、森林和二叉树</h3>\n<h4 id=\"森林的定义\">森林的定义</h4>\n<ul>\n<li>森林通常被定义为树的集合或树的序列</li>\n<li>存储\n<ul>\n<li>存储森林的每一棵树</li>\n<li>表示这些树属于同一个森林</li>\n</ul></li>\n</ul>\n<h4 id=\"森林的二叉树存储\">森林的二叉树存储</h4>\n<ol type=\"1\">\n<li>将每棵树 <span\nclass=\"math inline\"><em>T</em><sub><em>i</em></sub></span> 转化为二叉树\n<span class=\"math inline\"><em>B</em><sub><em>i</em></sub></span></li>\n<li>将 <span class=\"math inline\"><em>B</em><sub><em>i</em></sub></span>\n作为 <span\nclass=\"math inline\"><em>B</em><sub><em>i</em> − 1</sub></span>\n根节点的右子树</li>\n</ol>\n<h2 id=\"优先级队列\">优先级队列</h2>\n<h3 id=\"优先级队列的定义\">优先级队列的定义</h3>\n<ul>\n<li>节点之间的关系是由节点的优先级决定的</li>\n<li>优先级高的先出队，优先级低的后出队</li>\n<li>继承于队列的抽象类</li>\n</ul>\n<h3 id=\"优先级队列的简单实现\">优先级队列的简单实现</h3>\n<ol type=\"1\">\n<li>入队时进行排序，出队操作不变 入队时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>)</span>，出队时间复杂度为\n<span class=\"math inline\"><em>O</em>(1)</span></li>\n<li>出队时进行排序，入队操作不变 入队时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(1)</span>，出队时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>)</span></li>\n</ol>\n<h3 id=\"二叉堆\">二叉堆</h3>\n<ul>\n<li>二叉堆是一个完全二叉树</li>\n<li>二叉堆满足下述关系之一（下标是按层次遍历的次序）\n<ol type=\"1\">\n<li><strong>最大化堆</strong>：<span class=\"math inline\">$k_i &gt;\nk_{2i},\\quad k_i &gt; k{2i+1} \\quad (i = 1,2,\\ldots,\\lfloor\n\\frac{n}{2}\\rfloor$</span></li>\n<li><strong>最小化堆</strong>：<span class=\"math inline\">$k_i &lt;\nk_{2i},\\quad k_i &lt; k{2i+1} \\quad (i = 1,2,\\ldots,\\lfloor\n\\frac{n}{2}\\rfloor)$</span></li>\n</ol></li>\n<li>后面的讨论都以最小化堆为例</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504081709343.png\"\nalt=\"binaryHeap\" />\n<figcaption aria-hidden=\"true\">binaryHeap</figcaption>\n</figure>\n<h4 id=\"二叉堆的特性\">二叉堆的特性</h4>\n<ul>\n<li><strong>结构性</strong>\n<ul>\n<li>符合完全二叉树的结构</li>\n</ul></li>\n<li><strong>有序性</strong>\n<ul>\n<li>父节点小于子节点（最小化堆）</li>\n<li>父节点大于子节点（最大化堆）</li>\n</ul></li>\n</ul>\n<h3 id=\"基于二叉堆的优先级队列\">基于二叉堆的优先级队列</h3>\n<ul>\n<li>如果数值越小，优先级越高，则可以用一个最小化堆存储优先级队列</li>\n<li>最小化堆中，最小元素为根元素，存放在数组下标为 <code>1</code> 的位置\n<ul>\n<li>获取队头元素的操作为返回下标为 <code>1</code> 的元素值</li>\n<li>出队操作为删除下标为 <code>1</code> 的元素，重新调整堆</li>\n<li>入队操作为将新元素插入到堆的最后一个位置，然后向上调整堆</li>\n</ul></li>\n</ul>\n<h3 id=\"优先级队列类的定义\">优先级队列类的定义</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">priorityQueue</span>:<span class=\"hljs-keyword\">public</span> quque&lt;T&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> currentSize;<br>    T *array;<br>    <span class=\"hljs-type\">int</span> maxSize;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">doubleSpace</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\">voif <span class=\"hljs-title\">buildHeap</span><span class=\"hljs-params\">()</span></span>;  <span class=\"hljs-comment\">// 建堆，被 priorityQueue() 调用</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">percolateDown</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> hole)</span></span>; <span class=\"hljs-comment\">// 向下过滤</span><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">priorityQueue</span>(<span class=\"hljs-type\">int</span> capacity = <span class=\"hljs-number\">100</span>) <span class=\"hljs-comment\">// 构造函数</span><br>    &#123;<br>      array = <span class=\"hljs-keyword\">new</span> T[capacity];<br>      maxSize = capacity;<br>      currentSize = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-built_in\">priorityQueue</span>(<span class=\"hljs-type\">const</span> T data[] , <span class=\"hljs-type\">int</span> size); <span class=\"hljs-comment\">// 构造函数</span><br>    ~<span class=\"hljs-built_in\">priorityQueue</span>(); <span class=\"hljs-comment\">// 析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-comment\">// 是否为空</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> currentSize == <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">enQueue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T &amp;x)</span></span>; <span class=\"hljs-comment\">//入队</span><br>    <span class=\"hljs-function\">T <span class=\"hljs-title\">deQueue</span><span class=\"hljs-params\">()</span></span>; <span class=\"hljs-comment\">// 出队</span><br>    <span class=\"hljs-function\">T <span class=\"hljs-title\">getHead</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-comment\">// 获取队头元素</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> array[<span class=\"hljs-number\">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"enqueue-2\"><code>enQueue</code></h4>\n<ul>\n<li>在堆中插入一个新元素</li>\n<li>在最大序号中的元素之后插入新的元素或者节点</li>\n<li>如果没有违反堆的<strong>有序性</strong>，则操作结束，否则向父节点移动，直到满足有序性或者到达根节点</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> priorityQueue&lt;T&gt;::<span class=\"hljs-built_in\">enQueue</span>(<span class=\"hljs-type\">const</span> T &amp;x)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (currentSize == maxSize - <span class=\"hljs-number\">1</span>)<br>  &#123;<br>    <span class=\"hljs-built_in\">doubleSpace</span>();<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 向上过滤</span><br>  <span class=\"hljs-type\">int</span> hole = ++currentSize;<br>  <span class=\"hljs-keyword\">for</span> (;hole &gt; <span class=\"hljs-number\">1</span> &amp;&amp; x &lt; array[hole/<span class=\"hljs-number\">2</span>] ; hole /= <span class=\"hljs-number\">2</span>)<br>  &#123;<br>    array[hole] = array[hole/<span class=\"hljs-number\">2</span>];<br>  &#125;<br>  array[hole] = x;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>最坏情况时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(log <em>n</em>)</span></li>\n<li>平均情况来说，过滤会提前结束。资料表明平均为 <span\nclass=\"math inline\">2.6</span> 次比较，即平均上移 <span\nclass=\"math inline\">1.6</span> 层</li>\n</ul>\n<h4 id=\"dequeue-2\"><code>deQueue</code></h4>\n<ul>\n<li>删除堆顶元素，同时删除最后一个节点，以满足是完全二叉树</li>\n<li>空节点向下过滤，找到一个较小的子节点，将该儿子放入空节点，空节点向下推一层，直至删除的节点能够被放入空节点</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br>T priorityQueue&lt;T&gt;::<span class=\"hljs-built_in\">deQueue</span>()<br>&#123;<br>  T minItem;<br>  minItem = array[<span class=\"hljs-number\">1</span>];<br>  array[<span class=\"hljs-number\">1</span>] = array[currentSize--];<br>  <span class=\"hljs-built_in\">percolateDown</span>(<span class=\"hljs-number\">1</span>);<br>  <span class=\"hljs-keyword\">return</span> minItem;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"percolatedown\"><code>percolateDown</code></h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> priorityQueue&lt;T&gt;::<span class=\"hljs-built_in\">precolateDown</span>(<span class=\"hljs-type\">int</span> hole)<br>&#123;<br>  <span class=\"hljs-type\">int</span> child;<br>  T tmp = array[hole];<br><br>  <span class=\"hljs-keyword\">for</span> (;hole * <span class=\"hljs-number\">2</span> &lt;= currentSize; hole = child)<br>  &#123;<br>    child = hole * <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">if</span> (child != currentSIze &amp;&amp; array[child + <span class=\"hljs-number\">1</span>] &lt; array[child])<br>    &#123;<br>      child++;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (array[child] &lt; tmp)<br>    &#123;<br>      array[hole] = array[child];<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>  &#125;<br>  array[hole] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"buildheap\"><code>buildHeap</code></h4>\n<h5 id=\"连续插入\">连续插入</h5>\n<ul>\n<li>时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>log <em>n</em>)</span></li>\n</ul>\n<h5 id=\"自上而下调整二叉树\">自上而下调整二叉树</h5>\n<ul>\n<li>对左子树和右子树递归调用\n<code>buildHeaap</code>，再对根节点向下过滤</li>\n<li>时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>)</span></li>\n</ul>\n<h5 id=\"非递归实现-1\">非递归实现</h5>\n<p>从编号最大的非叶节点 <span class=\"math inline\">$\\lfloor \\frac{n}{2}\n\\rfloor$</span> 开始逆层次遍历，每个节点调用\n<code>percolateDown</code>，直到根节点</p>\n<h2 id=\"集合与静态查找表\">集合与静态查找表</h2>\n<h3 id=\"集合的基本概念\">集合的基本概念</h3>\n<ol type=\"1\">\n<li>数据元素除了属于同一集合之外，没有任何逻辑关系</li>\n<li>每个数据元素有一个区别于其他元素的唯一标识，称为<strong>键值</strong>或者<strong>关键字值</strong></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span>&lt;calss KEY , <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">SET</span><br>&#123;<br>  KEY key; <span class=\"hljs-comment\">// 关键字值</span><br>  OTHER other; <span class=\"hljs-comment\">// 其他信息</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>运算</p>\n<ul>\n<li><strong>查找</strong> 某一元素是否存在</li>\n<li>将集合中的元素按照它的唯一标识排序</li>\n</ul>\n<p>这些都是对 <code>key</code> 的操作</p>\n<h3 id=\"集合的存储\">集合的存储</h3>\n<ul>\n<li>任何容器都能存储集合</li>\n<li>常用的表达形式是借鉴于<strong>线性表</strong>和<strong>树</strong></li>\n<li>唯一一个仅适合于存储和处理集合的数据结构是<strong>散列表</strong></li>\n</ul>\n<h3 id=\"查找\">查找</h3>\n<h4 id=\"查找的基本概念\">查找的基本概念</h4>\n<ul>\n<li>用于查找的集合称之为<strong>查找表</strong></li>\n<li>查找表的分类\n<ul>\n<li>静态查找表</li>\n<li>动态查找表</li>\n<li>内部查找</li>\n<li>外部查找</li>\n</ul></li>\n</ul>\n<h4 id=\"静态查找表\">静态查找表</h4>\n<ul>\n<li>数据元素的个数和值不允许变化的查找表称为静态查找表</li>\n<li>不允许插入和删除操作</li>\n<li>实例：字典</li>\n<li>可以用顺序表 <code>seqList</code> 存储，或直接存储在\nC++的原始数组中</li>\n</ul>\n<h4 id=\"无序表的查找\">无序表的查找</h4>\n<ul>\n<li><p>只能做顺序查找</p></li>\n<li><p>时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>)</span></p></li>\n<li><p>可以使用哨兵减少 <span class=\"math inline\"><em>n</em></span>\n次查找</p></li>\n<li><p>优化后的顺序查找</p></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">seqSearch</span><span class=\"hljs-params\">(SET&lt;KEY, OTHER&gt; data[] , <span class=\"hljs-type\">int</span> size , <span class=\"hljs-type\">const</span> KEY &amp;x)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  data[<span class=\"hljs-number\">0</span>].key = x;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = size ; x != data[i].key; --i)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> i;<br>  &#125;<br>&#125;<br><span class=\"hljs-number\">13</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"有序表的查找\">有序表的查找</h4>\n<h5 id=\"顺序查找\">顺序查找</h5>\n<ul>\n<li><p>与无序表的顺序查找类似，只是当被查元素在表中不存在时，不需要查到表头</p></li>\n<li><p>时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>)</span></p></li>\n<li><p>有序表的顺序查找</p></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">seqSearch</span><span class=\"hljs-params\">(SET&lt;KEY , OTHER&gt; data[] , <span class=\"hljs-type\">int</span> size , <span class=\"hljs-type\">const</span> KEY &amp;x)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  data[<span class=\"hljs-number\">0</span>].key = x;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = size ; x &lt; data[i].key; --i);<br>  <span class=\"hljs-keyword\">if</span> (x == data[i].key)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> i;<br>  &#125;<br><span class=\"hljs-keyword\">else</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"二分查找\">二分查找</h5>\n<ol type=\"1\">\n<li>每次检查中间的元素（向下取整）</li>\n<li>若中间的元素等于要查找的元素，则查找成功</li>\n<li>若中间的元素大于要查找的元素，则在左半部分继续查找</li>\n<li>若中间的元素小于要查找的元素，则在右半部分继续查找</li>\n</ol>\n<ul>\n<li>时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(log <em>n</em>)</span></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">binarySearch</span><span class=\"hljs-params\">(SET&lt;KEY , OTHER&gt;data[] , <span class=\"hljs-type\">int</span> size , <span class=\"hljs-type\">const</span> KEY &amp;x)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> low = <span class=\"hljs-number\">1</span>,  high = size, mid;<br>    <span class=\"hljs-keyword\">while</span> (low &lt;= high)<br>    &#123;                 <span class=\"hljs-comment\">//查找区间存在</span><br>      mid = (low + high) / <span class=\"hljs-number\">2</span>;         <span class=\"hljs-comment\">//计算中间位置</span><br>      <span class=\"hljs-keyword\">if</span> ( x == data[mid].key )<br>      &#123;<br>        <span class=\"hljs-keyword\">return</span> mid;<br>      &#125;<br>      <span class=\"hljs-keyword\">if</span> (x &lt; data[mid].key)<br>      &#123;<br>        high = mid - <span class=\"hljs-number\">1</span>;<br>      &#125;<br>      <span class=\"hljs-keyword\">else</span> low = mid + <span class=\"hljs-number\">1</span>;<br>    &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"插值查找\">插值查找</h5>\n<ul>\n<li>适用于数据分布较为均匀的情况</li>\n<li>计算中间位置的公式为</li>\n</ul>\n<p><span class=\"math display\">$$\n\\text{next} = \\text{low} + \\frac{(x - a[\\text{low}])}{(a[\\text{high}] -\na[\\text{low}])} \\times (\\text{high} - \\text{low}+1)\n$$</span></p>\n<ul>\n<li>缺点：计算量大</li>\n</ul>\n<h5 id=\"分块查找\">分块查找</h5>\n<ul>\n<li>将数据分成若干个块，每个块内可以是有序和无序的，但块之间是有序的</li>\n<li>查找分为两个阶段\n<ol type=\"1\">\n<li>查找索引</li>\n<li>查找块 设表长为 <span class=\"math inline\"><em>n</em></span>，块长为\n<span class=\"math inline\"><em>m</em></span> 则平均所需的时间为 <span\nclass=\"math inline\">$\\frac{m+1}{2}+\\frac{\\frac{n}{m}+1}{2}$</span> 当\n<span class=\"math inline\">$m=\\sqrt{n}$</span>\n时，平均所需的时间<strong>最短</strong>，为 <span\nclass=\"math inline\">$O(\\sqrt{n})$</span></li>\n</ol></li>\n</ul>\n<h2 id=\"动态查找表\">动态查找表</h2>\n<h3 id=\"二叉查找树\">二叉查找树</h3>\n<h4 id=\"抽象类-1\">抽象类</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">dynamicSearchTable</span><br>&#123;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> SET&lt;KEY, OTHER&gt; *<span class=\"hljs-title\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> SET&lt;KEY, OTHER&gt; &amp;x)</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x)</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">dynamicSearchTable</span>() &#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"二叉查找树的定义\">二叉查找树的定义</h4>\n<ul>\n<li>对于任意一个节点 <code>p</code>\n<ul>\n<li><code>p</code> 的左子树中所有节点的值都小于 <code>p</code> 的值</li>\n<li><code>p</code> 的右子树中所有节点的值都大于 <code>p</code> 的值</li>\n<li><code>p</code> 的左子树和右子树都是二叉查找树</li>\n</ul></li>\n<li>二叉查找树的<strong>中序遍历</strong>是排好序的，又称为<strong>排序树</strong></li>\n<li>最大和最小的元素不一定存放在叶节点中，但是最大节点的右子树、最小节点的左子树都是空的</li>\n</ul>\n<h4 id=\"二叉查找树的存储实现\">二叉查找树的存储实现</h4>\n<ul>\n<li>使用二叉链表存储，需要一个指向根节点的数据成员</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BinarySearchTree</span>:<span class=\"hljs-keyword\">public</span> dynamicSearchTable&lt;KEY , OTHER&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">BinaryNode</span><br>    &#123;<br>      SET&lt;KEY, OTHER&gt; data;<br>      BinaryNode*left;<br>      BinaryNode*right;<br>      <span class=\"hljs-built_in\">BinaryNode</span>( <span class=\"hljs-type\">const</span> SET&lt;KEY, OTHER&gt; &amp; thedata,<br>      BinaryNode *lt = <span class=\"hljs-literal\">nullptr</span> , BinaryNode *rt = <span class=\"hljs-literal\">nullptr</span>):<span class=\"hljs-built_in\">data</span>(thedata) , <span class=\"hljs-built_in\">left</span>(lt) , <span class=\"hljs-built_in\">right</span>(rt)&#123;&#125;<br>    &#125;;<br>    BinaryNode*root;<br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">BinarySearchTree</span>();<br>    ~<span class=\"hljs-built_in\">BinarySearchTree</span>();<br>    <span class=\"hljs-function\">SET&lt;KEY, OTHER&gt; *<span class=\"hljs-title\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x)</span> <span class=\"hljs-type\">const</span> </span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> SET&lt;KEY , OTHER&gt; &amp;x )</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x)</span></span>;<br><br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> SET&lt;KEY , OTHER&gt; &amp;x, BinaryNode *&amp;t)</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x , BinaryNode *&amp;t)</span></span>;<br>    <span class=\"hljs-function\">SET&lt;KEY , OTHER&gt; *<span class=\"hljs-title\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x , BinaryNode *t )</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">makeEmpty</span><span class=\"hljs-params\">(BinaryNode *t)</span></span>;<span class=\"hljs-comment\">//析构用，同二叉树的clear</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"二叉查找树的操作\">二叉查找树的操作</h4>\n<h5 id=\"查找-1\">查找</h5>\n<ol type=\"1\">\n<li>检查根节点的关键字值</li>\n<li>如果等于要查找的值，则查找成功，返回根节点地址</li>\n<li>如果小于要查找的值，则在右子树中查找</li>\n<li>如果大于要查找的值，则在左子树中查找</li>\n</ol>\n<ul>\n<li>公有函数 <code>find(const KEY &amp;x)</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *BinarySearchTree&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-type\">const</span> KEY &amp;x ) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">find</span>( x, root );<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>私有辅助函数 <code>find(const KEY &amp;x, BinaryNode *t)</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *BinarySearchTree&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-type\">const</span> KEY &amp;x, BinaryNode *t ) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">nullptr</span> || t-&gt;data.key == x)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> (SET&lt;KEY , OTHER&gt; *)t;<span class=\"hljs-comment\">//强制类型转换</span><br>  &#125;<br>  <span class=\"hljs-keyword\">if</span>(x &lt; t-&gt;data.key)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">find</span>(x , t-&gt;left);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">find</span>(x , t-&gt;right );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"插入\">插入</h5>\n<ul>\n<li><p>若二叉树为空树，则插入的节点为根节点</p></li>\n<li><p>若二叉树非空</p>\n<ul>\n<li>判断是左儿子还是右儿子，作为叶节点插入</li>\n</ul></li>\n<li><p>公有的\n<code>insert(const SET&lt;KEY, OTHER&gt; &amp;x)</code></p></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> BinarySearchTree&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-type\">const</span> SET&lt;KEY , OTHER&gt; &amp;x)<br>&#123;<br>  <span class=\"hljs-built_in\">insert</span>(x, root);<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>私有的\n<code>insert(const SET&lt;KEY, OTHER&gt; &amp;x, BinaryNode *&amp;t)</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> BinarySearchTree&lt;KEY , OTHER&gt;::<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-type\">const</span> SET&lt;KEY , OTHER&gt; &amp;x, BinaryNode *&amp;t)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span>(t == <span class=\"hljs-literal\">nullptr</span>)<br>  t = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">BinaryNode</span>(x , <span class=\"hljs-literal\">nullptr</span> , <span class=\"hljs-literal\">nullptr</span>);<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(x.key&lt; t-&gt;data.key)<br>  &#123;<br>    <span class=\"hljs-built_in\">insert</span>(x, t-&gt;left);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(x.key &gt; t-&gt;data.key)<br>  &#123;<br>    <span class=\"hljs-built_in\">insert</span>(x , t-&gt;right);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    cout &lt;&lt; x.key &lt;&lt; “is exist” &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"删除\">删除</h5>\n<ul>\n<li><p><span class=\"math inline\"><em>P</em><sub><em>L</em></sub></span>\n和 <span class=\"math inline\"><em>P</em><sub><em>R</em></sub></span>\n分别是 <span class=\"math inline\"><em>P</em></span> 的左子树和右子树</p>\n<ol type=\"1\">\n<li>如果 <span class=\"math inline\"><em>P</em></span>\n是叶节点，则直接删除</li>\n<li>如果 <span class=\"math inline\"><em>P</em></span> 只有一个子树，则将\n<span class=\"math inline\"><em>P</em></span> 的父节点指向 <span\nclass=\"math inline\"><em>P</em></span> 的子树</li>\n<li>如果 <span class=\"math inline\"><em>P</em></span> 有两个子树，则\n<ol type=\"1\">\n<li>找到 <span class=\"math inline\"><em>P</em></span>\n的右子树中最左的节点或者左子树的最右节点 <span\nclass=\"math inline\"><em>Q</em></span></li>\n<li>将 <span class=\"math inline\"><em>Q</em></span> 的值赋给 <span\nclass=\"math inline\"><em>P</em></span></li>\n<li>删除 <span class=\"math inline\"><em>Q</em></span> 节点</li>\n</ol></li>\n</ol></li>\n<li><p>公有的 <code>remove(const KEY &amp;x)</code></p></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> BinarySearchTree&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-type\">const</span> KEY &amp;x)<br>&#123;<br>  <span class=\"hljs-built_in\">remove</span>(x , root);<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>私有的\n<code>remove(const KEY &amp;x, BinaryNode *&amp;t)</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> BinarySearchTree&lt;KEY , OTHER&gt;::<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-type\">const</span> KEY &amp;x , BinaryNode *&amp;t)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span>(t == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    cout &lt;&lt; x.key &lt;&lt; <span class=\"hljs-string\">&quot;is not exist&quot;</span> &lt;&lt; endl;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(x.key &lt; t-&gt;data.key)<br>  &#123;<br>    <span class=\"hljs-built_in\">remove</span>(x , t-&gt;left);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(x.key &gt; t-&gt;data.key)<br>  &#123;<br>    <span class=\"hljs-built_in\">remove</span>(x , t-&gt;right);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(t-&gt;left != <span class=\"hljs-literal\">nullptr</span> &amp;&amp; t-&gt;right != <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    BinaryNode *p = t-&gt;right;<br>    <span class=\"hljs-keyword\">while</span>(p-&gt;left != <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>      p = p-&gt;left;<br>    &#125;<br>    t-&gt;data = p-&gt;data;<br>    <span class=\"hljs-built_in\">remove</span>(p-&gt;data.key , t-&gt;right);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    BinaryNode *oldNode = t;<br>    t = (t-&gt;left != <span class=\"hljs-literal\">nullptr</span>) ? t-&gt;left : t-&gt;right;<br>    <span class=\"hljs-keyword\">delete</span> oldNode;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"二叉查找树的性能\">二叉查找树的性能</h4>\n<ul>\n<li>二叉查找树的操作的时间复杂度为树的高度</li>\n<li>如果二叉查找树是平衡的，则访问的代价是 <span\nclass=\"math inline\"><em>O</em>(log <em>n</em>)</span></li>\n<li>最坏的情况下，二叉查找树会退化成一个单链表，时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>)</span></li>\n</ul>\n<p><strong>平均性能</strong></p>\n<p>具有 <span class=\"math inline\"><em>n</em></span>\n个节点的二叉查找树可能有 <span class=\"math inline\"><em>n</em></span>\n种不同的形态 <span\nclass=\"math inline\">(0, 1, <em>n</em> − 1), (1, 1<em>n</em> − 2), (2, 1, <em>n</em> − 3), …, (<em>n</em> − 1, 1, 0)</span>\n若设这些形态出现的概率是相同的，设 <span\nclass=\"math inline\"><em>P</em>(<em>n</em>)</span> 为查找 <span\nclass=\"math inline\"><em>n</em></span>\n个节点的二叉查找树的平均查找时间，则有如下递归关系式：</p>\n<p><span class=\"math display\">$$\nP(n) = \\frac{\\sum_{i = 0}^{n-1} \\left[ 1 + (P(i)+1) \\cdot i + (P( n - i\n- 1)+1)\\cdot (n-i-1)\\right]}{n} \\leq 2(1 + \\frac{1}{n})\\ln{n} \\approx\n1.33 \\log{n}\n$$</span></p>\n<h3 id=\"avl-树\">AVL 树</h3>\n<h4 id=\"avl-树的定义\">AVL 树的定义</h4>\n<ul>\n<li>也叫平衡树\n<ul>\n<li>对于任意一个节点的两棵子树的高度至多相差 1</li>\n</ul></li>\n<li>平衡因子\n<ul>\n<li>节点的左子树的高度减去右子树的高度</li>\n<li>平衡因子只能是 <span class=\"math inline\">−1</span>，<span\nclass=\"math inline\">0</span>，<span class=\"math inline\">1</span></li>\n</ul></li>\n<li>优点\n<ul>\n<li>查找，插入和删除操作的时间复杂度都是 <span\nclass=\"math inline\"><em>O</em>(log <em>n</em>)</span></li>\n</ul></li>\n</ul>\n<h5 id=\"查找性能\">查找性能</h5>\n<ul>\n<li><p>与二叉树的高度成正比</p></li>\n<li><p>定理：</p>\n<ul>\n<li>具有 <span class=\"math inline\"><em>n</em></span>\n个节点的平衡树，高度 <span class=\"math inline\"><em>h</em></span> 满足\n<span\nclass=\"math inline\">log<sub>2</sub>(<em>n</em> + 1) ≤ <em>h</em> ≤ 1.44log<sub>2</sub>(<em>n</em> + 2) − 0.328</span></li>\n<li>因此，平衡二叉树的操作都是 <span\nclass=\"math inline\"><em>O</em>(log <em>n</em>)</span></li>\n</ul></li>\n</ul>\n<h5 id=\"斐波那契树\">斐波那契树</h5>\n<ul>\n<li><p>斐波那契树是平衡树的最坏情况，其每一子树的左右子树高度差都为\n1</p></li>\n<li><p>定义</p>\n<ol type=\"1\">\n<li>空树是高度为 0 的斐波那契树</li>\n<li>单个节点是高度为 1 的斐波那契树</li>\n<li>若 <span\nclass=\"math inline\"><em>T</em><sub><em>h</em> − 1</sub></span> 和 <span\nclass=\"math inline\"><em>T</em><sub><em>h</em> − 2</sub></span>\n分别为高度为 <span class=\"math inline\"><em>h</em> − 1</span> 和 <span\nclass=\"math inline\"><em>h</em> − 2</span> 的斐波那契树，则 <span\nclass=\"math inline\"><em>T</em><sub><em>h</em></sub> = <em>T</em><sub><em>h</em> − 1</sub>, <em>x</em>, <em>T</em><sub><em>h</em> − 2</sub></span>\n是高度为 <span class=\"math inline\"><em>h</em></span> 的斐波那契树</li>\n<li>没有其他的树是斐波那契树</li>\n</ol></li>\n</ul>\n<h6 id=\"斐波那契树的特点\">斐波那契树的特点</h6>\n<p>对于高度为 <span class=\"math inline\"><em>h</em></span>\n的斐波那契树，节点数 <span class=\"math inline\"><em>n</em></span>\n满足</p>\n<ul>\n<li><span class=\"math inline\"><em>n</em><sub>0</sub> = 0</span></li>\n<li><span class=\"math inline\"><em>n</em><sub>1</sub> = 1</span></li>\n<li><span\nclass=\"math inline\"><em>n</em><sub><em>h</em></sub> = <em>n</em><sub><em>h</em> − 1</sub> + <em>n</em><sub><em>h</em> − 2</sub> + 1</span></li>\n</ul>\n<h4 id=\"avl-树的存储实现\">AVL 树的存储实现</h4>\n<ul>\n<li>使用二叉链表</li>\n<li>每个节点必须保存平衡信息\n<ul>\n<li>每棵树的高度</li>\n<li>平衡度即左右子树的高度差</li>\n</ul></li>\n</ul>\n<h5 id=\"avl-树类的实现\">AVL 树类的实现</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;clas KEY,<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AvlTree</span>:<span class=\"hljs-keyword\">public</span> dynamicSearchTable&lt;KEY , OTHER&gt;<br>&#123;<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">AvlNode</span><br>    &#123;<br>      SET&lt;KEY , OTHER&gt; data ; <span class=\"hljs-comment\">// 关键字</span><br>      AvlNode *left , *right; <span class=\"hljs-comment\">// 左右子树指针</span><br>      <span class=\"hljs-type\">int</span> height;            <span class=\"hljs-comment\">// 节点高度</span><br><br>      <span class=\"hljs-built_in\">AvlNode</span>(<span class=\"hljs-type\">const</span> SET&lt;KEY , OTHER&gt; &amp;element , AvlNode *lt ,AvlNode   *rt , <span class=\"hljs-type\">int</span> h = <span class=\"hljs-number\">1</span>):<span class=\"hljs-built_in\">data</span>(elemeent) , <span class=\"hljs-built_in\">left</span>(lt) , <span class=\"hljs-built_in\">right</span>(rt) , <span class=\"hljs-built_in\">height</span>  (h) &#123;&#125; <span class=\"hljs-comment\">// 构造函数</span><br>    &#125;;<br><br>    AvlNode *root; <span class=\"hljs-comment\">// 根节点</span><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">AvlTree</span>() <span class=\"hljs-comment\">// 构造函数</span><br>    &#123;<br>      root = <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br>    ~<span class=\"hljs-built_in\">AvlTree</span>() <span class=\"hljs-comment\">// 析构函数</span><br>    &#123;<br>      <span class=\"hljs-built_in\">makeEmpty</span>(root);<br>    &#125;<br>    <span class=\"hljs-function\">SET&lt;KEY, OTHER&gt; *<span class=\"hljs-title\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x)</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp; x)</span></span>;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">( <span class=\"hljs-type\">const</span> SET&lt;KEY, OTHER&gt; &amp; x, AvlNode * &amp; t )</span> </span>; <span class=\"hljs-comment\">// 插入</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">( <span class=\"hljs-type\">const</span> KEY &amp; x, AvlNode * &amp; t )</span> </span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">makeEmpty</span><span class=\"hljs-params\">( AvlNode *t )</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">height</span><span class=\"hljs-params\">(AvlNode *t)</span> <span class=\"hljs-type\">const</span>  <span class=\"hljs-comment\">// 返回节点的高度</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> t == <span class=\"hljs-literal\">nullptr</span> ? <span class=\"hljs-number\">0</span> : t -&gt; height;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">LL</span><span class=\"hljs-params\">( AvlNode * &amp; t )</span></span>; <span class=\"hljs-comment\">// 左旋</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">RR</span><span class=\"hljs-params\">( AvlNode * &amp; t )</span></span>; <span class=\"hljs-comment\">// 右旋</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">LR</span><span class=\"hljs-params\">( AvlNode * &amp; t )</span></span>; <span class=\"hljs-comment\">// 左右旋</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">RL</span><span class=\"hljs-params\">( AvlNode * &amp; t )</span></span>; <span class=\"hljs-comment\">// 右左旋</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span>     <span class=\"hljs-comment\">// 返回两个数中较大的一个</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> a &gt; b ? a : b;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">adjust</span><span class=\"hljs-params\">(AvlNode *&amp;t, <span class=\"hljs-type\">int</span> subTree)</span></span>; <span class=\"hljs-comment\">//用于删除</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"avl-树的查找\">AVL 树的查找</h4>\n<ul>\n<li>与二叉查找树相同</li>\n<li>二叉查找树类采用递归实现</li>\n<li>AVL 树类展示非递归实现</li>\n</ul>\n<h5 id=\"查找的非递归实现\">查找的非递归实现</h5>\n<ol type=\"1\">\n<li>设当前节点为根节点</li>\n<li>若当前节点非空\n<ol type=\"1\">\n<li>若当前节点的值等于 <code>x</code>，则返回当前节点</li>\n<li>若当前节点的值大于 <code>x</code>，则将当前节点指向左子树</li>\n<li>若当前节点的值小于 <code>x</code>，则将当前节点指向右子树</li>\n</ol></li>\n<li>若当前节点为空，则返回空</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>,<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *AvlTree&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-type\">const</span> KEY &amp; x) <span class=\"hljs-type\">const</span><br>&#123;<br>  AvlNode *t = root; <br>  <span class=\"hljs-keyword\">while</span> (t!=<span class=\"hljs-literal\">nullptr</span> &amp;&amp; t-&gt;data.key != x)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (x &lt; t-&gt;data.key)<br>    &#123;<br>      t = t-&gt;left;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      t = t-&gt;right;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> t-&gt;data;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"avl-树的插入\">AVL 树的插入</h4>\n<ul>\n<li>与二叉查找树相同\n<ul>\n<li>可能改变了根到插入节点的路径上某些节点的平衡度</li>\n<li>需要向上修改树的结构</li>\n</ul></li>\n</ul>\n<h5 id=\"可能引起节点不平衡的情况\">可能引起节点不平衡的情况</h5>\n<ul>\n<li>节点的左孩子的左子树上插入（LL）</li>\n<li>节点的左孩子的右子树上插入（LR）</li>\n<li>节点的右孩子的左子树上插入（RL）</li>\n<li>节点的右孩子的右子树上插入（RR）</li>\n</ul>\n<h5 id=\"重构的方法\">重构的方法</h5>\n<ul>\n<li>指针调整\n<ul>\n<li>按照投影序保持结点相邻关系不变</li>\n<li>辈分可以改变</li>\n</ul></li>\n</ul>\n<h6 id=\"ll-问题\">LL 问题</h6>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141158768.png\"\nalt=\"LL\" />\n<figcaption aria-hidden=\"true\">LL</figcaption>\n</figure>\n<ul>\n<li><strong>左旋</strong>\n<ol type=\"1\">\n<li>将失衡点的左儿子作为新的根节点</li>\n<li>左儿子的右儿子作为原根节点的左儿子</li>\n</ol></li>\n<li>若为 RR\n问题，则将失衡点的右儿子作为新的根节点，右儿子的左儿子作为原根节点的右儿子，称为<strong>右旋</strong></li>\n<li>左旋和右旋统称为<strong>单旋转</strong>，保留了树的有序性和原先的高度</li>\n</ul>\n<h6 id=\"lr-问题\">LR 问题</h6>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141206204.png\"\nalt=\"LR\" />\n<figcaption aria-hidden=\"true\">LR</figcaption>\n</figure>\n<ul>\n<li><strong>双旋转</strong>\n<ol type=\"1\">\n<li>将失衡点的左儿子右旋</li>\n<li>将失衡点左旋</li>\n</ol></li>\n<li>若为 RL 问题，则将失衡点的右儿子左旋，再将失衡点右旋</li>\n<li>先对失衡结点的儿子和孙子进行一次单旋转，使孙子变成儿子。然后是失衡结点和新的儿子进行一次单旋转，使<strong>原先的孙子变成根</strong></li>\n</ul>\n<h5 id=\"私有的insert-函数\">私有的<code>insert</code> 函数</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>,<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> AvlTree&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-type\">const</span> SET&lt;KEY, OTHER&gt; &amp; x, AvlNode * &amp; t)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    t = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">AvlNode</span>(x , <span class=\"hljs-literal\">nullptr</span> , <span class=\"hljs-literal\">nullptr</span>);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (x.key &lt; t-&gt;data.key)<br>  &#123;<br>    <span class=\"hljs-built_in\">insert</span>(x , t-&gt;left);<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">height</span>(t-&gt;left) - <span class=\"hljs-built_in\">height</span>(t-&gt;right) == <span class=\"hljs-number\">2</span>)<br>    &#123;<br>      <span class=\"hljs-keyword\">if</span> (x.key &lt; t-&gt;left-&gt;data.key)<br>      &#123;<br>        <span class=\"hljs-built_in\">LL</span>(t);<br>      &#125;<br>      <span class=\"hljs-keyword\">else</span><br>      &#123;<br>        <span class=\"hljs-built_in\">LR</span>(t);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (x.key &gt; t-&gt;data.key)<br>  &#123;<br>    <span class=\"hljs-built_in\">insert</span>(x , t-&gt;right);<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">height</span>(t-&gt;right) - <span class=\"hljs-built_in\">height</span>(t-&gt;left) == <span class=\"hljs-number\">2</span>)<br>    &#123;<br>      <span class=\"hljs-keyword\">if</span> (x.key &gt; t-&gt;right-&gt;data.key)<br>      &#123;<br>        <span class=\"hljs-built_in\">RR</span>(t);<br>      &#125;<br>      <span class=\"hljs-keyword\">else</span><br>      &#123;<br>        <span class=\"hljs-built_in\">RL</span>(t);<br>      &#125;<br>    &#125;<br>  &#125;<br>  t-&gt;height = <span class=\"hljs-built_in\">max</span>(<span class=\"hljs-built_in\">height</span>(t-&gt;left) , <span class=\"hljs-built_in\">height</span>(t-&gt;right)) + <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 更新高度</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"ll\"><code>LL</code></h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>,<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class=\"hljs-built_in\">LL</span>(AvlNode *&amp; t)<br>&#123;<br>  AvlNode *t1 = t-&gt;left;<br>  t-&gt;left = t1-&gt;right;<br>  t1-&gt;right = t;<br>  t-&gt;height = <span class=\"hljs-built_in\">max</span>(<span class=\"hljs-built_in\">height</span>(t-&gt;left) , <span class=\"hljs-built_in\">height</span>(t-&gt;right)) + <span class=\"hljs-number\">1</span>;<br>  t1-&gt;height = <span class=\"hljs-built_in\">max</span>(<span class=\"hljs-built_in\">height</span>(t1-&gt;left) , <span class=\"hljs-built_in\">height</span>(t1-&gt;right)) + <span class=\"hljs-number\">1</span>;<br>  t = t1;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"rr\"><code>RR</code></h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>,<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class=\"hljs-built_in\">RR</span>(AvlNode *&amp; t)<br>&#123;<br>  AvlNode *t1 = t-&gt;right;<br>  t-&gt;right = t1-&gt;left;<br>  t1-&gt;left = t;<br>  t-&gt;height = <span class=\"hljs-built_in\">max</span>(<span class=\"hljs-built_in\">height</span>(t-&gt;left) , <span class=\"hljs-built_in\">height</span>(t-&gt;right)) + <span class=\"hljs-number\">1</span>;<br>  t1-&gt;height = <span class=\"hljs-built_in\">max</span>(<span class=\"hljs-built_in\">height</span>(t1-&gt;left) , <span class=\"hljs-built_in\">height</span>(t1-&gt;right)) + <span class=\"hljs-number\">1</span>;<br>  t = t1;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"lr\"><code>LR</code></h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>,<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class=\"hljs-built_in\">LR</span>(AvlNode *&amp; t)<br>&#123;<br>  <span class=\"hljs-built_in\">RR</span>(t-&gt;left);<br>  <span class=\"hljs-built_in\">LL</span>(t);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"rl\"><code>RL</code></h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>,<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class=\"hljs-built_in\">RL</span>(AvlNode *&amp; t)<br>&#123;<br>  <span class=\"hljs-built_in\">LL</span>(t-&gt;right);<br>  <span class=\"hljs-built_in\">RR</span>(t);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>所有旋转的算法时间复杂度都是 <span\nclass=\"math inline\"><em>O</em>(1)</span>，且只运行一次，所以\n<code>insert</code> 的时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(log <em>n</em>)</span></p>\n<h4 id=\"avl-树的删除\">AVL 树的删除</h4>\n<ol type=\"1\">\n<li>在 AVL 树上删除节点 <code>x</code>，删除操作和二叉查找树相同</li>\n<li>调整平衡，与插入操作相同</li>\n</ol>\n<h4 id=\"调整\">调整</h4>\n<ul>\n<li>与插入操作相同，失衡节点存在于被删的节点到根节点的路径上。删除一个节点之后，必须沿着到根节点的路径向上回溯，随时调整路径上的节点的平衡度</li>\n<li>删除时无法保证子树在平衡调整之后的高度不变</li>\n<li>递归的删除函数有一个 bool 型的返回值，当返回值为 <code>true</code>\n时，调整停止</li>\n</ul>\n<h4 id=\"五种情况\">五种情况</h4>\n<h5 id=\"情况-a\">情况 a</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191603536.png\"\nalt=\"Sitiationa\" />\n<figcaption aria-hidden=\"true\">Sitiationa</figcaption>\n</figure>\n<p>此时没有失衡，高度也没有改变，返回<code>true</code></p>\n<h5 id=\"情况-b\">情况 b</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191604348.png\"\nalt=\"Situationb\" />\n<figcaption aria-hidden=\"true\">Situationb</figcaption>\n</figure>\n<p>此时没有失衡，但是高度变矮，返回<code>false</code></p>\n<h5 id=\"情况-c\">情况 c</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191607359.png\"\nalt=\"Situationc\" />\n<figcaption aria-hidden=\"true\">Situationc</figcaption>\n</figure>\n<p>经过 RR 旋转后高度变矮，返回<code>false</code></p>\n<h5 id=\"情况-d\">情况 d</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191609189.png\"\nalt=\"Situationd\" />\n<figcaption aria-hidden=\"true\">Situationd</figcaption>\n</figure>\n<p>经过 RL 旋转后高度变矮，返回<code>false</code></p>\n<h5 id=\"情况-e\">情况 e</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191613240.png\"\nalt=\"Situatione\" />\n<figcaption aria-hidden=\"true\">Situatione</figcaption>\n</figure>\n<p>经过 RR 或 RL 旋转后高度不变，返回<code>true</code></p>\n<h4 id=\"删除总结\">删除总结</h4>\n<ul>\n<li>节点删除同二叉查找树。在删除了叶节点或者只有一个孩子的节点后，子树变矮，返回\n<code>false</code></li>\n<li>在每次调用后，检查返回值，如果是 <code>true</code>，则返回\n<code>true</code>，否则分 5 种情况进行处理</li>\n</ul>\n<h4 id=\"私有的-remove-函数\">私有的 <code>remove</code> 函数</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>,<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> AvlTree&lt;KEY , OTHER&gt;::<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-type\">const</span> KEY &amp;x , AvlNOde *&amp;x)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t = <span class=\"hljs-literal\">nullptr</span>) <span class=\"hljs-comment\">// 被删除节点不存在</span><br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (x == t-&gt; data.key)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (t-&gt;left == <span class=\"hljs-literal\">nullptr</span> || t-&gt; right == <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>      AvlNode *oldNode = t;<br>      t = (t-&gt;left == <span class=\"hljs-literal\">nullptr</span>) ? t-&gt;right : t-&gt;left; <span class=\"hljs-comment\">// 删除节点的孩子节点</span><br>      <span class=\"hljs-keyword\">delete</span> oldNode;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// 删除了一个节点，返回 `false`</span><br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      AvlNode *tmp = t-&gt; right;<br>      <span class=\"hljs-keyword\">while</span> (tmp-&gt;left != <span class=\"hljs-literal\">nullptr</span>) <span class=\"hljs-comment\">// 找到右子树的最小节点</span><br>      &#123;<br>        tmp = tmp-&gt;left;<br>      &#125;<br>      t-&gt;data = tmp.data;<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">remove</span>(tmp-&gt;data,key , t-&gt;right))<br>      &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">adjust</span>(t,<span class=\"hljs-number\">1</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (x &lt; t-&gt;data,key)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">remove</span>(x,t-&gt;left))<br>    &#123;<br>      teturn <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">adjust</span>(t,<span class=\"hljs-number\">0</span>);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">remove</span>(x , t-&gt;right))<br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">adjust</span>(t,<span class=\"hljs-number\">1</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"adjust\"><code>adjust</code></h4>\n<ul>\n<li>进入调整函数的条件是某棵子树变矮了</li>\n<li>调整函数需要检查节点是否失衡，若失衡则进行相应的调整</li>\n<li>函数的返回值是子树是否变矮\n<ul>\n<li><code>true</code>：子树没有变矮</li>\n<li><code>false</code>：子树变矮</li>\n</ul></li>\n<li>需要传入两个参数\n<ul>\n<li><code>AVlNode *&amp;t</code>：传入的节点</li>\n<li><code>int subTree</code>：参数 <code>t</code> 变矮的子树\n<ul>\n<li><code>0</code>：左子树</li>\n<li><code>1</code>：右子树</li>\n</ul></li>\n</ul></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span> , classs OTHER&gt;<br><span class=\"hljs-type\">bool</span> AvlTree&lt;KEY , OTHER&gt;::<span class=\"hljs-built_in\">adjust</span>(AvlNode *&amp;t , <span class=\"hljs-type\">int</span> SubTree)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (subTree) <span class=\"hljs-comment\">// 在右子树上删除</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">height</span>(t-&gt;left) - <span class=\"hljs-built_in\">height</span>(t-&gt;right) == <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// Situation a</span><br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">height</span>(t-&gt;right) == <span class=\"hljs-built_in\">height</span>(t-&gt;left)) <span class=\"hljs-comment\">// Situation b</span><br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">height</span>(t-&gt;left-&gt;right) &gt; <span class=\"hljs-built_in\">height</span>(t-&gt;left-&gt;left)) <span class=\"hljs-comment\">// Situation d</span><br>    &#123;<br>      <span class=\"hljs-built_in\">LR</span>(t);<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>    <span class=\"hljs-built_in\">LL</span>(t); <span class=\"hljs-comment\">// Situation c and e</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">height</span>(t-&gt;left) == <span class=\"hljs-built_in\">height</span>(t-&gt;right))s<br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-comment\">// 在左子树上删除</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">height</span>(t-&gt;right) - <span class=\"hljs-built_in\">height</span>(t-&gt;left) == <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// Situation a</span><br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">height</span>(t-&gt;right) == <span class=\"hljs-built_in\">height</span>(t-&gt;left)) <span class=\"hljs-comment\">// Situation b</span><br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<span class=\"hljs-function\">s</span><br><span class=\"hljs-function\">    <span class=\"hljs-title\">if</span> <span class=\"hljs-params\">(height(t-&gt;right-&gt;left) &gt; height(t-&gt;right-&gt;right))</span> <span class=\"hljs-comment\">// Situation d</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-built_in\">RL</span>(t);<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>    <span class=\"hljs-built_in\">RR</span>(t); <span class=\"hljs-comment\">// Situation c and e</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">height</span>(t-&gt;right) == <span class=\"hljs-built_in\">height</span>(t-&gt;left))<br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"散列表\">散列表</h3>\n<ul>\n<li>也叫哈希表</li>\n<li>通过所求节点的关键字词 <code>KEY</code> 找到这个节点</li>\n<li>时间复杂度为 <span class=\"math inline\"><em>O</em>(1)</span></li>\n</ul>\n<h4 id=\"基本概念\">基本概念</h4>\n<ol type=\"1\">\n<li>初始化 将数组转化为一个特殊的、表示单元为空的值</li>\n<li><code>insert(i)</code> 将 <code>i</code> 存放到\n<code>a[i.key]</code> 中</li>\n<li><code>find(i)</code> 取出 <code>a[i.key]</code> 中的值</li>\n<li><code>remove(i)</code> 将 <code>a[i.key]</code> 中的值置为空</li>\n</ol>\n<h4 id=\"散列函数\">散列函数</h4>\n<p>将一个项映射成一个较小的下标的函数称为散列函数（hush function）</p>\n<ul>\n<li><span\nclass=\"math inline\"><em>D</em> = <em>H</em>(<em>k</em><em>e</em><em>y</em>)</span>\nD 为存储地址，key 为关键值，H 为散列函数</li>\n<li>散列函数的要求\n<ul>\n<li>计算速度快</li>\n<li>散列地址均匀分布</li>\n</ul></li>\n</ul>\n<h4 id=\"常用的散列函数\">常用的散列函数</h4>\n<h5 id=\"直接地址法\">直接地址法</h5>\n<p><span\nclass=\"math inline\"><em>H</em>(<em>k</em><em>e</em><em>y</em>) = <em>k</em><em>e</em><em>y</em></span>\n或 <span\nclass=\"math inline\"><em>H</em>(<em>k</em><em>e</em><em>y</em>) = <em>a</em> × <em>k</em><em>e</em><em>y</em> + <em>b</em></span></p>\n<h5 id=\"除留余数法\"><strong>除留余数法</strong></h5>\n<p><span\nclass=\"math inline\"><em>H</em>(<em>k</em><em>e</em><em>y</em>) = <em>k</em><em>e</em><em>y</em> mod  <em>p</em></span>\n或 <span\nclass=\"math inline\"><em>H</em>(<em>k</em><em>e</em><em>y</em>) = <em>k</em><em>e</em><em>y</em> mod  <em>p</em> + <em>c</em></span>\n这里的 <span class=\"math inline\"><em>p</em></span> 是一个小于等于 <span\nclass=\"math inline\"><em>m</em></span> 的素数</p>\n<h5 id=\"数字分析法\">数字分析法</h5>\n<p>对关键字集合中的所有关键字，分析每一位上数字分布。取数字分布均匀的位作为地址的组成部分</p>\n<h5 id=\"平方取中法\">平方取中法</h5>\n<p>如果关键字中各位的分布都比较均匀，但关键字的值域比数组规模大，则可以将关键字<strong>平方后</strong>，取其结果的中间各位作为散列函数值。由于中间各位和每一位数字都有关系，因此均匀分布的可能性较大。</p>\n<h5 id=\"折叠法\">折叠法</h5>\n<ul>\n<li>如果关键字相当长，以至于和散列表的单元总数相比大得多时，可采用此法</li>\n<li>选取一个长度后，将关键字按此长度分组相加</li>\n</ul>\n<h4 id=\"冲突问题\">冲突问题</h4>\n<p>当两个以上的关键字映射到一个存储单元时，称为<strong>冲突或碰撞</strong></p>\n<ul>\n<li>解决冲突的方法\n<ul>\n<li>闭散列表：利用本散列表中的空余单元\n<ul>\n<li>线性探测法</li>\n<li>二次探测法</li>\n<li>再次散列法</li>\n</ul></li>\n<li>开散列表：将碰撞的节点存放在散列表外的各自的线性表中（链接法）</li>\n</ul></li>\n</ul>\n<h5 id=\"闭散列表类的实现\">闭散列表类的实现</h5>\n<ul>\n<li>支持三种操作\n<ul>\n<li><code>insert</code>：插入一个元素</li>\n<li><code>remove</code>：删除一个元素</li>\n<li><code>find</code>：查找一个元素</li>\n</ul></li>\n<li>由一个数组实现，数组的大小由用户定义散列表时指定</li>\n<li>由于删除时的迟删除，每个数组元素还要保存一个状态值\n<ul>\n<li><code>0</code>：空</li>\n<li><code>1</code>：有效</li>\n<li><code>2</code>：删除</li>\n</ul></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">closeHashTable</span>:<span class=\"hljs-keyword\">public</span> dynamicSearchTable&lt;KEY, OTHER&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">node</span>  <span class=\"hljs-comment\">//散列表的结点类</span><br>    &#123;<br>      SET &lt;KEY, OTHER&gt; data;<br>      <span class=\"hljs-type\">int</span> state; <span class=\"hljs-comment\">//0 -- empty 1 -- active 2 -- deleted</span><br>      <span class=\"hljs-built_in\">node</span>()<br>      &#123;<br>        state = <span class=\"hljs-number\">0</span>;<br>      &#125;<br>    &#125;;<br>    node *array;<br><br>    <span class=\"hljs-type\">int</span> size;<br>    <span class=\"hljs-built_in\">int</span> (*key)(<span class=\"hljs-type\">const</span> KEY &amp;x);<span class=\"hljs-comment\">//哈希函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">defaultKey</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> &amp;x)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> x;<br>    &#125;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">closeHashTable</span>(<span class=\"hljs-type\">int</span> length = <span class=\"hljs-number\">101</span>, <span class=\"hljs-built_in\">int</span> (*f)(<span class=\"hljs-type\">const</span> KEY &amp;x) = defaultKey)<br>    ~<span class=\"hljs-built_in\">closeHashTable</span>()<br>    &#123;<br>      <span class=\"hljs-keyword\">delete</span> [] array;<br>    &#125;<br>    <span class=\"hljs-function\">SET&lt;KEY, OTHER&gt; *<span class=\"hljs-title\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x)</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> SET&lt;KEY, OTHER&gt; &amp;x)</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>构造函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br>closeHashTable&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">closeHashTable</span>(<span class=\"hljs-type\">int</span> length, <span class=\"hljs-built_in\">int</span> (*f)(<span class=\"hljs-type\">const</span> KEY &amp;x))<br>&#123;<br>  size = length;<br>  array = <span class=\"hljs-keyword\">new</span> node[size];<br>  key = f; <span class=\"hljs-comment\">//哈希函数为f</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>insert</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> closeHashTable&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-type\">const</span> SET&lt;KEY, OTHER&gt; &amp;x)<br>&#123;<br>  <span class=\"hljs-type\">int</span> initPos, pos ;<br>  initPos= pos = <span class=\"hljs-built_in\">key</span>(x.key) % size; <span class=\"hljs-comment\">//%size保护作用，避免越界</span><br>  <span class=\"hljs-keyword\">do</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (array[pos].state != <span class=\"hljs-number\">1</span>)<br>    &#123; <span class=\"hljs-comment\">// 0或2，找到空单元</span><br>      array[pos].data = x;<br>      array[pos].state = <span class=\"hljs-number\">1</span>;<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    pos = (pos<span class=\"hljs-number\">+1</span>) % size;<br>  &#125; <span class=\"hljs-keyword\">while</span> (pos != initPos);<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>remove</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> closeHashTable&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-type\">const</span> KEY &amp;x)<br>&#123;<br>  <span class=\"hljs-type\">int</span> initPos, pos ;<br>  initPos= pos = <span class=\"hljs-built_in\">key</span>(x) % size;<br>  <span class=\"hljs-keyword\">do</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (array[pos].state == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span>; <span class=\"hljs-comment\">//没找到</span><br>    <span class=\"hljs-keyword\">if</span> (array[pos].state == <span class=\"hljs-number\">1</span> &amp;&amp; array[pos].data.key== x)<span class=\"hljs-comment\">// 找到，删除</span><br>    &#123;<br>      array[pos].state = <span class=\"hljs-number\">2</span>;<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    pos = (pos<span class=\"hljs-number\">+1</span>) % size; <span class=\"hljs-comment\">//没找到，需要往后找</span><br>  &#125; <span class=\"hljs-keyword\">while</span> (pos != initPos);<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>find</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *closeHashTable&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-type\">const</span> KEY &amp;x) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-type\">int</span> initPos, pos ;<br>  initPos = pos = <span class=\"hljs-built_in\">key</span>(x) % size;<br>  <span class=\"hljs-keyword\">do</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (array[pos].state == <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// 没有找到</span><br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (array[pos].state == <span class=\"hljs-number\">1</span> &amp;&amp; array[pos].data.key == x) <span class=\"hljs-comment\">// 找到</span><br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> (SET&lt;KEY,OTHER&gt; *)&amp;array[pos];<br>    &#125;<br>    pos = (pos<span class=\"hljs-number\">+1</span>) % size;<br>  &#125; <span class=\"hljs-keyword\">while</span> (pos != initPos);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"线性探测法\">线性探测法</h6>\n<p>当散列发生冲突时，依次<strong>探测下一个单元</strong>，直到发现一个空单元</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504210826498.png\"\nalt=\"线性探测法\" />\n<figcaption aria-hidden=\"true\">线性探测法</figcaption>\n</figure>\n<h6 id=\"二次探测法\">二次探测法</h6>\n<p>以此向后探测 <span class=\"math inline\">1<sup>2</sup></span>，<span\nclass=\"math inline\">2<sup>2</sup></span>，<span\nclass=\"math inline\">3<sup>2</sup></span>，<span\nclass=\"math inline\">4<sup>2</sup></span>，<span\nclass=\"math inline\">5<sup>2</sup></span>，<span\nclass=\"math inline\">…</span></p>\n<p><strong>定理</strong></p>\n<ul>\n<li>如果采用二次探测法，并且表的大小是一个素数，那么，如果表至少有一半是空的（负载因子\n<span\nclass=\"math inline\"> &lt; 0.5</span>），新的元素总能被插入。并且在插入过程中，没有一个单元被探测两次</li>\n</ul>\n<h6 id=\"再次散列法\">再次散列法</h6>\n<ul>\n<li>采用一个新的散列函数 <span\nclass=\"math inline\"><em>H</em><sub>2</sub>(<em>k</em><em>e</em><em>y</em>)</span></li>\n<li><span\nclass=\"math inline\"><em>H</em><sub>1</sub>(<em>x</em>)</span>，<span\nclass=\"math inline\"><em>H</em><sub>1</sub>(<em>x</em>) + <em>H</em><sub>2</sub>(<em>x</em>)</span>\n，<span\nclass=\"math inline\"><em>H</em><sub>1</sub>(<em>x</em>) + 2<em>H</em><sub>2</sub>(<em>x</em>)</span>，<span\nclass=\"math inline\"><em>H</em><sub>1</sub>(<em>x</em>) + 3<em>H</em><sub>2</sub>(<em>x</em>)</span>，<span\nclass=\"math inline\">…</span></li>\n</ul>\n<h5 id=\"开散列表\">开散列表</h5>\n<p>链地址法</p>\n<ul>\n<li>将具有同一散列地址的结点保存于 <code>M</code>\n存区的各自的链表之中</li>\n</ul>\n<h6 id=\"开散列表的实现\">开散列表的实现</h6>\n<ul>\n<li>将所有散列到同一地址的元素链接成一个单链表</li>\n<li>采用不带头结点的单链表</li>\n<li>散列表保存在一个数组中，每个元素是一个指向对应单链表的首地址的指针</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span> , <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">openHashTable</span>:<span class=\"hljs-keyword\">public</span> dynamicSearchTable&lt;KEU , OTHER&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">node</span><br>    &#123;<br>      SET&lt;KEY , OTHER&gt; data;<br>      node *next;<br>      <span class=\"hljs-built_in\">node</span> (<span class=\"hljs-type\">const</span> SET&lt;KEY , OTHER&gt; &amp;d , nde *n = <span class=\"hljs-literal\">nullptr</span>)<br>      &#123;<br>        data = d;<br>        next = n;<br>      &#125;<br>      <span class=\"hljs-built_in\">node</span>()<br>      &#123;<br>        next = <span class=\"hljs-literal\">nullptr</span>;<br>      &#125;<br>    &#125;;<br>    node **array; <span class=\"hljs-comment\">// 散列表，指针数组</span><br>     <span class=\"hljs-type\">int</span> size;<br>     <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">defaultKry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> &amp;x)</span></span><br><span class=\"hljs-function\">     </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> x;<br>     &#125;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">openHashTable</span>(<span class=\"hljs-type\">int</span> length = <span class=\"hljs-number\">101</span>,<span class=\"hljs-built_in\">int</span> (*f)(<span class=\"hljs-type\">const</span> KEY &amp;x) = defaultKey);<br>    ~<span class=\"hljs-built_in\">openashTable</span>();<br>    <span class=\"hljs-function\">SET&lt;KEY,OTHER&gt; *<span class=\"hljs-title\">finf</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x)</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> SET&lt;KEY,OTHER&gt; &amp;x)</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>构造函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br>openHashTable&lt;KEY, OTHER&gt;::~<span class=\"hljs-built_in\">openHashTable</span>()<br>&#123;<br>  node *p, *q;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i&lt; size; ++i)<br>  &#123;<br>    p = array[i];<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>      q= p-&gt;next; <span class=\"hljs-keyword\">delete</span> p; p = q;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">delete</span> [] array；<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>insert</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> openHashTable&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-type\">const</span> SET&lt;KEY, OTHER&gt; &amp;x)<br>&#123;<br>  <span class=\"hljs-type\">int</span> pos;<br>  node *p;<br>  <span class=\"hljs-comment\">//插入单链表的头部</span><br>  pos = <span class=\"hljs-built_in\">key</span>(x.key) % size;<br>  array[pos] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">node</span>(x, array[pos]);<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>remove</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> openHashTable&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-type\">const</span> KEY &amp;x)<br>&#123;<br>  <span class=\"hljs-type\">int</span> pos ;<br>  node *p, *q;<br>  pos = <span class=\"hljs-built_in\">key</span>(x) % size;<br>  <span class=\"hljs-keyword\">if</span> (array[pos] == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  p = array[pos];<br>  <span class=\"hljs-keyword\">if</span> (array[pos]-&gt;data.key== x)<br>  &#123; <span class=\"hljs-comment\">// 删除第一个结点</span><br>    array[pos] = p-&gt;next;<br>    <span class=\"hljs-keyword\">delete</span> p;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">while</span> (p-&gt;next != <span class=\"hljs-literal\">nullptr</span> &amp;&amp; !(p-&gt;next-&gt;data.key== x))<br>  &#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (p-&gt;next != <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    q = p-&gt;next;<br>    p-&gt;next = q-&gt;next;<br>    <span class=\"hljs-keyword\">delete</span> q;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>find</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *openHashTable&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-type\">const</span> KEY &amp;x) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-type\">int</span> pos ;<br>  node *p;<br>  pos = <span class=\"hljs-built_in\">key</span>(x) % size;<br>  p = array[pos];<br>  <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-literal\">nullptr</span> &amp;&amp; !(p-&gt;data.key == x))<br>  &#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-built_in\">return</span> (SET&lt;KEY, OTHER&gt; *)p;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"排序\">排序</h2>\n<h3 id=\"基本概念-1\">基本概念</h3>\n<ul>\n<li>按照关键字的非递减或非递增序排成一个序列</li>\n<li><strong>稳定与非稳定排序</strong>:关键字值相同的数据元素在排序前后的相对次序保持不变，则称为稳定排序，否则称为不稳定排序</li>\n<li>内排序与外排序\n<ul>\n<li><strong>内排序：</strong>排序的数据元素全部存放在计算机的内存之中，并且在内存中调整数据元素的相对位置</li>\n<li><strong>外排序：</strong>在排序的过程中，数据元素主要存放在外存储器中，借助于内存储器逐步调整数据元素之间的相对位置</li>\n</ul></li>\n</ul>\n<h3 id=\"插入排序\">插入排序</h3>\n<p>首先将由第一个数据元素组成的序列看成是有序的，然后将剩余的 n-1\n个元素依次插入到前面的已排好序的子序列中去，使得每次插入后的子序列也是有序的</p>\n<h4 id=\"直接插入排序\">直接插入排序</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">simpleInsertSort</span><span class=\"hljs-params\">(SET&lt;KEY, OTHER&gt;a[], <span class=\"hljs-type\">int</span> size)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> k;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">1</span>; j&lt;size; ++j)<br>  &#123;<br>  tmp = a[j];<br>  <span class=\"hljs-keyword\">for</span> ( k = j<span class=\"hljs-number\">-1</span>; tmp.key &lt; a[k].key &amp;&amp; k &gt;= <span class=\"hljs-number\">0</span>; --k)<br>  &#123;<br>    a[k<span class=\"hljs-number\">+1</span>] = a[k];<br>  &#125;<br>  a[k<span class=\"hljs-number\">+1</span>] = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>空间复杂度：<span class=\"math inline\"><em>O</em>(1)</span></li>\n<li>稳定性：稳定</li>\n<li>时间复杂度\n<ul>\n<li>最好：<span class=\"math inline\"><em>O</em>(<em>n</em>)</span></li>\n<li>最坏：<span\nclass=\"math inline\"><em>O</em>(<em>n</em><sup>2</sup>)</span></li>\n<li>平均：<span\nclass=\"math inline\"><em>O</em>(<em>n</em><sup>2</sup>)</span></li>\n</ul></li>\n<li>适用情况：短序列或者几乎已经排好序的</li>\n</ul>\n<h4 id=\"折半插入排序\">折半插入排序</h4>\n<p>先用二分排序找到插入位置</p>\n<ul>\n<li>时间复杂度\n<ul>\n<li>最好：<span\nclass=\"math inline\"><em>O</em>(<em>n</em>log <em>n</em>)</span></li>\n<li>最坏：<span\nclass=\"math inline\"><em>O</em>(<em>n</em><sup>2</sup>)</span></li>\n<li>平均：<span\nclass=\"math inline\"><em>O</em>(<em>n</em><sup>2</sup>)</span></li>\n</ul></li>\n<li>空间复杂度：<span class=\"math inline\"><em>O</em>(1)</span></li>\n<li>稳定性：稳定</li>\n</ul>\n<p>改进很小，对于接近排好序的序列甚至<strong>更差</strong></p>\n<h4 id=\"希尔排序\">希尔排序</h4>\n<ul>\n<li>相隔一定的距离的记录组成一个子序列</li>\n<li>逐渐扩大小序列的规模，减小序列的个数，使得待排序列处于更有序的状态</li>\n<li>最后再用直接插入排序对整个序列进行一次排序</li>\n</ul>\n<h5 id=\"步长序列的选择\">步长序列的选择</h5>\n<ul>\n<li><p><span class=\"math inline\">1, 2, 4, 8, …</span></p></li>\n<li><p>时间复杂度：<span\nclass=\"math inline\"><em>O</em>(<em>n</em><sup>2</sup>)</span></p></li>\n<li><p>Knuth 推荐：<span\nclass=\"math inline\">1, 3, 7, 15, 31, 63, …</span></p></li>\n<li><p>时间复杂度：<span\nclass=\"math inline\"><em>O</em>(<em>n</em><sup>1.5</sup>)</span></p></li>\n<li><p>空间复杂度：<span\nclass=\"math inline\"><em>O</em>(1)</span></p></li>\n<li><p>不稳定</p></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">shellSort</span><span class=\"hljs-params\">(SET&lt;KEY, OTHER&gt; a[], <span class=\"hljs-type\">int</span> size)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> step, i, j;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class=\"hljs-keyword\">for</span> (step = size/<span class=\"hljs-number\">2</span>; step &gt; <span class=\"hljs-number\">0</span>; step /= <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">//step为希尔增量</span><br>  &#123;<br>    <span class=\"hljs-keyword\">for</span> (i = step; i &lt; size; ++i)<br>    &#123;<br>      tmp = a[i];<br>      <span class=\"hljs-keyword\">for</span> (j = i -step; j &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; a[j].key &gt; tmp.key; j -= step)<br>      &#123;<br>        a[j+step] = a[j];<br>      &#125;<br>      a[j+step] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"选择排序\">选择排序</h3>\n<ol type=\"1\">\n<li>在 <span class=\"math inline\"><em>n</em></span>\n个元素中选出最小的元素</li>\n<li>从剩下的 <span class=\"math inline\"><em>n</em> − 1</span>\n个元素中选出最小的元素</li>\n<li>以此类推，直到最后一个元素</li>\n</ol>\n<h4 id=\"直接选择排序\">直接选择排序</h4>\n<ol type=\"1\">\n<li>在所有元素中逐个比较找到最小元素，与第一个元素交换</li>\n<li>在剩下的元素中逐个比较找到最小元素，与第二个元素交换</li>\n<li>以此类推，直到最后一个元素</li>\n</ol>\n<ul>\n<li>时间复杂度：<span\nclass=\"math inline\"><em>O</em>(<em>n</em><sup>2</sup>)</span></li>\n<li>空间复杂度：<span class=\"math inline\"><em>O</em>(1)</span></li>\n<li>不稳定</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">simpleSelectSort</span><span class=\"hljs-params\">(SET&lt;KEY, OTHER&gt; a[], <span class=\"hljs-type\">int</span> size)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> i, j, min;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; size <span class=\"hljs-number\">-1</span>; ++i)<br>  &#123;<br>  min = i;<br>  <span class=\"hljs-keyword\">for</span> (j = i<span class=\"hljs-number\">+1</span>; j &lt; size; ++j)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (a[j].key &lt; a[min].key)<br>    &#123;<br>      min = j;<br>    &#125;<br>  &#125;<br>  tmp = a[i]; a[i] = a[min]; a[min] = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"堆排序\">堆排序</h4>\n<ol type=\"1\">\n<li>建立一个最大堆</li>\n<li>执行 <span class=\"math inline\"><em>n</em></span> 次\n<code>deQuqeue</code> 操作取出每个项</li>\n</ol>\n<ul>\n<li><p>时间复杂度 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>log <em>n</em>)</span></p></li>\n<li><p>堆排序</p></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">heapSort</span><span class=\"hljs-params\">(SET&lt;KEY, OTHER&gt; a[], <span class=\"hljs-type\">int</span> size)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> i;<br>  SET&lt;KEY, OTHER&gt; tmp; <span class=\"hljs-comment\">// 创建初始的堆</span><br>  <span class=\"hljs-keyword\">for</span>( i = size / <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">-1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--)<br>  &#123;<br>    <span class=\"hljs-built_in\">percolateDown</span>( a, i, size );<br>  &#125;<br>  <span class=\"hljs-comment\">//执行n-1次deQueue</span><br>  <span class=\"hljs-keyword\">for</span> ( i = size <span class=\"hljs-number\">-1</span>; i &gt; <span class=\"hljs-number\">0</span>; --i)\\<br>  &#123;<br>  tmp = a[<span class=\"hljs-number\">0</span>]; a[<span class=\"hljs-number\">0</span>] = a[i]; a[i] = tmp; <span class=\"hljs-comment\">//delete a[0]</span><br>  <span class=\"hljs-built_in\">percolateDown</span>( a, <span class=\"hljs-number\">0</span>, i );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>precolateDown</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">percolateDown</span><span class=\"hljs-params\">( SET&lt;KEY, OTHER&gt; a[], <span class=\"hljs-type\">int</span> hole, <span class=\"hljs-type\">int</span> size)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> child;<br>  SET&lt;KEY, OTHER&gt; tmp= a[ hole ];<br>  <span class=\"hljs-keyword\">for</span>( ; hole * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span> &lt; size; hole = child )<br>  &#123;<br>    child = hole * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">if</span>( child != size <span class=\"hljs-number\">-1</span> &amp;&amp; a[ child + <span class=\"hljs-number\">1</span> ].key &gt; a[ child ].key )<br>    &#123;<br>      child++;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>( a[ child ].key &gt;tmp.key)<br>    &#123;<br>      a[ hole ] = a[ child ];<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>  &#125;<br>  a[ hole ] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"交换排序\">交换排序</h3>\n<p>通过交换，将关键字值较大的数据元素向序列的尾部移动，关键字值较小的数据元素向序列的头部移动</p>\n<h4 id=\"冒泡排序\">冒泡排序</h4>\n<p>从头到尾比较相邻的两个元素，将小的换到前面，大的换到后面。经过了从头到尾的一趟比较，就把最大的元素交换到了最后一个位置。这个过程称为一趟起泡</p>\n<p>然后再从头开始到倒数第二个元素进行第二趟起泡。经过了第二趟比较，又将第二大的元素放到了倒数第二个位置</p>\n<p>依次类推，经过第 <span class=\"math inline\"><em>n</em> − 1</span>\n趟起泡，将倒数第 <span class=\"math inline\"><em>n</em> − 1</span>\n个大的元素放入第 2 个单元</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">bubbleSort</span><span class=\"hljs-params\">(SET&lt;KEY, OTHER&gt; a[], <span class=\"hljs-type\">int</span> size)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> i, j;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class=\"hljs-type\">bool</span> flag = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">//记录一趟起泡中有没有发生过交换</span><br>  <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">1</span>; i &lt; size&amp;&amp; flag; ++i)<br>  &#123; <span class=\"hljs-comment\">//size-1次起泡</span><br>    flag = <span class=\"hljs-literal\">false</span>;<br>    <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; size-i; ++j) <span class=\"hljs-comment\">//第i次起泡</span><br>    <span class=\"hljs-keyword\">if</span> (a[j<span class=\"hljs-number\">+1</span>].key &lt; a[j].key)<br>    &#123;<br>      tmp = a[j]; a[j] = a[j<span class=\"hljs-number\">+1</span>]; a[j<span class=\"hljs-number\">+1</span>] = tmp;<br>      flag = <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"快速排序\">快速排序</h4>\n<ul>\n<li>选择一个基准元素，将比基准元素小的元素放在左边，比基准元素大的元素放在右边</li>\n<li>然后对基准元素左边和右边的子序列进行递归排序</li>\n</ul>\n<h5 id=\"选择中心点\">选择中心点</h5>\n<ul>\n<li>第一个元素</li>\n<li>随机</li>\n<li>中值（采样得到）</li>\n</ul>\n<h5 id=\"划分第一个元素为中心点\">划分（第一个元素为中心点）</h5>\n<ol type=\"1\">\n<li>序列的下标上界为 <code>high</code>，下届为\n<code>low</code>，中心点选取第一个元素，关键值为\n<code>K</code>，<code>low</code> 位置空出</li>\n<li>从右向左开始检查：如果 <code>high</code> 的关键值大于\n<code>K</code>，该位置中的值位置正确，<code>high</code> 减 <span\nclass=\"math inline\">1</span>，继续往前检查，直到遇到一个小于\n<code>K</code> 的值</li>\n<li>将小于 <code>k</code> 的这个值放入 <code>low</code> 的位置，此时\n<code>high</code> 的位置又空出。然后从 <code>low</code>\n位置开始从左向右检查，直到遇到一个大于 <code>K</code> 的值</li>\n<li>将 <code>low</code> 位置的值放入 <code>high</code> 位置，重复第 2\n步，直到 <code>low</code> 和 <code>high</code> 重叠，将 <code>K</code>\n放入此位置</li>\n</ol>\n<p>划分函数的实现</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">divide</span><span class=\"hljs-params\">( SET&lt;KEY, OTHER&gt; a[], <span class=\"hljs-type\">int</span> low, <span class=\"hljs-type\">int</span> high)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  SET&lt;KEY, OTHER&gt; k = a[low];<br>  <span class=\"hljs-keyword\">do</span><br>  &#123;<br>    <span class=\"hljs-keyword\">while</span> (low &lt; high &amp;&amp; a[high].key &gt;= k.key)<br>    &#123;<br>      --high;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (low &lt; high)<br>    &#123;<br>      a[low] = a[high]; ++low;<br>    &#125;<br>    <span class=\"hljs-keyword\">while</span> (low &lt; high &amp;&amp; a[low].key &lt;= k.key)<br>    &#123;<br>      ++low;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (low &lt; high)<br>    &#123;<br>      a[high] = a[low]; --high;<br>    &#125;<br>  &#125; <span class=\"hljs-keyword\">while</span> (low != high);<br>  a[low] = k;<br>  <span class=\"hljs-keyword\">return</span> low;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"归并排序\">归并排序</h3>\n<ul>\n<li>将待排序的序列分成两个子序列，分别进行排序</li>\n<li>将两个有序的子序列合并成一个有序的序列</li>\n<li>递归进行</li>\n</ul>\n<h3 id=\"基数排序\">基数排序</h3>\n<ul>\n<li>称为口袋排序法</li>\n<li>通过分配的方法进行排序</li>\n<li>基数（r）：子关键字的值域的元素的个数\n<ul>\n<li>十进制数：<span class=\"math inline\">0, 1, 2, …, 9</span>，基数为\n<span class=\"math inline\">10</span></li>\n<li>二进制数：<span class=\"math inline\">0, 1</span>，基数为 <span\nclass=\"math inline\">2</span></li>\n<li>英文字符：<span\nclass=\"math inline\"><em>A</em>, <em>B</em>, <em>C</em>, …, <em>Z</em></span>，基数为\n<span class=\"math inline\">26</span></li>\n</ul></li>\n</ul>\n<h4 id=\"高位优先法msd\">高位优先法（MSD）</h4>\n<ul>\n<li>先将高位进入口袋中你进行排序，再将低位放入口袋中进入排序，最终将最小的口袋依次链接在一起形成有序序列</li>\n</ul>\n<h4 id=\"低位优先法lsd\">低位优先法（LSD）</h4>\n<ul>\n<li>先将最低为进入口袋进行排序，再将所有记录按照口袋的顺序收在一起</li>\n<li>然后将次低位进入口袋进行排序，依次类推</li>\n<li>最后将所有记录按照口袋的顺序收在一起</li>\n</ul>\n<h2 id=\"外存储器中的查找和排序\">外存储器中的查找和排序</h2>\n<h3 id=\"主存储器与外存储器\">主存储器与外存储器</h3>\n<ul>\n<li>主存储器：计算机的内存，用于存储正在运行的程序代码以及处理数据</li>\n<li>外存储器：计算机的硬盘、光盘、磁带等，用于长期存储数据和程序，用于存储长期保存的信息\n<ul>\n<li>价格低廉、存储量大、永久保存、<strong>访问速度慢</strong></li>\n</ul></li>\n</ul>\n<h3 id=\"外部查找\">外部查找</h3>\n<h4 id=\"b-树\">B 树</h4>\n<p>B 树是一棵平衡的 M 叉查找树，需要 <span\nclass=\"math inline\"><em>M</em> − 1</span>\n个关键字来判断到哪个分支查找</p>\n<h5 id=\"b-树的定义\">B 树的定义</h5>\n<ul>\n<li>一棵 <span class=\"math inline\"><em>m</em></span> 阶 B\n树要么为空，要么满足一下条件\n<ul>\n<li>根节点要么是叶节点，要么至少有两个儿子，至多有 <span\nclass=\"math inline\"><em>m</em></span> 个儿子</li>\n<li>每个非根节点至少有 <span class=\"math inline\">⌈<em>m</em>/2⌉</span>\n个儿子，至多有 <span class=\"math inline\"><em>m</em></span> 个儿子</li>\n<li>有 <span class=\"math inline\"><em>s</em></span> 个儿子的非叶节点具有\n<span class=\"math inline\"><em>n</em> = <em>s</em> − 1</span>\n个关键字</li>\n<li>所有的叶子节点都出现在同一层上</li>\n</ul></li>\n</ul>\n<h5 id=\"b-树的插入\">B 树的插入</h5>\n<ul>\n<li>在最底层进行插入</li>\n</ul>\n<ol type=\"1\">\n<li>在 <span class=\"math inline\"><em>m</em></span> 阶 B\n树上进行查找操作，确定新插入的关键字 <code>key</code>\n在最底层非叶节点的插入位置</li>\n<li>如果被插入节点的关键字个数小于等于 <span\nclass=\"math inline\"><em>m</em> − 1</span>，则插入结束</li>\n<li>如果被插入节点的关键字个数大于 <span\nclass=\"math inline\"><em>m</em> − 1</span>，则需要进行分裂</li>\n</ol>\n<ul>\n<li>被插入节点分为三个部分\n<ul>\n<li>前半部分：前 <span class=\"math inline\"><em>m</em>/2</span>\n个关键字</li>\n<li>中间部分：中间的关键字</li>\n<li>后半部分：后 <span class=\"math inline\"><em>m</em>/2</span>\n个关键字</li>\n</ul></li>\n<li>中间部分的关键字上升到父节点</li>\n<li>前后半部分生成新的两个节点</li>\n</ul>\n<h5 id=\"b-树的删除\">B 树的删除</h5>\n<ul>\n<li>采用替身法，替身为右子树的最小值或者左子树的最大值</li>\n</ul>\n<ol type=\"1\">\n<li>删除节点，替身进入</li>\n<li>如果删除后的替身原来在的节点满足，则直接删除</li>\n<li>如果删除后的关键字小于下限，\n<ul>\n<li>向该节点的左或右兄弟借一个关键字</li>\n<li>如果兄弟节点的关键字个数等于下限，则需要进行合并</li>\n</ul></li>\n</ol>\n<h5 id=\"m-的选择\">M 的选择</h5>\n<h4 id=\"b树\">B+树</h4>\n<p>B+树是既能提供随机查找，也能提供顺序访问的存储结构</p>\n<h5 id=\"b树的定义\">B+树的定义</h5>\n<ul>\n<li>所有数据都记录在叶节点中，所有叶节点连成一个单链表</li>\n<li>非叶节点至多保存 <span class=\"math inline\"><em>m</em> − 1</span>\n个关键字来引导查找，键 <span class=\"math inline\"><em>i</em></span>\n表示子树 <span class=\"math inline\"><em>i</em> + 1</span>\n中键的最小值</li>\n<li>根节点或者是叶节点，或者有 <span class=\"math inline\">2</span> 到\n<span class=\"math inline\"><em>m</em></span> 个子树</li>\n<li>除了根节点之外的所有非叶节点至少有 <span\nclass=\"math inline\"><em>m</em>/2</span> 个儿子，最多有 <span\nclass=\"math inline\"><em>m</em></span> 个儿子</li>\n<li>所有的叶节点都在同一层上，并且每个叶子有 <span\nclass=\"math inline\">⌈<em>L</em>/2⌉</span> 到 <span\nclass=\"math inline\"><em>L</em></span> 个关键字</li>\n</ul>\n<h5 id=\"b树的插入\">B+树的插入</h5>\n<ul>\n<li>叶结点不满：把新结点插入叶子，重新调整该叶子中数据的顺序</li>\n<li>叶子已经装满 ：通过分裂该叶子，形成两个半满的叶子来插入一个新的项\n<ul>\n<li>更新父结点</li>\n<li>如果父亲的儿子数量已经满了，就继续分裂父亲</li>\n</ul></li>\n</ul>\n<h3 id=\"外排序\">外排序</h3>\n<p>一次外存操作所需的时间可以执行数百条甚至上千条指令，因此在外排序中主要考虑的是如何减少外存储器的读写（I/O\n操作）</p>\n<h4 id=\"外排序模型\">外排序模型</h4>\n<ul>\n<li>外排序由两个阶段组成\n<ol type=\"1\">\n<li>预处理阶段：根据内存的大小将一个有 n\n个记录的文件分批读入内存，用各种内排序算法排序，形成一个个有序片段</li>\n<li>归并阶段：将这些有序片段逐步归并成一个有序文件</li>\n</ol></li>\n</ul>\n<p>减少 I/O 操作的关键</p>\n<ol type=\"1\">\n<li>减少归并轮数</li>\n<li>减少有序片段数量</li>\n<li>增加合并路数</li>\n</ol>\n<h4 id=\"预处理\">预处理</h4>\n<h5 id=\"减少有序片段数量\">减少有序片段数量</h5>\n<ul>\n<li>每次读入的记录数越多，形成的初始的已排序的片段越少，归并的次数也越少</li>\n<li>最简单的方法是按照内存的容量尽可能多地读入数据记录，然后再内存中进行排序，排序地结果写入文件，形成一个已排序片段</li>\n</ul>\n<h5 id=\"置换排序\">置换排序</h5>\n<p>置换选择可以在只能容纳 <span class=\"math inline\"><em>p</em></span>\n个记录的内存中生成平均长度为 <span\nclass=\"math inline\">2<em>p</em></span> 的初始的已排序片段</p>\n<p>只要前面的元素被写到文件上，它所用的内存空间就可以给别的元素使用。如果输入文件中的下一个元素比刚刚输出的元素大，它能被放入这个已排序片段</p>\n<p>具体方法</p>\n<ol type=\"1\">\n<li>初始时，将 <span class=\"math inline\"><em>m</em></span>\n个元素读入内存，用 <code>buildHeap</code> 建立一个优先级队列</li>\n<li>执行一次 <code>deQuqeue</code>，将最小的元素写入输出文件</li>\n<li>从输入磁带读入下一个元素\n<ul>\n<li>如果它比刚才写进去的元素大，那么将它加入到优先级队列中</li>\n<li>否则，则无法写入队列，进行下一次 <code>deQuqeue</code></li>\n</ul></li>\n<li>重复第 2、3 步，直到输入文件读完</li>\n<li>重新执行 <code>buildHeap</code>，使用存放在空余位置中的元素</li>\n</ol>\n<h4 id=\"归并\">归并</h4>\n<h5 id=\"二路归并\">二路归并</h5>\n<ul>\n<li>归并时，每次将两个有序文件归并为一个有序文件</li>\n<li>如果生成的有序片段数量为 <span\nclass=\"math inline\"><em>M</em></span>，则归并次数为 <span\nclass=\"math inline\">⌈log<sub>2</sub><em>M</em>⌉</span></li>\n</ul>\n<h5 id=\"多路归并\">多路归并</h5>\n<ul>\n<li>归并时，每次将 <span class=\"math inline\"><em>k</em></span>\n个有序文件归并为一个有序文件</li>\n<li>优点：减少归并次数，为 <span\nclass=\"math inline\">⌈log<sub><em>k</em></sub><em>M</em>⌉</span> 次</li>\n<li>缺点：寻找最小元素的操作复杂，通常可以将每个文件的第一个记录组成一个优先级队列</li>\n</ul>\n<h5 id=\"多阶段归并\">多阶段归并</h5>\n<ul>\n<li>可以仅使用 <span class=\"math inline\"><em>K</em> + 1</span>\n条磁带实现 <span class=\"math inline\"><em>K</em></span>\n路归并，称为<strong>多阶段归并</strong></li>\n</ul>\n<p><strong>实现的过程</strong></p>\n<ol type=\"1\">\n<li>按照非均匀的方法分解原来的已排序的片段</li>\n<li>将每个片段分成 <span class=\"math inline\"><em>K</em></span>\n个子片段</li>\n</ol>\n<h2 id=\"图\">图</h2>\n<h3 id=\"图的定义\">图的定义</h3>\n<ul>\n<li>图可以用 <span\nclass=\"math inline\"><em>G</em> = (<em>V</em>, <em>E</em>)</span>\n表示。其中，<span class=\"math inline\"><em>V</em></span> 是顶点集，<span\nclass=\"math inline\"><em>E</em></span> 是边集。</li>\n<li>如果边是有方向的，称为<strong>有向图</strong>.有向图的边用 <span\nclass=\"math inline\">⟨⟩</span> 表示\n<ul>\n<li><span class=\"math inline\">⟨<em>A</em>, <em>B</em>⟩</span> 表示从\n<span class=\"math inline\"><em>A</em></span> 到 <span\nclass=\"math inline\"><em>B</em></span> 的一条边</li>\n</ul></li>\n<li>如果边是无方向的，称为<strong>无向图</strong>.无向图的边用 <span\nclass=\"math inline\">()</span> 表示\n<ul>\n<li><span class=\"math inline\">(<em>A</em>, <em>B</em>)</span> 表示 <span\nclass=\"math inline\"><em>A</em></span> 和 <span\nclass=\"math inline\"><em>B</em></span> 之间有一条边</li>\n<li>无向图也称为双向图</li>\n</ul></li>\n<li><strong>加权图：</strong>\n边被赋予一个权值的图称为加权图.如果图是有向的，称为加权有向图，如果是无向的，称为加权无向图\n<ul>\n<li>加权图中边的表示：<span\nclass=\"math inline\">(<em>V</em><sub><em>i</em></sub>, <em>V</em><sub><em>j</em></sub>, <em>W</em>)</span></li>\n</ul></li>\n</ul>\n<h3 id=\"图的基本术语\">图的基本术语</h3>\n<ul>\n<li>邻接\n<ul>\n<li>若 <span\nclass=\"math inline\">(<em>V</em><sub><em>i</em></sub>, <em>V</em><sub><em>j</em></sub>)</span>\n是图 <span class=\"math inline\"><em>G</em></span> 的一条边，则称 <span\nclass=\"math inline\"><em>V</em><sub><em>i</em></sub></span> 和 <span\nclass=\"math inline\"><em>V</em><sub><em>j</em></sub></span> 是邻接的；若\n<span\nclass=\"math inline\">⟨<em>V</em><sub><em>i</em></sub>, <em>V</em><sub><em>j</em></sub>⟩</span>\n是图 <span class=\"math inline\"><em>G</em></span> 的一条边，则称 <span\nclass=\"math inline\"><em>V</em><sub><em>i</em></sub></span> 邻接到 <span\nclass=\"math inline\"><em>V</em><sub><em>j</em></sub></span>，<span\nclass=\"math inline\"><em>V</em><sub><em>j</em></sub></span> 和 <span\nclass=\"math inline\"><em>V</em><sub><em>i</em></sub></span> 邻接</li>\n</ul></li>\n<li>度 无向图中邻接与某一顶点的边的总数</li>\n<li>入度 有向图中进入某一顶点的边数</li>\n<li>出度 有向图中离开某一顶点的边数</li>\n<li>边与度的关系 <span class=\"math inline\">$\\displaystyle\ne=\\frac{1}{2}\\sum_{i=1}^n d_i$</span>，其中 <span\nclass=\"math inline\"><em>e</em></span> 是边数，<span\nclass=\"math inline\"><em>d</em><sub><em>i</em></sub></span> 是顶点 <span\nclass=\"math inline\"><em>V</em><sub><em>i</em></sub></span> 的度</li>\n</ul>\n<h4 id=\"子图\">子图</h4>\n<p>设有两个图 <span\nclass=\"math inline\"><em>G</em><sub>1</sub> = (<em>V</em><sub>1</sub>, <em>E</em><sub>1</sub>)</span>\n和 <span\nclass=\"math inline\"><em>G</em><sub>2</sub> = (<em>V</em><sub>2</sub>, <em>E</em><sub>2</sub>)</span>，如果\n<span\nclass=\"math inline\"><em>V</em><sub>1</sub> ⊆ <em>V</em><sub>2</sub></span>，<span\nclass=\"math inline\"><em>E</em><sub>1</sub> ⊆ <em>E</em><sub>2</sub></span>，则称\n<span class=\"math inline\"><em>G</em><sub>1</sub></span> 是 <span\nclass=\"math inline\"><em>G</em><sub>2</sub></span> 的子图</p>\n<h4 id=\"路径和路径长度\">路径和路径长度</h4>\n<ul>\n<li>对于 <span\nclass=\"math inline\">1 &lt; <em>i</em> &lt; <em>N</em></span>，顶点序列\n<span\nclass=\"math inline\"><em>w</em><sub>1</sub>, <em>w</em><sub>2</sub>, …, <em>w</em><sub><em>N</em></sub></span>\n中的顶点对 <span\nclass=\"math inline\">(<em>w</em><sub><em>i</em></sub>, <em>w</em><sub><em>i</em> + 1</sub>)</span>\n都有 <span\nclass=\"math inline\">(<em>W</em><sub><em>i</em></sub>, <em>w</em><sub><em>i</em> + 1</sub>) ∈ <em>E</em></span>\n或 <span\nclass=\"math inline\">⟨<em>w</em><sub><em>i</em></sub>, <em>w</em><sub><em>i</em> + 1</sub>⟩ ∈ <em>E</em></span>，则称\n<span\nclass=\"math inline\"><em>w</em><sub>1</sub>, <em>w</em><sub>2</sub>, …, <em>w</em><sub><em>N</em></sub></span>\n是图中的一条<strong>路径</strong></li>\n<li><strong>非加权的路径长度</strong>就是组成路径的边数，对于路径 <span\nclass=\"math inline\"><em>w</em><sub>1</sub>, <em>w</em><sub>2</sub>, …, <em>w</em><sub><em>N</em></sub></span>，路径长度为\n<span class=\"math inline\"><em>N</em> − 1</span></li>\n<li><strong>加权的路径长度</strong>是指路径上所有边的权值之和</li>\n<li><strong>简单路径和环：</strong>\n如果一条路径上所有顶点，除了起始顶点和终止顶点可能相同外，其余的顶点都不相同，则称其为简单路径。一个回路或环是一条简单路径，其起始顶点和终止顶点相同，且路径长度至少为\n<span class=\"math inline\">1</span></li>\n</ul>\n<h4 id=\"无向图的连通性\">无向图的连通性</h4>\n<ul>\n<li><strong>连通：</strong> 顶点 <span\nclass=\"math inline\"><em>V</em></span> 和顶点 <span\nclass=\"math inline\"><em>V</em><sup>′</sup></span> 之间又路径存在</li>\n<li><strong>连通图：</strong> 无向图 G 的任意两点之间都是连通的</li>\n<li><strong>连通分量：</strong> 非连通图中的极大连通子图</li>\n</ul>\n<h4 id=\"有向图的连通性\">有向图的连通性</h4>\n<ul>\n<li><strong>强连通图：</strong> 有向图 G 的任意两点之间都是连通的，则称\nG 是强连通图</li>\n<li><strong>强连通分量：</strong> 极大连通子图</li>\n<li><strong>弱连通图：</strong> 如有向图 G\n不是强连通的，但是如果把它看作是无向图时则是连通的，则称该图是弱连通的</li>\n</ul>\n<h4 id=\"完全图\">完全图</h4>\n<ul>\n<li><strong>完全图：</strong>\n每两个顶点之间都有边的无向图称为完全图。完全图有 <span\nclass=\"math inline\">$\\frac{n(n-1)}{2}$</span> 条边，即 <span\nclass=\"math inline\"><em>C</em><sub><em>n</em></sub><sup>2</sup></span></li>\n<li><strong>有向完全图：</strong>\n每两个顶点之间都有两条边的有向图称为有向完全图。有向完全图有 <span\nclass=\"math inline\"><em>n</em>(<em>n</em> − 1)</span> 条边，即 <span\nclass=\"math inline\"><em>P</em><sub><em>n</em></sub><sup>2</sup></span></li>\n<li><strong>有向无环图：</strong> 不含环的有向图</li>\n</ul>\n<h4 id=\"生成树与最小生成树\">生成树与最小生成树</h4>\n<ul>\n<li><strong>生成树</strong>是图 G 的<strong>极小</strong>连通子图\nG’，其中 <span\nclass=\"math inline\"><em>V</em>(<em>G</em><sup>′</sup>) = <em>V</em>(<em>G</em>)</span></li>\n<li>用一棵树把图 G 的所有顶点都连起来，并且没有回路</li>\n<li>生成树有 <span class=\"math inline\"><em>n</em></span> 个顶点，<span\nclass=\"math inline\"><em>n</em> − 1</span> 条边</li>\n<li>生成树可以有多个</li>\n<li><strong>最小生成树</strong>是所有生成树中权值之和最小的生成树</li>\n</ul>\n<h3 id=\"图的运算\">图的运算</h3>\n<ul>\n<li>常规操作\n<ul>\n<li>构造一个由若干个顶点、若干条边组成的图</li>\n<li>判断两个顶点之间是否有边存在</li>\n<li>在图中添加或删除一条边</li>\n<li>返回图中的顶点数或边数</li>\n<li>按某种规则<strong>遍历</strong>图中的所有顶点</li>\n</ul></li>\n<li>和应用紧密结合的运算\n<ul>\n<li>拓扑排序和关键路径</li>\n<li>找最小生成树</li>\n<li>找最短路径等</li>\n</ul></li>\n</ul>\n<h3 id=\"图的抽象类\">图的抽象类</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TypeOfVer</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TypeOfEdge</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">graph</span><br>&#123;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(TypeOfVer x, TypeOfVer y, TypeOfEdge w)</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(TypeOfVer x, TypeOfVer y)</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">exist</span><span class=\"hljs-params\">(TypeOfVer x, TypeOfVer y)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">numOfVer</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> Vers;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">numOfEdge</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> Edges;<br>    &#125;<br> <br>  <span class=\"hljs-keyword\">protected</span>:<br>    <span class=\"hljs-type\">int</span> Vers, Edges;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"图的存储\">图的存储</h3>\n<h4 id=\"邻接矩阵和加权邻接矩阵\">邻接矩阵和加权邻接矩阵</h4>\n<h5 id=\"有向图的邻接矩阵\">有向图的邻接矩阵</h5>\n<p>设有向图有 <span class=\"math inline\"><em>n</em></span>\n个顶点，则用一个 <span\nclass=\"math inline\"><em>n</em> × <em>n</em></span> 的布尔矩阵 <span\nclass=\"math inline\"><em>A</em></span> 来表示该有向图</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505212328867.png\"\nalt=\"有向图的邻接矩阵\" />\n<figcaption aria-hidden=\"true\">有向图的邻接矩阵</figcaption>\n</figure>\n<ul>\n<li>分别使用 <span class=\"math inline\">0, 1, 2, …, <em>n</em> − 1</span>\n表示 顶点 <span\nclass=\"math inline\"><em>V</em><sub>0</sub>, <em>V</em><sub>1</sub>, …, <em>V</em><sub><em>n</em> − 1</sub></span>，如果存在一条从\n<span class=\"math inline\"><em>V</em><sub><em>i</em></sub></span> 到\n<span class=\"math inline\"><em>V</em><sub><em>j</em></sub></span>\n的边，则 <span\nclass=\"math inline\"><em>A</em>[<em>i</em>][<em>j</em>] = 1</span>，否则\n<span\nclass=\"math inline\"><em>A</em>[<em>i</em>][<em>j</em>] = 0</span></li>\n<li>出度：<span class=\"math inline\"><em>i</em></span> 行之和</li>\n<li>入度：<span class=\"math inline\"><em>j</em></span> 列之和</li>\n<li>真正的顶点数据字段之值放入一个一维数组之中</li>\n</ul>\n<h5 id=\"无向图的邻接矩阵\">无向图的邻接矩阵</h5>\n<p>设无向图有 <span class=\"math inline\"><em>n</em></span>\n个顶点，则用一个 <span\nclass=\"math inline\"><em>n</em> × <em>n</em></span> 的布尔矩阵 <span\nclass=\"math inline\"><em>A</em></span> 来表示该无向图</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505212332916.png\"\nalt=\"无向图的邻接矩阵\" />\n<figcaption aria-hidden=\"true\">无向图的邻接矩阵</figcaption>\n</figure>\n<ul>\n<li>分别使用 <span class=\"math inline\">0, 1, 2, …, <em>n</em> − 1</span>\n表示 顶点 <span\nclass=\"math inline\"><em>V</em><sub>0</sub>, <em>V</em><sub>1</sub>, …, <em>V</em><sub><em>n</em> − 1</sub></span>，如果存在一条从\n<span class=\"math inline\"><em>V</em><sub><em>i</em></sub></span> 到\n<span class=\"math inline\"><em>V</em><sub><em>j</em></sub></span>\n的边，则 <span\nclass=\"math inline\"><em>A</em>[<em>i</em>][<em>j</em>] = <em>A</em>[<em>j</em>][<em>i</em>] = 1</span>，否则\n<span\nclass=\"math inline\"><em>A</em>[<em>i</em>][<em>j</em>] = <em>A</em>[<em>j</em>][<em>i</em>] = 0</span></li>\n<li>顶点 <span class=\"math inline\"><em>i</em></span> 的度：第 <span\nclass=\"math inline\"><em>i</em></span> 行或第 <span\nclass=\"math inline\"><em>i</em></span> 列之和</li>\n<li>无向图的邻接矩阵是一个三角对称矩阵</li>\n</ul>\n<h5 id=\"邻接矩阵的特点\">邻接矩阵的特点</h5>\n<ul>\n<li>优点：判断任意两点之间是否有边方便，仅耗费 <span\nclass=\"math inline\"><em>O</em>(1)</span> 时间</li>\n<li>缺点：即使 <span\nclass=\"math inline\"> ≪ <em>n</em><sub>2</sub></span> 条边，也需内存\n<span class=\"math inline\"><em>n</em><sub>2</sub></span> 单元，太多;\n仅读入数据耗费 <span\nclass=\"math inline\"><em>O</em>(<em>n</em><sub>2</sub>)</span>\n时间，太长。而大多数的图的边数远远小于 <span\nclass=\"math inline\"><em>n</em><sub>2</sub></span>。<strong>适合稠密网</strong></li>\n<li>不适合增减顶点</li>\n</ul>\n<h4 id=\"邻接表\">邻接表</h4>\n<ul>\n<li><p>设有向图或者无向图由 <span class=\"math inline\"><em>n</em></span>\n个顶点，则用<strong>顶点表</strong>和<strong>边表</strong>来表示该有向图或无向图</p></li>\n<li><p><strong>顶点表：</strong> 用数组或单链表的形式存放所有的顶点</p>\n<ul>\n<li>如果顶点数 <span class=\"math inline\"><em>n</em></span>\n已知，则采用数组</li>\n<li>如果顶点数未知，则采用单链表</li>\n<li>每个元素包含两个部分\n<ul>\n<li>顶点值</li>\n<li>指向该顶点对应的边表的首地址</li>\n</ul></li>\n</ul></li>\n<li><p><strong>边表：</strong> 每条边用一个节点进行表示</p>\n<p>同一个顶点出发的所有的边形成它的边界点单链表</p></li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505222230615.png\"\nalt=\"邻接表\" />\n<figcaption aria-hidden=\"true\">邻接表</figcaption>\n</figure>\n<h4 id=\"邻接表的特点\">邻接表的特点</h4>\n<ul>\n<li>邻接表是图的<strong>标准</strong>存储方式</li>\n<li>优点\n<ul>\n<li><span class=\"math inline\">内存 = 顶点数 + 边数</span>，时间复杂度为\n<span\nclass=\"math inline\"><em>O</em>(|<em>V</em>|+|<em>E</em>|)</span>，<strong>适合稀疏网</strong></li>\n</ul></li>\n<li>当谈及图的线性算法时，一般指的是 <span\nclass=\"math inline\"><em>O</em>(|<em>V</em>|+|<em>E</em>|)</span></li>\n<li>缺点\n<ul>\n<li>确定 <span class=\"math inline\"><em>i</em> → <em>j</em></span>\n是否有边，最坏需耗费 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>)</span> 时间</li>\n<li>无向图同一条边表示两次。边表空间浪费一倍</li>\n<li>有向图中寻找进入某结点的边，非常困难（逆邻接表）</li>\n</ul></li>\n</ul>\n<h3 id=\"图的遍历\">图的遍历</h3>\n<p>按照某种次序系统地访问图中的所有顶点，并且使得<strong>每个顶点需且只能被访问一次</strong></p>\n<p>需对访问过的顶点加以<strong>标记</strong></p>\n<h4 id=\"深度优先搜索\">深度优先搜索</h4>\n<ol type=\"1\">\n<li>选中第一个被访问的顶点</li>\n<li>对顶点作已访问过的标志</li>\n<li>依次从顶点的未被访问过的第一个、第二个、第三个……邻接顶点出发，进行深度优先搜索</li>\n</ol>\n<p>出现了问题</p>\n<h5 id=\"存在的问题\">存在的问题</h5>\n<p><span id=\"DFSdamn\">如果图不是连通或强连通，在进行 DFS\n时，有时并不一定能够保证从某一个结点出发能访问到所有的顶点</span></p>\n<h5 id=\"深度优先生成森林\">深度优先生成森林</h5>\n<p>在<a\nhref=\"##图###图的遍历####深度优先搜索#####存在的问题\">这种情况</a>下，必须再选中一个未访问过的顶点，继续进行深度优先搜索。直至所有的顶点都被访问过为止</p>\n<p>此时生成的是一组树而不是一棵树，这一组树被称为深度优先生成<strong>森林</strong></p>\n<p>所以将深度优先搜索的流程改为</p>\n<ol type=\"1\">\n<li>选中第一个被访问的顶点</li>\n<li>对顶点作已访问过的标志</li>\n<li>依次从顶点的未被访问过的第一个、第二个、第三个……邻接顶点出发，进行深度优先搜索</li>\n<li>如果还有顶点未被访问，则选中一个起始顶点，转向 2</li>\n<li>所有的顶点都被访问到，则结束</li>\n</ol>\n<h5 id=\"深度优先搜索的实现\">深度优先搜索的实现</h5>\n<ul>\n<li>公有的 <code>dfs</code> 函数的伪代码</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  visited [v] =<span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">//对每个节点标记为未访问</span><br><br>  <span class=\"hljs-keyword\">while</span>(v=尚未访问的节点)<br>  &#123;<br>    <span class=\"hljs-built_in\">dfs</span>(v,visited);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>私有的 <code>dfs</code> 函数的伪代码</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(v,visited)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-built_in\">visited</span>(v)=<span class=\"hljs-literal\">true</span>;<br>  <span class=\"hljs-keyword\">for</span> 每个 v 的邻接点 w<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>(!visited[w])<br>    &#123;<br>      <span class=\"hljs-built_in\">dfs</span>(w,visited);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"广度优先搜索\">广度优先搜索</h4>\n<ol type=\"1\">\n<li>选中第一个被访问的顶点</li>\n<li>对顶点作已访问过的标志</li>\n<li>依次访问已访问顶点的未被访问过的第 <span\nclass=\"math inline\">1</span> 个、第 <span class=\"math inline\">2</span>\n个、第 <span class=\"math inline\">3</span> 个、<span\nclass=\"math inline\">…</span> 、第 <span\nclass=\"math inline\"><em>m</em></span> 个邻接顶点 <span\nclass=\"math inline\"><em>W</em><sub>1</sub>, <em>W</em><sub>2</sub>, <em>W</em><sub>3</sub>, …, <em>W</em><sub><em>m</em></sub></span>\n，进行访问且进行标记，转向 3</li>\n<li>如果还有顶点未被访问，则选中一个起始顶点，转向 2</li>\n<li>所有的顶点都被访问到，则结束</li>\n</ol>\n<p>按照顶点序号小的先访问，大的后访问的原则以<strong>队列</strong>的形式实现</p>\n<p>同样能够生成广度优先生成森林</p>\n<h5 id=\"广度优先搜索的实现\">广度优先搜索的实现</h5>\n<ol type=\"1\">\n<li>将序号最小的顶点放入队列</li>\n<li>重复取队列的队头元素进行处理，直到队列为空。对出队的每个元素，首先检查该元素是否已被访问\n<ul>\n<li>如果没有被访问过，则访问该元素，并将它的所有的没有被访问过的后继入队</li>\n</ul></li>\n<li>检查是否还有顶点未被访问。如果有，重复上述两个步骤</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TypeOfVer</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TypeOfEdge</span>&gt;<br><span class=\"hljs-type\">void</span> adjListGraph&lt;TypeOfVer, TypeOfEdge&gt;::<span class=\"hljs-built_in\">bfs</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-type\">bool</span> *visited = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">bool</span>[Vers];<br>  <span class=\"hljs-type\">int</span> currentNode;<br>  linkQueue&lt;<span class=\"hljs-type\">int</span>&gt; q;<br>  edgeNode *p;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>   visited[i] = <span class=\"hljs-literal\">false</span>;<br>  &#125;<br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;当前图的广度优先遍历序列为：&quot;</span>&lt;&lt; endl;<br>  <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (visited[i] == <span class=\"hljs-literal\">true</span>)<br>    &#123;<br>      <span class=\"hljs-keyword\">continue</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">while</span> (!q.<span class=\"hljs-built_in\">isEmpty</span>()) <span class=\"hljs-comment\">//连续访问队列的队头，将其拉出，若其后继非空则拉入队列</span><br>    &#123;<br>      currentNode = q.<span class=\"hljs-built_in\">deQueue</span>();<br>      <span class=\"hljs-keyword\">if</span> (visited[currentNode] == <span class=\"hljs-literal\">true</span>)<br>      &#123;<br>        <span class=\"hljs-keyword\">continue</span>;<br>      &#125;<br>      cout &lt;&lt; verList[currentNode].ver &lt;&lt;<span class=\"hljs-string\">&#x27;\\t&#x27;</span>;<br>      visited[currentNode] = <span class=\"hljs-literal\">true</span>;<br>      p = verList[currentNode].head;<br>      <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-literal\">NULL</span>)<br>      &#123;<br>        <span class=\"hljs-keyword\">if</span> (visited[p-&gt;end] == <span class=\"hljs-literal\">false</span>)<br>        q.<span class=\"hljs-built_in\">enQueue</span>(p-&gt;end);<br>        p = p-&gt;next;<br>      &#125;<br>    &#125;<br>    cout &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"图遍历的应用\">图遍历的应用</h3>\n<h4 id=\"无向图的连通性-1\">无向图的连通性</h4>\n<ul>\n<li>如果无向图是连通的，则从无向图中的任意顶点出发进行深度优先搜索或广度优先搜索都可以访问到每一个顶点。访问的次序是一棵深度/广度优先<strong>生成树</strong></li>\n<li>如果图是非连通的，深度/广度优先搜索可以找到一片深度/广度优先<strong>生成森林</strong>。每棵树就是一个<strong>连通分量</strong>。对无向图来说，深度/广度优先搜索可以找到了它的所有连通分量</li>\n<li>在深度优先搜索和广度优先搜索函数的输出中，每一行代表一个连通分量</li>\n</ul>\n<h4 id=\"有向图的连通性-1\">有向图的连通性</h4>\n<ul>\n<li>对有向图，深度优先搜索可以<strong>测试是否强连通</strong>，并<strong>找出所有强连通分量</strong>\n<ol type=\"1\">\n<li>从任意顶点开始<strong>深度优先遍历</strong> <span\nclass=\"math inline\"><em>G</em></span></li>\n<li>对森林中的每棵树进行<strong>后序遍历</strong>，并按遍历的顺序给每个顶点编号</li>\n<li>将 <span class=\"math inline\"><em>G</em></span> 的每条边逆向，形成\n<span class=\"math inline\"><em>G</em><sub><em>r</em></sub></span></li>\n<li>从编号<strong>最大</strong>的顶点开始<strong>深度优先遍历 <span\nclass=\"math inline\"><em>G</em><sub><em>r</em></sub></span></strong>。得到的深度优先遍历森林的每棵树就是\n<span class=\"math inline\"><em>G</em></span> 的强连通分量</li>\n</ol></li>\n</ul>\n<h4 id=\"欧拉回路\">欧拉回路</h4>\n<ul>\n<li>哥尼斯堡七桥问题：能否找到一条走遍这七座桥，而且每座桥只经过一次，最后又回到原出发点的路径</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505230120835.png\"\nalt=\"哥尼斯堡七桥问题\" />\n<figcaption aria-hidden=\"true\">哥尼斯堡七桥问题</figcaption>\n</figure>\n<h5 id=\"欧拉的证明\">欧拉的证明</h5>\n<ul>\n<li>如果都是偶数桥，从任意地方出发都能回到原点\n<strong>（欧拉回路）</strong></li>\n<li>如果都是偶数桥，从任意地方出发都能回到原点\n<strong>（欧拉路径）</strong></li>\n<li>如果有奇数桥的地方不止两个，满足要求的路径是找不到的</li>\n</ul>\n<h5 id=\"查找欧拉回路的基本想法\">查找欧拉回路的基本想法</h5>\n<ul>\n<li>执行一次<strong>不允许回溯</strong>的 <code>DFS</code>\n，也被称为一笔画问题</li>\n<li>但是很多搜索都是不符合的</li>\n</ul>\n<h5 id=\"解决方法\">解决方法</h5>\n<p>找出路径上的另外一个尚有未访问的边的顶点，开始另一次深度优先的搜索，将得到的遍历序列拼接到原来的序列中，直到所有的边都已被访问</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505230128080.png\"\nalt=\"欧拉回路解决方法\" />\n<figcaption aria-hidden=\"true\">欧拉回路解决方法</figcaption>\n</figure>\n<h4 id=\"拓扑排序\">拓扑排序</h4>\n<p>设 <span\nclass=\"math inline\"><em>G</em> = (<em>V</em>, <em>E</em>)</span>\n是一个具有 <span class=\"math inline\"><em>n</em></span>\n个顶点的<strong>有向无环图</strong></p>\n<p>若 <span class=\"math inline\"><em>V</em></span> 中的顶点序列 <span\nclass=\"math inline\"><em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>, …, <em>V</em><sub><em>n</em></sub></span>\n满足下列条件</p>\n<ul>\n<li>在 <span class=\"math inline\"><em>G</em></span> 中，从 <span\nclass=\"math inline\"><em>V</em><sub><em>i</em></sub></span> 到 <span\nclass=\"math inline\"><em>V</em><sub><em>j</em></sub></span>\n有一条路径</li>\n<li>在序列中 <span\nclass=\"math inline\"><em>V</em><sub><em>i</em></sub></span> 在 <span\nclass=\"math inline\"><em>V</em><sub><em>j</em></sub></span> 之前</li>\n</ul>\n<p>则称 <span\nclass=\"math inline\"><em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>, …, <em>V</em><sub><em>n</em></sub></span>\n是 <span class=\"math inline\"><em>G</em></span>\n的一个<strong>拓扑排序</strong></p>\n<p>拓扑排序将图转换为线性序，相对前去后继关系不变</p>\n<h5 id=\"顶点活动网络activu-on-vertex-network\">顶点活动网络（Activu on\nvertex network）</h5>\n<ul>\n<li>顶点表示各项子任务</li>\n<li>有向边表示具有先决条件关系</li>\n<li>仅当作为某一子任务的所有作为先决条件的子任务实施完成后，该子任务才能得以实施</li>\n</ul>\n<p><strong>AOV</strong>的特点</p>\n<ol type=\"1\">\n<li>有起始顶点</li>\n<li>无回路</li>\n</ol>\n<h5 id=\"找出拓扑排序的过程\">找出拓扑排序的过程</h5>\n<ul>\n<li>第一个输出的顶点必须无前驱，即入度为 <span\nclass=\"math inline\">0</span></li>\n<li>无前驱以及后继的顶点在任何时候都可以输出</li>\n<li>逻辑删除法：当某个顶点被输出之后，该顶点以及从该顶点出发的边都被删除，所有以该顶点作为前驱的入度的所有顶点的入度\n<span class=\"math inline\">−1</span></li>\n</ul>\n<h5 id=\"拓扑排序的实现\">拓扑排序的实现</h5>\n<ul>\n<li>计算每个顶点的入度，保存在数组 <code>inDegree</code> 中</li>\n<li>检查 <code>inDegree</code> 中的每个元素，将入度为 <span\nclass=\"math inline\">0</span> 的顶点入队</li>\n<li>不断从队列中将入度为 <span class=\"math inline\">0</span>\n的顶点入队，输出此顶点，并将该顶点的入度 <span\nclass=\"math inline\">−1</span>，如果某个邻接点的入度为 <span\nclass=\"math inline\">0</span>，则将其入队</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TypeOfVer</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TypeOfEdge</span>&gt;<br><span class=\"hljs-type\">void</span> adjListGraph&lt;TypeOfVer, TypeOfEdge&gt;::<span class=\"hljs-built_in\">topSort</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  linkQueue&lt;<span class=\"hljs-type\">int</span>&gt; q;<br>  edgeNode *p;<br>  <span class=\"hljs-type\">int</span> current, *inDegree = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[Vers];<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>    inDegree[i] = <span class=\"hljs-number\">0</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">for</span> ( i = <span class=\"hljs-number\">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>    <span class=\"hljs-keyword\">for</span> (p = verList[i].head; p != <span class=\"hljs-literal\">NULL</span>; p = p-&gt;next)<br>    &#123;<br>    ++inDegree[p-&gt;end];<br>    &#125;<br>  &#125;                                                                 <span class=\"hljs-comment\">//计算入度</span><br>  <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; Vers; ++i)   <span class=\"hljs-keyword\">if</span> (inDegree[i] == <span class=\"hljs-number\">0</span>) q.<span class=\"hljs-built_in\">enQueue</span>(i);  <span class=\"hljs-comment\">//入度0节点入队</span><br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;拓扑排序为：&quot;</span> &lt;&lt; endl;<br>  <span class=\"hljs-keyword\">while</span>(!q.<span class=\"hljs-built_in\">isEmpty</span>())<br>  &#123;<br>    current = q.<span class=\"hljs-built_in\">deQueue</span>( );<br>    cout &lt;&lt; verList[current].ver &lt;&lt; <span class=\"hljs-string\">&#x27;\\t&#x27;</span>;<br>    <span class=\"hljs-keyword\">for</span> (p = verList[current].head; p != <span class=\"hljs-literal\">NULL</span>; p = p-&gt;next)<br>    <span class=\"hljs-keyword\">if</span>( --inDegree[p-&gt;end] == <span class=\"hljs-number\">0</span> )    q.<span class=\"hljs-built_in\">enQueue</span>( p-&gt;end );<br>  &#125;                                                                 <span class=\"hljs-comment\">//出队，删除关联的边</span><br>  cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>时间复杂度：</strong></p>\n<ul>\n<li>若图以邻接表表示</li>\n<li>计算入度的时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(|<em>V</em>|+|<em>E</em>|)</span>，搜索入度为\n<span class=\"math inline\">0</span> 的顶点的时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(|<em>V</em>|)</span>，出队和删除边的时间复杂度为\n<span class=\"math inline\"><em>O</em>(|<em>E</em>|)</span>，总执行时间为\n<span\nclass=\"math inline\"><em>O</em>(|<em>V</em>|+|<em>E</em>|)</span></li>\n</ul>\n<h4 id=\"关键路径\">关键路径</h4>\n<h5 id=\"边活动网络activity-on-edge\">边活动网络（Activity on Edge）</h5>\n<ul>\n<li><strong>AOE 网络：</strong> 加权有向无环图\n<ul>\n<li>顶点表示事件，边表示活动</li>\n<li>有向边的权值表示活动的持续时间</li>\n<li>有向边的方向表示事件发生的先后次序</li>\n<li>顶点的进入表示事件发生后允许开始的活动</li>\n<li>有一个源点、一个终点</li>\n</ul></li>\n</ul>\n<h5 id=\"关键路径的定义\">关键路径的定义</h5>\n<p>AOE\n网路可用于描述整个工程的各个活动之间的关系，活动安排的先后次序</p>\n<p>再次基础上可以用来估算工程的完成时间以及哪些活动是关键的活动</p>\n","excerpt":"","more":"<p><a href=\"https://oi-wiki.org/ds\">oiWiki 中的数据结构</a></p>\n<h2 id=\"引言\">引言</h2>\n<h3 id=\"算法与数据结构\">算法与数据结构</h3>\n<p>数据结构的研究内容</p>\n<ol type=\"1\">\n<li>数据之间的<strong>逻辑关系</strong>，以及这种关系对应的操作</li>\n<li><strong>储存实现</strong>：数据及逻辑关系的存储</li>\n<li><strong>运算实现</strong>：具体存储模式下，运算的实现，即<strong>算法</strong></li>\n</ol>\n<h4 id=\"数据的逻辑结构\">数据的逻辑结构</h4>\n<ul>\n<li><strong>集合结构</strong>\n次序任意，元素之间除了<strong>同处于一个集合内</strong>之外没有任意其他的关系.</li>\n<li><strong>线性结构</strong>\n数据元素的<strong>有序</strong>排列，除了头尾的元素外其余元素都有一个前趋和一个后继.</li>\n<li><strong>树形结构</strong>\n除了根元素之外，每个节点都有且仅有一个前趋，但是后继数量不限.</li>\n<li><strong>图形结构</strong> 每个元素的前趋和后继数量都不限 <img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/FourLogicalDataStructures.png\"\nalt=\"FourLogicalDataStructures\" /></li>\n</ul>\n<h4 id=\"数据结构的操作\">数据结构的操作</h4>\n<ul>\n<li><strong>创造</strong></li>\n<li><strong>清除</strong></li>\n<li><strong>插入</strong></li>\n<li><strong>删除</strong></li>\n<li><strong>更新</strong></li>\n<li><strong>搜索</strong></li>\n<li><strong>访问</strong></li>\n<li><strong>遍历（traverse）</strong>：按照某种次序访问数据结构中的每一元素，使每个元素恰好被访问一次</li>\n<li>每一种数据结构的特定操作</li>\n</ul>\n<p>数据结构的<strong>五大类</strong>：构建类、属性类、数据操纵类、遍历类、特定类</p>\n<h3 id=\"存储实现\">存储实现</h3>\n<h3 id=\"算法分析\">算法分析</h3>\n<h4 id=\"时间复杂度的概念\">时间复杂度的概念</h4>\n<ul>\n<li>是一种抽象的度量，表示运算量和问题规模（输入规模）之间的关系，<span\nclass=\"math inline\"><em>T</em>(<em>n</em>)</span></li>\n<li>算法的时间复杂度也与被处理的数据分布有关</li>\n<li>算法的时间复杂度分为三种\n<ul>\n<li>最好的</li>\n<li>最坏的</li>\n<li>平均</li>\n</ul></li>\n</ul>\n<h4 id=\"算法运算量的计算\">算法运算量的计算</h4>\n<h4 id=\"渐进时间复杂度\">渐进时间复杂度</h4>\n<h4 id=\"算法的优化\">算法的优化</h4>\n<h4 id=\"空间复杂度的概念\">空间复杂度的概念</h4>\n<ul>\n<li>渐进的空间复杂度</li>\n<li>一般只考虑<strong>辅助</strong>空间的占用情况</li>\n<li>空间复杂度一般按照最坏情况处理</li>\n<li>空间复杂度的计算、表示方法与时间复杂度相同</li>\n</ul>\n<h3 id=\"面向对象方法\">面向对象方法</h3>\n<h4 id=\"类模板的定义\">类模板的定义</h4>\n<p>类模板允许用户为类定义一种模式，使得类中的某些数据成员、某些成员函数的参数或返回值能取任意数据类型</p>\n<h5 id=\"定义格式\">定义格式</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> 标识符&gt;<br><span class=\"hljs-keyword\">class</span> 类名<br>&#123;<br>    <span class=\"hljs-comment\">// 类成员声明</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h5 id=\"类定义的一般格式\">类定义的一般格式</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> 类名<br>&#123;<br>  [<span class=\"hljs-keyword\">private</span>:]<br>    <span class=\"hljs-comment\">// 私有数据成员和成员函数声明</span><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 公有数据成员和成员函数声明</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"虚函数\">虚函数</h4>\n<ul>\n<li><p>在基类中用关键词 <code>virtual</code>\n声明的成员函数，并在派生类中重新定义的函数称为虚函数</p></li>\n<li><p>虚函数的一般格式</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">virtual</span> 返回类型 函数名(参数表)<br>&#123;<br>  <span class=\"hljs-comment\">// 函数体</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>\n<li><p>在派生类中重新定义时，其函数原型，包括返回类型、函数名、参数个数和参数类型的顺序都必须与基类中的原型完全相同（<strong>继承</strong>）</p></li>\n<li><p>当把一个函数定义为虚函数时，等于告诉编译器，这个成员函数在派生类中可能有不同的实现。必须在执行时根据传递的参数来决定调用哪一个函数</p></li>\n<li><p>虚函数在基类中有默认实现，派生类可以选择性地对其进行重写</p></li>\n</ul>\n<h4 id=\"纯虚函数\">纯虚函数</h4>\n<ul>\n<li><p>是一个在基类中说明的虚函数，它在该基类中没有实现，但要在它的派生类里定义和实现自己的版本，或重新说明为纯虚函数</p></li>\n<li><p>纯虚函数的一般形式</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">virtual</span> 返回类型 函数名(参数表) = <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure></li>\n<li><p>纯虚函数在基类中无实现，只有函数原型，派生类必须实现</p></li>\n</ul>\n<h4 id=\"抽象类\">抽象类</h4>\n<ul>\n<li>如果一个类中<strong>至少有一个纯虚函数</strong>，那么这个类就是抽象类</li>\n<li>抽象类只能作为其他类的基类，不能建立抽象类的对象</li>\n</ul>\n<h4 id=\"继承\">继承</h4>\n<ul>\n<li>在已有类的基础上建立新的类</li>\n<li>基类（父类）和派生类（子类）</li>\n<li>继承可以让程序员在已有类的基础上通过增加或修改少量代码的方法得到新的类，从而解决代码重用的问题</li>\n</ul>\n<h5 id=\"派生类\">派生类</h5>\n<ul>\n<li><p>一般格式</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> 派生类名 : [派生方式] 基类名<br>&#123;<br>  <span class=\"hljs-comment\">// 派生类新增的数据成员和成员函数</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>\n<li><p>派生方法</p>\n<ul>\n<li>公有派生：<code>public</code></li>\n<li>私有派生：<code>protected</code></li>\n<li>保护派生：<code>private</code></li>\n</ul></li>\n<li><p><code>class</code> 默认是 <code>private</code> 继承，\n<code>struct</code> 默认是 <code>public</code> 继承</p></li>\n</ul>\n<h6 id=\"派生类对基类成员的访问性\">派生类对基类成员的访问性</h6>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\"></th>\n<th style=\"text-align: center;\"><code>public</code> 继承</th>\n<th style=\"text-align: center;\"><code>protected</code> 继承</th>\n<th style=\"text-align: center;\"><code>private</code> 继承</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\"><code>public</code> 成员</td>\n<td style=\"text-align: center;\">public</td>\n<td style=\"text-align: center;\">protected</td>\n<td style=\"text-align: center;\">private</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><code>protected</code> 成员</td>\n<td style=\"text-align: center;\">protected</td>\n<td style=\"text-align: center;\">protected</td>\n<td style=\"text-align: center;\">private</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><code>private</code> 成员</td>\n<td style=\"text-align: center;\">不可访问</td>\n<td style=\"text-align: center;\">不可访问</td>\n<td style=\"text-align: center;\">不可访问</td>\n</tr>\n</tbody>\n</table>\n<h4\nid=\"类定义时常见的两种const用法\">类定义时常见的两种<code>const</code>用法</h4>\n<p>以函数 <code>int search(constelemType&amp;x) const</code> 为例</p>\n<ol type=\"1\">\n<li>修饰参数 <code>x</code> 的 <code>const</code> 和 <code>&amp;</code>\n组合\n<ul>\n<li><code>const</code> 修饰参数 <code>x</code>，表示函数\n<code>search</code> 不会修改参数 <code>x</code> 的值</li>\n<li>参数加了 <code>const</code>\n之后，编译器会在程序编译阶段帮助程序检查函数实现代码中是否含有对参数\n<code>x</code> 的修改操作，若有则会报错</li>\n<li><strong>如果确认函数实现中不准备改变 <code>x</code> 的值，养成加\n<code>const</code>的习惯</strong></li>\n<li><code>&amp;</code> 修饰参数 <code>x</code>，表示参数 <code>x</code>\n是引用传递，即传递的是实参的地址，而不是实参的值</li>\n</ul></li>\n<li>修饰函数 <code>search</code> 的 <code>const</code>\n<ul>\n<li>参数表后的 <code>const</code> 保护调用对象的值不被修改</li>\n<li>如果没有 <code>const</code> 修饰，那么在调用对象为\n<code>const</code> 类型时，不能调用该函数 常量对象只能调用参数表后带\n<code>const</code> 的常量成员函数</li>\n</ul></li>\n</ol>\n<h2 id=\"线性表\">线性表</h2>\n<h3 id=\"线性表的定义\">线性表的定义</h3>\n<h4 id=\"线性表的概念\">线性表的概念</h4>\n<ul>\n<li><p>是一种<strong>线性结构</strong>，是由 <span\nclass=\"math inline\"><em>n</em>(<em>n</em> ≥ 0)</span>\n个数据元素组成的有限序列</p></li>\n<li><p>除了首节点 <span\nclass=\"math inline\"><em>A</em><sub>0</sub></span> 和尾节点 <span\nclass=\"math inline\"><em>A</em><sub><em>n</em> − 1</sub></span>\n之外，每个节点 <span\nclass=\"math inline\"><em>A</em><sub><em>i</em></sub></span>\n有且仅有一个前趋 <span\nclass=\"math inline\"><em>A</em><sub><em>i</em> − 1</sub></span>\n和一个后继 <span\nclass=\"math inline\"><em>A</em><sub><em>i</em> + 1</sub></span></p></li>\n<li><p><span class=\"math inline\"><em>A</em><sub>0</sub></span>\n只有后趋，<span\nclass=\"math inline\"><em>A</em><sub><em>n</em> − 1</sub></span>\n只有前趋</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271603830.png\"\nalt=\"线性表\" />\n<figcaption aria-hidden=\"true\">线性表</figcaption>\n</figure></li>\n</ul>\n<h4 id=\"表的基本操作\">表的基本操作</h4>\n<ul>\n<li><strong>创建 <code>create()</code></strong>：创建一个空的线性表</li>\n<li><strong>清除\n<code>clear()</code></strong>：删除线性表中的所有数据元素</li>\n<li><strong>长度 <code>length()</code></strong>：返回线性表的长度</li>\n<li><strong>插入 <code>insert(i,x)</code></strong>：在线性表的第 <span\nclass=\"math inline\"><em>i</em></span> 个位置插入一个新元素\n<code>x</code></li>\n<li><strong>删除 <code>remove(i)</code></strong>：删除线性表中第 <span\nclass=\"math inline\"><em>i</em></span> 个位置的元素</li>\n<li><strong>搜索 <code>search(x)</code></strong>：在线性表中搜索元素\n<code>x</code>，返回其位置</li>\n<li><strong>访问 <code>visit(i)</code></strong>：返回线性表中第 <span\nclass=\"math inline\"><em>i</em></span> 个位置的元素</li>\n<li><strong>遍历\n<code>traverse()</code></strong>：依次访问线性表中的每个元素</li>\n</ul>\n<h4 id=\"线性表的抽象类\">线性表的抽象类</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">list</span><br>&#123;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;                           <span class=\"hljs-comment\">// 清空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">length</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;                     <span class=\"hljs-comment\">// 返回长度</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i, <span class=\"hljs-type\">const</span> elemType &amp;x)</span> </span>= <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// 插入</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> </span>= <span class=\"hljs-number\">0</span>;                     <span class=\"hljs-comment\">// 删除</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">search</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;    <span class=\"hljs-comment\">// 搜索</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> elemType <span class=\"hljs-title\">visit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;            <span class=\"hljs-comment\">// 访问</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">traverse</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;                  <span class=\"hljs-comment\">// 遍历</span><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">list</span>() &#123;&#125;                                  <span class=\"hljs-comment\">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>抽象类定义了线性表基本的操作，全是用纯虚函数定义，不做实现</li>\n<li><strong>抽象类无构造函数</strong></li>\n</ul>\n<h3 id=\"线性表的顺序实现\">线性表的顺序实现</h3>\n<h4 id=\"顺序存储结构\">顺序存储结构</h4>\n<ul>\n<li>节点存储在存储器的一块<strong>连续</strong>的空间中</li>\n<li>节点依照逻辑顺序依次<strong>存放</strong></li>\n<li>节点存放的物理位置和逻辑顺序是对应的</li>\n<li>线性表的顺序实现通常被称为<strong>顺序表</strong></li>\n</ul>\n<h4 id=\"顺序表类的定义\">顺序表类的定义</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">seqList</span> : <span class=\"hljs-keyword\">public</span> list&lt;elemtype&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    elemType *data;<br>    <span class=\"hljs-type\">int</span> currentLength;<br>    <span class=\"hljs-type\">int</span> maxSize;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">doubleSpace</span><span class=\"hljs-params\">()</span></span>;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">seqList</span>(<span class=\"hljs-type\">int</span> initSize = <span class=\"hljs-number\">10</span>);             <span class=\"hljs-comment\">// 构造函数</span><br>    ~<span class=\"hljs-built_in\">seqList</span>()                              <span class=\"hljs-comment\">// 析构函数</span><br>    &#123;<br>      <span class=\"hljs-keyword\">delete</span>[] data;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">()</span>                            <span class=\"hljs-comment\">//清空</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      currentLength = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">length</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span>                      <span class=\"hljs-comment\">// 返回长度</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> currentLength;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i, <span class=\"hljs-type\">const</span> elemType &amp;x)</span></span>;  <span class=\"hljs-comment\">// 插入</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;                     <span class=\"hljs-comment\">// 删除</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">search</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span> <span class=\"hljs-type\">const</span></span>;    <span class=\"hljs-comment\">// 搜索</span><br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">visit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> <span class=\"hljs-type\">const</span></span>;            <span class=\"hljs-comment\">// 访问</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">traverse</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;                  <span class=\"hljs-comment\">// 遍历</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"函数实现\">函数实现</h4>\n<h5 id=\"构造函数\">构造函数</h5>\n<ul>\n<li>定义对象时自动调用，用于初始化对象的数据成员</li>\n<li><strong>函数名与类名相同</strong></li>\n<li>可以有任何类型的参数，也可以没有参数，但是<strong>不能有返回类型</strong>，所以定义时不能说明类型</li>\n<li>若没有给出构造函数，编译器会自动生成一个默认的构造函数，只为对象开辟空间，里面的内容为随机数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>seqList&lt;elemType&gt;::<span class=\"hljs-built_in\">seqList</span>(<span class=\"hljs-type\">int</span> initSize)<br>&#123;<br>  data = <span class=\"hljs-keyword\">new</span> elemType[initSize];<br>  maxSize = initSize;<br>  currentLength = <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271640573.png\"\nalt=\"seqList\" />\n<figcaption aria-hidden=\"true\">seqList</figcaption>\n</figure>\n<h5 id=\"析构函数\">析构函数</h5>\n<ul>\n<li>用于释放对象所占用的内存空间，由编译系统自动调用</li>\n<li><strong>函数名与类名相同，前面加 <code>~</code></strong></li>\n<li>不能有参数，也不能有返回类型</li>\n<li>若没有给出析构函数，编译器会自动生成一个默认的析构函数</li>\n<li>不是所有类都要由析构函数</li>\n<li>一般在构造函数中动态申请内存的，必须有析构函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">~<span class=\"hljs-built_in\">seqList</span>()<br>&#123;<br>  <span class=\"hljs-keyword\">delete</span>[] data;<br>&#125;  <span class=\"hljs-comment\">//在线性表的类中已经实现了，不用到类外定义</span><br></code></pre></td></tr></table></figure>\n<h5 id=\"顺序表的运算实现\">顺序表的运算实现</h5>\n<h6 id=\"search\"><code>search</code></h6>\n<p>从数组的第 0 个下标变量开始一次往后检查每一个元素，直到找到\n<code>x</code> 或找到表尾</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">int</span> seqList&lt;elemType&gt;::<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-type\">const</span> elemType &amp;x) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-type\">int</span> i ;<br>  <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span> ; i &lt; currentLength &amp;&amp; data[i] != x ; ++i);<br>  <span class=\"hljs-keyword\">if</span> (i == currentLength)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"traverse\"><code>traverse</code></h6>\n<p>从数组的第 0 个下标变量开始一次往后访问每一个元素，直到表尾</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemtype</span>&gt;<br><span class=\"hljs-type\">void</span> seqList&lt;elemType&gt;::<span class=\"hljs-built_in\">traverse</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span> ; i &lt; currentLength ; ++i)<br>  &#123;<br>    cout &lt;&lt; data[i] &lt;&lt; <span class=\"hljs-string\">&#x27; &#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"insert\"><code>insert</code></h6>\n<ul>\n<li>在第 <code>i</code> 个位置插入元素 <code>x</code></li>\n<li>若插入后表长超过 <code>maxSize</code>，则将 <code>maxSize</code>\n扩大一倍</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271747022.png\"\nalt=\"seqList::insert\" />\n<figcaption aria-hidden=\"true\">seqList::insert</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> seqList&lt;elemType&gt;::<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-type\">int</span> i , <span class=\"hljs-type\">const</span> elemType &amp;x)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (currentSize = maxSize)<br>  &#123;<br>    <span class=\"hljs-built_in\">doubleSpace</span>();<br>  &#125;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = currentLength ; j &gt; i ; --j)<br>  &#123;<br>    data[j] = data[j - <span class=\"hljs-number\">1</span>];<br>  &#125;<br>  data[i] = x;<br>  ++currentLength;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"doublespace-操作的实现\"><code>doubleSpace</code> 操作的实现</h6>\n<ul>\n<li>重新申请一个更大规模的动态数组，将原有数组的内容拷贝到新数组中，释放原有数组空间，将新数组作为存储线性表的存储区</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281230588.png\"\nalt=\"seqList::doublespace\" />\n<figcaption aria-hidden=\"true\">seqList::doublespace</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> seqList&lt;elemType&gt;::<span class=\"hljs-built_in\">doublespace</span>()<br>&#123;<br>  elemtype *tmp = data;<br>  maxSize *= <span class=\"hljs-number\">2</span>;<br>  data = <span class=\"hljs-keyword\">new</span> elemtype[maxSize];<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span> ; i &lt; currentLength ; +<span class=\"hljs-number\">+1</span>)<br>  &#123;<br>    data[i] = tmp[i];<br>  &#125;<br>  <span class=\"hljs-keyword\">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"remove\"><code>remove</code></h6>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281238735.png\"\nalt=\"seqlist::remove\" />\n<figcaption aria-hidden=\"true\">seqlist::remove</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> seqList&lt;elemType&gt;::<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-type\">int</span> i)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">0</span> ||i &gt; currentlength)<br>  &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">OutOfBound</span>();<br>  &#125;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = i ; j &lt; currentlength <span class=\"hljs-number\">-1</span> ; ++j)<br>  &#123;<br>    data[j] = data[j + <span class=\"hljs-number\">1</span>];<br>  &#125;<br>  --currentLength;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"线性表的链接存储\">线性表的链接存储</h3>\n<h4 id=\"单链表\">单链表</h4>\n<ul>\n<li>每个节点附加指针字段，如\n<code>next</code>，指向直接后继节点，最后一个节点的 <code>next</code>\n指向 <code>nullptr</code></li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281247119.png\"\nalt=\"单链表\" />\n<figcaption aria-hidden=\"true\">单链表</figcaption>\n</figure>\n<h5 id=\"头节点头指针\">头节点、头指针</h5>\n<ul>\n<li>在表头额外增加一个相同类型的特殊结点</li>\n<li>不是线性表中的组成部分</li>\n<li>头节点使得在表头位置上进行插入和删除和在其他节点位置上是完全一致的，使得插入和删除算法得到简化</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281407312.png\"\nalt=\"带头节点的单链表\" />\n<figcaption aria-hidden=\"true\">带头节点的单链表</figcaption>\n</figure>\n<h5 id=\"结点及其组成\">结点及其组成</h5>\n<ul>\n<li>链表的节点包含两个部分\n<ul>\n<li>数据字段\n<ul>\n<li>可以存储任何类型的数据，仍然使用 <code>elemType</code> 表示</li>\n</ul></li>\n<li>指针字段\n<ul>\n<li>用于存储<strong>后继节点</strong>的地址值</li>\n</ul></li>\n<li>结点类型是链表专用的，可以设为内嵌类</li>\n<li>将节点类定义为 <code>struct</code> 方便链表类访问</li>\n</ul></li>\n</ul>\n<h5 id=\"单链表类的定义\">单链表类的定义</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">sLinkList</span>:<span class=\"hljs-keyword\">public</span> list&lt;elemtype&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">node</span>                                    <span class=\"hljs-comment\">// 节点类</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      <span class=\"hljs-built_in\">node</span>(<span class=\"hljs-type\">const</span> elemType &amp;x , node *n = <span class=\"hljs-literal\">nullptr</span>)<br>      &#123;<br>        data = x;<br>        next = n;<br>      &#125;<br>      <span class=\"hljs-built_in\">node</span>():<span class=\"hljs-built_in\">next</span>(<span class=\"hljs-literal\">nullptr</span>)&#123;&#125;<br>      ~<span class=\"hljs-built_in\">node</span>()&#123;&#125;<br>    &#125;;<br><br>    node *head;<br>    <span class=\"hljs-type\">int</span> currentLength;<br>    <span class=\"hljs-function\">node *<span class=\"hljs-title\">move</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> <span class=\"hljs-type\">const</span></span>;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">sLinkList</span>();<br>    ~<span class=\"hljs-built_in\">sLinkList</span>();<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">length</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> currentLength;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i , <span class=\"hljs-type\">const</span> elemType &amp;x)</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">search</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">visit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">traverse</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h5 id=\"构造函数-1\">构造函数</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281418321.png\"\nalt=\"sLinklist\" />\n<figcaption aria-hidden=\"true\">sLinklist</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>sLinkList&lt;elemType&gt;::<span class=\"hljs-built_in\">sLinkList</span>()<br>&#123;<br>  head = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">node</span>();<br>  currentLength = <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"clear\"><code>clear</code></h5>\n<ul>\n<li>将单链表变成一个空表</li>\n<li>回收节点空间</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281420756.png\"\nalt=\"sLinkList::clear\" />\n<figcaption aria-hidden=\"true\">sLinkList::clear</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> sLinkList&lt;elemType&gt;::<span class=\"hljs-built_in\">clear</span>()<br>&#123;<br>  node *p = head-&gt;next , *q;<br><br>  <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-literal\">nullptr</span>)        <span class=\"hljs-comment\">// 删除节点</span><br>  &#123;<br>    q = p-&gt;next;<br>    <span class=\"hljs-keyword\">delete</span> p;<br>    p = q;<br>  &#125;<br>  currentLength = <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"move\"><code>move</code></h5>\n<ul>\n<li>返回第 <span class=\"math inline\"><em>i</em></span> 个元素的指针</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">sLinkList</span>&lt;elemType&gt;::node *sLinkList&lt;elemType&gt;::<span class=\"hljs-built_in\">move</span>(<span class=\"hljs-type\">int</span> i) <span class=\"hljs-type\">const</span><br>&#123;<br>  node *p = head;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span> ; j &lt; i ; ++j)<br>  &#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"insert-1\"><code>insert</code></h5>\n<ol type=\"1\">\n<li>指针 <code>p</code> 指向要插入的位置 <code>i</code>\n的前一个节点</li>\n<li>申请一个新节点 <code>s</code></li>\n<li>将 <code>s</code> 的 <code>next</code> 指向 <code>p</code> 的\n<code>next</code></li>\n<li>将 <code>p</code> 的 <code>next</code> 指向 <code>s</code></li>\n</ol>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281437080.png\"\nalt=\"sLinkList::insert\" />\n<figcaption aria-hidden=\"true\">sLinkList::insert</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> sinkList&lt;elemtype&gt;::<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-type\">int</span> i , <span class=\"hljs-type\">const</span> elemType &amp;x)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">0</span> || i &gt; currentLength)<br>  &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">OutOfBound</span>();<br>  &#125;<br>  node *p = <span class=\"hljs-built_in\">move</span>(i<span class=\"hljs-number\">-1</span>);<br>  node *s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">node</span>(x , p-&gt;next);<br>  p-&gt;next = s;<br>  ++currentLength;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"remove-1\"><code>remove</code></h5>\n<ol type=\"1\">\n<li>找到被删除节点的前一个节点 <code>pos</code></li>\n<li>让 <code>delp</code> 指向被删除节点</li>\n<li>让 <code>pos</code> 的 <code>next</code> 指向 <code>delp</code> 的\n<code>next</code></li>\n<li>释放 <code>delp</code> 的空间</li>\n</ol>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281444167.png\"\nalt=\"sLinkList::remove\" />\n<figcaption aria-hidden=\"true\">sLinkList::remove</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> sLinkList&lt;elemType&gt;::<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-type\">int</span> i)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">0</span> || i &gt;= currentLength)<br>  &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">OutOfBound</span>();<br>  &#125;<br>  node *pos = <span class=\"hljs-built_in\">move</span>(i<span class=\"hljs-number\">-1</span>);<br>  node *delp = pos-&gt;next;<br>  pos-&gt;next = delp-&gt;next;<br>  <span class=\"hljs-keyword\">delete</span> delp;<br>  --currentLength;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"search-1\"><code>search</code></h5>\n<ul>\n<li>从头节点开始，依次访问每个节点，直到找到 <code>x</code>\n或到达表尾</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">int</span> sLinkList&lt;elemType&gt;::<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-type\">const</span> elemtype <span class=\"hljs-number\">7</span>x) <span class=\"hljs-type\">const</span><br>&#123;<br>  node *p = head -&gt; next;<br>  <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-literal\">nullptr</span> &amp;&amp; p-&gt;data != x) <span class=\"hljs-comment\">// 访问每个节点，条件的顺序不能交换</span><br>  &#123;<br>    p = p-&gt;next;<br>    ++i;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>如果判定条件改为\n<code>p-&gt;data != x &amp;&amp; p != nullptr</code>，会在\n<code>p</code> 为空时试图访问\n<code>p-&gt;data</code>，导致访问空指针，从而产生未定义行为</li>\n</ul>\n<h5 id=\"visit\"><code>visit</code></h5>\n<ol type=\"1\">\n<li>找到第 <code>i</code> 个节点</li>\n<li>返回 <code>p-&gt;data</code></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>elemType sLinkList&lt;elemType&gt;::<span class=\"hljs-built_in\">visit</span>(<span class=\"hljs-type\">int</span> i) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">0</span> || i &gt;= currentLength)<br>  &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">OutOfBound</span>();<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">move</span>(i)-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"traverse-1\"><code>traverse</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> sLinkList&lt;elemType&gt;::<span class=\"hljs-built_in\">traverse</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  node *p = head-&gt;next;<br>  <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    cout &lt;&lt; p-&gt;data &lt;&lt; <span class=\"hljs-string\">&#x27; &#x27;</span>;<br>    p = p-&gt;next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"双链表\">双链表</h4>\n<ul>\n<li>每个节点有两个指针字段\n<ul>\n<li><code>next</code> 指向直接后继节点</li>\n<li><code>prev</code> 指向直接前驱节点</li>\n</ul></li>\n</ul>\n<h5 id=\"双链表的头尾节点\">双链表的头尾节点</h5>\n<ul>\n<li>头节点\n<ul>\n<li><code>prev</code> 指向 <code>nullptr</code></li>\n<li><code>next</code> 指向首节点</li>\n</ul></li>\n<li>尾节点 <code>tail</code>\n<ul>\n<li><code>prev</code> 指向最后一个节点</li>\n<li><code>next</code> 指向 <code>nullptr</code></li>\n</ul></li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291712872.png\"\nalt=\"双链表\" />\n<figcaption aria-hidden=\"true\">双链表</figcaption>\n</figure>\n<h5 id=\"双链表类的定义\">双链表类的定义</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">dLinkList</span>:<span class=\"hljs-keyword\">public</span> list&lt;elemType&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">node</span>                                                         <span class=\"hljs-comment\">// 双链表中的节点类</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      node *prev;<br>      <span class=\"hljs-built_in\">node</span>(<span class=\"hljs-type\">const</span> elemType &amp;x , node *p = <span class=\"hljs-literal\">nullptr</span> , node *n = <span class=\"hljs-literal\">nullptr</span>)<br>      &#123;<br>        data = x;<br>        prev = p;<br>        next = n;<br>      &#125;<br>      <span class=\"hljs-built_in\">node</span>():<span class=\"hljs-built_in\">next</span>(<span class=\"hljs-literal\">nullptr</span>),<span class=\"hljs-built_in\">prev</span>(<span class=\"hljs-literal\">nullptr</span>)&#123;&#125;<br>      ~<span class=\"hljs-built_in\">node</span>()&#123;&#125;<br>    &#125;;<br>    node *head , *tail;                                                  <span class=\"hljs-comment\">// 头节点和尾节点</span><br>    <span class=\"hljs-type\">int</span> currentLength;                                                   <span class=\"hljs-comment\">// 当前长度</span><br>    <span class=\"hljs-function\">node *<span class=\"hljs-title\">move</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> <span class=\"hljs-type\">const</span></span>;                                             <span class=\"hljs-comment\">// 返回第 i 个节点的指针</span><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">dLinkList</span>();<br>    ~<span class=\"hljs-built_in\">dLinkList</span>();<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">length</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> currentLength;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i , <span class=\"hljs-type\">const</span> elemType &amp;x)</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">search</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">visit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">traverse</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h5 id=\"构造函数-2\">构造函数</h5>\n<ul>\n<li>申请头节点和尾节点</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291715359.png\"\nalt=\"dLinkList\" />\n<figcaption aria-hidden=\"true\">dLinkList</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>dLinkList&lt;elemType&gt;::<span class=\"hljs-built_in\">dLinkList</span>()<br>&#123;<br>  head = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">node</span>();<br>  tail = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">node</span>();<br>  head-&gt;next = tail;<br>  tail-&gt;prev = head;<br>  currentLength = <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"insert-2\"><code>insert</code></h5>\n<ol type=\"1\">\n<li>申请一个新节点 <code>tmp</code>，找到要插入的位置\n<code>pos</code></li>\n<li>将 <code>tmp</code> 的 <code>prev</code> 指向 <code>pos</code> 的\n<code>prev</code>，<code>tmp</code> 的 <code>next</code> 指向\n<code>pos</code></li>\n<li>将 <code>pos</code> 的前一个结点的 <code>next</code> 指向\n<code>tmp</code></li>\n<li>将 <code>pos</code> 的 <code>prev</code> 指向 <code>tmp</code></li>\n</ol>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291718343.png\"\nalt=\"dLinkList::insert\" />\n<figcaption aria-hidden=\"true\">dLinkList::insert</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> dLinkList&lt;elemtype&gt;::<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-type\">int</span> i ,<span class=\"hljs-type\">const</span> elemTypr &amp;x)<br>[<br>  node *pos , *tmp;<br><br>  pos = <span class=\"hljs-built_in\">move</span>(i);<br>  temp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">node</span>(x,pos -&gt; prev , pos);<br>  pos-&gt;prev-&gt;next = tmp;<br>  pos-&gt;prev = tmp;<br><br>  ++currentLength;<br>]<br></code></pre></td></tr></table></figure>\n<h5 id=\"remove-2\"><code>remove</code></h5>\n<ol type=\"1\">\n<li>找到要删除的节点 <code>pos</code></li>\n<li>将 <code>pos</code> 的前一个节点的 <code>next</code> 指向\n<code>pos</code> 的后一个节点</li>\n<li>将 <code>pos</code> 的后一个节点的 <code>prev</code> 指向\n<code>pos</code> 的前一个节点</li>\n</ol>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291730399.png\"\nalt=\"dLinkList::remove\" />\n<figcaption aria-hidden=\"true\">dLinkList::remove</figcaption>\n</figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> dLinkList&lt;elemType&gt;::<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-type\">int</span> i)<br>&#123;<br>  node *pos = <span class=\"hljs-built_in\">move</span>(i);<br><br>  pos-&gt;prev-&gt;next = pos-&gt;next;<br>  pos-&gt;next-&gt;prev = pos-&gt;prev;<br><br>  <span class=\"hljs-keyword\">delete</span> pos;<br>  --currentLength;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"单循环链表\">单循环链表</h4>\n<ul>\n<li>一般单循环链表不带头节点</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291732560.png\"\nalt=\"单循环链表\" />\n<figcaption aria-hidden=\"true\">单循环链表</figcaption>\n</figure>\n<h4 id=\"双循环链表\">双循环链表</h4>\n<ul>\n<li>头结点中 <code>prev</code> 字段给出尾结点的地址，尾结点中\n<code>next</code> 字段给出头结点的地址</li>\n<li>一般也不设置头尾节点</li>\n</ul>\n<h2 id=\"栈\">栈</h2>\n<h3 id=\"栈的定义\">栈的定义</h3>\n<ul>\n<li>栈是一种特殊的线性表</li>\n<li>只允许在一段进行插入和删除操作</li>\n<li>先进后出（LIFO，Last In First Out）</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291811552.png\"\nalt=\"栈\" />\n<figcaption aria-hidden=\"true\">栈</figcaption>\n</figure>\n<h4 id=\"栈的基本操作\">栈的基本操作</h4>\n<ul>\n<li><strong>创建 <code>create()</code></strong>：创建一个空栈</li>\n<li><strong>进栈 <code>push(x)</code></strong>：将元素 <code>x</code>\n压入栈顶</li>\n<li><strong>出栈\n<code>pop()</code></strong>：删除栈顶元素并返回其值</li>\n<li><strong>访问栈顶元素\n<code>top()</code></strong>：返回栈顶元素的值但是不删除</li>\n<li><strong>判断是否为空 <code>isEmpty()</code></strong>：若栈空返回\n<code>true</code>，否则返回 <code>false</code></li>\n</ul>\n<h4 id=\"栈的抽象类\">栈的抽象类</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">stack</span><br>&#123;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span> </span>= <span class=\"hljs-number\">0</span>;       <span class=\"hljs-comment\">// 进栈</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> elemType <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;                     <span class=\"hljs-comment\">// 出栈</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> elemType <span class=\"hljs-title\">top</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;               <span class=\"hljs-comment\">// 访问栈顶元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;               <span class=\"hljs-comment\">// 是否为空</span><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">stack</span>() &#123;&#125;                             <span class=\"hljs-comment\">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"栈的顺序实现\">栈的顺序实现</h3>\n<ul>\n<li>使用数组储存栈中的节点</li>\n<li>进栈和出栈都是在栈顶进行，不会引起类似顺序表中的大量元素的移动，数组的后端为栈顶</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291817453.png\"\nalt=\"顺序栈\" />\n<figcaption aria-hidden=\"true\">顺序栈</figcaption>\n</figure>\n<h4 id=\"顺序栈类\">顺序栈类</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">seqStack</span>:<span class=\"hljs-keyword\">public</span> stack&lt;elemType&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    elemType *data;                     <span class=\"hljs-comment\">// 数据域</span><br>    <span class=\"hljs-type\">int</span> top_p;                          <span class=\"hljs-comment\">// 栈顶指针</span><br>    <span class=\"hljs-type\">int</span> maxSize;                        <span class=\"hljs-comment\">// 栈的最大容量</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">doubleSpace</span><span class=\"hljs-params\">()</span></span>;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">seqStack</span>(<span class=\"hljs-type\">int</span> initSize = <span class=\"hljs-number\">10</span>);        <span class=\"hljs-comment\">// 构造函数</span><br>    ~<span class=\"hljs-built_in\">seqStack</span>();                        <span class=\"hljs-comment\">// 析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;               <span class=\"hljs-comment\">// 是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span></span>;       <span class=\"hljs-comment\">// 进栈</span><br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span></span>;                    <span class=\"hljs-comment\">// 出栈</span><br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">top</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;               <span class=\"hljs-comment\">// 访问栈顶元素</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"顺序存储的运算实现\">顺序存储的运算实现</h4>\n<h5 id=\"构造函数-3\">构造函数</h5>\n<ul>\n<li>按照用户估计的栈的规模申请一个动态数组，将数组地址保存在\n<code>elem</code> 中，数组规模保存在 <code>maxSize</code> 中，并设\n<code>top_p</code> 的值为 <span class=\"math inline\">−1</span></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>seqStack&lt;elemType&gt;::<span class=\"hljs-built_in\">seqStack</span>(<span class=\"hljs-type\">int</span> initSize)<br>&#123;<br>  elem = <span class=\"hljs-keyword\">new</span> elemType[initSize];<br>  maxSize = initSize;<br>  top_p = <span class=\"hljs-number\">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"push\"><code>push</code></h4>\n<ul>\n<li>先判断栈是否已满，若满则调用 <code>doubleSpace</code>\n扩大栈的容量</li>\n<li>将 <code>top_p</code> 加 1，指向栈顶元素</li>\n<li>将 <code>x</code> 压入栈顶</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> seqStack&lt;elemType&gt;::<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-type\">const</span> elemType &amp;x)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (top_p == maxSize - <span class=\"hljs-number\">1</span>)<br>  &#123;<br>    <span class=\"hljs-built_in\">doubleSpace</span>();<br>  &#125;<br>  elem[++top_p] = x;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"doublespace\"><code>doubleSpace</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> seqStack&lt;elemType&gt;::<span class=\"hljs-built_in\">doubleSpace</span>()<br>&#123;<br>  elemType *tmp = elem;<br>  elem = <span class=\"hljs-keyword\">new</span> elemType[maxSize * <span class=\"hljs-number\">2</span>];<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span> ; i &lt; maxSize ; ++i)<br>  &#123;<br>    elem[i] = tmp[i];<br>  &#125;<br>  maxSize *= <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"pop\"><code>pop</code></h5>\n<ul>\n<li>返回 <code>top_p</code> 指向的元素</li>\n<li>将 <code>top_p</code> 减 1</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>elemType seqStack&lt;elemType&gt;::<span class=\"hljs-built_in\">pop</span>()<br>&#123;<br>  <span class=\"hljs-keyword\">return</span> elem[top_p--];<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"top\"><code>top</code></h5>\n<ul>\n<li>返回 <code>top_p</code> 指向的元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>elemType seqStack&lt;elemType&gt;::<span class=\"hljs-built_in\">top</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> elem[top_p];<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"isempty\"><code>isEmpty</code></h5>\n<ul>\n<li>判断 <code>top_p</code> 是否为 <span\nclass=\"math inline\">−1</span>，若是则栈空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">bool</span> seqStack&lt;elemType&gt;::<span class=\"hljs-built_in\">isEmpty</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> top_p == <span class=\"hljs-number\">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"析构函数-1\">析构函数</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>seqStack&lt;elemType&gt;::~<span class=\"hljs-built_in\">seqStack</span>()<br>&#123;<br>  <span class=\"hljs-keyword\">delete</span>[] elem;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"性能分析\">性能分析</h4>\n<ul>\n<li>所有运算实现的时间复杂度都为 <span\nclass=\"math inline\"><em>O</em>(1)</span></li>\n<li>进栈运算在最坏的情况下的时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>)</span> （需要\n<code>doublespace</code> 时）</li>\n</ul>\n<h3 id=\"栈的链接实现\">栈的链接实现</h3>\n<ul>\n<li>使用<strong>不含头结点的单链表</strong>实现栈</li>\n<li>从使用方便性上看，将单链表的头指针指向栈顶</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291834782.png\"\nalt=\"链接栈\" />\n<figcaption aria-hidden=\"true\">链接栈</figcaption>\n</figure>\n<h4 id=\"链接栈类\">链接栈类</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LinkedStack</span>:<span class=\"hljs-keyword\">public</span> stack&lt;elemType&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">node</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      <span class=\"hljs-built_in\">node</span>(<span class=\"hljs-type\">const</span> elemType &amp;x , node *n = <span class=\"hljs-literal\">nullptr</span>)<br>      &#123;<br>        data = x;<br>        next = n;<br>      &#125;<br>      <span class=\"hljs-built_in\">node</span>():<span class=\"hljs-built_in\">next</span>(<span class=\"hljs-literal\">nullptr</span>)&#123;&#125;<br>      ~<span class=\"hljs-built_in\">node</span>()&#123;&#125;<br>    &#125;;<br>    node *top_p;                       <span class=\"hljs-comment\">// 栈顶指针</span><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">LinkedStack</span>();                    <span class=\"hljs-comment\">// 构造函数</span><br>    ~<span class=\"hljs-built_in\">LinkedStack</span>();                   <span class=\"hljs-comment\">// 析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;             <span class=\"hljs-comment\">// 是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span></span>;     <span class=\"hljs-comment\">// 进栈</span><br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span></span>;                   <span class=\"hljs-comment\">// 出栈</span><br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">top</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;             <span class=\"hljs-comment\">// 访问栈顶元素</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"链接存储的运算实现\">链接存储的运算实现</h4>\n<h5 id=\"构造函数-4\">构造函数</h5>\n<ul>\n<li>将 <code>top_p</code> 初始化为 <code>nullptr</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>LinkedStack&lt;elemType&gt;::<span class=\"hljs-built_in\">LinkedStack</span>()<br>&#123;<br>  top_p = <span class=\"hljs-literal\">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"析构函数-2\">析构函数</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>LinkStack&lt;elemType&gt;::~<span class=\"hljs-built_in\">LinkStack</span>()<br>&#123;<br>  node *tmp;<br>  <span class=\"hljs-keyword\">while</span> (top_p != <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    tmp = top_p;<br>    top_p = top_p-&gt;next;<br>    <span class=\"hljs-keyword\">delete</span> tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"push-1\"><code>push</code></h5>\n<ul>\n<li>在表头插入</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> LinkedStack&lt;elemType&gt;::<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-type\">const</span> elemType &amp;x)<br>&#123;<br>  top_p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">node</span>(x , top_p);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"pop-1\"><code>pop</code></h5>\n<ul>\n<li>删除表头节点</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>elemType LinkedStack&lt;elemType&gt;::<span class=\"hljs-built_in\">pop</span>()<br>&#123;<br>  node *tmp = top_p;<br>  elemType x = top_p-&gt;data;<br>  top_p = top_p-&gt;next;<br>  <span class=\"hljs-keyword\">delete</span> tmp;<br>  <span class=\"hljs-keyword\">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"top-1\"><code>top</code></h5>\n<ul>\n<li>返回 <code>top_p</code> 指向的节点的 <code>data</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>elemType LinkedStack&lt;elemType&gt;::<span class=\"hljs-built_in\">top</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> top_p-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"isempty-1\"><code>isEmpty</code></h5>\n<ul>\n<li>判断 <code>top_p</code> 是否为 <code>nullptr</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">bool</span> LinkedStack&lt;elemType&gt;::<span class=\"hljs-built_in\">isEmpty</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> top_p == <span class=\"hljs-literal\">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"性能分析-1\">性能分析</h4>\n<ul>\n<li>所有运算实现的时间复杂度都为 <span\nclass=\"math inline\"><em>O</em>(1)</span>，因为都是对栈顶进行操作</li>\n</ul>\n<h3 id=\"栈的应用\">栈的应用</h3>\n<h4 id=\"递归函数的非递归实现\">递归函数的非递归实现</h4>\n<h5 id=\"函数调用\">函数调用</h5>\n<ul>\n<li>递归的本质是函数调用，函数调用又是通过栈实现的，递归时会产生隐式栈</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  ...<br>  r1:<span class=\"hljs-built_in\">f1</span>();<br>  r2:<br>  ..<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  ...<br>  t1:<span class=\"hljs-built_in\">f2</span>();<br>  t2:<br>  ...<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  ...<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503301445662.png\"\nalt=\"函数执行过程\" />\n<figcaption aria-hidden=\"true\">函数执行过程</figcaption>\n</figure>\n<ul>\n<li>设置一个栈模拟函数调用，当调用发生时，将函数压入栈中</li>\n<li>函数返回时，将栈顶元素弹出</li>\n</ul>\n<h6 id=\"递归算法的例子\">递归算法的例子</h6>\n<p>hanoi 塔算法</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Move</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> Height , <span class=\"hljs-type\">int</span> FromNeedle ,<span class=\"hljs-type\">int</span> ToNeedle ,<span class=\"hljs-type\">int</span> UsingNeedle)</span> <span class=\"hljs-comment\">// FromNeedle是起始针，ToNeedle是目标针，UsingNeedle是辅助针</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (Height &gt; <span class=\"hljs-number\">0</span>)<br>  &#123;<br>    <span class=\"hljs-built_in\">Move</span>(Height - <span class=\"hljs-number\">1</span>，FromNeedle , UsingNeeedle,ToNeedle); <span class=\"hljs-comment\">// 将上面n-1个盘子从FromNeedle移动到UsingNeedle</span><br>    cout &lt;&lt; FromNeedle &lt;&lt; <span class=\"hljs-string\">&quot;-&gt;&quot;</span> &lt;&lt; ToNeedle &lt;&lt; endl; <span class=\"hljs-comment\">// 将最底下的盘子从FromNeedle移动到ToNeedle&gt;</span><br>    <span class=\"hljs-built_in\">Move</span>(Height - <span class=\"hljs-number\">1</span>,UsingNeedle , ToNeedle , FromNeedle); <span class=\"hljs-comment\">// 将上面的盘子从UsingNeedle移动到ToNeedle</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"递归算法的时间复杂度\">递归算法的时间复杂度</h5>\n<h6 id=\"数学归纳法\">数学归纳法</h6>\n<p>以 Hanio 塔问题为例</p>\n<p><span class=\"math display\">$$\n\\begin{dcases}\nT(n) = 2T(n-1) + 1 &amp;\\\\\nT(1) = 1 &amp;\n\\end{dcases}\n$$</span></p>\n<p>可以使用数学归纳法证明 <span\nclass=\"math inline\"><em>T</em>(<em>n</em>) = 2<sup><em>n</em></sup> − 1</span></p>\n<h6 id=\"递归方程\">递归方程</h6>\n<p><strong>主定理</strong>：设 <span\nclass=\"math inline\"><em>a</em> ≥ 1</span>，<span\nclass=\"math inline\"><em>b</em> &gt; 1</span> 为常数，<span\nclass=\"math inline\"><em>f</em>(<em>n</em>)</span>\n是一个函数，则递归方程</p>\n<p><span class=\"math display\">$$\nT(n) = aT(\\frac{n}{b}) + f(n) \\quad (n &gt; 1)\n$$</span></p>\n<p>的解为</p>\n<ol type=\"1\">\n<li>若 <span\nclass=\"math inline\"><em>f</em>(<em>n</em>) &lt; <em>O</em>(<em>n</em><sup>log<sub><em>b</em></sub><em>a</em></sup>)</span>，则\n<span\nclass=\"math inline\"><em>T</em>(<em>n</em>) = <em>O</em>(<em>n</em><sup>log<sub><em>b</em></sub><em>a</em></sup>)</span></li>\n<li>若 <span\nclass=\"math inline\"><em>f</em>(<em>n</em>) = <em>O</em>(<em>n</em><sup>log<sub><em>b</em></sub><em>a</em></sup>)</span>，则\n<span\nclass=\"math inline\"><em>T</em>(<em>n</em>) = <em>O</em>(<em>n</em><sup>log<sub><em>b</em></sub><em>a</em></sup>log<sub>2</sub><em>n</em>)</span></li>\n<li>若 <span\nclass=\"math inline\"><em>f</em>(<em>n</em>) &gt; <em>O</em>(<em>n</em><sup>log<sub><em>b</em></sub><em>a</em></sup>)</span>，则\n<span\nclass=\"math inline\"><em>T</em>(<em>n</em>) = <em>O</em>(<em>f</em>(<em>n</em>))</span></li>\n</ol>\n<h6 id=\"生成函数\">生成函数</h6>\n<p><strong>定义</strong>：设 <span\nclass=\"math inline\"><em>u</em><sub>0</sub>, <em>u</em><sub>1</sub>, <em>u</em><sub>2</sub>, …, <em>u</em><sub><em>n</em></sub>, …</span>\n是一无穷序列，称形式幂级数 <span\nclass=\"math inline\"><em>G</em>(<em>t</em>) = ∑<sub><em>i</em> ≥ 0</sub><em>u</em><sub><em>i</em></sub><em>t</em><sup><em>i</em></sup></span>\n为其生成函数</p>\n<p>利用生成函数求通项的方法</p>\n<ol type=\"1\">\n<li>按照递归关系式消去无限延长的部分</li>\n<li>展开为 <span class=\"math inline\"><em>t</em></span>\n的幂级数求通项</li>\n</ol>\n<p>以 Fibonacci 数列为例</p>\n<p><span class=\"math display\">$$\n\\begin{dcases}\nF_{0} =0 &amp; \\\\\nF_{1} =1 &amp; \\\\\nF_{n} =F_{n-1} +F_{n-2} &amp;\n\\end{dcases}\n$$</span></p>\n<p><span class=\"math display\">$$\n\\begin{aligned}\n  &amp;G(t) = F_{0}t^0 + F_{1}t^1 + F_{2}t^2 + F_{3}t^3 + \\cdots \\\\\n  &amp;G(t) = t + t^2 + t^3 + \\cdots \\\\\n  &amp;tG(t)=t^2 + t^3 + t^4 + \\cdots \\\\\n  &amp;t^2G(t)=t^3 + t^4 + t^5 + \\cdots \\\\\n  &amp;(1-t-t^2)G(t) = t \\\\\n  &amp;G(t) = \\frac{t}{1-t-t^2} = \\frac{1}{\\sqrt{5}}\n\\left(\\frac{1}{1-\\frac{1+\\sqrt{5}}{2}t} -\n\\frac{1}{1-\\frac{1-\\sqrt{5}}{2}t}\\right) \\\\\n\\end{aligned}\n$$</span></p>\n<p>令 <span class=\"math inline\">$\\Phi =\n\\frac{1}{2}(1+\\sqrt{5})$</span>，<span\nclass=\"math inline\">$\\hat{\\Phi}=\\frac{1}{2}(1-\\sqrt{5})$</span></p>\n<p><span class=\"math display\">$$\nG(t) =\\frac{1}{\\sqrt{5}}(\\frac{1}{1-\\Phi t} - \\frac{1}{1-\\hat{\\Phi}t})\n$$</span></p>\n<p>有 <span class=\"math inline\">$\\displaystyle\\frac{1}{1-\\Phi t} =\n\\sum_{n=0}^{\\infty} \\Phi^n t^n$</span></p>\n<p><span class=\"math display\">$$\nG(t) = \\frac{1}{\\sqrt{5}} \\sum_{n=0}^{\\infty} (\\Phi^n t^n - \\hat{\\Phi}^n\nt^n)\n$$</span></p>\n<p>则</p>\n<p><span class=\"math display\">$$\nF_n = \\frac{1}{\\sqrt{5}}(\\Phi^n - \\hat{\\Phi}^n)\n$$</span></p>\n<h4 id=\"递归消除\">递归消除</h4>\n<p>以打印正整数为例</p>\n<h5 id=\"递归实现\">递归实现</h5>\n<h6 id=\"代码\">代码</h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printNum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (num &gt;= <span class=\"hljs-number\">10</span>)<br>  &#123;<br>    <span class=\"hljs-built_in\">printNum</span>(num / <span class=\"hljs-number\">10</span>);<br>    cout.<span class=\"hljs-built_in\">put</span>(num % <span class=\"hljs-number\">10</span> + <span class=\"hljs-string\">&#x27;0&#x27;</span>);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    cout.<span class=\"hljs-built_in\">put</span>(num + <span class=\"hljs-string\">&#x27;0&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"代码运行过程中栈的变化\">代码运行过程中栈的变化</h6>\n<ol type=\"1\">\n<li><code>push(1234)</code></li>\n<li><code>pop(1234)</code>，<code>push(4)</code>，<code>push(123)</code></li>\n<li><code>pop(123)</code>，<code>push(3)</code>，<code>push(12)</code></li>\n<li><code>pop(12)</code>，<code>push(2)</code>，<code>push(1)</code></li>\n<li><code>pop(1)</code>，<code>pop(2)</code>，<code>pop(3)</code>，<code>pop(4)</code></li>\n</ol>\n<h5 id=\"非递归实现\">非递归实现</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printNum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  LinkStack&lt;<span class=\"hljs-type\">int</span>&gt; s;<br>  <span class=\"hljs-type\">int</span> tmp;<br>  s.<span class=\"hljs-built_in\">push</span>(num);<br>  <span class=\"hljs-keyword\">while</span> (!<span class=\"hljs-built_in\">isEmpty</span>())<br>  &#123;<br>    tmp = s.<span class=\"hljs-built_in\">pop</span>();<br>    <span class=\"hljs-keyword\">if</span> (tmp &gt; <span class=\"hljs-number\">9</span>)<br>    &#123;<br>      s.<span class=\"hljs-built_in\">push</span>(tmp % <span class=\"hljs-number\">10</span>);<br>      s.<span class=\"hljs-built_in\">push</span>(tmp / <span class=\"hljs-number\">10</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      cout.<span class=\"hljs-built_in\">put</span>(tmp + <span class=\"hljs-string\">&#x27;0&#x27;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"括号匹配\">括号匹配</h3>\n<ul>\n<li>判断一个表达式中的括号是否匹配</li>\n<li>遇到左括号就入栈，遇到右括号就出栈</li>\n</ul>\n<p>判断错误的原则</p>\n<ol type=\"1\">\n<li>栈空时遇到右括号</li>\n<li>出栈时遇到不匹配的括号</li>\n<li>栈不空时结束</li>\n</ol>\n<h3 id=\"简单的计算数学表达式\">简单的计算数学表达式</h3>\n<h4 id=\"前缀式中缀式和后缀式\">前缀式、中缀式和后缀式</h4>\n<p>对于一个表达式 <span\nclass=\"math inline\"><em>a</em> + <em>b</em></span></p>\n<ul>\n<li>前缀式 <code>+ab</code>，波兰式</li>\n<li>中缀式 <code>a+b</code></li>\n<li>后缀式 <code>ab+</code>，逆波兰式</li>\n</ul>\n<h4 id=\"后缀式的优点\">后缀式的优点</h4>\n<ul>\n<li>不需要括号</li>\n<li>不需要考虑运算符的优先级</li>\n<li>计算机容易处理</li>\n</ul>\n<h4 id=\"后缀式的计算\">后缀式的计算</h4>\n<ul>\n<li>使用栈来存储操作数</li>\n<li>遇到操作数就入栈</li>\n<li>遇到操作符就出栈两个操作数，进行计算，将结果入栈</li>\n<li>最后栈中只剩下一个元素，就是结果</li>\n</ul>\n<h4 id=\"中缀式转换为后缀式的算法\">中缀式转换为后缀式的算法</h4>\n<p>操作方法见<a\nhref=\"/本科/编程/数据结构/中缀计算式转换为后缀计算式.md\">中缀计算式转换为后缀计算式</a></p>\n<h2 id=\"队列\">队列</h2>\n<ul>\n<li><p>队列的定义</p></li>\n<li><p>先进先出（FIFO，First In First Out）</p></li>\n<li><p>只允许在一端（队首）进行插入操作，另一端（队尾）进行删除操作</p></li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503310847159.png\"\nalt=\"队列\" />\n<figcaption aria-hidden=\"true\">队列</figcaption>\n</figure>\n<h4 id=\"队列的基本操作\">队列的基本操作</h4>\n<ul>\n<li><strong>创建 <code>create()</code></strong>：创建一个空队列</li>\n<li><strong>入队 <code>enQueue(x)</code></strong>：将元素 <code>x</code>\n入队</li>\n<li><strong>出队\n<code>deQueue()</code></strong>：删除队首元素并返回其值</li>\n<li><strong>访问队首元素\n<code>getHead()</code></strong>：返回队首元素的值但不删除</li>\n<li><strong>判断是否为空 <code>isEmpty()</code></strong>：若队列空返回\n<code>true</code>，否则返回 <code>false</code></li>\n</ul>\n<h4 id=\"队列的抽象类\">队列的抽象类</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">queue</span><br>&#123;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">enQueue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span> </span>= <span class=\"hljs-number\">0</span>;       <span class=\"hljs-comment\">// 入队</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> elemType <span class=\"hljs-title\">deQueue</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;                    <span class=\"hljs-comment\">// 出队</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> elemType <span class=\"hljs-title\">getHead</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;              <span class=\"hljs-comment\">// 访问队首元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;                  <span class=\"hljs-comment\">// 是否为空</span><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">queue</span>() &#123;&#125;                                 <span class=\"hljs-comment\">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"队列的顺序实现\">队列的顺序实现</h3>\n<ul>\n<li>使用数组来存储队列中的元素</li>\n<li>元素下标的范围为 <span class=\"math inline\">0</span> 到\n<code>maxSize - 1</code></li>\n<li>存储队里的三种组织方法\n<ol type=\"1\">\n<li>队头位置固定</li>\n<li>队头位置不固定</li>\n<li>循环队列</li>\n</ol></li>\n</ul>\n<h4 id=\"队头位置固定\">队头位置固定</h4>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311613560.png\"\nalt=\"队头位置固定\" />\n<figcaption aria-hidden=\"true\">队头位置固定</figcaption>\n</figure>\n<p><strong>缺点</strong>：出队的时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>)</span>，因为出队时需要将所有元素向前移动一位</p>\n<h4 id=\"队头位置不固定\">队头位置不固定</h4>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311614368.png\"\nalt=\"队头位置不固定\" />\n<figcaption aria-hidden=\"true\">队头位置不固定</figcaption>\n</figure>\n<p><strong>优点</strong>：所有操作的时间复杂度均为 <span\nclass=\"math inline\"><em>O</em>(1)</span>\n<strong>缺点</strong>：浪费大量的空间</p>\n<h4 id=\"循环队列\">循环队列</h4>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311626377.png\"\nalt=\"循环队列\" />\n<figcaption aria-hidden=\"true\">循环队列</figcaption>\n</figure>\n<ul>\n<li>入队\n<ul>\n<li><code>rear = (rear + 1) % maxSize</code>;\n<code>elem[rear] = x</code></li>\n</ul></li>\n<li>出队\n<ul>\n<li><code>front = (front + 1) % maxSize</code>;\n<code>return elem[front]</code></li>\n</ul></li>\n</ul>\n<p>为了解决队列空和队列满的判断问题，令 <code>front</code>\n指向的单元不能存储队列元素，只能起到标志作用</p>\n<ul>\n<li>队列空：<code>front == rear</code></li>\n<li>队列满：<code>(rear + 1) % maxSize == front</code></li>\n</ul>\n<h6 id=\"循环队列类的定义\">循环队列类的定义</h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">seqQueue</span>:<span class=\"hljs-keyword\">public</span> queue&lt;elemType&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    elemType *elem;<br>    <span class=\"hljs-type\">int</span> maxSize;<br>    <span class=\"hljs-type\">int</span> front , rear;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">doubleSpace</span><span class=\"hljs-params\">()</span></span>;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">seqQueue</span>(<span class=\"hljs-type\">int</span> initSize = <span class=\"hljs-number\">10</span>);        <span class=\"hljs-comment\">// 构造函数</span><br>    ~<span class=\"hljs-built_in\">seqQueue</span>();                        <span class=\"hljs-comment\">// 析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span></span>;                     <span class=\"hljs-comment\">// 是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">enQueue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span></span>;    <span class=\"hljs-comment\">// 入队</span><br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">deQueue</span><span class=\"hljs-params\">()</span></span>;                 <span class=\"hljs-comment\">// 出队</span><br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">getHead</span><span class=\"hljs-params\">()</span></span>;                 <span class=\"hljs-comment\">// 访问队首元素</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h5 id=\"构造函数-5\">构造函数</h5>\n<ul>\n<li>申请一块空间，将 <code>front</code> 和 <code>rear</code> 初始化为\n<span class=\"math inline\">0</span></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>seqQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">seqQueue</span>(<span class=\"hljs-type\">int</span> initSize)<br>&#123;<br>  elem = <span class=\"hljs-keyword\">new</span> elemType[initSize];<br>  maxSize = initSize;<br>  front = rear = <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"析构函数-3\">析构函数</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>seqQueue&lt;elemType&gt;::~<span class=\"hljs-built_in\">seqQueue</span>()<br>&#123;<br>  <span class=\"hljs-keyword\">delete</span>[] elem;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"enqueue\"><code>enQueue</code></h5>\n<ul>\n<li>先判断队列是否已满，若满则调用 <code>doubleSpace</code>\n扩大队列的容量</li>\n<li>将 <code>rear</code> 加 1，指向队尾元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> seqQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">enQueue</span>(<span class=\"hljs-type\">const</span> elemType &amp;x)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> ((rear + <span class=\"hljs-number\">1</span>) % maxSize == front)<br>  &#123;<br>    <span class=\"hljs-built_in\">doubleSpace</span>();<br>  &#125;<br>  rear = (rear + <span class=\"hljs-number\">1</span>) % maxSize;<br>  elem[rear] = x;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"doublespace-1\"><code>doubleSpace</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> seqQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">doubleSpace</span>()<br>&#123;<br>  elemType *tmp = elem;<br>  elem = <span class=\"hljs-keyword\">new</span> elemType[maxSize * <span class=\"hljs-number\">2</span>];<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span> ; i &lt; maxSize ; ++i)<br>  &#123;<br>    elem[i] = tmp[(front + i) % maxSize];<br>  &#125;<br>  front = <span class=\"hljs-number\">0</span>;<br>  rear = maxSize - <span class=\"hljs-number\">1</span>;<br>  maxSize *= <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"dequeue\"><code>deQueue</code></h5>\n<ul>\n<li>将 <code>front</code> 加 1，指向队首元素</li>\n<li>返回 <code>elem[front]</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>elemType seqQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">deQueue</span>()<br>&#123;<br>  front = (front + <span class=\"hljs-number\">1</span>) % maxSize;<br>  <span class=\"hljs-keyword\">return</span> elem[front];<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"gethead\"><code>getHead</code></h5>\n<ul>\n<li>返回 <code>elem[(front + 1) % maxSize]</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>elemType seqQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">getHead</span>()<br>&#123;<br>  <span class=\"hljs-keyword\">return</span> elem[(front + <span class=\"hljs-number\">1</span>) % maxSize];<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"isempty-2\"><code>isEmpty</code></h5>\n<ul>\n<li>判断 <code>front</code> 是否等于 <code>rear</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">bool</span> seqQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">isEmpty</span>()<br>&#123;<br>  <span class=\"hljs-keyword\">return</span> front == rear;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"队列的链接实现\">队列的链接实现</h3>\n<ul>\n<li>为了方便操作，使用含头节点和尾节点的单链表实现</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311804800.png\"\nalt=\"链接队列\" />\n<figcaption aria-hidden=\"true\">链接队列</figcaption>\n</figure>\n<p><strong>链接队列的特点</strong></p>\n<ul>\n<li>不会出现队列满的情况，但是会出现队列空的情况</li>\n<li>队列为空时，单链表中没有节点存在，即头尾指针都为\n<code>nullptr</code></li>\n<li>保存一个链接队列只需要两个分别指向单链表节点的指针\n<code>front</code> 和 <code>rear</code>\n<ul>\n<li><code>front</code> 指向队首元素</li>\n<li><code>rear</code> 指向队尾元素</li>\n</ul></li>\n</ul>\n<h4 id=\"连接队列类\">连接队列类</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">linkQueue</span>:<span class=\"hljs-keyword\">public</span> queue&lt;elemType&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">node</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      <span class=\"hljs-built_in\">node</span>(<span class=\"hljs-type\">const</span> elemType &amp;x , node *n = <span class=\"hljs-literal\">nullptr</span>)<br>      &#123;<br>        data = x;<br>        next = n;<br>      &#125;<br>      <span class=\"hljs-built_in\">node</span>():<span class=\"hljs-built_in\">next</span>(<span class=\"hljs-literal\">nullptr</span>)&#123;&#125;<br>      ~<span class=\"hljs-built_in\">node</span>()&#123;&#125;<br>    &#125;;<br>    node *front , *rear;                <span class=\"hljs-comment\">// 队头和队尾指针</span><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">linkQueue</span>();                       <span class=\"hljs-comment\">// 构造函数</span><br>    ~<span class=\"hljs-built_in\">linkQueue</span>();                      <span class=\"hljs-comment\">// 析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> </span>;              <span class=\"hljs-comment\">// 是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">enQueue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> elemType &amp;x)</span></span>;   <span class=\"hljs-comment\">// 入队</span><br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">deQueue</span><span class=\"hljs-params\">()</span></span>;                <span class=\"hljs-comment\">// 出队</span><br>    <span class=\"hljs-function\">elemType <span class=\"hljs-title\">getHead</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;          <span class=\"hljs-comment\">// 访问队首元素</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h5 id=\"构造函数-6\">构造函数</h5>\n<ul>\n<li>将 <code>front</code> 和 <code>rear</code> 初始化为\n<code>nullptr</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>linkQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">linkQueue</span>()<br>&#123;<br>  front = rear = <span class=\"hljs-literal\">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"enqueue-1\"><code>enQueue</code></h5>\n<ol type=\"1\">\n<li>申请一个节点空间 <code>x</code></li>\n<li>将 <code>rear</code> 指向的节点的 <code>next</code> 指向\n<code>x</code></li>\n<li>将 <code>rear</code> 指向 <code>x</code></li>\n</ol>\n<p><strong>注意</strong>：存在队列为空的情况，此时我们只需要将\n<code>front</code> 和 <code>rear</code> 都指向 <code>x</code> 即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> linkQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">enQueue</span>(<span class=\"hljs-type\">const</span> elemType &amp;x)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (rear == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    front = rear = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">node</span>(x);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    rear = rear-&gt;next = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">node</span>(x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"dequeue-1\"><code>deQueue</code></h5>\n<ol type=\"1\">\n<li>返回 <code>front</code> 指向的节点的 <code>data</code></li>\n<li>将 <code>front</code> 指向的节点从链表中摘下</li>\n<li>释放空间</li>\n</ol>\n<p><strong>注意</strong>：当队列中只有一个元素时，删除后队列为空，此时需要将\n<code>front</code> 和 <code>rear</code> 都置为 <code>nullptr</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">void</span> LinkQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">deQueue</span>()<br>&#123;<br>  node *tmp = front;<br>  <span class=\"hljs-keyword\">if</span> (front)<br>  &#123;<br>    emelType value = front-&gt;data;<br>    front = front-&gt;next;<br>    <span class=\"hljs-keyword\">if</span> (front == <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>      rear = <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">delete</span> tmp;<br>    <span class=\"hljs-keyword\">return</span> value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"gethead-1\"><code>getHead</code></h5>\n<ul>\n<li>返回 <code>front</code> 指向的节点的 <code>data</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>elemType linkQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">getHead</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> front-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"isempty-3\"><code>isEmpty</code></h5>\n<ul>\n<li>判断 <code>front</code> 或 <code>rear</code> 是否为\n<code>nullptr</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br><span class=\"hljs-type\">bool</span> linkQueue&lt;elemType&gt;::<span class=\"hljs-built_in\">isEmpty</span>()<br>&#123;<br>  <span class=\"hljs-keyword\">return</span> front == <span class=\"hljs-literal\">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"析构函数-4\">析构函数</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">elemType</span>&gt;<br>linkQueue&lt;elemType&gt;::~<span class=\"hljs-built_in\">linkQueue</span>()<br>&#123;<br>  node *tmp;<br>  <span class=\"hljs-keyword\">while</span> (front != <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    tmp = front;<br>    front = front-&gt;next;<br>    <span class=\"hljs-keyword\">delete</span> tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"树\">树</h2>\n<h3 id=\"树的定义\">树的定义</h3>\n<h4 id=\"树的递归定义\">树的递归定义</h4>\n<ul>\n<li>树是 <span class=\"math inline\"><em>n</em></span>\n个节点的有限集合，它或者是空集，或者满足\n<ul>\n<li>有一个特殊的节点称为根节点</li>\n<li>除根节点外，其他节点分为 <span class=\"math inline\"><em>m</em></span>\n个互不相交的有限集合 <span\nclass=\"math inline\"><em>T</em><sub>1</sub>, <em>T</em><sub>2</sub>, …, <em>T</em><sub><em>m</em></sub></span>，每个集合都是一棵树</li>\n</ul></li>\n</ul>\n<h4 id=\"树的术语\">树的术语</h4>\n<ul>\n<li><strong>根节点、叶节点、内部节点</strong>：\n<ul>\n<li>根节点：没有父节点的节点</li>\n<li>叶节点：没有子节点的节点</li>\n<li>内部节点：有子节点的节点</li>\n</ul></li>\n<li><strong>节点的度和树的度</strong>：\n<ul>\n<li>节点的度：节点的子树个数</li>\n<li>树的度：树中所有节点的度的最大值</li>\n</ul></li>\n<li><strong>儿子节点</strong></li>\n<li><strong>父亲节点</strong></li>\n<li><strong>兄弟节点</strong></li>\n<li><strong>祖先节点</strong></li>\n<li><strong>子孙节点</strong></li>\n<li><strong>节点所处层次</strong></li>\n<li><strong>树的高度</strong></li>\n<li><strong>有序树</strong></li>\n<li><strong>无序树</strong></li>\n<li><strong>森林</strong></li>\n</ul>\n<h4 id=\"树的运算\">树的运算</h4>\n<ul>\n<li><strong>建树 <code>create()</code></strong>：创建一个空树</li>\n<li><strong>清空 <code>clear()</code></strong>：删除树中所有节点</li>\n<li><strong>判空 <code>IsEmpty()</code></strong>：判断是否为空树</li>\n<li><strong>找根节点\n<code>root()</code></strong>：找出树的根节点值，若为空树则返回特殊值</li>\n<li><strong>找父节点\n<code>parent()</code></strong>：找到节点的父节点，若该节点不存在或为根节点则返回特殊值</li>\n<li><strong>找子节点\n<code>child()</code></strong>：找到节点的某个子节点，若该节点不存在或没有子节点则返回特殊值</li>\n<li><strong>剪枝 <code>remove()</code></strong>：删除节点的某棵子树</li>\n<li><strong>遍历\n<code>traverse()</code></strong>：访问树上的每个节点</li>\n</ul>\n<h4 id=\"树的抽象类\">树的抽象类</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">tree</span><br>&#123;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> T <span class=\"hljs-title\">root</span><span class=\"hljs-params\">(T flag)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> T <span class=\"hljs-title\">parent</span><span class=\"hljs-params\">(T x , T flag)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> T <span class=\"hljs-title\">child</span><span class=\"hljs-params\">(T x , <span class=\"hljs-type\">int</span> i , T flag)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(T x)</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">traverse</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"二叉树\">二叉树</h3>\n<h4 id=\"二叉树的定义\">二叉树的定义</h4>\n<ul>\n<li>二叉树（Binary\nTree）是节点的有限集合，要么为空，要么由一个根节点以及两棵互不相交的左右子树构成，而其左右子树也是二叉树</li>\n</ul>\n<p><strong>注意</strong>：二叉树是<strong>有序树</strong>，必须严格区分左右子树，即使只有一棵子树也要说明是左子树还是右子树，交换左右子树得到另一棵二叉树</p>\n<p>二叉树有五种基本形态</p>\n<ol type=\"1\">\n<li>空树</li>\n<li>只有一个节点的树</li>\n<li>只有左子树的树</li>\n<li>只有右子树的树</li>\n<li>左右子树都有的树</li>\n</ol>\n<h5 id=\"满二叉树\">满二叉树</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311916690.png\"\nalt=\"满二叉树\" />\n<figcaption aria-hidden=\"true\">满二叉树</figcaption>\n</figure>\n<ul>\n<li>每个节点的度都为 <span class=\"math inline\">0</span> 或 <span\nclass=\"math inline\">2</span> 的二叉树称为满二叉树</li>\n<li>性质\n<ul>\n<li>高度为 <span class=\"math inline\"><em>h</em></span> 的满二叉树有\n<span class=\"math inline\">2<sup><em>h</em></sup> − 1</span> 个节点</li>\n<li>任意一层的节点个数达到了上限 <span\nclass=\"math inline\">2<sup><em>n</em> − 1</sup></span></li>\n</ul></li>\n</ul>\n<h5 id=\"完全二叉树\">完全二叉树</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311917668.png\"\nalt=\"完全二叉树\" />\n<figcaption aria-hidden=\"true\">完全二叉树</figcaption>\n</figure>\n<ul>\n<li>在满二叉树的最底层从右向左依次删除若干个节点得到的树为完全二叉树</li>\n<li>满二叉树是完全二叉树，完全二叉树不一定是满二叉树</li>\n<li>性质\n<ul>\n<li>所有的叶节点都出现在最低的两层生</li>\n<li>对于任意节点，如果其右子树的高度为 <span\nclass=\"math inline\"><em>h</em></span>，则其左子树的高度为 <span\nclass=\"math inline\"><em>h</em></span> 或 <span\nclass=\"math inline\"><em>h</em> + 1</span></li>\n</ul></li>\n</ul>\n<h4 id=\"二叉树的性质\">二叉树的性质</h4>\n<ol type=\"1\">\n<li>二叉树的第 <span class=\"math inline\"><em>i</em></span> 层最多有\n<span class=\"math inline\">2<sup><em>i</em> − 1</sup></span> 个节点</li>\n<li>二叉树的深度为 <span class=\"math inline\"><em>h</em></span>，则最多有\n<span class=\"math inline\">2<sup><em>h</em></sup> − 1</span> 个节点</li>\n<li>对于一棵非空二叉树，若其叶节点个数为 <span\nclass=\"math inline\"><em>n</em><sub>0</sub></span>，则其度为 <span\nclass=\"math inline\">2</span> 的节点个数为 <span\nclass=\"math inline\"><em>n</em><sub>2</sub></span>，则有 <span\nclass=\"math inline\"><em>n</em><sub>0</sub> = <em>n</em><sub>2</sub> + 1</span></li>\n<li>具有 <span class=\"math inline\"><em>n</em></span>\n个节点的二叉树的高度为 <span class=\"math inline\"><em>h</em></span>，则\n<span\nclass=\"math inline\"><em>h</em> = ⌊log<sub>2</sub><em>n</em>⌋ + 1</span></li>\n<li>对于一棵具有 <span class=\"math inline\"><em>n</em></span>\n个节点的完全二叉树中的节点按层自上而下，每层从左到右编号，若设根节点的编号为\n<span class=\"math inline\">1</span>，则对任一编号为 <span\nclass=\"math inline\"><em>u</em></span> 的节点，有\n<ol type=\"1\">\n<li>如果 <span class=\"math inline\"><em>i</em> = 1</span>，则 <span\nclass=\"math inline\"><em>u</em></span> 为根节点</li>\n<li>如果 <span class=\"math inline\"><em>i</em> &gt; 1</span>，则 <span\nclass=\"math inline\"><em>u</em></span> 的父节点编号为 <span\nclass=\"math inline\">$\\lfloor \\frac{u}{2} \\rfloor$</span></li>\n<li>如果 <span\nclass=\"math inline\">2<em>i</em> ≥ <em>n</em></span>，则编号为 <span\nclass=\"math inline\"><em>i</em></span>\n的节点为叶子节点，没有儿子；否则，其左子编号为 <span\nclass=\"math inline\">2<em>i</em></span></li>\n<li>如果 <span\nclass=\"math inline\">2<em>i</em> + 1 ≥ <em>n</em></span>，则编号为 <span\nclass=\"math inline\"><em>i</em></span> 的节点无右儿子；否则，其右子编号为\n<span class=\"math inline\">2<em>i</em> + 1</span></li>\n</ol></li>\n</ol>\n<h4 id=\"二叉树的基本运算\">二叉树的基本运算</h4>\n<ul>\n<li><strong>建树 <code>create()</code></strong>：创建一棵空树</li>\n<li><strong>清空 <code>clear()</code></strong>：删除树中所有节点</li>\n<li><strong>判空 <code>isEmpty()</code></strong>：判断是否为空树</li>\n<li><strong>找根节点\n<code>root()</code></strong>：找出树的根节点值，若为空树则返回特殊值</li>\n<li><strong>找父节点\n<code>parent()</code></strong>：找到节点的父节点，若该节点不存在或为根节点则返回特殊值</li>\n<li><strong>找左子节点\n<code>lchild()</code></strong>：找到节点的左子节点，若该节点不存在或没有左子节点则返回特殊值</li>\n<li><strong>找右子节点\n<code>rchild()</code></strong>：找到节点的右子节点，若该节点不存在或没有右子节点则返回特殊值</li>\n<li><strong>删除左子树\n<code>delLeft()</code></strong>：删除节点的左子树</li>\n<li><strong>删除右子树\n<code>delRight()</code></strong>：删除节点的右子树</li>\n<li><strong>遍历\n<code>traverse()</code></strong>：访问树上的每个节点</li>\n</ul>\n<h4 id=\"二叉树的遍历\">二叉树的遍历</h4>\n<h5 id=\"前序遍历\">前序遍历</h5>\n<ul>\n<li>如果树为空，则操作为空</li>\n<li>如果树不空，则访问根节点，然后前序遍历左子树，最后前序遍历右子树</li>\n</ul>\n<h5 id=\"中序遍历\">中序遍历</h5>\n<ul>\n<li>如果树为空，则操作为空</li>\n<li>如果树不空，则中序遍历左子树，然后访问根节点，最后中序遍历右子树</li>\n</ul>\n<h5 id=\"后序遍历\">后序遍历</h5>\n<ul>\n<li>如果树为空，则操作为空</li>\n<li>如果树不空，则后序遍历左子树，然后后序遍历右子树，最后访问根节点</li>\n</ul>\n<h5 id=\"层次遍历\">层次遍历</h5>\n<ul>\n<li>从上到下，从左到右访问树的每个节点</li>\n</ul>\n<h5 id=\"性质\">性质</h5>\n<ul>\n<li>由前序遍历和中序遍历可以唯一确定一棵二叉树</li>\n<li>由中序遍历和后序遍历可以唯一确定一棵二叉树</li>\n<li>由前序遍历和后序遍历<strong>不能</strong>唯一确定一棵二叉树</li>\n</ul>\n<h4 id=\"二叉树抽象类\">二叉树抽象类</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">binaryTree</span><br>&#123;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;                     <span class=\"hljs-comment\">// 清空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;             <span class=\"hljs-comment\">// 是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> T <span class=\"hljs-title\">root</span><span class=\"hljs-params\">(T flag)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;             <span class=\"hljs-comment\">// 找根节点</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> T <span class=\"hljs-title\">parent</span><span class=\"hljs-params\">(T x , T flag)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;     <span class=\"hljs-comment\">// 找父节点</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> T <span class=\"hljs-title\">lchild</span><span class=\"hljs-params\">(T x , T flag)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;     <span class=\"hljs-comment\">// 找左子节点</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> T <span class=\"hljs-title\">rchild</span><span class=\"hljs-params\">(T x , T flag)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;     <span class=\"hljs-comment\">// 找右子节点</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">delLeft</span><span class=\"hljs-params\">(T x)</span> </span>= <span class=\"hljs-number\">0</span>;                <span class=\"hljs-comment\">// 删除左子树</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">delRight</span><span class=\"hljs-params\">(T x)</span> </span>= <span class=\"hljs-number\">0</span>;               <span class=\"hljs-comment\">// 删除右子树</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">preOrder</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;            <span class=\"hljs-comment\">// 前序遍历</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">midOrder</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;            <span class=\"hljs-comment\">// 中序遍历</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">postOrder</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;           <span class=\"hljs-comment\">// 后序遍历</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">levelOrder</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;          <span class=\"hljs-comment\">// 层次遍历</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"二叉树的实现\">二叉树的实现</h4>\n<h5 id=\"二叉树的顺序实现\">二叉树的顺序实现</h5>\n<ul>\n<li>使用数组来存储二叉树中的节点</li>\n<li>将二叉树补全为完全二叉树再进行存储</li>\n<li>会导致空间浪费</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504031058255.png\"\nalt=\"顺序二叉树\" />\n<figcaption aria-hidden=\"true\">顺序二叉树</figcaption>\n</figure>\n<h5 id=\"二叉树的链接实现\">二叉树的链接实现</h5>\n<ul>\n<li>使用链表来存储二叉树中的节点\n<ul>\n<li>标准形式：<code>left</code>，<code>data</code>，<code>right</code></li>\n</ul></li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504041445826.png\"\nalt=\"标准形式\" />\n<figcaption aria-hidden=\"true\">标准形式</figcaption>\n</figure>\n<ul>\n<li>广义标准形式：<code>data</code>，<code>left</code>，<code>parent</code>，<code>right</code></li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504041445472.png\"\nalt=\"广义标准形式\" />\n<figcaption aria-hidden=\"true\">广义标准形式</figcaption>\n</figure>\n<h4 id=\"二叉树类\">二叉树类</h4>\n<h5 id=\"节点类\">节点类</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span><br>&#123;<br>  <span class=\"hljs-keyword\">public</span>:<br>    Node *left *right;                                                                <span class=\"hljs-comment\">// 左右子树指针</span><br>    T data;                                                                           <span class=\"hljs-comment\">// 节点数据</span><br>    <span class=\"hljs-built_in\">Node</span>():<span class=\"hljs-built_in\">left</span>(<span class=\"hljs-literal\">nullptr</span>),<span class=\"hljs-built_in\">right</span>(<span class=\"hljs-literal\">nullptr</span>)&#123;&#125;                                             <span class=\"hljs-comment\">// 默认构造函数</span><br>    <span class=\"hljs-built_in\">Node</span>(T item , Node *L = <span class=\"hljs-literal\">nullptr</span>,Node *R = <span class=\"hljs-literal\">nullptr</span>):<span class=\"hljs-built_in\">data</span>(item),<span class=\"hljs-built_in\">left</span>(L),<span class=\"hljs-built_in\">right</span>(R)&#123;&#125;  <span class=\"hljs-comment\">// 带参数的构造函数</span><br>    ~<span class=\"hljs-built_in\">Node</span>()&#123;&#125;                                                                         <span class=\"hljs-comment\">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h5 id=\"二叉树类-1\">二叉树类</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">binaryTree</span>:<span class=\"hljs-keyword\">public</span> tree&lt;T&gt;<br>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">friend</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printTree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> binaryTree &amp;t, t flag)</span></span>;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span><br>    &#123;<br>      <span class=\"hljs-keyword\">public</span>:<br>        Node *left *right;<br>        T data;<br>        <span class=\"hljs-built_in\">Node</span>():<span class=\"hljs-built_in\">left</span>(<span class=\"hljs-literal\">nullptr</span>),<span class=\"hljs-built_in\">right</span>(<span class=\"hljs-literal\">nullptr</span>)&#123;&#125;<br>        <span class=\"hljs-built_in\">Node</span>(T item , Node *L = <span class=\"hljs-literal\">nullptr</span>,Node *R = <span class=\"hljs-literal\">nullptr</span>):<span class=\"hljs-built_in\">data</span>(item),<span class=\"hljs-built_in\">left</span>(L),<span class=\"hljs-built_in\">right</span>(R)&#123;&#125;<br>        ~<span class=\"hljs-built_in\">Node</span>()&#123;&#125;<br>    &#125;<br>    Node *root;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">binaryTree</span>():<span class=\"hljs-built_in\">root</span>(<span class=\"hljs-literal\">nullptr</span>)&#123;&#125;                    <span class=\"hljs-comment\">// 构造函数,创建空树</span><br>    <span class=\"hljs-built_in\">binaryTree</span>(T x):<span class=\"hljs-built_in\">root</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(x))&#123;&#125;             <span class=\"hljs-comment\">// 构造函数,创建只有根节点的树</span><br>    ~<span class=\"hljs-built_in\">binaryTree</span>()&#123;&#125;                                 <span class=\"hljs-comment\">// 析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">()</span></span>;                                   <span class=\"hljs-comment\">// 清空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;                           <span class=\"hljs-comment\">// 是否为空</span><br>    <span class=\"hljs-function\">T <span class=\"hljs-title\">Root</span><span class=\"hljs-params\">(T flag)</span> <span class=\"hljs-type\">const</span></span>;                           <span class=\"hljs-comment\">// 找根节点</span><br>    <span class=\"hljs-function\">T <span class=\"hljs-title\">lchild</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T &amp;x , T flag)</span> <span class=\"hljs-type\">const</span></span>;            <span class=\"hljs-comment\">// 找左子节点</span><br>    <span class=\"hljs-function\">T <span class=\"hljs-title\">rchild</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T &amp;x , T flag)</span> <span class=\"hljs-type\">const</span></span>;            <span class=\"hljs-comment\">// 找右子节点</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">delLeft</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T &amp;x)</span></span>;                       <span class=\"hljs-comment\">// 删除左子树</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">delRight</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T &amp;x)</span></span>;                      <span class=\"hljs-comment\">// 删除右子树</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">preOrder</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;                          <span class=\"hljs-comment\">// 前序遍历</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">midOrder</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;                          <span class=\"hljs-comment\">// 中序遍历</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">postOrder</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;                         <span class=\"hljs-comment\">// 后序遍历</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">levelOrder</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;                        <span class=\"hljs-comment\">// 层次遍历</span><br>    <span class=\"hljs-function\">coid <span class=\"hljs-title\">creatTree</span><span class=\"hljs-params\">(T flag)</span></span>;                         <span class=\"hljs-comment\">// 创建树</span><br>    <span class=\"hljs-function\">T <span class=\"hljs-title\">parent</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T &amp;x , T flag)</span> <span class=\"hljs-type\">const</span>             <span class=\"hljs-comment\">// 找父节点</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> flag;<br>    &#125;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-function\">Node *<span class=\"hljs-title\">Find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T &amp;x, Node *t)</span> <span class=\"hljs-type\">const</span></span>;            <span class=\"hljs-comment\">// 查找节点</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">(Node *&amp;x)</span></span>;                             <span class=\"hljs-comment\">// 清空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">preOrder</span><span class=\"hljs-params\">(Node *t)</span> <span class=\"hljs-type\">const</span></span>;                     <span class=\"hljs-comment\">// 前序遍历</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">midOrder</span><span class=\"hljs-params\">(Node *t)</span> <span class=\"hljs-type\">const</span></span>;                     <span class=\"hljs-comment\">// 中序遍历</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">postOrder</span><span class=\"hljs-params\">(Node *t)</span> <span class=\"hljs-type\">const</span></span>;                    <span class=\"hljs-comment\">// 后序遍历</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h5 id=\"构造函数-7\">构造函数</h5>\n<p>将 <code>root</code> 初始化为 <code>nullptr</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br>binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">binaryTree</span>()<br>&#123;<br>  root = <span class=\"hljs-literal\">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"isempty-4\"><code>isEmpty</code></h5>\n<ul>\n<li>判断 <code>root</code> 是否为 <code>nullptr</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">bool</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">isEmpty</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> root == <span class=\"hljs-literal\">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"root\"><code>Root</code></h5>\n<p>返回 <code>Root</code> 指向的节点的数据，若为空树则返回特殊值</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br>T binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">Root</span>(T flag)<span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> flag;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> root-&gt;data;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"二叉树的遍历-1\">二叉树的遍历</h5>\n<h6 id=\"前序遍历-1\">前序遍历</h6>\n<ol type=\"1\">\n<li>访问根节点</li>\n<li>前序遍历左子树</li>\n<li>前序遍历右子树</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">preOrder</span>(binaryTree&lt;T&gt;::Node *t) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    cout &lt;&lt; t -&gt; data &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    <span class=\"hljs-built_in\">preorder</span>(t -&gt; left);<br>    <span class=\"hljs-built_in\">preorder</span>(t -&gt; right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">preOrder</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n前序遍历：&quot;</span><br>  <span class=\"hljs-built_in\">preOrder</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"中序遍历-1\">中序遍历</h6>\n<ol type=\"1\">\n<li>中序遍历左子树</li>\n<li>访问根节点</li>\n<li>中序遍历右子树</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">midOrder</span>(binaryTree&lt;T&gt;::Node *t) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-built_in\">midOrder</span>(t -&gt; left);<br>    cout &lt;&lt; t -&gt; data &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    <span class=\"hljs-built_in\">midOrder</span>(t -&gt; right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">midOrder</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n中序遍历：&quot;</span><br>  <span class=\"hljs-built_in\">midOrder</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"后序遍历-1\">后序遍历</h6>\n<ol type=\"1\">\n<li>后序遍历左子树</li>\n<li>后序遍历右子树</li>\n<li>访问根节点</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">postOrder</span>(binaryTree&lt;T&gt;::Node *t) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-built_in\">postOrder</span>(t -&gt; left);<br>    <span class=\"hljs-built_in\">postOrder</span>(t -&gt; right);<br>    cout &lt;&lt; t -&gt; data &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">postOrder</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n后序遍历：&quot;</span><br>  <span class=\"hljs-built_in\">postOrder</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"size\"><code>size</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">int</span> binaryTree&lt;t&gt;::<span class=\"hljs-built_in\">size</span>(binarytree&lt;t&gt;::Node *t) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t = <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>+<span class=\"hljs-built_in\">sizze</span>(t -&gt; left)+<span class=\"hljs-built_in\">size</span>(t -&gt; right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">int</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">size</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">size</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"height\"><code>height</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">int</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">size</span>(binaryTree&lt;T&gt;::Node *t) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-type\">int</span> lt = <span class=\"hljs-built_in\">height</span>(t -&gt; left);<br>    <span class=\"hljs-type\">int</span> rt = <span class=\"hljs-built_in\">height</span>(t -&gt; right);<br>    <span class=\"hljs-keyword\">return</span> (lt &gt; rt ? lt : rt) + <span class=\"hljs-number\">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">int</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">height</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">height</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"层次遍历-1\">层次遍历</h5>\n<ul>\n<li>使用链接队列实现</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">levelOrder</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  linkQueue&lt;Node *&gt; que;<br>  Node *tmp;<br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n层次遍历：&quot;</span>;<br>  que.<span class=\"hljs-built_in\">enQueue</span>(root);<br>  <span class=\"hljs-keyword\">while</span> (!que.<span class=\"hljs-built_in\">isEmpty</span>())<br>  &#123;<br>    tmp = que.<span class=\"hljs-built_in\">deQueue</span>();<br>    cout &lt;&lt; tmp -&gt; data &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    <span class=\"hljs-keyword\">if</span> (tmp.left)<br>    &#123;<br>      que.<span class=\"hljs-built_in\">enQueue</span>(tmp -&gt; left);<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (tmp.right)<br>    &#123;<br>      que.<span class=\"hljs-built_in\">enQueue</span>(tmp -&gt; right);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"clear-1\"><code>clear</code></h5>\n<ul>\n<li>递归删除树中所有节点</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">clear</span>(Node *&amp;t)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-built_in\">clear</span>(t -&gt; left);<br>    <span class=\"hljs-built_in\">clear</span>(t -&gt; right);<br>    <span class=\"hljs-keyword\">delete</span> t;<br>    t = <span class=\"hljs-literal\">nullptr</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">clear</span>()<br>&#123;<br>  <span class=\"hljs-built_in\">clear</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"析构函数-5\">析构函数</h5>\n<ul>\n<li>调用 <code>clear</code> 函数删除树中所有节点</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br>binaryTree&lt;T&gt;::~<span class=\"hljs-built_in\">binaryTree</span>()<br>&#123;<br>  <span class=\"hljs-built_in\">clear</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"find\"><code>Find</code></h5>\n<ul>\n<li>使用前序遍历查找 <code>x</code> 节点</li>\n<li>首先检查根节点是否存放 <code>x</code>\n的值，若是则返回根节点地址</li>\n<li>对左子树递归调用 <code>Find</code> 函数，若返回空指针则说明\n<code>x</code> 不在左子树中</li>\n<li>对右子树递归调用 <code>Find</code> 函数，若返回空指针则说明\n<code>x</code> 不在右子树中</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">binaryTree</span>&lt;T&gt;:: Node *binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">Find</span>(<span class=\"hljs-type\">const</span> T &amp;x ,binaryTree&lt;T&gt;::Node *t) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (t -&gt; data == x)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> t;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (tmp = <span class=\"hljs-built_in\">Find</span>(x,t-&gt;left))<br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> tmp;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Find</span>(x,t-&gt;right);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"delleft\"><code>delLeft</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">delLeft</span>(<span class=\"hljs-type\">const</span> T &amp;x)<br>&#123;<br>  Node *tmp = <span class=\"hljs-built_in\">Find</span>(x,root);<br>  <span class=\"hljs-keyword\">if</span> (tmp == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-built_in\">clear</span>(tmp -&gt; left);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"delright\"><code>delRight</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">delRight</span>(<span class=\"hljs-type\">const</span> T &amp;x)<br>&#123;<br>  Node *tmp = <span class=\"hljs-built_in\">Find</span>(x,root);<br>  <span class=\"hljs-keyword\">if</span> (tmp == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-built_in\">clear</span>(tmp -&gt; right);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"lchild\"><code>lchild</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br>T binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">lchild</span>(<span class=\"hljs-type\">const</span> T &amp;x ,T flag) <span class=\"hljs-type\">const</span><br>&#123;<br>  Node *tmp = <span class=\"hljs-built_in\">Find</span>(x,root)<br>  <span class=\"hljs-keyword\">if</span> (tmp == <span class=\"hljs-literal\">nullptr</span> || tmp -&gt; left ==<span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> flag;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> tmp -&gt; left;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"rchild\"><code>rchild</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br>T binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">rchild</span>(<span class=\"hljs-type\">const</span> T &amp;x ,T flag) <span class=\"hljs-type\">const</span><br>&#123;<br>  Node *tmp = <span class=\"hljs-built_in\">Find</span>(x,root)<br>  <span class=\"hljs-keyword\">if</span> (tmp == <span class=\"hljs-literal\">nullptr</span> || tmp -&gt; right ==<span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> flag;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> tmp -&gt; right;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"createtree\"><code>createTree</code></h5>\n<ul>\n<li>创建过程（类似层次遍历？）\n<ol type=\"1\">\n<li>输入根节点的值，创建根节点</li>\n<li>对已添加到树上的每个节点，依次输入它的两个儿子的值，若没有儿子则输入\n<code>flag</code></li>\n</ol></li>\n<li>实现过程\n<ul>\n<li>使用队列，将新加入到书中的节点添加到队列中</li>\n<li>依次出队，对每个出队的元素输入它的儿子</li>\n</ul></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">createTree</span>(T flag)<br>&#123;<br>  linkQueue&lt;Node *&gt; que;<br>  Node *tmp;<br>  T x , ldata , rdata;<br><br>  <span class=\"hljs-comment\">// 创建树，flag表示空</span><br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n输入根节点：&quot;</span><br>  cin &gt;&gt; x;<br>  root = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(x);<br>  que.<span class=\"hljs-built_in\">enQueue</span>(root);<br>  <span class=\"hljs-keyword\">while</span> (!que.<span class=\"hljs-built_in\">isEmpty</span>())<br>  &#123;<br>    tmp = que,<span class=\"hljs-built_in\">deQueue</span>();<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n输入&quot;</span> &lt;&lt; tmp -&gt; data &lt;&lt; <span class=\"hljs-string\">&quot;的两个儿子（&quot;</span>&lt;&lt;flag&lt;&lt;<span class=\"hljs-string\">&quot;表示空节点）：&quot;</span>;<br>    cin &gt;&gt; ldata &gt;&gt; rdata;<br>    <span class=\"hljs-keyword\">if</span> (ldata != flag)<br>    &#123;<br>      tmp -&gt; left = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(ldata);<br>      que.<span class=\"hljs-built_in\">enQueue</span>(tmp -&gt; left);<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (rdata != flag)<br>    &#123;<br>      tmp -&gt; right = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(rdata);<br>      que.<span class=\"hljs-built_in\">enQueue</span>(tmp -&gt; right);<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;that&#x27;s good!\\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"printtree\"><code>printTree</code></h5>\n<ul>\n<li>层次遍历输出每个节点和它的左右孩子</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printTree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> binaryTree&lt;T&gt; &amp;t,T flag)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  linkQueue&lt;T&gt; que;<br>  que.<span class=\"hljs-built_in\">enQueue</span>(t.<span class=\"hljs-built_in\">root</span>());<br>  <span class=\"hljs-keyword\">while</span>(!que.<span class=\"hljs-built_in\">isEmpty</span>())<br>  &#123;<br>    T tmp = que.<span class=\"hljs-built_in\">deQueue</span>();<br>    T l = tmp.<span class=\"hljs-built_in\">lchild</span>(tmp , flag);<br>    T r = tmp.<span class=\"hljs-built_in\">rchild</span>(tmp , flag);<br>    cout &lt;&lt; p &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; l &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">if</span> (l != flag)<br>    &#123;<br>      que.<span class=\"hljs-built_in\">enQueue</span>(l);<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (r != flag)<br>    &#123;<br>      que.<span class=\"hljs-built_in\">enQueue</span>(r);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"二叉树遍历的非递归实现\">二叉树遍历的非递归实现</h4>\n<h5 id=\"前序遍历-2\">前序遍历</h5>\n<ol type=\"1\">\n<li>将根节点入栈</li>\n<li>栈顶元素出栈并输出值</li>\n<li>将左右子树入栈（先右后左，以便输出时先输出左子树）</li>\n<li>循环直至栈为空</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">preOrder</span>(<span class=\"hljs-type\">const</span> binaryTree&lt;T&gt;::Node *t) <span class=\"hljs-type\">const</span><br>&#123;<br>  linkStack&lt;Node *&gt; s;<br>  Node *tmp = t;<br><br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n前序遍历：&quot;</span>;<br>  <span class=\"hljs-keyword\">while</span> (!s.<span class=\"hljs-built_in\">isEmpty</span>())<br>  &#123;<br>    tmp = s.<span class=\"hljs-built_in\">pop</span>();<br>    cout &lt;&lt; tm -&gt; data &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    <span class=\"hljs-keyword\">if</span> (tmp -&gt; right != <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>      s.<span class=\"hljs-built_in\">push</span>(tmp -&gt; right);<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (tmp -&gt; left != <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>      s.<span class=\"hljs-built_in\">push</span>(tmp -&gt; left);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"中序遍历-2\">中序遍历</h5>\n<ol type=\"1\">\n<li>根节点入栈</li>\n<li>左子树入栈</li>\n<li>栈顶元素出栈并输出值</li>\n<li>左子树出栈完成之后根节点出栈</li>\n<li>右子树入栈</li>\n<li>循环直至栈为空</li>\n</ol>\n<p>栈的设计</p>\n<ul>\n<li>根节点入栈出栈两次\n<ul>\n<li>第一次出栈时不能被访问，立刻重新入栈，并将左子树入栈</li>\n<li>第二次出栈后返回值，并且将右子树入栈</li>\n</ul></li>\n<li>对于根节点要记住\n<ul>\n<li>在哪棵树上</li>\n<li>第几次出栈</li>\n</ul></li>\n<li>每个节点在某种意义上都是根节点</li>\n</ul>\n<h6 id=\"stnode-类定义\"><code>StNode</code> 类定义</h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">StNode</span><br>&#123;<br>  Node *node;<br>  <span class=\"hljs-type\">int</span> TimesPop;<br>  <span class=\"hljs-built_in\">StNode</span>(Node *N=<span class=\"hljs-literal\">nullptr</span>):<span class=\"hljs-built_in\">node</span>(N),<span class=\"hljs-built_in\">TimesPop</span>(<span class=\"hljs-number\">0</span>)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h6 id=\"中序遍历的非递归实现\">中序遍历的非递归实现</h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">midOrder</span>(<span class=\"hljs-type\">const</span> binaryTree&lt;T&gt;::Node *t) <span class=\"hljs-type\">const</span><br>&#123;<br>  linkStack&lt;Node *t&gt; s;<br>  <span class=\"hljs-function\">StNode <span class=\"hljs-title\">current</span><span class=\"hljs-params\">(root)</span></span>;<br><br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n中序遍历：&quot;</span>;<br>  s.<span class=\"hljs-built_in\">push</span>(current);<br>  <span class=\"hljs-keyword\">while</span>(!s.<span class=\"hljs-built_in\">isEmpty</span>())<br>  &#123;<br>    current = s.<span class=\"hljs-built_in\">pop</span>();<br>    <span class=\"hljs-keyword\">if</span> (++current.TimesPop == <span class=\"hljs-number\">2</span>)<br>    &#123;<br>      cout &lt;&lt; current.node -&gt; data;<br>      <span class=\"hljs-keyword\">if</span> (current.node -&gt; right != <span class=\"hljs-literal\">nullptr</span>)<br>      &#123;<br>        s.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">StNode</span>(current.node -&gt; right));<br>      &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      s.<span class=\"hljs-built_in\">push</span>(current);<br>      <span class=\"hljs-keyword\">if</span> (current.node -&gt; left != <span class=\"hljs-literal\">nullptr</span>)<br>      &#123;<br>        s.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">StNode</span>(current.node -&gt; left));<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"后序遍历-2\">后序遍历</h5>\n<ol type=\"1\">\n<li>根节点入栈</li>\n<li>左子树入栈</li>\n<li>右子树入栈</li>\n<li>栈顶元素出栈并输出值</li>\n<li>循环直至栈为空</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> binaryTree&lt;T&gt;::<span class=\"hljs-built_in\">postOrder</span>(<span class=\"hljs-type\">const</span> binaryTree&lt;T&gt;::Node *t) <span class=\"hljs-type\">const</span><br>&#123;<br>  linkStack&lt;Node *&gt; s;<br>  <span class=\"hljs-function\">StNode <span class=\"hljs-title\">current</span><span class=\"hljs-params\">(root)</span></span>;<br><br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n后序遍历：&quot;</span>;<br>  s.<span class=\"hljs-built_in\">push</span>(current);<br>  <span class=\"hljs-keyword\">while</span>(!s.<span class=\"hljs-built_in\">isEmpty</span>())<br>  &#123;<br>    current = s.<span class=\"hljs-built_in\">pop</span>();<br>    <span class=\"hljs-keyword\">if</span> (++current.TimesPop == <span class=\"hljs-number\">3</span>)<br>    &#123;<br>      cout &lt;&lt; current.node -&gt; data;<br>      <span class=\"hljs-keyword\">continue</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      s.<span class=\"hljs-built_in\">push</span>(current);<br>      <span class=\"hljs-keyword\">if</span> (current.node -&gt; right != <span class=\"hljs-literal\">nullptr</span>)<br>      &#123;<br>        s.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">StNode</span>(current.node -&gt; right));<br>      &#125;<br>      <span class=\"hljs-keyword\">if</span> (current.node -&gt; left != <span class=\"hljs-literal\">nullptr</span>)<br>      &#123;<br>        s.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">StNode</span>(current.node -&gt; left));<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"哈夫曼树和哈夫曼编码\">哈夫曼树和哈夫曼编码</h3>\n<h4 id=\"字符的机内表示\">字符的机内表示</h4>\n<ul>\n<li>用二进制数来表示字符</li>\n<li>前缀编码\n<ul>\n<li>字符只放在叶结点中</li>\n<li>字符编码可以有不同的长度</li>\n<li>每个字符的编码都不可能是其他字符编码的前缀</li>\n<li>可以被唯一解码</li>\n</ul></li>\n</ul>\n<h4 id=\"哈夫曼树\">哈夫曼树</h4>\n<ul>\n<li>最小代价，即带权路径长度最小的二叉树</li>\n<li>所有字符都在叶结点上</li>\n<li>权值大的字符离根节点近，权值小的字符离根节点远</li>\n<li>哈夫曼编码是一种前缀编码</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141528425.png\"\nalt=\"huffmanTree\" />\n<figcaption aria-hidden=\"true\">huffmanTree</figcaption>\n</figure>\n<h4 id=\"哈夫曼算法\">哈夫曼算法</h4>\n<ol type=\"1\">\n<li>给定一个具有 <span class=\"math inline\"><em>n</em></span> 个权值\n<span\nclass=\"math inline\">{<em>w</em><sub>1</sub>, <em>w</em><sub>2</sub>, …, <em>w</em><sub>4</sub>}</span>\n的节点的集合 <span class=\"math inline\">𝔸</span> <span\nclass=\"math inline\">𝔽 = {<em>T</em><sub>1</sub>, <em>T</em><sub>2</sub>, …, <em>T</em><sub><em>n</em></sub>}</span></li>\n<li>初始时，设集合 <span class=\"math inline\">𝔸 = 𝔽</span></li>\n<li>执行从 <span class=\"math inline\"><em>i</em></span> 到 <span\nclass=\"math inline\"><em>n</em> − 1</span> 的循环\n<ol type=\"1\">\n<li>从当前集合中选取权值最小、次最小的两个节点，以这两个节点作为内部节点\n<span class=\"math inline\"><em>b</em><sub><em>i</em></sub></span>\n的左右儿子，<span\nclass=\"math inline\"><em>b</em><sub><em>i</em></sub></span>\n的权值为这两个节点的权值之和</li>\n<li>集合中去除这两个节点，将 <span\nclass=\"math inline\"><em>b</em><sub><em>i</em></sub></span> 加入其中</li>\n</ol></li>\n<li>循环结束后，集合 <span class=\"math inline\">𝔸</span>中只剩下一个节点\n<span\nclass=\"math inline\"><em>b</em><sub><em>n</em></sub></span>，即为哈夫曼树的根节点</li>\n</ol>\n<h4 id=\"哈夫曼编码\">哈夫曼编码</h4>\n<ul>\n<li>每个节点的编码是从根节点到该节点的路径</li>\n<li>左子树为 <code>0</code>，右子树为 <code>1</code></li>\n</ul>\n<h4 id=\"哈夫曼树类的实现\">哈夫曼树类的实现</h4>\n<ol type=\"1\">\n<li>接受一组符号以及对应的权值,并返回每个符号对应的哈夫曼编码</li>\n<li>有两个公有的成员函数\n<ol type=\"1\">\n<li>构造函数：接受一组待编码的符号以及它们的权值，构造哈夫曼树</li>\n<li><code>getCode</code>：根据保存的哈夫曼树，返回每个符号对应的哈夫曼编码</li>\n</ol></li>\n</ol>\n<h5 id=\"哈夫曼树的存储\">哈夫曼树的存储</h5>\n<ul>\n<li>在哈夫曼树中，每个要编码的元素都是一个叶节点，其余的节点都是度为\n<span class=\"math inline\">2</span> 的节点</li>\n<li>若待编码的元素个数为 <span\nclass=\"math inline\"><em>n</em></span>，则哈夫曼树的节点数为 <span\nclass=\"math inline\">2<em>n</em> − 1</span></li>\n<li>哈夫曼树使用一个大小为 <span class=\"math inline\">2<em>n</em></span>\n的数组来存储，不使用 <span class=\"math inline\">0</span>\n节点，将根节点存储在下标为 <span class=\"math inline\">1</span>\n的位置，叶节点依次存储在下标为 <span\nclass=\"math inline\"><em>n</em> + 1</span> 到 <span\nclass=\"math inline\">2<em>n</em></span> 的位置，<span\nclass=\"math inline\">0</span> 结点作为结束的判断依据</li>\n<li>每个数组保存\n<strong>节点的数据</strong>，<strong>节点的权值</strong>，<strong>节点的父节点下标</strong>，<strong>左子节点下标</strong>，<strong>右子节点下标</strong></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Type</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">hfTree</span><br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span><br>    &#123;<br>      Type data; <span class=\"hljs-comment\">//节点数据</span><br>      <span class=\"hljs-type\">int</span> weight; <span class=\"hljs-comment\">//节点权值</span><br>      <span class=\"hljs-type\">int</span> parent; <span class=\"hljs-comment\">//父节点下标</span><br>      <span class=\"hljs-type\">int</span> left , right; <span class=\"hljs-comment\">//左右子节点下标</span><br>    &#125;;<br><br>    Node *elem;<br>    <span class=\"hljs-type\">int</span> length;<br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">hfCode</span><br>    &#123;<br>      Type data; <span class=\"hljs-comment\">//节点数据</span><br>      string code; <span class=\"hljs-comment\">//哈夫曼编码</span><br>    &#125;;<br><br>    <span class=\"hljs-built_in\">hfTree</span>(<span class=\"hljs-type\">const</span> Type *v , <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *w , <span class=\"hljs-type\">int</span> size);<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">getCode</span><span class=\"hljs-params\">(hfCode result[])</span></span>;<br>    ~<span class=\"hljs-built_in\">hfTree</span>()<br>    &#123;<br>      <span class=\"hljs-keyword\">delete</span> [] elem;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h5 id=\"构造函数-8\">构造函数</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Type</span>&gt;<br>hfTree&lt;Type&gt;::<span class=\"hljs-built_in\">hfTree</span>(<span class=\"hljs-type\">const</span> Type *v , <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *w , <span class=\"hljs-type\">int</span> size)<br>&#123;<br>  <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> MAX_INT = <span class=\"hljs-number\">32767</span>;<br>  <span class=\"hljs-type\">int</span> min1 , min2; <span class=\"hljs-comment\">// 最小树、次最小树的权值</span><br>  <span class=\"hljs-type\">int</span> x , y ; <span class=\"hljs-comment\">// 最小树、次最小树的下标</span><br><br>  <span class=\"hljs-comment\">/* 初始化 */</span><br>  length = <span class=\"hljs-number\">2</span> * size ;                                            <span class=\"hljs-comment\">// 哈夫曼树的节点数为 $2\\text&#123;size&#125;-1$，但我们只需要存储 $2\\text&#123;size&#125;$ 个节点</span><br>  elem = <span class=\"hljs-keyword\">new</span> Node[length];                                       <span class=\"hljs-comment\">// 创建一个大小为 $2\\text&#123;size&#125;$ 的数组来存储哈夫曼树的节点</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = size ; i &lt; length ; i++)                          <span class=\"hljs-comment\">// 对数组 `elem` 中的节点进行初始化，前 $\\text&#123;size&#125;$ 个节点存储待编码的元素，从下标 `size` 开始，依次存储待编码的元素的权值</span><br>  &#123;<br>    elem[i].weight = w[i-size]; <span class=\"hljs-comment\">// 储存权值</span><br>    elem[i].data = v[i-size]; <span class=\"hljs-comment\">// 储存待编码的元素</span><br>    elem[i].parent = elem[i].left = elem[i].right = <span class=\"hljs-number\">0</span>;           <span class=\"hljs-comment\">// 初始化父节点、左子节点和右子节点的下标为 `0`</span><br>  &#125;<br><br>  <span class=\"hljs-comment\">/* 构造新的二叉树 */</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = size - <span class=\"hljs-number\">1</span> ; i &gt; <span class=\"hljs-number\">0</span> ; i--)                           <span class=\"hljs-comment\">// 从下标为 `size-1` 的节点开始，依次向上构造哈夫曼树的节点</span><br>  &#123;<br>    min1 = min2 = MAX_INT;                                       <span class=\"hljs-comment\">// 初始化这两个变量为一个很大的值，以确保能够找到真正最小和次小的权值</span><br>    x = y = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = i + <span class=\"hljs-number\">1</span> ; j &lt; length ; j++)                       <span class=\"hljs-comment\">// 遍历当前节点之后的所有节点</span><br>    &#123;<br>      <span class=\"hljs-keyword\">if</span> (elem[j].parent == <span class=\"hljs-number\">0</span>)                                   <span class=\"hljs-comment\">// 判断是否未加入树中</span><br>      &#123;<br>        <span class=\"hljs-keyword\">if</span> (elem[j].weight &lt; min1)                               <span class=\"hljs-comment\">// 找到真正的最小值和次小值以及他们对应的下标</span><br>        &#123;<br>          min2 = min1;<br>          min1 = elem[j].weight;<br>          x = y;<br>          y = j;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(elem[j].weight &lt; min2)<br>        &#123;<br>          min2 = elem[j].weight;<br>          x = j;<br>        &#125;<br>      &#125;<br>    &#125;<br>    elem[i].weight = min1 + min2;                                <span class=\"hljs-comment\">// 将最小值和次小值的权值相加，作为当前节点的权值</span><br>    elem[i].left = x;                                            <span class=\"hljs-comment\">// 将最小值的节点作为当前节点的左子节点</span><br>    elem[i].right = y;                                           <span class=\"hljs-comment\">// 将次小值的节点作为当前节点的右子节点</span><br>    elem[x].parent = i;                                          <span class=\"hljs-comment\">// 将当前节点作为最小值节点的父节点</span><br>    elem[y].parent = i;                                          <span class=\"hljs-comment\">// 将当前节点作为次小值节点的父节点</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"getcode\"><code>getCode</code></h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Type</span>&gt;<br><span class=\"hljs-type\">void</span> hdTree&lt;Type&gt;::<span class=\"hljs-built_in\">getcode</span>(hfCode result[])<br>&#123;<br>  <span class=\"hljs-type\">int</span> size = length / <span class=\"hljs-number\">2</span> ;<br>  <span class=\"hljs-type\">int</span> p , s ;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = size; i &lt; length; ++i)<br>  &#123;<br>    result[i -size].data = elem[i].data;<br>    result[i -size].code = <span class=\"hljs-string\">&quot;&quot;</span>;<br>    p = elem[i].parent; s = i;<br>    <span class=\"hljs-keyword\">while</span> (p)<br>    &#123;<br>      <span class=\"hljs-keyword\">if</span> (elem[p].left == s)<br>      &#123;<br>        result[i -size].code = <span class=\"hljs-string\">&#x27;0&#x27;</span> + result[i -size].code;<br>      &#125;<br>      <span class=\"hljs-keyword\">else</span><br>      &#123;<br>        result[i -size].code = <span class=\"hljs-string\">&#x27;1&#x27;</span> + result[i -size].code;<br>      &#125;<br>      s = p;<br>      p = elem[p].parent;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"树和森林\">树和森林</h3>\n<h4 id=\"树的存储实现\">树的存储实现</h4>\n<ul>\n<li><strong>标准形式</strong>：除了数据字段之外，还有 <span\nclass=\"math inline\"><em>K</em></span> 个指针字段，指向 <span\nclass=\"math inline\"><em>K</em></span> 个孩子节点，其中 <span\nclass=\"math inline\"><em>K</em></span> 是树的度</li>\n<li><strong>广义标准形式</strong>：除了数据字段之外，还有 <span\nclass=\"math inline\"><em>K</em></span> 个指针字段，指向 <span\nclass=\"math inline\"><em>K</em></span>\n个孩子节点和一个指针字段，指向父节点</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504211450009.png\"\nalt=\"树的存储实现\" />\n<figcaption aria-hidden=\"true\">树的存储实现</figcaption>\n</figure>\n<h4 id=\"树的表示方法\">树的表示方法</h4>\n<h5 id=\"孩子链表示法\">孩子链表示法</h5>\n<ul>\n<li><p>每个节点的所有孩子组织成一个链表</p></li>\n<li><p>节点由两个部分组成</p>\n<ul>\n<li>储存数据元素值的数据部分</li>\n<li>指向孩子链的指针</li>\n</ul></li>\n<li><p><strong>静态</strong>的孩子链表：树的所有节点存放在一个名叫表头数组的<strong>数组</strong>中</p></li>\n<li><p><strong>动态</strong>的孩子链表：树的所有节点组织成一个<strong>链表</strong></p></li>\n</ul>\n<h5 id=\"孩子兄弟链表示法\">孩子兄弟链表示法</h5>\n<ul>\n<li>将一棵树转化为二叉树</li>\n<li>左子树指向第一颗子树树根的指针</li>\n<li>右子树指向兄弟节点的指针</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504211559361.png\"\nalt=\"孩子兄弟链\" />\n<figcaption aria-hidden=\"true\">孩子兄弟链</figcaption>\n</figure>\n<h5 id=\"双亲表示法\">双亲表示法</h5>\n<ul>\n<li>每一个节点由两个部分组成\n<ul>\n<li>储存数据元素的数据字段</li>\n<li>储存父节点的父指针字段</li>\n</ul></li>\n<li>便于查找节点的祖先，但是不便于查找指定节点的子孙</li>\n</ul>\n<h3 id=\"树的遍历\">树的遍历</h3>\n<h4 id=\"前序遍历-3\">前序遍历</h4>\n<ol type=\"1\">\n<li>访问根节点</li>\n<li>依次前序遍历所有子树</li>\n</ol>\n<h4 id=\"后序遍历-3\">后序遍历</h4>\n<ol type=\"1\">\n<li>依次后序遍历所有子树</li>\n<li>访问根节点</li>\n</ol>\n<h4 id=\"层次遍历-2\">层次遍历</h4>\n<ol type=\"1\">\n<li>访问根节点</li>\n<li>若第 <span class=\"math inline\"><em>i</em></span> 层已被访问，且第\n<span class=\"math inline\"><em>i</em> + 1</span>\n层的结点尚未被访问，则从左到右依次访问第 <span\nclass=\"math inline\"><em>i</em> + 1</span> 层的结点</li>\n</ol>\n<h4 id=\"特点\">特点</h4>\n<ul>\n<li>树的前序遍历和用儿子兄弟链表示法转化的二叉树的前序遍历是相同的</li>\n<li>树的后序遍历和用儿子兄弟链表示法转化的二叉树的中序遍历是相同的</li>\n</ul>\n<p>由前序遍历和后序遍历可以唯一确定一棵树</p>\n<h3 id=\"树森林和二叉树\">树、森林和二叉树</h3>\n<h4 id=\"森林的定义\">森林的定义</h4>\n<ul>\n<li>森林通常被定义为树的集合或树的序列</li>\n<li>存储\n<ul>\n<li>存储森林的每一棵树</li>\n<li>表示这些树属于同一个森林</li>\n</ul></li>\n</ul>\n<h4 id=\"森林的二叉树存储\">森林的二叉树存储</h4>\n<ol type=\"1\">\n<li>将每棵树 <span\nclass=\"math inline\"><em>T</em><sub><em>i</em></sub></span> 转化为二叉树\n<span class=\"math inline\"><em>B</em><sub><em>i</em></sub></span></li>\n<li>将 <span class=\"math inline\"><em>B</em><sub><em>i</em></sub></span>\n作为 <span\nclass=\"math inline\"><em>B</em><sub><em>i</em> − 1</sub></span>\n根节点的右子树</li>\n</ol>\n<h2 id=\"优先级队列\">优先级队列</h2>\n<h3 id=\"优先级队列的定义\">优先级队列的定义</h3>\n<ul>\n<li>节点之间的关系是由节点的优先级决定的</li>\n<li>优先级高的先出队，优先级低的后出队</li>\n<li>继承于队列的抽象类</li>\n</ul>\n<h3 id=\"优先级队列的简单实现\">优先级队列的简单实现</h3>\n<ol type=\"1\">\n<li>入队时进行排序，出队操作不变 入队时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>)</span>，出队时间复杂度为\n<span class=\"math inline\"><em>O</em>(1)</span></li>\n<li>出队时进行排序，入队操作不变 入队时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(1)</span>，出队时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>)</span></li>\n</ol>\n<h3 id=\"二叉堆\">二叉堆</h3>\n<ul>\n<li>二叉堆是一个完全二叉树</li>\n<li>二叉堆满足下述关系之一（下标是按层次遍历的次序）\n<ol type=\"1\">\n<li><strong>最大化堆</strong>：<span class=\"math inline\">$k_i &gt;\nk_{2i},\\quad k_i &gt; k{2i+1} \\quad (i = 1,2,\\ldots,\\lfloor\n\\frac{n}{2}\\rfloor$</span></li>\n<li><strong>最小化堆</strong>：<span class=\"math inline\">$k_i &lt;\nk_{2i},\\quad k_i &lt; k{2i+1} \\quad (i = 1,2,\\ldots,\\lfloor\n\\frac{n}{2}\\rfloor)$</span></li>\n</ol></li>\n<li>后面的讨论都以最小化堆为例</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504081709343.png\"\nalt=\"binaryHeap\" />\n<figcaption aria-hidden=\"true\">binaryHeap</figcaption>\n</figure>\n<h4 id=\"二叉堆的特性\">二叉堆的特性</h4>\n<ul>\n<li><strong>结构性</strong>\n<ul>\n<li>符合完全二叉树的结构</li>\n</ul></li>\n<li><strong>有序性</strong>\n<ul>\n<li>父节点小于子节点（最小化堆）</li>\n<li>父节点大于子节点（最大化堆）</li>\n</ul></li>\n</ul>\n<h3 id=\"基于二叉堆的优先级队列\">基于二叉堆的优先级队列</h3>\n<ul>\n<li>如果数值越小，优先级越高，则可以用一个最小化堆存储优先级队列</li>\n<li>最小化堆中，最小元素为根元素，存放在数组下标为 <code>1</code> 的位置\n<ul>\n<li>获取队头元素的操作为返回下标为 <code>1</code> 的元素值</li>\n<li>出队操作为删除下标为 <code>1</code> 的元素，重新调整堆</li>\n<li>入队操作为将新元素插入到堆的最后一个位置，然后向上调整堆</li>\n</ul></li>\n</ul>\n<h3 id=\"优先级队列类的定义\">优先级队列类的定义</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">priorityQueue</span>:<span class=\"hljs-keyword\">public</span> quque&lt;T&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> currentSize;<br>    T *array;<br>    <span class=\"hljs-type\">int</span> maxSize;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">doubleSpace</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\">voif <span class=\"hljs-title\">buildHeap</span><span class=\"hljs-params\">()</span></span>;  <span class=\"hljs-comment\">// 建堆，被 priorityQueue() 调用</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">percolateDown</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> hole)</span></span>; <span class=\"hljs-comment\">// 向下过滤</span><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">priorityQueue</span>(<span class=\"hljs-type\">int</span> capacity = <span class=\"hljs-number\">100</span>) <span class=\"hljs-comment\">// 构造函数</span><br>    &#123;<br>      array = <span class=\"hljs-keyword\">new</span> T[capacity];<br>      maxSize = capacity;<br>      currentSize = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-built_in\">priorityQueue</span>(<span class=\"hljs-type\">const</span> T data[] , <span class=\"hljs-type\">int</span> size); <span class=\"hljs-comment\">// 构造函数</span><br>    ~<span class=\"hljs-built_in\">priorityQueue</span>(); <span class=\"hljs-comment\">// 析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-comment\">// 是否为空</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> currentSize == <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">enQueue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T &amp;x)</span></span>; <span class=\"hljs-comment\">//入队</span><br>    <span class=\"hljs-function\">T <span class=\"hljs-title\">deQueue</span><span class=\"hljs-params\">()</span></span>; <span class=\"hljs-comment\">// 出队</span><br>    <span class=\"hljs-function\">T <span class=\"hljs-title\">getHead</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-comment\">// 获取队头元素</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> array[<span class=\"hljs-number\">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"enqueue-2\"><code>enQueue</code></h4>\n<ul>\n<li>在堆中插入一个新元素</li>\n<li>在最大序号中的元素之后插入新的元素或者节点</li>\n<li>如果没有违反堆的<strong>有序性</strong>，则操作结束，否则向父节点移动，直到满足有序性或者到达根节点</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> priorityQueue&lt;T&gt;::<span class=\"hljs-built_in\">enQueue</span>(<span class=\"hljs-type\">const</span> T &amp;x)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (currentSize == maxSize - <span class=\"hljs-number\">1</span>)<br>  &#123;<br>    <span class=\"hljs-built_in\">doubleSpace</span>();<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 向上过滤</span><br>  <span class=\"hljs-type\">int</span> hole = ++currentSize;<br>  <span class=\"hljs-keyword\">for</span> (;hole &gt; <span class=\"hljs-number\">1</span> &amp;&amp; x &lt; array[hole/<span class=\"hljs-number\">2</span>] ; hole /= <span class=\"hljs-number\">2</span>)<br>  &#123;<br>    array[hole] = array[hole/<span class=\"hljs-number\">2</span>];<br>  &#125;<br>  array[hole] = x;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>最坏情况时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(log <em>n</em>)</span></li>\n<li>平均情况来说，过滤会提前结束。资料表明平均为 <span\nclass=\"math inline\">2.6</span> 次比较，即平均上移 <span\nclass=\"math inline\">1.6</span> 层</li>\n</ul>\n<h4 id=\"dequeue-2\"><code>deQueue</code></h4>\n<ul>\n<li>删除堆顶元素，同时删除最后一个节点，以满足是完全二叉树</li>\n<li>空节点向下过滤，找到一个较小的子节点，将该儿子放入空节点，空节点向下推一层，直至删除的节点能够被放入空节点</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br>T priorityQueue&lt;T&gt;::<span class=\"hljs-built_in\">deQueue</span>()<br>&#123;<br>  T minItem;<br>  minItem = array[<span class=\"hljs-number\">1</span>];<br>  array[<span class=\"hljs-number\">1</span>] = array[currentSize--];<br>  <span class=\"hljs-built_in\">percolateDown</span>(<span class=\"hljs-number\">1</span>);<br>  <span class=\"hljs-keyword\">return</span> minItem;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"percolatedown\"><code>percolateDown</code></h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-type\">void</span> priorityQueue&lt;T&gt;::<span class=\"hljs-built_in\">precolateDown</span>(<span class=\"hljs-type\">int</span> hole)<br>&#123;<br>  <span class=\"hljs-type\">int</span> child;<br>  T tmp = array[hole];<br><br>  <span class=\"hljs-keyword\">for</span> (;hole * <span class=\"hljs-number\">2</span> &lt;= currentSize; hole = child)<br>  &#123;<br>    child = hole * <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">if</span> (child != currentSIze &amp;&amp; array[child + <span class=\"hljs-number\">1</span>] &lt; array[child])<br>    &#123;<br>      child++;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (array[child] &lt; tmp)<br>    &#123;<br>      array[hole] = array[child];<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>  &#125;<br>  array[hole] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"buildheap\"><code>buildHeap</code></h4>\n<h5 id=\"连续插入\">连续插入</h5>\n<ul>\n<li>时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>log <em>n</em>)</span></li>\n</ul>\n<h5 id=\"自上而下调整二叉树\">自上而下调整二叉树</h5>\n<ul>\n<li>对左子树和右子树递归调用\n<code>buildHeaap</code>，再对根节点向下过滤</li>\n<li>时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>)</span></li>\n</ul>\n<h5 id=\"非递归实现-1\">非递归实现</h5>\n<p>从编号最大的非叶节点 <span class=\"math inline\">$\\lfloor \\frac{n}{2}\n\\rfloor$</span> 开始逆层次遍历，每个节点调用\n<code>percolateDown</code>，直到根节点</p>\n<h2 id=\"集合与静态查找表\">集合与静态查找表</h2>\n<h3 id=\"集合的基本概念\">集合的基本概念</h3>\n<ol type=\"1\">\n<li>数据元素除了属于同一集合之外，没有任何逻辑关系</li>\n<li>每个数据元素有一个区别于其他元素的唯一标识，称为<strong>键值</strong>或者<strong>关键字值</strong></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span>&lt;calss KEY , <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">SET</span><br>&#123;<br>  KEY key; <span class=\"hljs-comment\">// 关键字值</span><br>  OTHER other; <span class=\"hljs-comment\">// 其他信息</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>运算</p>\n<ul>\n<li><strong>查找</strong> 某一元素是否存在</li>\n<li>将集合中的元素按照它的唯一标识排序</li>\n</ul>\n<p>这些都是对 <code>key</code> 的操作</p>\n<h3 id=\"集合的存储\">集合的存储</h3>\n<ul>\n<li>任何容器都能存储集合</li>\n<li>常用的表达形式是借鉴于<strong>线性表</strong>和<strong>树</strong></li>\n<li>唯一一个仅适合于存储和处理集合的数据结构是<strong>散列表</strong></li>\n</ul>\n<h3 id=\"查找\">查找</h3>\n<h4 id=\"查找的基本概念\">查找的基本概念</h4>\n<ul>\n<li>用于查找的集合称之为<strong>查找表</strong></li>\n<li>查找表的分类\n<ul>\n<li>静态查找表</li>\n<li>动态查找表</li>\n<li>内部查找</li>\n<li>外部查找</li>\n</ul></li>\n</ul>\n<h4 id=\"静态查找表\">静态查找表</h4>\n<ul>\n<li>数据元素的个数和值不允许变化的查找表称为静态查找表</li>\n<li>不允许插入和删除操作</li>\n<li>实例：字典</li>\n<li>可以用顺序表 <code>seqList</code> 存储，或直接存储在\nC++的原始数组中</li>\n</ul>\n<h4 id=\"无序表的查找\">无序表的查找</h4>\n<ul>\n<li><p>只能做顺序查找</p></li>\n<li><p>时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>)</span></p></li>\n<li><p>可以使用哨兵减少 <span class=\"math inline\"><em>n</em></span>\n次查找</p></li>\n<li><p>优化后的顺序查找</p></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">seqSearch</span><span class=\"hljs-params\">(SET&lt;KEY, OTHER&gt; data[] , <span class=\"hljs-type\">int</span> size , <span class=\"hljs-type\">const</span> KEY &amp;x)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  data[<span class=\"hljs-number\">0</span>].key = x;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = size ; x != data[i].key; --i)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> i;<br>  &#125;<br>&#125;<br><span class=\"hljs-number\">13</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"有序表的查找\">有序表的查找</h4>\n<h5 id=\"顺序查找\">顺序查找</h5>\n<ul>\n<li><p>与无序表的顺序查找类似，只是当被查元素在表中不存在时，不需要查到表头</p></li>\n<li><p>时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>)</span></p></li>\n<li><p>有序表的顺序查找</p></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">seqSearch</span><span class=\"hljs-params\">(SET&lt;KEY , OTHER&gt; data[] , <span class=\"hljs-type\">int</span> size , <span class=\"hljs-type\">const</span> KEY &amp;x)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  data[<span class=\"hljs-number\">0</span>].key = x;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = size ; x &lt; data[i].key; --i);<br>  <span class=\"hljs-keyword\">if</span> (x == data[i].key)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> i;<br>  &#125;<br><span class=\"hljs-keyword\">else</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"二分查找\">二分查找</h5>\n<ol type=\"1\">\n<li>每次检查中间的元素（向下取整）</li>\n<li>若中间的元素等于要查找的元素，则查找成功</li>\n<li>若中间的元素大于要查找的元素，则在左半部分继续查找</li>\n<li>若中间的元素小于要查找的元素，则在右半部分继续查找</li>\n</ol>\n<ul>\n<li>时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(log <em>n</em>)</span></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">binarySearch</span><span class=\"hljs-params\">(SET&lt;KEY , OTHER&gt;data[] , <span class=\"hljs-type\">int</span> size , <span class=\"hljs-type\">const</span> KEY &amp;x)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> low = <span class=\"hljs-number\">1</span>,  high = size, mid;<br>    <span class=\"hljs-keyword\">while</span> (low &lt;= high)<br>    &#123;                 <span class=\"hljs-comment\">//查找区间存在</span><br>      mid = (low + high) / <span class=\"hljs-number\">2</span>;         <span class=\"hljs-comment\">//计算中间位置</span><br>      <span class=\"hljs-keyword\">if</span> ( x == data[mid].key )<br>      &#123;<br>        <span class=\"hljs-keyword\">return</span> mid;<br>      &#125;<br>      <span class=\"hljs-keyword\">if</span> (x &lt; data[mid].key)<br>      &#123;<br>        high = mid - <span class=\"hljs-number\">1</span>;<br>      &#125;<br>      <span class=\"hljs-keyword\">else</span> low = mid + <span class=\"hljs-number\">1</span>;<br>    &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"插值查找\">插值查找</h5>\n<ul>\n<li>适用于数据分布较为均匀的情况</li>\n<li>计算中间位置的公式为</li>\n</ul>\n<p><span class=\"math display\">$$\n\\text{next} = \\text{low} + \\frac{(x - a[\\text{low}])}{(a[\\text{high}] -\na[\\text{low}])} \\times (\\text{high} - \\text{low}+1)\n$$</span></p>\n<ul>\n<li>缺点：计算量大</li>\n</ul>\n<h5 id=\"分块查找\">分块查找</h5>\n<ul>\n<li>将数据分成若干个块，每个块内可以是有序和无序的，但块之间是有序的</li>\n<li>查找分为两个阶段\n<ol type=\"1\">\n<li>查找索引</li>\n<li>查找块 设表长为 <span class=\"math inline\"><em>n</em></span>，块长为\n<span class=\"math inline\"><em>m</em></span> 则平均所需的时间为 <span\nclass=\"math inline\">$\\frac{m+1}{2}+\\frac{\\frac{n}{m}+1}{2}$</span> 当\n<span class=\"math inline\">$m=\\sqrt{n}$</span>\n时，平均所需的时间<strong>最短</strong>，为 <span\nclass=\"math inline\">$O(\\sqrt{n})$</span></li>\n</ol></li>\n</ul>\n<h2 id=\"动态查找表\">动态查找表</h2>\n<h3 id=\"二叉查找树\">二叉查找树</h3>\n<h4 id=\"抽象类-1\">抽象类</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">dynamicSearchTable</span><br>&#123;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> SET&lt;KEY, OTHER&gt; *<span class=\"hljs-title\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> SET&lt;KEY, OTHER&gt; &amp;x)</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x)</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">dynamicSearchTable</span>() &#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"二叉查找树的定义\">二叉查找树的定义</h4>\n<ul>\n<li>对于任意一个节点 <code>p</code>\n<ul>\n<li><code>p</code> 的左子树中所有节点的值都小于 <code>p</code> 的值</li>\n<li><code>p</code> 的右子树中所有节点的值都大于 <code>p</code> 的值</li>\n<li><code>p</code> 的左子树和右子树都是二叉查找树</li>\n</ul></li>\n<li>二叉查找树的<strong>中序遍历</strong>是排好序的，又称为<strong>排序树</strong></li>\n<li>最大和最小的元素不一定存放在叶节点中，但是最大节点的右子树、最小节点的左子树都是空的</li>\n</ul>\n<h4 id=\"二叉查找树的存储实现\">二叉查找树的存储实现</h4>\n<ul>\n<li>使用二叉链表存储，需要一个指向根节点的数据成员</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BinarySearchTree</span>:<span class=\"hljs-keyword\">public</span> dynamicSearchTable&lt;KEY , OTHER&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">BinaryNode</span><br>    &#123;<br>      SET&lt;KEY, OTHER&gt; data;<br>      BinaryNode*left;<br>      BinaryNode*right;<br>      <span class=\"hljs-built_in\">BinaryNode</span>( <span class=\"hljs-type\">const</span> SET&lt;KEY, OTHER&gt; &amp; thedata,<br>      BinaryNode *lt = <span class=\"hljs-literal\">nullptr</span> , BinaryNode *rt = <span class=\"hljs-literal\">nullptr</span>):<span class=\"hljs-built_in\">data</span>(thedata) , <span class=\"hljs-built_in\">left</span>(lt) , <span class=\"hljs-built_in\">right</span>(rt)&#123;&#125;<br>    &#125;;<br>    BinaryNode*root;<br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">BinarySearchTree</span>();<br>    ~<span class=\"hljs-built_in\">BinarySearchTree</span>();<br>    <span class=\"hljs-function\">SET&lt;KEY, OTHER&gt; *<span class=\"hljs-title\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x)</span> <span class=\"hljs-type\">const</span> </span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> SET&lt;KEY , OTHER&gt; &amp;x )</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x)</span></span>;<br><br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> SET&lt;KEY , OTHER&gt; &amp;x, BinaryNode *&amp;t)</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x , BinaryNode *&amp;t)</span></span>;<br>    <span class=\"hljs-function\">SET&lt;KEY , OTHER&gt; *<span class=\"hljs-title\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x , BinaryNode *t )</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">makeEmpty</span><span class=\"hljs-params\">(BinaryNode *t)</span></span>;<span class=\"hljs-comment\">//析构用，同二叉树的clear</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"二叉查找树的操作\">二叉查找树的操作</h4>\n<h5 id=\"查找-1\">查找</h5>\n<ol type=\"1\">\n<li>检查根节点的关键字值</li>\n<li>如果等于要查找的值，则查找成功，返回根节点地址</li>\n<li>如果小于要查找的值，则在右子树中查找</li>\n<li>如果大于要查找的值，则在左子树中查找</li>\n</ol>\n<ul>\n<li>公有函数 <code>find(const KEY &amp;x)</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *BinarySearchTree&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-type\">const</span> KEY &amp;x ) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">find</span>( x, root );<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>私有辅助函数 <code>find(const KEY &amp;x, BinaryNode *t)</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *BinarySearchTree&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-type\">const</span> KEY &amp;x, BinaryNode *t ) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">nullptr</span> || t-&gt;data.key == x)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> (SET&lt;KEY , OTHER&gt; *)t;<span class=\"hljs-comment\">//强制类型转换</span><br>  &#125;<br>  <span class=\"hljs-keyword\">if</span>(x &lt; t-&gt;data.key)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">find</span>(x , t-&gt;left);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">find</span>(x , t-&gt;right );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"插入\">插入</h5>\n<ul>\n<li><p>若二叉树为空树，则插入的节点为根节点</p></li>\n<li><p>若二叉树非空</p>\n<ul>\n<li>判断是左儿子还是右儿子，作为叶节点插入</li>\n</ul></li>\n<li><p>公有的\n<code>insert(const SET&lt;KEY, OTHER&gt; &amp;x)</code></p></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> BinarySearchTree&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-type\">const</span> SET&lt;KEY , OTHER&gt; &amp;x)<br>&#123;<br>  <span class=\"hljs-built_in\">insert</span>(x, root);<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>私有的\n<code>insert(const SET&lt;KEY, OTHER&gt; &amp;x, BinaryNode *&amp;t)</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> BinarySearchTree&lt;KEY , OTHER&gt;::<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-type\">const</span> SET&lt;KEY , OTHER&gt; &amp;x, BinaryNode *&amp;t)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span>(t == <span class=\"hljs-literal\">nullptr</span>)<br>  t = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">BinaryNode</span>(x , <span class=\"hljs-literal\">nullptr</span> , <span class=\"hljs-literal\">nullptr</span>);<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(x.key&lt; t-&gt;data.key)<br>  &#123;<br>    <span class=\"hljs-built_in\">insert</span>(x, t-&gt;left);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(x.key &gt; t-&gt;data.key)<br>  &#123;<br>    <span class=\"hljs-built_in\">insert</span>(x , t-&gt;right);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    cout &lt;&lt; x.key &lt;&lt; “is exist” &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h5 id=\"删除\">删除</h5>\n<ul>\n<li><p><span class=\"math inline\"><em>P</em><sub><em>L</em></sub></span>\n和 <span class=\"math inline\"><em>P</em><sub><em>R</em></sub></span>\n分别是 <span class=\"math inline\"><em>P</em></span> 的左子树和右子树</p>\n<ol type=\"1\">\n<li>如果 <span class=\"math inline\"><em>P</em></span>\n是叶节点，则直接删除</li>\n<li>如果 <span class=\"math inline\"><em>P</em></span> 只有一个子树，则将\n<span class=\"math inline\"><em>P</em></span> 的父节点指向 <span\nclass=\"math inline\"><em>P</em></span> 的子树</li>\n<li>如果 <span class=\"math inline\"><em>P</em></span> 有两个子树，则\n<ol type=\"1\">\n<li>找到 <span class=\"math inline\"><em>P</em></span>\n的右子树中最左的节点或者左子树的最右节点 <span\nclass=\"math inline\"><em>Q</em></span></li>\n<li>将 <span class=\"math inline\"><em>Q</em></span> 的值赋给 <span\nclass=\"math inline\"><em>P</em></span></li>\n<li>删除 <span class=\"math inline\"><em>Q</em></span> 节点</li>\n</ol></li>\n</ol></li>\n<li><p>公有的 <code>remove(const KEY &amp;x)</code></p></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> BinarySearchTree&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-type\">const</span> KEY &amp;x)<br>&#123;<br>  <span class=\"hljs-built_in\">remove</span>(x , root);<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>私有的\n<code>remove(const KEY &amp;x, BinaryNode *&amp;t)</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> BinarySearchTree&lt;KEY , OTHER&gt;::<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-type\">const</span> KEY &amp;x , BinaryNode *&amp;t)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span>(t == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    cout &lt;&lt; x.key &lt;&lt; <span class=\"hljs-string\">&quot;is not exist&quot;</span> &lt;&lt; endl;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(x.key &lt; t-&gt;data.key)<br>  &#123;<br>    <span class=\"hljs-built_in\">remove</span>(x , t-&gt;left);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(x.key &gt; t-&gt;data.key)<br>  &#123;<br>    <span class=\"hljs-built_in\">remove</span>(x , t-&gt;right);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(t-&gt;left != <span class=\"hljs-literal\">nullptr</span> &amp;&amp; t-&gt;right != <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    BinaryNode *p = t-&gt;right;<br>    <span class=\"hljs-keyword\">while</span>(p-&gt;left != <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>      p = p-&gt;left;<br>    &#125;<br>    t-&gt;data = p-&gt;data;<br>    <span class=\"hljs-built_in\">remove</span>(p-&gt;data.key , t-&gt;right);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    BinaryNode *oldNode = t;<br>    t = (t-&gt;left != <span class=\"hljs-literal\">nullptr</span>) ? t-&gt;left : t-&gt;right;<br>    <span class=\"hljs-keyword\">delete</span> oldNode;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"二叉查找树的性能\">二叉查找树的性能</h4>\n<ul>\n<li>二叉查找树的操作的时间复杂度为树的高度</li>\n<li>如果二叉查找树是平衡的，则访问的代价是 <span\nclass=\"math inline\"><em>O</em>(log <em>n</em>)</span></li>\n<li>最坏的情况下，二叉查找树会退化成一个单链表，时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>)</span></li>\n</ul>\n<p><strong>平均性能</strong></p>\n<p>具有 <span class=\"math inline\"><em>n</em></span>\n个节点的二叉查找树可能有 <span class=\"math inline\"><em>n</em></span>\n种不同的形态 <span\nclass=\"math inline\">(0, 1, <em>n</em> − 1), (1, 1<em>n</em> − 2), (2, 1, <em>n</em> − 3), …, (<em>n</em> − 1, 1, 0)</span>\n若设这些形态出现的概率是相同的，设 <span\nclass=\"math inline\"><em>P</em>(<em>n</em>)</span> 为查找 <span\nclass=\"math inline\"><em>n</em></span>\n个节点的二叉查找树的平均查找时间，则有如下递归关系式：</p>\n<p><span class=\"math display\">$$\nP(n) = \\frac{\\sum_{i = 0}^{n-1} \\left[ 1 + (P(i)+1) \\cdot i + (P( n - i\n- 1)+1)\\cdot (n-i-1)\\right]}{n} \\leq 2(1 + \\frac{1}{n})\\ln{n} \\approx\n1.33 \\log{n}\n$$</span></p>\n<h3 id=\"avl-树\">AVL 树</h3>\n<h4 id=\"avl-树的定义\">AVL 树的定义</h4>\n<ul>\n<li>也叫平衡树\n<ul>\n<li>对于任意一个节点的两棵子树的高度至多相差 1</li>\n</ul></li>\n<li>平衡因子\n<ul>\n<li>节点的左子树的高度减去右子树的高度</li>\n<li>平衡因子只能是 <span class=\"math inline\">−1</span>，<span\nclass=\"math inline\">0</span>，<span class=\"math inline\">1</span></li>\n</ul></li>\n<li>优点\n<ul>\n<li>查找，插入和删除操作的时间复杂度都是 <span\nclass=\"math inline\"><em>O</em>(log <em>n</em>)</span></li>\n</ul></li>\n</ul>\n<h5 id=\"查找性能\">查找性能</h5>\n<ul>\n<li><p>与二叉树的高度成正比</p></li>\n<li><p>定理：</p>\n<ul>\n<li>具有 <span class=\"math inline\"><em>n</em></span>\n个节点的平衡树，高度 <span class=\"math inline\"><em>h</em></span> 满足\n<span\nclass=\"math inline\">log<sub>2</sub>(<em>n</em> + 1) ≤ <em>h</em> ≤ 1.44log<sub>2</sub>(<em>n</em> + 2) − 0.328</span></li>\n<li>因此，平衡二叉树的操作都是 <span\nclass=\"math inline\"><em>O</em>(log <em>n</em>)</span></li>\n</ul></li>\n</ul>\n<h5 id=\"斐波那契树\">斐波那契树</h5>\n<ul>\n<li><p>斐波那契树是平衡树的最坏情况，其每一子树的左右子树高度差都为\n1</p></li>\n<li><p>定义</p>\n<ol type=\"1\">\n<li>空树是高度为 0 的斐波那契树</li>\n<li>单个节点是高度为 1 的斐波那契树</li>\n<li>若 <span\nclass=\"math inline\"><em>T</em><sub><em>h</em> − 1</sub></span> 和 <span\nclass=\"math inline\"><em>T</em><sub><em>h</em> − 2</sub></span>\n分别为高度为 <span class=\"math inline\"><em>h</em> − 1</span> 和 <span\nclass=\"math inline\"><em>h</em> − 2</span> 的斐波那契树，则 <span\nclass=\"math inline\"><em>T</em><sub><em>h</em></sub> = <em>T</em><sub><em>h</em> − 1</sub>, <em>x</em>, <em>T</em><sub><em>h</em> − 2</sub></span>\n是高度为 <span class=\"math inline\"><em>h</em></span> 的斐波那契树</li>\n<li>没有其他的树是斐波那契树</li>\n</ol></li>\n</ul>\n<h6 id=\"斐波那契树的特点\">斐波那契树的特点</h6>\n<p>对于高度为 <span class=\"math inline\"><em>h</em></span>\n的斐波那契树，节点数 <span class=\"math inline\"><em>n</em></span>\n满足</p>\n<ul>\n<li><span class=\"math inline\"><em>n</em><sub>0</sub> = 0</span></li>\n<li><span class=\"math inline\"><em>n</em><sub>1</sub> = 1</span></li>\n<li><span\nclass=\"math inline\"><em>n</em><sub><em>h</em></sub> = <em>n</em><sub><em>h</em> − 1</sub> + <em>n</em><sub><em>h</em> − 2</sub> + 1</span></li>\n</ul>\n<h4 id=\"avl-树的存储实现\">AVL 树的存储实现</h4>\n<ul>\n<li>使用二叉链表</li>\n<li>每个节点必须保存平衡信息\n<ul>\n<li>每棵树的高度</li>\n<li>平衡度即左右子树的高度差</li>\n</ul></li>\n</ul>\n<h5 id=\"avl-树类的实现\">AVL 树类的实现</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;clas KEY,<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AvlTree</span>:<span class=\"hljs-keyword\">public</span> dynamicSearchTable&lt;KEY , OTHER&gt;<br>&#123;<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">AvlNode</span><br>    &#123;<br>      SET&lt;KEY , OTHER&gt; data ; <span class=\"hljs-comment\">// 关键字</span><br>      AvlNode *left , *right; <span class=\"hljs-comment\">// 左右子树指针</span><br>      <span class=\"hljs-type\">int</span> height;            <span class=\"hljs-comment\">// 节点高度</span><br><br>      <span class=\"hljs-built_in\">AvlNode</span>(<span class=\"hljs-type\">const</span> SET&lt;KEY , OTHER&gt; &amp;element , AvlNode *lt ,AvlNode   *rt , <span class=\"hljs-type\">int</span> h = <span class=\"hljs-number\">1</span>):<span class=\"hljs-built_in\">data</span>(elemeent) , <span class=\"hljs-built_in\">left</span>(lt) , <span class=\"hljs-built_in\">right</span>(rt) , <span class=\"hljs-built_in\">height</span>  (h) &#123;&#125; <span class=\"hljs-comment\">// 构造函数</span><br>    &#125;;<br><br>    AvlNode *root; <span class=\"hljs-comment\">// 根节点</span><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">AvlTree</span>() <span class=\"hljs-comment\">// 构造函数</span><br>    &#123;<br>      root = <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br>    ~<span class=\"hljs-built_in\">AvlTree</span>() <span class=\"hljs-comment\">// 析构函数</span><br>    &#123;<br>      <span class=\"hljs-built_in\">makeEmpty</span>(root);<br>    &#125;<br>    <span class=\"hljs-function\">SET&lt;KEY, OTHER&gt; *<span class=\"hljs-title\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x)</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp; x)</span></span>;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">( <span class=\"hljs-type\">const</span> SET&lt;KEY, OTHER&gt; &amp; x, AvlNode * &amp; t )</span> </span>; <span class=\"hljs-comment\">// 插入</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">( <span class=\"hljs-type\">const</span> KEY &amp; x, AvlNode * &amp; t )</span> </span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">makeEmpty</span><span class=\"hljs-params\">( AvlNode *t )</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">height</span><span class=\"hljs-params\">(AvlNode *t)</span> <span class=\"hljs-type\">const</span>  <span class=\"hljs-comment\">// 返回节点的高度</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> t == <span class=\"hljs-literal\">nullptr</span> ? <span class=\"hljs-number\">0</span> : t -&gt; height;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">LL</span><span class=\"hljs-params\">( AvlNode * &amp; t )</span></span>; <span class=\"hljs-comment\">// 左旋</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">RR</span><span class=\"hljs-params\">( AvlNode * &amp; t )</span></span>; <span class=\"hljs-comment\">// 右旋</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">LR</span><span class=\"hljs-params\">( AvlNode * &amp; t )</span></span>; <span class=\"hljs-comment\">// 左右旋</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">RL</span><span class=\"hljs-params\">( AvlNode * &amp; t )</span></span>; <span class=\"hljs-comment\">// 右左旋</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span>     <span class=\"hljs-comment\">// 返回两个数中较大的一个</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> a &gt; b ? a : b;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">adjust</span><span class=\"hljs-params\">(AvlNode *&amp;t, <span class=\"hljs-type\">int</span> subTree)</span></span>; <span class=\"hljs-comment\">//用于删除</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"avl-树的查找\">AVL 树的查找</h4>\n<ul>\n<li>与二叉查找树相同</li>\n<li>二叉查找树类采用递归实现</li>\n<li>AVL 树类展示非递归实现</li>\n</ul>\n<h5 id=\"查找的非递归实现\">查找的非递归实现</h5>\n<ol type=\"1\">\n<li>设当前节点为根节点</li>\n<li>若当前节点非空\n<ol type=\"1\">\n<li>若当前节点的值等于 <code>x</code>，则返回当前节点</li>\n<li>若当前节点的值大于 <code>x</code>，则将当前节点指向左子树</li>\n<li>若当前节点的值小于 <code>x</code>，则将当前节点指向右子树</li>\n</ol></li>\n<li>若当前节点为空，则返回空</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>,<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *AvlTree&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-type\">const</span> KEY &amp; x) <span class=\"hljs-type\">const</span><br>&#123;<br>  AvlNode *t = root; <br>  <span class=\"hljs-keyword\">while</span> (t!=<span class=\"hljs-literal\">nullptr</span> &amp;&amp; t-&gt;data.key != x)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (x &lt; t-&gt;data.key)<br>    &#123;<br>      t = t-&gt;left;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      t = t-&gt;right;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> t-&gt;data;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"avl-树的插入\">AVL 树的插入</h4>\n<ul>\n<li>与二叉查找树相同\n<ul>\n<li>可能改变了根到插入节点的路径上某些节点的平衡度</li>\n<li>需要向上修改树的结构</li>\n</ul></li>\n</ul>\n<h5 id=\"可能引起节点不平衡的情况\">可能引起节点不平衡的情况</h5>\n<ul>\n<li>节点的左孩子的左子树上插入（LL）</li>\n<li>节点的左孩子的右子树上插入（LR）</li>\n<li>节点的右孩子的左子树上插入（RL）</li>\n<li>节点的右孩子的右子树上插入（RR）</li>\n</ul>\n<h5 id=\"重构的方法\">重构的方法</h5>\n<ul>\n<li>指针调整\n<ul>\n<li>按照投影序保持结点相邻关系不变</li>\n<li>辈分可以改变</li>\n</ul></li>\n</ul>\n<h6 id=\"ll-问题\">LL 问题</h6>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141158768.png\"\nalt=\"LL\" />\n<figcaption aria-hidden=\"true\">LL</figcaption>\n</figure>\n<ul>\n<li><strong>左旋</strong>\n<ol type=\"1\">\n<li>将失衡点的左儿子作为新的根节点</li>\n<li>左儿子的右儿子作为原根节点的左儿子</li>\n</ol></li>\n<li>若为 RR\n问题，则将失衡点的右儿子作为新的根节点，右儿子的左儿子作为原根节点的右儿子，称为<strong>右旋</strong></li>\n<li>左旋和右旋统称为<strong>单旋转</strong>，保留了树的有序性和原先的高度</li>\n</ul>\n<h6 id=\"lr-问题\">LR 问题</h6>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141206204.png\"\nalt=\"LR\" />\n<figcaption aria-hidden=\"true\">LR</figcaption>\n</figure>\n<ul>\n<li><strong>双旋转</strong>\n<ol type=\"1\">\n<li>将失衡点的左儿子右旋</li>\n<li>将失衡点左旋</li>\n</ol></li>\n<li>若为 RL 问题，则将失衡点的右儿子左旋，再将失衡点右旋</li>\n<li>先对失衡结点的儿子和孙子进行一次单旋转，使孙子变成儿子。然后是失衡结点和新的儿子进行一次单旋转，使<strong>原先的孙子变成根</strong></li>\n</ul>\n<h5 id=\"私有的insert-函数\">私有的<code>insert</code> 函数</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>,<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> AvlTree&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-type\">const</span> SET&lt;KEY, OTHER&gt; &amp; x, AvlNode * &amp; t)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    t = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">AvlNode</span>(x , <span class=\"hljs-literal\">nullptr</span> , <span class=\"hljs-literal\">nullptr</span>);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (x.key &lt; t-&gt;data.key)<br>  &#123;<br>    <span class=\"hljs-built_in\">insert</span>(x , t-&gt;left);<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">height</span>(t-&gt;left) - <span class=\"hljs-built_in\">height</span>(t-&gt;right) == <span class=\"hljs-number\">2</span>)<br>    &#123;<br>      <span class=\"hljs-keyword\">if</span> (x.key &lt; t-&gt;left-&gt;data.key)<br>      &#123;<br>        <span class=\"hljs-built_in\">LL</span>(t);<br>      &#125;<br>      <span class=\"hljs-keyword\">else</span><br>      &#123;<br>        <span class=\"hljs-built_in\">LR</span>(t);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (x.key &gt; t-&gt;data.key)<br>  &#123;<br>    <span class=\"hljs-built_in\">insert</span>(x , t-&gt;right);<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">height</span>(t-&gt;right) - <span class=\"hljs-built_in\">height</span>(t-&gt;left) == <span class=\"hljs-number\">2</span>)<br>    &#123;<br>      <span class=\"hljs-keyword\">if</span> (x.key &gt; t-&gt;right-&gt;data.key)<br>      &#123;<br>        <span class=\"hljs-built_in\">RR</span>(t);<br>      &#125;<br>      <span class=\"hljs-keyword\">else</span><br>      &#123;<br>        <span class=\"hljs-built_in\">RL</span>(t);<br>      &#125;<br>    &#125;<br>  &#125;<br>  t-&gt;height = <span class=\"hljs-built_in\">max</span>(<span class=\"hljs-built_in\">height</span>(t-&gt;left) , <span class=\"hljs-built_in\">height</span>(t-&gt;right)) + <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 更新高度</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"ll\"><code>LL</code></h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>,<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class=\"hljs-built_in\">LL</span>(AvlNode *&amp; t)<br>&#123;<br>  AvlNode *t1 = t-&gt;left;<br>  t-&gt;left = t1-&gt;right;<br>  t1-&gt;right = t;<br>  t-&gt;height = <span class=\"hljs-built_in\">max</span>(<span class=\"hljs-built_in\">height</span>(t-&gt;left) , <span class=\"hljs-built_in\">height</span>(t-&gt;right)) + <span class=\"hljs-number\">1</span>;<br>  t1-&gt;height = <span class=\"hljs-built_in\">max</span>(<span class=\"hljs-built_in\">height</span>(t1-&gt;left) , <span class=\"hljs-built_in\">height</span>(t1-&gt;right)) + <span class=\"hljs-number\">1</span>;<br>  t = t1;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"rr\"><code>RR</code></h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>,<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class=\"hljs-built_in\">RR</span>(AvlNode *&amp; t)<br>&#123;<br>  AvlNode *t1 = t-&gt;right;<br>  t-&gt;right = t1-&gt;left;<br>  t1-&gt;left = t;<br>  t-&gt;height = <span class=\"hljs-built_in\">max</span>(<span class=\"hljs-built_in\">height</span>(t-&gt;left) , <span class=\"hljs-built_in\">height</span>(t-&gt;right)) + <span class=\"hljs-number\">1</span>;<br>  t1-&gt;height = <span class=\"hljs-built_in\">max</span>(<span class=\"hljs-built_in\">height</span>(t1-&gt;left) , <span class=\"hljs-built_in\">height</span>(t1-&gt;right)) + <span class=\"hljs-number\">1</span>;<br>  t = t1;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"lr\"><code>LR</code></h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>,<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class=\"hljs-built_in\">LR</span>(AvlNode *&amp; t)<br>&#123;<br>  <span class=\"hljs-built_in\">RR</span>(t-&gt;left);<br>  <span class=\"hljs-built_in\">LL</span>(t);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"rl\"><code>RL</code></h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>,<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class=\"hljs-built_in\">RL</span>(AvlNode *&amp; t)<br>&#123;<br>  <span class=\"hljs-built_in\">LL</span>(t-&gt;right);<br>  <span class=\"hljs-built_in\">RR</span>(t);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>所有旋转的算法时间复杂度都是 <span\nclass=\"math inline\"><em>O</em>(1)</span>，且只运行一次，所以\n<code>insert</code> 的时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(log <em>n</em>)</span></p>\n<h4 id=\"avl-树的删除\">AVL 树的删除</h4>\n<ol type=\"1\">\n<li>在 AVL 树上删除节点 <code>x</code>，删除操作和二叉查找树相同</li>\n<li>调整平衡，与插入操作相同</li>\n</ol>\n<h4 id=\"调整\">调整</h4>\n<ul>\n<li>与插入操作相同，失衡节点存在于被删的节点到根节点的路径上。删除一个节点之后，必须沿着到根节点的路径向上回溯，随时调整路径上的节点的平衡度</li>\n<li>删除时无法保证子树在平衡调整之后的高度不变</li>\n<li>递归的删除函数有一个 bool 型的返回值，当返回值为 <code>true</code>\n时，调整停止</li>\n</ul>\n<h4 id=\"五种情况\">五种情况</h4>\n<h5 id=\"情况-a\">情况 a</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191603536.png\"\nalt=\"Sitiationa\" />\n<figcaption aria-hidden=\"true\">Sitiationa</figcaption>\n</figure>\n<p>此时没有失衡，高度也没有改变，返回<code>true</code></p>\n<h5 id=\"情况-b\">情况 b</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191604348.png\"\nalt=\"Situationb\" />\n<figcaption aria-hidden=\"true\">Situationb</figcaption>\n</figure>\n<p>此时没有失衡，但是高度变矮，返回<code>false</code></p>\n<h5 id=\"情况-c\">情况 c</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191607359.png\"\nalt=\"Situationc\" />\n<figcaption aria-hidden=\"true\">Situationc</figcaption>\n</figure>\n<p>经过 RR 旋转后高度变矮，返回<code>false</code></p>\n<h5 id=\"情况-d\">情况 d</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191609189.png\"\nalt=\"Situationd\" />\n<figcaption aria-hidden=\"true\">Situationd</figcaption>\n</figure>\n<p>经过 RL 旋转后高度变矮，返回<code>false</code></p>\n<h5 id=\"情况-e\">情况 e</h5>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191613240.png\"\nalt=\"Situatione\" />\n<figcaption aria-hidden=\"true\">Situatione</figcaption>\n</figure>\n<p>经过 RR 或 RL 旋转后高度不变，返回<code>true</code></p>\n<h4 id=\"删除总结\">删除总结</h4>\n<ul>\n<li>节点删除同二叉查找树。在删除了叶节点或者只有一个孩子的节点后，子树变矮，返回\n<code>false</code></li>\n<li>在每次调用后，检查返回值，如果是 <code>true</code>，则返回\n<code>true</code>，否则分 5 种情况进行处理</li>\n</ul>\n<h4 id=\"私有的-remove-函数\">私有的 <code>remove</code> 函数</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>,<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> AvlTree&lt;KEY , OTHER&gt;::<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-type\">const</span> KEY &amp;x , AvlNOde *&amp;x)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (t = <span class=\"hljs-literal\">nullptr</span>) <span class=\"hljs-comment\">// 被删除节点不存在</span><br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (x == t-&gt; data.key)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (t-&gt;left == <span class=\"hljs-literal\">nullptr</span> || t-&gt; right == <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>      AvlNode *oldNode = t;<br>      t = (t-&gt;left == <span class=\"hljs-literal\">nullptr</span>) ? t-&gt;right : t-&gt;left; <span class=\"hljs-comment\">// 删除节点的孩子节点</span><br>      <span class=\"hljs-keyword\">delete</span> oldNode;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// 删除了一个节点，返回 `false`</span><br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      AvlNode *tmp = t-&gt; right;<br>      <span class=\"hljs-keyword\">while</span> (tmp-&gt;left != <span class=\"hljs-literal\">nullptr</span>) <span class=\"hljs-comment\">// 找到右子树的最小节点</span><br>      &#123;<br>        tmp = tmp-&gt;left;<br>      &#125;<br>      t-&gt;data = tmp.data;<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">remove</span>(tmp-&gt;data,key , t-&gt;right))<br>      &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">adjust</span>(t,<span class=\"hljs-number\">1</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (x &lt; t-&gt;data,key)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">remove</span>(x,t-&gt;left))<br>    &#123;<br>      teturn <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">adjust</span>(t,<span class=\"hljs-number\">0</span>);<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">remove</span>(x , t-&gt;right))<br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">adjust</span>(t,<span class=\"hljs-number\">1</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"adjust\"><code>adjust</code></h4>\n<ul>\n<li>进入调整函数的条件是某棵子树变矮了</li>\n<li>调整函数需要检查节点是否失衡，若失衡则进行相应的调整</li>\n<li>函数的返回值是子树是否变矮\n<ul>\n<li><code>true</code>：子树没有变矮</li>\n<li><code>false</code>：子树变矮</li>\n</ul></li>\n<li>需要传入两个参数\n<ul>\n<li><code>AVlNode *&amp;t</code>：传入的节点</li>\n<li><code>int subTree</code>：参数 <code>t</code> 变矮的子树\n<ul>\n<li><code>0</code>：左子树</li>\n<li><code>1</code>：右子树</li>\n</ul></li>\n</ul></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span> , classs OTHER&gt;<br><span class=\"hljs-type\">bool</span> AvlTree&lt;KEY , OTHER&gt;::<span class=\"hljs-built_in\">adjust</span>(AvlNode *&amp;t , <span class=\"hljs-type\">int</span> SubTree)<br>&#123;<br>  <span class=\"hljs-keyword\">if</span> (subTree) <span class=\"hljs-comment\">// 在右子树上删除</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">height</span>(t-&gt;left) - <span class=\"hljs-built_in\">height</span>(t-&gt;right) == <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// Situation a</span><br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">height</span>(t-&gt;right) == <span class=\"hljs-built_in\">height</span>(t-&gt;left)) <span class=\"hljs-comment\">// Situation b</span><br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">height</span>(t-&gt;left-&gt;right) &gt; <span class=\"hljs-built_in\">height</span>(t-&gt;left-&gt;left)) <span class=\"hljs-comment\">// Situation d</span><br>    &#123;<br>      <span class=\"hljs-built_in\">LR</span>(t);<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>    <span class=\"hljs-built_in\">LL</span>(t); <span class=\"hljs-comment\">// Situation c and e</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">height</span>(t-&gt;left) == <span class=\"hljs-built_in\">height</span>(t-&gt;right))s<br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-comment\">// 在左子树上删除</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">height</span>(t-&gt;right) - <span class=\"hljs-built_in\">height</span>(t-&gt;left) == <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// Situation a</span><br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">height</span>(t-&gt;right) == <span class=\"hljs-built_in\">height</span>(t-&gt;left)) <span class=\"hljs-comment\">// Situation b</span><br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<span class=\"hljs-function\">s</span><br><span class=\"hljs-function\">    <span class=\"hljs-title\">if</span> <span class=\"hljs-params\">(height(t-&gt;right-&gt;left) &gt; height(t-&gt;right-&gt;right))</span> <span class=\"hljs-comment\">// Situation d</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-built_in\">RL</span>(t);<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>    <span class=\"hljs-built_in\">RR</span>(t); <span class=\"hljs-comment\">// Situation c and e</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">height</span>(t-&gt;right) == <span class=\"hljs-built_in\">height</span>(t-&gt;left))<br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"散列表\">散列表</h3>\n<ul>\n<li>也叫哈希表</li>\n<li>通过所求节点的关键字词 <code>KEY</code> 找到这个节点</li>\n<li>时间复杂度为 <span class=\"math inline\"><em>O</em>(1)</span></li>\n</ul>\n<h4 id=\"基本概念\">基本概念</h4>\n<ol type=\"1\">\n<li>初始化 将数组转化为一个特殊的、表示单元为空的值</li>\n<li><code>insert(i)</code> 将 <code>i</code> 存放到\n<code>a[i.key]</code> 中</li>\n<li><code>find(i)</code> 取出 <code>a[i.key]</code> 中的值</li>\n<li><code>remove(i)</code> 将 <code>a[i.key]</code> 中的值置为空</li>\n</ol>\n<h4 id=\"散列函数\">散列函数</h4>\n<p>将一个项映射成一个较小的下标的函数称为散列函数（hush function）</p>\n<ul>\n<li><span\nclass=\"math inline\"><em>D</em> = <em>H</em>(<em>k</em><em>e</em><em>y</em>)</span>\nD 为存储地址，key 为关键值，H 为散列函数</li>\n<li>散列函数的要求\n<ul>\n<li>计算速度快</li>\n<li>散列地址均匀分布</li>\n</ul></li>\n</ul>\n<h4 id=\"常用的散列函数\">常用的散列函数</h4>\n<h5 id=\"直接地址法\">直接地址法</h5>\n<p><span\nclass=\"math inline\"><em>H</em>(<em>k</em><em>e</em><em>y</em>) = <em>k</em><em>e</em><em>y</em></span>\n或 <span\nclass=\"math inline\"><em>H</em>(<em>k</em><em>e</em><em>y</em>) = <em>a</em> × <em>k</em><em>e</em><em>y</em> + <em>b</em></span></p>\n<h5 id=\"除留余数法\"><strong>除留余数法</strong></h5>\n<p><span\nclass=\"math inline\"><em>H</em>(<em>k</em><em>e</em><em>y</em>) = <em>k</em><em>e</em><em>y</em> mod  <em>p</em></span>\n或 <span\nclass=\"math inline\"><em>H</em>(<em>k</em><em>e</em><em>y</em>) = <em>k</em><em>e</em><em>y</em> mod  <em>p</em> + <em>c</em></span>\n这里的 <span class=\"math inline\"><em>p</em></span> 是一个小于等于 <span\nclass=\"math inline\"><em>m</em></span> 的素数</p>\n<h5 id=\"数字分析法\">数字分析法</h5>\n<p>对关键字集合中的所有关键字，分析每一位上数字分布。取数字分布均匀的位作为地址的组成部分</p>\n<h5 id=\"平方取中法\">平方取中法</h5>\n<p>如果关键字中各位的分布都比较均匀，但关键字的值域比数组规模大，则可以将关键字<strong>平方后</strong>，取其结果的中间各位作为散列函数值。由于中间各位和每一位数字都有关系，因此均匀分布的可能性较大。</p>\n<h5 id=\"折叠法\">折叠法</h5>\n<ul>\n<li>如果关键字相当长，以至于和散列表的单元总数相比大得多时，可采用此法</li>\n<li>选取一个长度后，将关键字按此长度分组相加</li>\n</ul>\n<h4 id=\"冲突问题\">冲突问题</h4>\n<p>当两个以上的关键字映射到一个存储单元时，称为<strong>冲突或碰撞</strong></p>\n<ul>\n<li>解决冲突的方法\n<ul>\n<li>闭散列表：利用本散列表中的空余单元\n<ul>\n<li>线性探测法</li>\n<li>二次探测法</li>\n<li>再次散列法</li>\n</ul></li>\n<li>开散列表：将碰撞的节点存放在散列表外的各自的线性表中（链接法）</li>\n</ul></li>\n</ul>\n<h5 id=\"闭散列表类的实现\">闭散列表类的实现</h5>\n<ul>\n<li>支持三种操作\n<ul>\n<li><code>insert</code>：插入一个元素</li>\n<li><code>remove</code>：删除一个元素</li>\n<li><code>find</code>：查找一个元素</li>\n</ul></li>\n<li>由一个数组实现，数组的大小由用户定义散列表时指定</li>\n<li>由于删除时的迟删除，每个数组元素还要保存一个状态值\n<ul>\n<li><code>0</code>：空</li>\n<li><code>1</code>：有效</li>\n<li><code>2</code>：删除</li>\n</ul></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">closeHashTable</span>:<span class=\"hljs-keyword\">public</span> dynamicSearchTable&lt;KEY, OTHER&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">node</span>  <span class=\"hljs-comment\">//散列表的结点类</span><br>    &#123;<br>      SET &lt;KEY, OTHER&gt; data;<br>      <span class=\"hljs-type\">int</span> state; <span class=\"hljs-comment\">//0 -- empty 1 -- active 2 -- deleted</span><br>      <span class=\"hljs-built_in\">node</span>()<br>      &#123;<br>        state = <span class=\"hljs-number\">0</span>;<br>      &#125;<br>    &#125;;<br>    node *array;<br><br>    <span class=\"hljs-type\">int</span> size;<br>    <span class=\"hljs-built_in\">int</span> (*key)(<span class=\"hljs-type\">const</span> KEY &amp;x);<span class=\"hljs-comment\">//哈希函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">defaultKey</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> &amp;x)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> x;<br>    &#125;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">closeHashTable</span>(<span class=\"hljs-type\">int</span> length = <span class=\"hljs-number\">101</span>, <span class=\"hljs-built_in\">int</span> (*f)(<span class=\"hljs-type\">const</span> KEY &amp;x) = defaultKey)<br>    ~<span class=\"hljs-built_in\">closeHashTable</span>()<br>    &#123;<br>      <span class=\"hljs-keyword\">delete</span> [] array;<br>    &#125;<br>    <span class=\"hljs-function\">SET&lt;KEY, OTHER&gt; *<span class=\"hljs-title\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x)</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> SET&lt;KEY, OTHER&gt; &amp;x)</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>构造函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br>closeHashTable&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">closeHashTable</span>(<span class=\"hljs-type\">int</span> length, <span class=\"hljs-built_in\">int</span> (*f)(<span class=\"hljs-type\">const</span> KEY &amp;x))<br>&#123;<br>  size = length;<br>  array = <span class=\"hljs-keyword\">new</span> node[size];<br>  key = f; <span class=\"hljs-comment\">//哈希函数为f</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>insert</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> closeHashTable&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-type\">const</span> SET&lt;KEY, OTHER&gt; &amp;x)<br>&#123;<br>  <span class=\"hljs-type\">int</span> initPos, pos ;<br>  initPos= pos = <span class=\"hljs-built_in\">key</span>(x.key) % size; <span class=\"hljs-comment\">//%size保护作用，避免越界</span><br>  <span class=\"hljs-keyword\">do</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (array[pos].state != <span class=\"hljs-number\">1</span>)<br>    &#123; <span class=\"hljs-comment\">// 0或2，找到空单元</span><br>      array[pos].data = x;<br>      array[pos].state = <span class=\"hljs-number\">1</span>;<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    pos = (pos<span class=\"hljs-number\">+1</span>) % size;<br>  &#125; <span class=\"hljs-keyword\">while</span> (pos != initPos);<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>remove</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> closeHashTable&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-type\">const</span> KEY &amp;x)<br>&#123;<br>  <span class=\"hljs-type\">int</span> initPos, pos ;<br>  initPos= pos = <span class=\"hljs-built_in\">key</span>(x) % size;<br>  <span class=\"hljs-keyword\">do</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (array[pos].state == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span>; <span class=\"hljs-comment\">//没找到</span><br>    <span class=\"hljs-keyword\">if</span> (array[pos].state == <span class=\"hljs-number\">1</span> &amp;&amp; array[pos].data.key== x)<span class=\"hljs-comment\">// 找到，删除</span><br>    &#123;<br>      array[pos].state = <span class=\"hljs-number\">2</span>;<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    pos = (pos<span class=\"hljs-number\">+1</span>) % size; <span class=\"hljs-comment\">//没找到，需要往后找</span><br>  &#125; <span class=\"hljs-keyword\">while</span> (pos != initPos);<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>find</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *closeHashTable&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-type\">const</span> KEY &amp;x) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-type\">int</span> initPos, pos ;<br>  initPos = pos = <span class=\"hljs-built_in\">key</span>(x) % size;<br>  <span class=\"hljs-keyword\">do</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (array[pos].state == <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// 没有找到</span><br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (array[pos].state == <span class=\"hljs-number\">1</span> &amp;&amp; array[pos].data.key == x) <span class=\"hljs-comment\">// 找到</span><br>    &#123;<br>      <span class=\"hljs-keyword\">return</span> (SET&lt;KEY,OTHER&gt; *)&amp;array[pos];<br>    &#125;<br>    pos = (pos<span class=\"hljs-number\">+1</span>) % size;<br>  &#125; <span class=\"hljs-keyword\">while</span> (pos != initPos);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"线性探测法\">线性探测法</h6>\n<p>当散列发生冲突时，依次<strong>探测下一个单元</strong>，直到发现一个空单元</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504210826498.png\"\nalt=\"线性探测法\" />\n<figcaption aria-hidden=\"true\">线性探测法</figcaption>\n</figure>\n<h6 id=\"二次探测法\">二次探测法</h6>\n<p>以此向后探测 <span class=\"math inline\">1<sup>2</sup></span>，<span\nclass=\"math inline\">2<sup>2</sup></span>，<span\nclass=\"math inline\">3<sup>2</sup></span>，<span\nclass=\"math inline\">4<sup>2</sup></span>，<span\nclass=\"math inline\">5<sup>2</sup></span>，<span\nclass=\"math inline\">…</span></p>\n<p><strong>定理</strong></p>\n<ul>\n<li>如果采用二次探测法，并且表的大小是一个素数，那么，如果表至少有一半是空的（负载因子\n<span\nclass=\"math inline\"> &lt; 0.5</span>），新的元素总能被插入。并且在插入过程中，没有一个单元被探测两次</li>\n</ul>\n<h6 id=\"再次散列法\">再次散列法</h6>\n<ul>\n<li>采用一个新的散列函数 <span\nclass=\"math inline\"><em>H</em><sub>2</sub>(<em>k</em><em>e</em><em>y</em>)</span></li>\n<li><span\nclass=\"math inline\"><em>H</em><sub>1</sub>(<em>x</em>)</span>，<span\nclass=\"math inline\"><em>H</em><sub>1</sub>(<em>x</em>) + <em>H</em><sub>2</sub>(<em>x</em>)</span>\n，<span\nclass=\"math inline\"><em>H</em><sub>1</sub>(<em>x</em>) + 2<em>H</em><sub>2</sub>(<em>x</em>)</span>，<span\nclass=\"math inline\"><em>H</em><sub>1</sub>(<em>x</em>) + 3<em>H</em><sub>2</sub>(<em>x</em>)</span>，<span\nclass=\"math inline\">…</span></li>\n</ul>\n<h5 id=\"开散列表\">开散列表</h5>\n<p>链地址法</p>\n<ul>\n<li>将具有同一散列地址的结点保存于 <code>M</code>\n存区的各自的链表之中</li>\n</ul>\n<h6 id=\"开散列表的实现\">开散列表的实现</h6>\n<ul>\n<li>将所有散列到同一地址的元素链接成一个单链表</li>\n<li>采用不带头结点的单链表</li>\n<li>散列表保存在一个数组中，每个元素是一个指向对应单链表的首地址的指针</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span> , <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">openHashTable</span>:<span class=\"hljs-keyword\">public</span> dynamicSearchTable&lt;KEU , OTHER&gt;<br>&#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">node</span><br>    &#123;<br>      SET&lt;KEY , OTHER&gt; data;<br>      node *next;<br>      <span class=\"hljs-built_in\">node</span> (<span class=\"hljs-type\">const</span> SET&lt;KEY , OTHER&gt; &amp;d , nde *n = <span class=\"hljs-literal\">nullptr</span>)<br>      &#123;<br>        data = d;<br>        next = n;<br>      &#125;<br>      <span class=\"hljs-built_in\">node</span>()<br>      &#123;<br>        next = <span class=\"hljs-literal\">nullptr</span>;<br>      &#125;<br>    &#125;;<br>    node **array; <span class=\"hljs-comment\">// 散列表，指针数组</span><br>     <span class=\"hljs-type\">int</span> size;<br>     <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">defaultKry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> &amp;x)</span></span><br><span class=\"hljs-function\">     </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> x;<br>     &#125;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">openHashTable</span>(<span class=\"hljs-type\">int</span> length = <span class=\"hljs-number\">101</span>,<span class=\"hljs-built_in\">int</span> (*f)(<span class=\"hljs-type\">const</span> KEY &amp;x) = defaultKey);<br>    ~<span class=\"hljs-built_in\">openashTable</span>();<br>    <span class=\"hljs-function\">SET&lt;KEY,OTHER&gt; *<span class=\"hljs-title\">finf</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x)</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> SET&lt;KEY,OTHER&gt; &amp;x)</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> KEY &amp;x)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>构造函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br>openHashTable&lt;KEY, OTHER&gt;::~<span class=\"hljs-built_in\">openHashTable</span>()<br>&#123;<br>  node *p, *q;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i&lt; size; ++i)<br>  &#123;<br>    p = array[i];<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>      q= p-&gt;next; <span class=\"hljs-keyword\">delete</span> p; p = q;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">delete</span> [] array；<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>insert</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> openHashTable&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-type\">const</span> SET&lt;KEY, OTHER&gt; &amp;x)<br>&#123;<br>  <span class=\"hljs-type\">int</span> pos;<br>  node *p;<br>  <span class=\"hljs-comment\">//插入单链表的头部</span><br>  pos = <span class=\"hljs-built_in\">key</span>(x.key) % size;<br>  array[pos] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">node</span>(x, array[pos]);<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>remove</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-type\">void</span> openHashTable&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-type\">const</span> KEY &amp;x)<br>&#123;<br>  <span class=\"hljs-type\">int</span> pos ;<br>  node *p, *q;<br>  pos = <span class=\"hljs-built_in\">key</span>(x) % size;<br>  <span class=\"hljs-keyword\">if</span> (array[pos] == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  p = array[pos];<br>  <span class=\"hljs-keyword\">if</span> (array[pos]-&gt;data.key== x)<br>  &#123; <span class=\"hljs-comment\">// 删除第一个结点</span><br>    array[pos] = p-&gt;next;<br>    <span class=\"hljs-keyword\">delete</span> p;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">while</span> (p-&gt;next != <span class=\"hljs-literal\">nullptr</span> &amp;&amp; !(p-&gt;next-&gt;data.key== x))<br>  &#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (p-&gt;next != <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    q = p-&gt;next;<br>    p-&gt;next = q-&gt;next;<br>    <span class=\"hljs-keyword\">delete</span> q;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>find</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *openHashTable&lt;KEY, OTHER&gt;::<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-type\">const</span> KEY &amp;x) <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-type\">int</span> pos ;<br>  node *p;<br>  pos = <span class=\"hljs-built_in\">key</span>(x) % size;<br>  p = array[pos];<br>  <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-literal\">nullptr</span> &amp;&amp; !(p-&gt;data.key == x))<br>  &#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-literal\">nullptr</span>)<br>  &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">else</span><br>  &#123;<br>    <span class=\"hljs-built_in\">return</span> (SET&lt;KEY, OTHER&gt; *)p;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"排序\">排序</h2>\n<h3 id=\"基本概念-1\">基本概念</h3>\n<ul>\n<li>按照关键字的非递减或非递增序排成一个序列</li>\n<li><strong>稳定与非稳定排序</strong>:关键字值相同的数据元素在排序前后的相对次序保持不变，则称为稳定排序，否则称为不稳定排序</li>\n<li>内排序与外排序\n<ul>\n<li><strong>内排序：</strong>排序的数据元素全部存放在计算机的内存之中，并且在内存中调整数据元素的相对位置</li>\n<li><strong>外排序：</strong>在排序的过程中，数据元素主要存放在外存储器中，借助于内存储器逐步调整数据元素之间的相对位置</li>\n</ul></li>\n</ul>\n<h3 id=\"插入排序\">插入排序</h3>\n<p>首先将由第一个数据元素组成的序列看成是有序的，然后将剩余的 n-1\n个元素依次插入到前面的已排好序的子序列中去，使得每次插入后的子序列也是有序的</p>\n<h4 id=\"直接插入排序\">直接插入排序</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">simpleInsertSort</span><span class=\"hljs-params\">(SET&lt;KEY, OTHER&gt;a[], <span class=\"hljs-type\">int</span> size)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> k;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">1</span>; j&lt;size; ++j)<br>  &#123;<br>  tmp = a[j];<br>  <span class=\"hljs-keyword\">for</span> ( k = j<span class=\"hljs-number\">-1</span>; tmp.key &lt; a[k].key &amp;&amp; k &gt;= <span class=\"hljs-number\">0</span>; --k)<br>  &#123;<br>    a[k<span class=\"hljs-number\">+1</span>] = a[k];<br>  &#125;<br>  a[k<span class=\"hljs-number\">+1</span>] = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>空间复杂度：<span class=\"math inline\"><em>O</em>(1)</span></li>\n<li>稳定性：稳定</li>\n<li>时间复杂度\n<ul>\n<li>最好：<span class=\"math inline\"><em>O</em>(<em>n</em>)</span></li>\n<li>最坏：<span\nclass=\"math inline\"><em>O</em>(<em>n</em><sup>2</sup>)</span></li>\n<li>平均：<span\nclass=\"math inline\"><em>O</em>(<em>n</em><sup>2</sup>)</span></li>\n</ul></li>\n<li>适用情况：短序列或者几乎已经排好序的</li>\n</ul>\n<h4 id=\"折半插入排序\">折半插入排序</h4>\n<p>先用二分排序找到插入位置</p>\n<ul>\n<li>时间复杂度\n<ul>\n<li>最好：<span\nclass=\"math inline\"><em>O</em>(<em>n</em>log <em>n</em>)</span></li>\n<li>最坏：<span\nclass=\"math inline\"><em>O</em>(<em>n</em><sup>2</sup>)</span></li>\n<li>平均：<span\nclass=\"math inline\"><em>O</em>(<em>n</em><sup>2</sup>)</span></li>\n</ul></li>\n<li>空间复杂度：<span class=\"math inline\"><em>O</em>(1)</span></li>\n<li>稳定性：稳定</li>\n</ul>\n<p>改进很小，对于接近排好序的序列甚至<strong>更差</strong></p>\n<h4 id=\"希尔排序\">希尔排序</h4>\n<ul>\n<li>相隔一定的距离的记录组成一个子序列</li>\n<li>逐渐扩大小序列的规模，减小序列的个数，使得待排序列处于更有序的状态</li>\n<li>最后再用直接插入排序对整个序列进行一次排序</li>\n</ul>\n<h5 id=\"步长序列的选择\">步长序列的选择</h5>\n<ul>\n<li><p><span class=\"math inline\">1, 2, 4, 8, …</span></p></li>\n<li><p>时间复杂度：<span\nclass=\"math inline\"><em>O</em>(<em>n</em><sup>2</sup>)</span></p></li>\n<li><p>Knuth 推荐：<span\nclass=\"math inline\">1, 3, 7, 15, 31, 63, …</span></p></li>\n<li><p>时间复杂度：<span\nclass=\"math inline\"><em>O</em>(<em>n</em><sup>1.5</sup>)</span></p></li>\n<li><p>空间复杂度：<span\nclass=\"math inline\"><em>O</em>(1)</span></p></li>\n<li><p>不稳定</p></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">shellSort</span><span class=\"hljs-params\">(SET&lt;KEY, OTHER&gt; a[], <span class=\"hljs-type\">int</span> size)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> step, i, j;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class=\"hljs-keyword\">for</span> (step = size/<span class=\"hljs-number\">2</span>; step &gt; <span class=\"hljs-number\">0</span>; step /= <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">//step为希尔增量</span><br>  &#123;<br>    <span class=\"hljs-keyword\">for</span> (i = step; i &lt; size; ++i)<br>    &#123;<br>      tmp = a[i];<br>      <span class=\"hljs-keyword\">for</span> (j = i -step; j &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; a[j].key &gt; tmp.key; j -= step)<br>      &#123;<br>        a[j+step] = a[j];<br>      &#125;<br>      a[j+step] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"选择排序\">选择排序</h3>\n<ol type=\"1\">\n<li>在 <span class=\"math inline\"><em>n</em></span>\n个元素中选出最小的元素</li>\n<li>从剩下的 <span class=\"math inline\"><em>n</em> − 1</span>\n个元素中选出最小的元素</li>\n<li>以此类推，直到最后一个元素</li>\n</ol>\n<h4 id=\"直接选择排序\">直接选择排序</h4>\n<ol type=\"1\">\n<li>在所有元素中逐个比较找到最小元素，与第一个元素交换</li>\n<li>在剩下的元素中逐个比较找到最小元素，与第二个元素交换</li>\n<li>以此类推，直到最后一个元素</li>\n</ol>\n<ul>\n<li>时间复杂度：<span\nclass=\"math inline\"><em>O</em>(<em>n</em><sup>2</sup>)</span></li>\n<li>空间复杂度：<span class=\"math inline\"><em>O</em>(1)</span></li>\n<li>不稳定</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">simpleSelectSort</span><span class=\"hljs-params\">(SET&lt;KEY, OTHER&gt; a[], <span class=\"hljs-type\">int</span> size)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> i, j, min;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; size <span class=\"hljs-number\">-1</span>; ++i)<br>  &#123;<br>  min = i;<br>  <span class=\"hljs-keyword\">for</span> (j = i<span class=\"hljs-number\">+1</span>; j &lt; size; ++j)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (a[j].key &lt; a[min].key)<br>    &#123;<br>      min = j;<br>    &#125;<br>  &#125;<br>  tmp = a[i]; a[i] = a[min]; a[min] = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"堆排序\">堆排序</h4>\n<ol type=\"1\">\n<li>建立一个最大堆</li>\n<li>执行 <span class=\"math inline\"><em>n</em></span> 次\n<code>deQuqeue</code> 操作取出每个项</li>\n</ol>\n<ul>\n<li><p>时间复杂度 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>log <em>n</em>)</span></p></li>\n<li><p>堆排序</p></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">heapSort</span><span class=\"hljs-params\">(SET&lt;KEY, OTHER&gt; a[], <span class=\"hljs-type\">int</span> size)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> i;<br>  SET&lt;KEY, OTHER&gt; tmp; <span class=\"hljs-comment\">// 创建初始的堆</span><br>  <span class=\"hljs-keyword\">for</span>( i = size / <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">-1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--)<br>  &#123;<br>    <span class=\"hljs-built_in\">percolateDown</span>( a, i, size );<br>  &#125;<br>  <span class=\"hljs-comment\">//执行n-1次deQueue</span><br>  <span class=\"hljs-keyword\">for</span> ( i = size <span class=\"hljs-number\">-1</span>; i &gt; <span class=\"hljs-number\">0</span>; --i)\\<br>  &#123;<br>  tmp = a[<span class=\"hljs-number\">0</span>]; a[<span class=\"hljs-number\">0</span>] = a[i]; a[i] = tmp; <span class=\"hljs-comment\">//delete a[0]</span><br>  <span class=\"hljs-built_in\">percolateDown</span>( a, <span class=\"hljs-number\">0</span>, i );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>precolateDown</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">percolateDown</span><span class=\"hljs-params\">( SET&lt;KEY, OTHER&gt; a[], <span class=\"hljs-type\">int</span> hole, <span class=\"hljs-type\">int</span> size)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> child;<br>  SET&lt;KEY, OTHER&gt; tmp= a[ hole ];<br>  <span class=\"hljs-keyword\">for</span>( ; hole * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span> &lt; size; hole = child )<br>  &#123;<br>    child = hole * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">if</span>( child != size <span class=\"hljs-number\">-1</span> &amp;&amp; a[ child + <span class=\"hljs-number\">1</span> ].key &gt; a[ child ].key )<br>    &#123;<br>      child++;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>( a[ child ].key &gt;tmp.key)<br>    &#123;<br>      a[ hole ] = a[ child ];<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>      <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>  &#125;<br>  a[ hole ] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"交换排序\">交换排序</h3>\n<p>通过交换，将关键字值较大的数据元素向序列的尾部移动，关键字值较小的数据元素向序列的头部移动</p>\n<h4 id=\"冒泡排序\">冒泡排序</h4>\n<p>从头到尾比较相邻的两个元素，将小的换到前面，大的换到后面。经过了从头到尾的一趟比较，就把最大的元素交换到了最后一个位置。这个过程称为一趟起泡</p>\n<p>然后再从头开始到倒数第二个元素进行第二趟起泡。经过了第二趟比较，又将第二大的元素放到了倒数第二个位置</p>\n<p>依次类推，经过第 <span class=\"math inline\"><em>n</em> − 1</span>\n趟起泡，将倒数第 <span class=\"math inline\"><em>n</em> − 1</span>\n个大的元素放入第 2 个单元</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">bubbleSort</span><span class=\"hljs-params\">(SET&lt;KEY, OTHER&gt; a[], <span class=\"hljs-type\">int</span> size)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> i, j;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class=\"hljs-type\">bool</span> flag = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">//记录一趟起泡中有没有发生过交换</span><br>  <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">1</span>; i &lt; size&amp;&amp; flag; ++i)<br>  &#123; <span class=\"hljs-comment\">//size-1次起泡</span><br>    flag = <span class=\"hljs-literal\">false</span>;<br>    <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; size-i; ++j) <span class=\"hljs-comment\">//第i次起泡</span><br>    <span class=\"hljs-keyword\">if</span> (a[j<span class=\"hljs-number\">+1</span>].key &lt; a[j].key)<br>    &#123;<br>      tmp = a[j]; a[j] = a[j<span class=\"hljs-number\">+1</span>]; a[j<span class=\"hljs-number\">+1</span>] = tmp;<br>      flag = <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"快速排序\">快速排序</h4>\n<ul>\n<li>选择一个基准元素，将比基准元素小的元素放在左边，比基准元素大的元素放在右边</li>\n<li>然后对基准元素左边和右边的子序列进行递归排序</li>\n</ul>\n<h5 id=\"选择中心点\">选择中心点</h5>\n<ul>\n<li>第一个元素</li>\n<li>随机</li>\n<li>中值（采样得到）</li>\n</ul>\n<h5 id=\"划分第一个元素为中心点\">划分（第一个元素为中心点）</h5>\n<ol type=\"1\">\n<li>序列的下标上界为 <code>high</code>，下届为\n<code>low</code>，中心点选取第一个元素，关键值为\n<code>K</code>，<code>low</code> 位置空出</li>\n<li>从右向左开始检查：如果 <code>high</code> 的关键值大于\n<code>K</code>，该位置中的值位置正确，<code>high</code> 减 <span\nclass=\"math inline\">1</span>，继续往前检查，直到遇到一个小于\n<code>K</code> 的值</li>\n<li>将小于 <code>k</code> 的这个值放入 <code>low</code> 的位置，此时\n<code>high</code> 的位置又空出。然后从 <code>low</code>\n位置开始从左向右检查，直到遇到一个大于 <code>K</code> 的值</li>\n<li>将 <code>low</code> 位置的值放入 <code>high</code> 位置，重复第 2\n步，直到 <code>low</code> 和 <code>high</code> 重叠，将 <code>K</code>\n放入此位置</li>\n</ol>\n<p>划分函数的实现</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KEY</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OTHER</span>&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">divide</span><span class=\"hljs-params\">( SET&lt;KEY, OTHER&gt; a[], <span class=\"hljs-type\">int</span> low, <span class=\"hljs-type\">int</span> high)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  SET&lt;KEY, OTHER&gt; k = a[low];<br>  <span class=\"hljs-keyword\">do</span><br>  &#123;<br>    <span class=\"hljs-keyword\">while</span> (low &lt; high &amp;&amp; a[high].key &gt;= k.key)<br>    &#123;<br>      --high;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (low &lt; high)<br>    &#123;<br>      a[low] = a[high]; ++low;<br>    &#125;<br>    <span class=\"hljs-keyword\">while</span> (low &lt; high &amp;&amp; a[low].key &lt;= k.key)<br>    &#123;<br>      ++low;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (low &lt; high)<br>    &#123;<br>      a[high] = a[low]; --high;<br>    &#125;<br>  &#125; <span class=\"hljs-keyword\">while</span> (low != high);<br>  a[low] = k;<br>  <span class=\"hljs-keyword\">return</span> low;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"归并排序\">归并排序</h3>\n<ul>\n<li>将待排序的序列分成两个子序列，分别进行排序</li>\n<li>将两个有序的子序列合并成一个有序的序列</li>\n<li>递归进行</li>\n</ul>\n<h3 id=\"基数排序\">基数排序</h3>\n<ul>\n<li>称为口袋排序法</li>\n<li>通过分配的方法进行排序</li>\n<li>基数（r）：子关键字的值域的元素的个数\n<ul>\n<li>十进制数：<span class=\"math inline\">0, 1, 2, …, 9</span>，基数为\n<span class=\"math inline\">10</span></li>\n<li>二进制数：<span class=\"math inline\">0, 1</span>，基数为 <span\nclass=\"math inline\">2</span></li>\n<li>英文字符：<span\nclass=\"math inline\"><em>A</em>, <em>B</em>, <em>C</em>, …, <em>Z</em></span>，基数为\n<span class=\"math inline\">26</span></li>\n</ul></li>\n</ul>\n<h4 id=\"高位优先法msd\">高位优先法（MSD）</h4>\n<ul>\n<li>先将高位进入口袋中你进行排序，再将低位放入口袋中进入排序，最终将最小的口袋依次链接在一起形成有序序列</li>\n</ul>\n<h4 id=\"低位优先法lsd\">低位优先法（LSD）</h4>\n<ul>\n<li>先将最低为进入口袋进行排序，再将所有记录按照口袋的顺序收在一起</li>\n<li>然后将次低位进入口袋进行排序，依次类推</li>\n<li>最后将所有记录按照口袋的顺序收在一起</li>\n</ul>\n<h2 id=\"外存储器中的查找和排序\">外存储器中的查找和排序</h2>\n<h3 id=\"主存储器与外存储器\">主存储器与外存储器</h3>\n<ul>\n<li>主存储器：计算机的内存，用于存储正在运行的程序代码以及处理数据</li>\n<li>外存储器：计算机的硬盘、光盘、磁带等，用于长期存储数据和程序，用于存储长期保存的信息\n<ul>\n<li>价格低廉、存储量大、永久保存、<strong>访问速度慢</strong></li>\n</ul></li>\n</ul>\n<h3 id=\"外部查找\">外部查找</h3>\n<h4 id=\"b-树\">B 树</h4>\n<p>B 树是一棵平衡的 M 叉查找树，需要 <span\nclass=\"math inline\"><em>M</em> − 1</span>\n个关键字来判断到哪个分支查找</p>\n<h5 id=\"b-树的定义\">B 树的定义</h5>\n<ul>\n<li>一棵 <span class=\"math inline\"><em>m</em></span> 阶 B\n树要么为空，要么满足一下条件\n<ul>\n<li>根节点要么是叶节点，要么至少有两个儿子，至多有 <span\nclass=\"math inline\"><em>m</em></span> 个儿子</li>\n<li>每个非根节点至少有 <span class=\"math inline\">⌈<em>m</em>/2⌉</span>\n个儿子，至多有 <span class=\"math inline\"><em>m</em></span> 个儿子</li>\n<li>有 <span class=\"math inline\"><em>s</em></span> 个儿子的非叶节点具有\n<span class=\"math inline\"><em>n</em> = <em>s</em> − 1</span>\n个关键字</li>\n<li>所有的叶子节点都出现在同一层上</li>\n</ul></li>\n</ul>\n<h5 id=\"b-树的插入\">B 树的插入</h5>\n<ul>\n<li>在最底层进行插入</li>\n</ul>\n<ol type=\"1\">\n<li>在 <span class=\"math inline\"><em>m</em></span> 阶 B\n树上进行查找操作，确定新插入的关键字 <code>key</code>\n在最底层非叶节点的插入位置</li>\n<li>如果被插入节点的关键字个数小于等于 <span\nclass=\"math inline\"><em>m</em> − 1</span>，则插入结束</li>\n<li>如果被插入节点的关键字个数大于 <span\nclass=\"math inline\"><em>m</em> − 1</span>，则需要进行分裂</li>\n</ol>\n<ul>\n<li>被插入节点分为三个部分\n<ul>\n<li>前半部分：前 <span class=\"math inline\"><em>m</em>/2</span>\n个关键字</li>\n<li>中间部分：中间的关键字</li>\n<li>后半部分：后 <span class=\"math inline\"><em>m</em>/2</span>\n个关键字</li>\n</ul></li>\n<li>中间部分的关键字上升到父节点</li>\n<li>前后半部分生成新的两个节点</li>\n</ul>\n<h5 id=\"b-树的删除\">B 树的删除</h5>\n<ul>\n<li>采用替身法，替身为右子树的最小值或者左子树的最大值</li>\n</ul>\n<ol type=\"1\">\n<li>删除节点，替身进入</li>\n<li>如果删除后的替身原来在的节点满足，则直接删除</li>\n<li>如果删除后的关键字小于下限，\n<ul>\n<li>向该节点的左或右兄弟借一个关键字</li>\n<li>如果兄弟节点的关键字个数等于下限，则需要进行合并</li>\n</ul></li>\n</ol>\n<h5 id=\"m-的选择\">M 的选择</h5>\n<h4 id=\"b树\">B+树</h4>\n<p>B+树是既能提供随机查找，也能提供顺序访问的存储结构</p>\n<h5 id=\"b树的定义\">B+树的定义</h5>\n<ul>\n<li>所有数据都记录在叶节点中，所有叶节点连成一个单链表</li>\n<li>非叶节点至多保存 <span class=\"math inline\"><em>m</em> − 1</span>\n个关键字来引导查找，键 <span class=\"math inline\"><em>i</em></span>\n表示子树 <span class=\"math inline\"><em>i</em> + 1</span>\n中键的最小值</li>\n<li>根节点或者是叶节点，或者有 <span class=\"math inline\">2</span> 到\n<span class=\"math inline\"><em>m</em></span> 个子树</li>\n<li>除了根节点之外的所有非叶节点至少有 <span\nclass=\"math inline\"><em>m</em>/2</span> 个儿子，最多有 <span\nclass=\"math inline\"><em>m</em></span> 个儿子</li>\n<li>所有的叶节点都在同一层上，并且每个叶子有 <span\nclass=\"math inline\">⌈<em>L</em>/2⌉</span> 到 <span\nclass=\"math inline\"><em>L</em></span> 个关键字</li>\n</ul>\n<h5 id=\"b树的插入\">B+树的插入</h5>\n<ul>\n<li>叶结点不满：把新结点插入叶子，重新调整该叶子中数据的顺序</li>\n<li>叶子已经装满 ：通过分裂该叶子，形成两个半满的叶子来插入一个新的项\n<ul>\n<li>更新父结点</li>\n<li>如果父亲的儿子数量已经满了，就继续分裂父亲</li>\n</ul></li>\n</ul>\n<h3 id=\"外排序\">外排序</h3>\n<p>一次外存操作所需的时间可以执行数百条甚至上千条指令，因此在外排序中主要考虑的是如何减少外存储器的读写（I/O\n操作）</p>\n<h4 id=\"外排序模型\">外排序模型</h4>\n<ul>\n<li>外排序由两个阶段组成\n<ol type=\"1\">\n<li>预处理阶段：根据内存的大小将一个有 n\n个记录的文件分批读入内存，用各种内排序算法排序，形成一个个有序片段</li>\n<li>归并阶段：将这些有序片段逐步归并成一个有序文件</li>\n</ol></li>\n</ul>\n<p>减少 I/O 操作的关键</p>\n<ol type=\"1\">\n<li>减少归并轮数</li>\n<li>减少有序片段数量</li>\n<li>增加合并路数</li>\n</ol>\n<h4 id=\"预处理\">预处理</h4>\n<h5 id=\"减少有序片段数量\">减少有序片段数量</h5>\n<ul>\n<li>每次读入的记录数越多，形成的初始的已排序的片段越少，归并的次数也越少</li>\n<li>最简单的方法是按照内存的容量尽可能多地读入数据记录，然后再内存中进行排序，排序地结果写入文件，形成一个已排序片段</li>\n</ul>\n<h5 id=\"置换排序\">置换排序</h5>\n<p>置换选择可以在只能容纳 <span class=\"math inline\"><em>p</em></span>\n个记录的内存中生成平均长度为 <span\nclass=\"math inline\">2<em>p</em></span> 的初始的已排序片段</p>\n<p>只要前面的元素被写到文件上，它所用的内存空间就可以给别的元素使用。如果输入文件中的下一个元素比刚刚输出的元素大，它能被放入这个已排序片段</p>\n<p>具体方法</p>\n<ol type=\"1\">\n<li>初始时，将 <span class=\"math inline\"><em>m</em></span>\n个元素读入内存，用 <code>buildHeap</code> 建立一个优先级队列</li>\n<li>执行一次 <code>deQuqeue</code>，将最小的元素写入输出文件</li>\n<li>从输入磁带读入下一个元素\n<ul>\n<li>如果它比刚才写进去的元素大，那么将它加入到优先级队列中</li>\n<li>否则，则无法写入队列，进行下一次 <code>deQuqeue</code></li>\n</ul></li>\n<li>重复第 2、3 步，直到输入文件读完</li>\n<li>重新执行 <code>buildHeap</code>，使用存放在空余位置中的元素</li>\n</ol>\n<h4 id=\"归并\">归并</h4>\n<h5 id=\"二路归并\">二路归并</h5>\n<ul>\n<li>归并时，每次将两个有序文件归并为一个有序文件</li>\n<li>如果生成的有序片段数量为 <span\nclass=\"math inline\"><em>M</em></span>，则归并次数为 <span\nclass=\"math inline\">⌈log<sub>2</sub><em>M</em>⌉</span></li>\n</ul>\n<h5 id=\"多路归并\">多路归并</h5>\n<ul>\n<li>归并时，每次将 <span class=\"math inline\"><em>k</em></span>\n个有序文件归并为一个有序文件</li>\n<li>优点：减少归并次数，为 <span\nclass=\"math inline\">⌈log<sub><em>k</em></sub><em>M</em>⌉</span> 次</li>\n<li>缺点：寻找最小元素的操作复杂，通常可以将每个文件的第一个记录组成一个优先级队列</li>\n</ul>\n<h5 id=\"多阶段归并\">多阶段归并</h5>\n<ul>\n<li>可以仅使用 <span class=\"math inline\"><em>K</em> + 1</span>\n条磁带实现 <span class=\"math inline\"><em>K</em></span>\n路归并，称为<strong>多阶段归并</strong></li>\n</ul>\n<p><strong>实现的过程</strong></p>\n<ol type=\"1\">\n<li>按照非均匀的方法分解原来的已排序的片段</li>\n<li>将每个片段分成 <span class=\"math inline\"><em>K</em></span>\n个子片段</li>\n</ol>\n<h2 id=\"图\">图</h2>\n<h3 id=\"图的定义\">图的定义</h3>\n<ul>\n<li>图可以用 <span\nclass=\"math inline\"><em>G</em> = (<em>V</em>, <em>E</em>)</span>\n表示。其中，<span class=\"math inline\"><em>V</em></span> 是顶点集，<span\nclass=\"math inline\"><em>E</em></span> 是边集。</li>\n<li>如果边是有方向的，称为<strong>有向图</strong>.有向图的边用 <span\nclass=\"math inline\">⟨⟩</span> 表示\n<ul>\n<li><span class=\"math inline\">⟨<em>A</em>, <em>B</em>⟩</span> 表示从\n<span class=\"math inline\"><em>A</em></span> 到 <span\nclass=\"math inline\"><em>B</em></span> 的一条边</li>\n</ul></li>\n<li>如果边是无方向的，称为<strong>无向图</strong>.无向图的边用 <span\nclass=\"math inline\">()</span> 表示\n<ul>\n<li><span class=\"math inline\">(<em>A</em>, <em>B</em>)</span> 表示 <span\nclass=\"math inline\"><em>A</em></span> 和 <span\nclass=\"math inline\"><em>B</em></span> 之间有一条边</li>\n<li>无向图也称为双向图</li>\n</ul></li>\n<li><strong>加权图：</strong>\n边被赋予一个权值的图称为加权图.如果图是有向的，称为加权有向图，如果是无向的，称为加权无向图\n<ul>\n<li>加权图中边的表示：<span\nclass=\"math inline\">(<em>V</em><sub><em>i</em></sub>, <em>V</em><sub><em>j</em></sub>, <em>W</em>)</span></li>\n</ul></li>\n</ul>\n<h3 id=\"图的基本术语\">图的基本术语</h3>\n<ul>\n<li>邻接\n<ul>\n<li>若 <span\nclass=\"math inline\">(<em>V</em><sub><em>i</em></sub>, <em>V</em><sub><em>j</em></sub>)</span>\n是图 <span class=\"math inline\"><em>G</em></span> 的一条边，则称 <span\nclass=\"math inline\"><em>V</em><sub><em>i</em></sub></span> 和 <span\nclass=\"math inline\"><em>V</em><sub><em>j</em></sub></span> 是邻接的；若\n<span\nclass=\"math inline\">⟨<em>V</em><sub><em>i</em></sub>, <em>V</em><sub><em>j</em></sub>⟩</span>\n是图 <span class=\"math inline\"><em>G</em></span> 的一条边，则称 <span\nclass=\"math inline\"><em>V</em><sub><em>i</em></sub></span> 邻接到 <span\nclass=\"math inline\"><em>V</em><sub><em>j</em></sub></span>，<span\nclass=\"math inline\"><em>V</em><sub><em>j</em></sub></span> 和 <span\nclass=\"math inline\"><em>V</em><sub><em>i</em></sub></span> 邻接</li>\n</ul></li>\n<li>度 无向图中邻接与某一顶点的边的总数</li>\n<li>入度 有向图中进入某一顶点的边数</li>\n<li>出度 有向图中离开某一顶点的边数</li>\n<li>边与度的关系 <span class=\"math inline\">$\\displaystyle\ne=\\frac{1}{2}\\sum_{i=1}^n d_i$</span>，其中 <span\nclass=\"math inline\"><em>e</em></span> 是边数，<span\nclass=\"math inline\"><em>d</em><sub><em>i</em></sub></span> 是顶点 <span\nclass=\"math inline\"><em>V</em><sub><em>i</em></sub></span> 的度</li>\n</ul>\n<h4 id=\"子图\">子图</h4>\n<p>设有两个图 <span\nclass=\"math inline\"><em>G</em><sub>1</sub> = (<em>V</em><sub>1</sub>, <em>E</em><sub>1</sub>)</span>\n和 <span\nclass=\"math inline\"><em>G</em><sub>2</sub> = (<em>V</em><sub>2</sub>, <em>E</em><sub>2</sub>)</span>，如果\n<span\nclass=\"math inline\"><em>V</em><sub>1</sub> ⊆ <em>V</em><sub>2</sub></span>，<span\nclass=\"math inline\"><em>E</em><sub>1</sub> ⊆ <em>E</em><sub>2</sub></span>，则称\n<span class=\"math inline\"><em>G</em><sub>1</sub></span> 是 <span\nclass=\"math inline\"><em>G</em><sub>2</sub></span> 的子图</p>\n<h4 id=\"路径和路径长度\">路径和路径长度</h4>\n<ul>\n<li>对于 <span\nclass=\"math inline\">1 &lt; <em>i</em> &lt; <em>N</em></span>，顶点序列\n<span\nclass=\"math inline\"><em>w</em><sub>1</sub>, <em>w</em><sub>2</sub>, …, <em>w</em><sub><em>N</em></sub></span>\n中的顶点对 <span\nclass=\"math inline\">(<em>w</em><sub><em>i</em></sub>, <em>w</em><sub><em>i</em> + 1</sub>)</span>\n都有 <span\nclass=\"math inline\">(<em>W</em><sub><em>i</em></sub>, <em>w</em><sub><em>i</em> + 1</sub>) ∈ <em>E</em></span>\n或 <span\nclass=\"math inline\">⟨<em>w</em><sub><em>i</em></sub>, <em>w</em><sub><em>i</em> + 1</sub>⟩ ∈ <em>E</em></span>，则称\n<span\nclass=\"math inline\"><em>w</em><sub>1</sub>, <em>w</em><sub>2</sub>, …, <em>w</em><sub><em>N</em></sub></span>\n是图中的一条<strong>路径</strong></li>\n<li><strong>非加权的路径长度</strong>就是组成路径的边数，对于路径 <span\nclass=\"math inline\"><em>w</em><sub>1</sub>, <em>w</em><sub>2</sub>, …, <em>w</em><sub><em>N</em></sub></span>，路径长度为\n<span class=\"math inline\"><em>N</em> − 1</span></li>\n<li><strong>加权的路径长度</strong>是指路径上所有边的权值之和</li>\n<li><strong>简单路径和环：</strong>\n如果一条路径上所有顶点，除了起始顶点和终止顶点可能相同外，其余的顶点都不相同，则称其为简单路径。一个回路或环是一条简单路径，其起始顶点和终止顶点相同，且路径长度至少为\n<span class=\"math inline\">1</span></li>\n</ul>\n<h4 id=\"无向图的连通性\">无向图的连通性</h4>\n<ul>\n<li><strong>连通：</strong> 顶点 <span\nclass=\"math inline\"><em>V</em></span> 和顶点 <span\nclass=\"math inline\"><em>V</em><sup>′</sup></span> 之间又路径存在</li>\n<li><strong>连通图：</strong> 无向图 G 的任意两点之间都是连通的</li>\n<li><strong>连通分量：</strong> 非连通图中的极大连通子图</li>\n</ul>\n<h4 id=\"有向图的连通性\">有向图的连通性</h4>\n<ul>\n<li><strong>强连通图：</strong> 有向图 G 的任意两点之间都是连通的，则称\nG 是强连通图</li>\n<li><strong>强连通分量：</strong> 极大连通子图</li>\n<li><strong>弱连通图：</strong> 如有向图 G\n不是强连通的，但是如果把它看作是无向图时则是连通的，则称该图是弱连通的</li>\n</ul>\n<h4 id=\"完全图\">完全图</h4>\n<ul>\n<li><strong>完全图：</strong>\n每两个顶点之间都有边的无向图称为完全图。完全图有 <span\nclass=\"math inline\">$\\frac{n(n-1)}{2}$</span> 条边，即 <span\nclass=\"math inline\"><em>C</em><sub><em>n</em></sub><sup>2</sup></span></li>\n<li><strong>有向完全图：</strong>\n每两个顶点之间都有两条边的有向图称为有向完全图。有向完全图有 <span\nclass=\"math inline\"><em>n</em>(<em>n</em> − 1)</span> 条边，即 <span\nclass=\"math inline\"><em>P</em><sub><em>n</em></sub><sup>2</sup></span></li>\n<li><strong>有向无环图：</strong> 不含环的有向图</li>\n</ul>\n<h4 id=\"生成树与最小生成树\">生成树与最小生成树</h4>\n<ul>\n<li><strong>生成树</strong>是图 G 的<strong>极小</strong>连通子图\nG’，其中 <span\nclass=\"math inline\"><em>V</em>(<em>G</em><sup>′</sup>) = <em>V</em>(<em>G</em>)</span></li>\n<li>用一棵树把图 G 的所有顶点都连起来，并且没有回路</li>\n<li>生成树有 <span class=\"math inline\"><em>n</em></span> 个顶点，<span\nclass=\"math inline\"><em>n</em> − 1</span> 条边</li>\n<li>生成树可以有多个</li>\n<li><strong>最小生成树</strong>是所有生成树中权值之和最小的生成树</li>\n</ul>\n<h3 id=\"图的运算\">图的运算</h3>\n<ul>\n<li>常规操作\n<ul>\n<li>构造一个由若干个顶点、若干条边组成的图</li>\n<li>判断两个顶点之间是否有边存在</li>\n<li>在图中添加或删除一条边</li>\n<li>返回图中的顶点数或边数</li>\n<li>按某种规则<strong>遍历</strong>图中的所有顶点</li>\n</ul></li>\n<li>和应用紧密结合的运算\n<ul>\n<li>拓扑排序和关键路径</li>\n<li>找最小生成树</li>\n<li>找最短路径等</li>\n</ul></li>\n</ul>\n<h3 id=\"图的抽象类\">图的抽象类</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TypeOfVer</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TypeOfEdge</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">graph</span><br>&#123;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(TypeOfVer x, TypeOfVer y, TypeOfEdge w)</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(TypeOfVer x, TypeOfVer y)</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">exist</span><span class=\"hljs-params\">(TypeOfVer x, TypeOfVer y)</span> <span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">numOfVer</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> Vers;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">numOfEdge</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> Edges;<br>    &#125;<br> <br>  <span class=\"hljs-keyword\">protected</span>:<br>    <span class=\"hljs-type\">int</span> Vers, Edges;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"图的存储\">图的存储</h3>\n<h4 id=\"邻接矩阵和加权邻接矩阵\">邻接矩阵和加权邻接矩阵</h4>\n<h5 id=\"有向图的邻接矩阵\">有向图的邻接矩阵</h5>\n<p>设有向图有 <span class=\"math inline\"><em>n</em></span>\n个顶点，则用一个 <span\nclass=\"math inline\"><em>n</em> × <em>n</em></span> 的布尔矩阵 <span\nclass=\"math inline\"><em>A</em></span> 来表示该有向图</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505212328867.png\"\nalt=\"有向图的邻接矩阵\" />\n<figcaption aria-hidden=\"true\">有向图的邻接矩阵</figcaption>\n</figure>\n<ul>\n<li>分别使用 <span class=\"math inline\">0, 1, 2, …, <em>n</em> − 1</span>\n表示 顶点 <span\nclass=\"math inline\"><em>V</em><sub>0</sub>, <em>V</em><sub>1</sub>, …, <em>V</em><sub><em>n</em> − 1</sub></span>，如果存在一条从\n<span class=\"math inline\"><em>V</em><sub><em>i</em></sub></span> 到\n<span class=\"math inline\"><em>V</em><sub><em>j</em></sub></span>\n的边，则 <span\nclass=\"math inline\"><em>A</em>[<em>i</em>][<em>j</em>] = 1</span>，否则\n<span\nclass=\"math inline\"><em>A</em>[<em>i</em>][<em>j</em>] = 0</span></li>\n<li>出度：<span class=\"math inline\"><em>i</em></span> 行之和</li>\n<li>入度：<span class=\"math inline\"><em>j</em></span> 列之和</li>\n<li>真正的顶点数据字段之值放入一个一维数组之中</li>\n</ul>\n<h5 id=\"无向图的邻接矩阵\">无向图的邻接矩阵</h5>\n<p>设无向图有 <span class=\"math inline\"><em>n</em></span>\n个顶点，则用一个 <span\nclass=\"math inline\"><em>n</em> × <em>n</em></span> 的布尔矩阵 <span\nclass=\"math inline\"><em>A</em></span> 来表示该无向图</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505212332916.png\"\nalt=\"无向图的邻接矩阵\" />\n<figcaption aria-hidden=\"true\">无向图的邻接矩阵</figcaption>\n</figure>\n<ul>\n<li>分别使用 <span class=\"math inline\">0, 1, 2, …, <em>n</em> − 1</span>\n表示 顶点 <span\nclass=\"math inline\"><em>V</em><sub>0</sub>, <em>V</em><sub>1</sub>, …, <em>V</em><sub><em>n</em> − 1</sub></span>，如果存在一条从\n<span class=\"math inline\"><em>V</em><sub><em>i</em></sub></span> 到\n<span class=\"math inline\"><em>V</em><sub><em>j</em></sub></span>\n的边，则 <span\nclass=\"math inline\"><em>A</em>[<em>i</em>][<em>j</em>] = <em>A</em>[<em>j</em>][<em>i</em>] = 1</span>，否则\n<span\nclass=\"math inline\"><em>A</em>[<em>i</em>][<em>j</em>] = <em>A</em>[<em>j</em>][<em>i</em>] = 0</span></li>\n<li>顶点 <span class=\"math inline\"><em>i</em></span> 的度：第 <span\nclass=\"math inline\"><em>i</em></span> 行或第 <span\nclass=\"math inline\"><em>i</em></span> 列之和</li>\n<li>无向图的邻接矩阵是一个三角对称矩阵</li>\n</ul>\n<h5 id=\"邻接矩阵的特点\">邻接矩阵的特点</h5>\n<ul>\n<li>优点：判断任意两点之间是否有边方便，仅耗费 <span\nclass=\"math inline\"><em>O</em>(1)</span> 时间</li>\n<li>缺点：即使 <span\nclass=\"math inline\"> ≪ <em>n</em><sub>2</sub></span> 条边，也需内存\n<span class=\"math inline\"><em>n</em><sub>2</sub></span> 单元，太多;\n仅读入数据耗费 <span\nclass=\"math inline\"><em>O</em>(<em>n</em><sub>2</sub>)</span>\n时间，太长。而大多数的图的边数远远小于 <span\nclass=\"math inline\"><em>n</em><sub>2</sub></span>。<strong>适合稠密网</strong></li>\n<li>不适合增减顶点</li>\n</ul>\n<h4 id=\"邻接表\">邻接表</h4>\n<ul>\n<li><p>设有向图或者无向图由 <span class=\"math inline\"><em>n</em></span>\n个顶点，则用<strong>顶点表</strong>和<strong>边表</strong>来表示该有向图或无向图</p></li>\n<li><p><strong>顶点表：</strong> 用数组或单链表的形式存放所有的顶点</p>\n<ul>\n<li>如果顶点数 <span class=\"math inline\"><em>n</em></span>\n已知，则采用数组</li>\n<li>如果顶点数未知，则采用单链表</li>\n<li>每个元素包含两个部分\n<ul>\n<li>顶点值</li>\n<li>指向该顶点对应的边表的首地址</li>\n</ul></li>\n</ul></li>\n<li><p><strong>边表：</strong> 每条边用一个节点进行表示</p>\n<p>同一个顶点出发的所有的边形成它的边界点单链表</p></li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505222230615.png\"\nalt=\"邻接表\" />\n<figcaption aria-hidden=\"true\">邻接表</figcaption>\n</figure>\n<h4 id=\"邻接表的特点\">邻接表的特点</h4>\n<ul>\n<li>邻接表是图的<strong>标准</strong>存储方式</li>\n<li>优点\n<ul>\n<li><span class=\"math inline\">内存 = 顶点数 + 边数</span>，时间复杂度为\n<span\nclass=\"math inline\"><em>O</em>(|<em>V</em>|+|<em>E</em>|)</span>，<strong>适合稀疏网</strong></li>\n</ul></li>\n<li>当谈及图的线性算法时，一般指的是 <span\nclass=\"math inline\"><em>O</em>(|<em>V</em>|+|<em>E</em>|)</span></li>\n<li>缺点\n<ul>\n<li>确定 <span class=\"math inline\"><em>i</em> → <em>j</em></span>\n是否有边，最坏需耗费 <span\nclass=\"math inline\"><em>O</em>(<em>n</em>)</span> 时间</li>\n<li>无向图同一条边表示两次。边表空间浪费一倍</li>\n<li>有向图中寻找进入某结点的边，非常困难（逆邻接表）</li>\n</ul></li>\n</ul>\n<h3 id=\"图的遍历\">图的遍历</h3>\n<p>按照某种次序系统地访问图中的所有顶点，并且使得<strong>每个顶点需且只能被访问一次</strong></p>\n<p>需对访问过的顶点加以<strong>标记</strong></p>\n<h4 id=\"深度优先搜索\">深度优先搜索</h4>\n<ol type=\"1\">\n<li>选中第一个被访问的顶点</li>\n<li>对顶点作已访问过的标志</li>\n<li>依次从顶点的未被访问过的第一个、第二个、第三个……邻接顶点出发，进行深度优先搜索</li>\n</ol>\n<p>出现了问题</p>\n<h5 id=\"存在的问题\">存在的问题</h5>\n<p><span id=\"DFSdamn\">如果图不是连通或强连通，在进行 DFS\n时，有时并不一定能够保证从某一个结点出发能访问到所有的顶点</span></p>\n<h5 id=\"深度优先生成森林\">深度优先生成森林</h5>\n<p>在<a\nhref=\"##图###图的遍历####深度优先搜索#####存在的问题\">这种情况</a>下，必须再选中一个未访问过的顶点，继续进行深度优先搜索。直至所有的顶点都被访问过为止</p>\n<p>此时生成的是一组树而不是一棵树，这一组树被称为深度优先生成<strong>森林</strong></p>\n<p>所以将深度优先搜索的流程改为</p>\n<ol type=\"1\">\n<li>选中第一个被访问的顶点</li>\n<li>对顶点作已访问过的标志</li>\n<li>依次从顶点的未被访问过的第一个、第二个、第三个……邻接顶点出发，进行深度优先搜索</li>\n<li>如果还有顶点未被访问，则选中一个起始顶点，转向 2</li>\n<li>所有的顶点都被访问到，则结束</li>\n</ol>\n<h5 id=\"深度优先搜索的实现\">深度优先搜索的实现</h5>\n<ul>\n<li>公有的 <code>dfs</code> 函数的伪代码</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  visited [v] =<span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">//对每个节点标记为未访问</span><br><br>  <span class=\"hljs-keyword\">while</span>(v=尚未访问的节点)<br>  &#123;<br>    <span class=\"hljs-built_in\">dfs</span>(v,visited);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>私有的 <code>dfs</code> 函数的伪代码</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(v,visited)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-built_in\">visited</span>(v)=<span class=\"hljs-literal\">true</span>;<br>  <span class=\"hljs-keyword\">for</span> 每个 v 的邻接点 w<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>(!visited[w])<br>    &#123;<br>      <span class=\"hljs-built_in\">dfs</span>(w,visited);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"广度优先搜索\">广度优先搜索</h4>\n<ol type=\"1\">\n<li>选中第一个被访问的顶点</li>\n<li>对顶点作已访问过的标志</li>\n<li>依次访问已访问顶点的未被访问过的第 <span\nclass=\"math inline\">1</span> 个、第 <span class=\"math inline\">2</span>\n个、第 <span class=\"math inline\">3</span> 个、<span\nclass=\"math inline\">…</span> 、第 <span\nclass=\"math inline\"><em>m</em></span> 个邻接顶点 <span\nclass=\"math inline\"><em>W</em><sub>1</sub>, <em>W</em><sub>2</sub>, <em>W</em><sub>3</sub>, …, <em>W</em><sub><em>m</em></sub></span>\n，进行访问且进行标记，转向 3</li>\n<li>如果还有顶点未被访问，则选中一个起始顶点，转向 2</li>\n<li>所有的顶点都被访问到，则结束</li>\n</ol>\n<p>按照顶点序号小的先访问，大的后访问的原则以<strong>队列</strong>的形式实现</p>\n<p>同样能够生成广度优先生成森林</p>\n<h5 id=\"广度优先搜索的实现\">广度优先搜索的实现</h5>\n<ol type=\"1\">\n<li>将序号最小的顶点放入队列</li>\n<li>重复取队列的队头元素进行处理，直到队列为空。对出队的每个元素，首先检查该元素是否已被访问\n<ul>\n<li>如果没有被访问过，则访问该元素，并将它的所有的没有被访问过的后继入队</li>\n</ul></li>\n<li>检查是否还有顶点未被访问。如果有，重复上述两个步骤</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TypeOfVer</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TypeOfEdge</span>&gt;<br><span class=\"hljs-type\">void</span> adjListGraph&lt;TypeOfVer, TypeOfEdge&gt;::<span class=\"hljs-built_in\">bfs</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  <span class=\"hljs-type\">bool</span> *visited = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">bool</span>[Vers];<br>  <span class=\"hljs-type\">int</span> currentNode;<br>  linkQueue&lt;<span class=\"hljs-type\">int</span>&gt; q;<br>  edgeNode *p;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>   visited[i] = <span class=\"hljs-literal\">false</span>;<br>  &#125;<br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;当前图的广度优先遍历序列为：&quot;</span>&lt;&lt; endl;<br>  <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (visited[i] == <span class=\"hljs-literal\">true</span>)<br>    &#123;<br>      <span class=\"hljs-keyword\">continue</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">while</span> (!q.<span class=\"hljs-built_in\">isEmpty</span>()) <span class=\"hljs-comment\">//连续访问队列的队头，将其拉出，若其后继非空则拉入队列</span><br>    &#123;<br>      currentNode = q.<span class=\"hljs-built_in\">deQueue</span>();<br>      <span class=\"hljs-keyword\">if</span> (visited[currentNode] == <span class=\"hljs-literal\">true</span>)<br>      &#123;<br>        <span class=\"hljs-keyword\">continue</span>;<br>      &#125;<br>      cout &lt;&lt; verList[currentNode].ver &lt;&lt;<span class=\"hljs-string\">&#x27;\\t&#x27;</span>;<br>      visited[currentNode] = <span class=\"hljs-literal\">true</span>;<br>      p = verList[currentNode].head;<br>      <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-literal\">NULL</span>)<br>      &#123;<br>        <span class=\"hljs-keyword\">if</span> (visited[p-&gt;end] == <span class=\"hljs-literal\">false</span>)<br>        q.<span class=\"hljs-built_in\">enQueue</span>(p-&gt;end);<br>        p = p-&gt;next;<br>      &#125;<br>    &#125;<br>    cout &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"图遍历的应用\">图遍历的应用</h3>\n<h4 id=\"无向图的连通性-1\">无向图的连通性</h4>\n<ul>\n<li>如果无向图是连通的，则从无向图中的任意顶点出发进行深度优先搜索或广度优先搜索都可以访问到每一个顶点。访问的次序是一棵深度/广度优先<strong>生成树</strong></li>\n<li>如果图是非连通的，深度/广度优先搜索可以找到一片深度/广度优先<strong>生成森林</strong>。每棵树就是一个<strong>连通分量</strong>。对无向图来说，深度/广度优先搜索可以找到了它的所有连通分量</li>\n<li>在深度优先搜索和广度优先搜索函数的输出中，每一行代表一个连通分量</li>\n</ul>\n<h4 id=\"有向图的连通性-1\">有向图的连通性</h4>\n<ul>\n<li>对有向图，深度优先搜索可以<strong>测试是否强连通</strong>，并<strong>找出所有强连通分量</strong>\n<ol type=\"1\">\n<li>从任意顶点开始<strong>深度优先遍历</strong> <span\nclass=\"math inline\"><em>G</em></span></li>\n<li>对森林中的每棵树进行<strong>后序遍历</strong>，并按遍历的顺序给每个顶点编号</li>\n<li>将 <span class=\"math inline\"><em>G</em></span> 的每条边逆向，形成\n<span class=\"math inline\"><em>G</em><sub><em>r</em></sub></span></li>\n<li>从编号<strong>最大</strong>的顶点开始<strong>深度优先遍历 <span\nclass=\"math inline\"><em>G</em><sub><em>r</em></sub></span></strong>。得到的深度优先遍历森林的每棵树就是\n<span class=\"math inline\"><em>G</em></span> 的强连通分量</li>\n</ol></li>\n</ul>\n<h4 id=\"欧拉回路\">欧拉回路</h4>\n<ul>\n<li>哥尼斯堡七桥问题：能否找到一条走遍这七座桥，而且每座桥只经过一次，最后又回到原出发点的路径</li>\n</ul>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505230120835.png\"\nalt=\"哥尼斯堡七桥问题\" />\n<figcaption aria-hidden=\"true\">哥尼斯堡七桥问题</figcaption>\n</figure>\n<h5 id=\"欧拉的证明\">欧拉的证明</h5>\n<ul>\n<li>如果都是偶数桥，从任意地方出发都能回到原点\n<strong>（欧拉回路）</strong></li>\n<li>如果都是偶数桥，从任意地方出发都能回到原点\n<strong>（欧拉路径）</strong></li>\n<li>如果有奇数桥的地方不止两个，满足要求的路径是找不到的</li>\n</ul>\n<h5 id=\"查找欧拉回路的基本想法\">查找欧拉回路的基本想法</h5>\n<ul>\n<li>执行一次<strong>不允许回溯</strong>的 <code>DFS</code>\n，也被称为一笔画问题</li>\n<li>但是很多搜索都是不符合的</li>\n</ul>\n<h5 id=\"解决方法\">解决方法</h5>\n<p>找出路径上的另外一个尚有未访问的边的顶点，开始另一次深度优先的搜索，将得到的遍历序列拼接到原来的序列中，直到所有的边都已被访问</p>\n<figure>\n<img\nsrc=\"https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505230128080.png\"\nalt=\"欧拉回路解决方法\" />\n<figcaption aria-hidden=\"true\">欧拉回路解决方法</figcaption>\n</figure>\n<h4 id=\"拓扑排序\">拓扑排序</h4>\n<p>设 <span\nclass=\"math inline\"><em>G</em> = (<em>V</em>, <em>E</em>)</span>\n是一个具有 <span class=\"math inline\"><em>n</em></span>\n个顶点的<strong>有向无环图</strong></p>\n<p>若 <span class=\"math inline\"><em>V</em></span> 中的顶点序列 <span\nclass=\"math inline\"><em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>, …, <em>V</em><sub><em>n</em></sub></span>\n满足下列条件</p>\n<ul>\n<li>在 <span class=\"math inline\"><em>G</em></span> 中，从 <span\nclass=\"math inline\"><em>V</em><sub><em>i</em></sub></span> 到 <span\nclass=\"math inline\"><em>V</em><sub><em>j</em></sub></span>\n有一条路径</li>\n<li>在序列中 <span\nclass=\"math inline\"><em>V</em><sub><em>i</em></sub></span> 在 <span\nclass=\"math inline\"><em>V</em><sub><em>j</em></sub></span> 之前</li>\n</ul>\n<p>则称 <span\nclass=\"math inline\"><em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>, …, <em>V</em><sub><em>n</em></sub></span>\n是 <span class=\"math inline\"><em>G</em></span>\n的一个<strong>拓扑排序</strong></p>\n<p>拓扑排序将图转换为线性序，相对前去后继关系不变</p>\n<h5 id=\"顶点活动网络activu-on-vertex-network\">顶点活动网络（Activu on\nvertex network）</h5>\n<ul>\n<li>顶点表示各项子任务</li>\n<li>有向边表示具有先决条件关系</li>\n<li>仅当作为某一子任务的所有作为先决条件的子任务实施完成后，该子任务才能得以实施</li>\n</ul>\n<p><strong>AOV</strong>的特点</p>\n<ol type=\"1\">\n<li>有起始顶点</li>\n<li>无回路</li>\n</ol>\n<h5 id=\"找出拓扑排序的过程\">找出拓扑排序的过程</h5>\n<ul>\n<li>第一个输出的顶点必须无前驱，即入度为 <span\nclass=\"math inline\">0</span></li>\n<li>无前驱以及后继的顶点在任何时候都可以输出</li>\n<li>逻辑删除法：当某个顶点被输出之后，该顶点以及从该顶点出发的边都被删除，所有以该顶点作为前驱的入度的所有顶点的入度\n<span class=\"math inline\">−1</span></li>\n</ul>\n<h5 id=\"拓扑排序的实现\">拓扑排序的实现</h5>\n<ul>\n<li>计算每个顶点的入度，保存在数组 <code>inDegree</code> 中</li>\n<li>检查 <code>inDegree</code> 中的每个元素，将入度为 <span\nclass=\"math inline\">0</span> 的顶点入队</li>\n<li>不断从队列中将入度为 <span class=\"math inline\">0</span>\n的顶点入队，输出此顶点，并将该顶点的入度 <span\nclass=\"math inline\">−1</span>，如果某个邻接点的入度为 <span\nclass=\"math inline\">0</span>，则将其入队</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TypeOfVer</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TypeOfEdge</span>&gt;<br><span class=\"hljs-type\">void</span> adjListGraph&lt;TypeOfVer, TypeOfEdge&gt;::<span class=\"hljs-built_in\">topSort</span>() <span class=\"hljs-type\">const</span><br>&#123;<br>  linkQueue&lt;<span class=\"hljs-type\">int</span>&gt; q;<br>  edgeNode *p;<br>  <span class=\"hljs-type\">int</span> current, *inDegree = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[Vers];<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>    inDegree[i] = <span class=\"hljs-number\">0</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">for</span> ( i = <span class=\"hljs-number\">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>    <span class=\"hljs-keyword\">for</span> (p = verList[i].head; p != <span class=\"hljs-literal\">NULL</span>; p = p-&gt;next)<br>    &#123;<br>    ++inDegree[p-&gt;end];<br>    &#125;<br>  &#125;                                                                 <span class=\"hljs-comment\">//计算入度</span><br>  <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; Vers; ++i)   <span class=\"hljs-keyword\">if</span> (inDegree[i] == <span class=\"hljs-number\">0</span>) q.<span class=\"hljs-built_in\">enQueue</span>(i);  <span class=\"hljs-comment\">//入度0节点入队</span><br>  cout &lt;&lt; <span class=\"hljs-string\">&quot;拓扑排序为：&quot;</span> &lt;&lt; endl;<br>  <span class=\"hljs-keyword\">while</span>(!q.<span class=\"hljs-built_in\">isEmpty</span>())<br>  &#123;<br>    current = q.<span class=\"hljs-built_in\">deQueue</span>( );<br>    cout &lt;&lt; verList[current].ver &lt;&lt; <span class=\"hljs-string\">&#x27;\\t&#x27;</span>;<br>    <span class=\"hljs-keyword\">for</span> (p = verList[current].head; p != <span class=\"hljs-literal\">NULL</span>; p = p-&gt;next)<br>    <span class=\"hljs-keyword\">if</span>( --inDegree[p-&gt;end] == <span class=\"hljs-number\">0</span> )    q.<span class=\"hljs-built_in\">enQueue</span>( p-&gt;end );<br>  &#125;                                                                 <span class=\"hljs-comment\">//出队，删除关联的边</span><br>  cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>时间复杂度：</strong></p>\n<ul>\n<li>若图以邻接表表示</li>\n<li>计算入度的时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(|<em>V</em>|+|<em>E</em>|)</span>，搜索入度为\n<span class=\"math inline\">0</span> 的顶点的时间复杂度为 <span\nclass=\"math inline\"><em>O</em>(|<em>V</em>|)</span>，出队和删除边的时间复杂度为\n<span class=\"math inline\"><em>O</em>(|<em>E</em>|)</span>，总执行时间为\n<span\nclass=\"math inline\"><em>O</em>(|<em>V</em>|+|<em>E</em>|)</span></li>\n</ul>\n<h4 id=\"关键路径\">关键路径</h4>\n<h5 id=\"边活动网络activity-on-edge\">边活动网络（Activity on Edge）</h5>\n<ul>\n<li><strong>AOE 网络：</strong> 加权有向无环图\n<ul>\n<li>顶点表示事件，边表示活动</li>\n<li>有向边的权值表示活动的持续时间</li>\n<li>有向边的方向表示事件发生的先后次序</li>\n<li>顶点的进入表示事件发生后允许开始的活动</li>\n<li>有一个源点、一个终点</li>\n</ul></li>\n</ul>\n<h5 id=\"关键路径的定义\">关键路径的定义</h5>\n<p>AOE\n网路可用于描述整个工程的各个活动之间的关系，活动安排的先后次序</p>\n<p>再次基础上可以用来估算工程的完成时间以及哪些活动是关键的活动</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}